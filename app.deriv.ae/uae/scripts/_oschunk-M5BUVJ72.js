var Z2 = Object.create;
var Vc = Object.defineProperty,
    Q2 = Object.defineProperties,
    e$ = Object.getOwnPropertyDescriptor,
    t$ = Object.getOwnPropertyDescriptors,
    r$ = Object.getOwnPropertyNames,
    jR = Object.getOwnPropertySymbols,
    n$ = Object.getPrototypeOf,
    GR = Object.prototype.hasOwnProperty,
    i$ = Object.prototype.propertyIsEnumerable;
var WR = (r, e, t) => e in r ? Vc(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t,
    Rt = (r, e) => {
        for (var t in e || (e = {})) GR.call(e, t) && WR(r, t, e[t]);
        if (jR)
            for (var t of jR(e)) i$.call(e, t) && WR(r, t, e[t]);
        return r
    },
    ns = (r, e) => Q2(r, t$(e)),
    o = (r, e) => Vc(r, "name", {
        value: e,
        configurable: !0
    }),
    is = (r => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r, {
        get: (e, t) => (typeof require != "undefined" ? require : e)[t]
    }) : r)(function(r) {
        if (typeof require != "undefined") return require.apply(this, arguments);
        throw Error('Dynamic require of "' + r + '" is not supported')
    });
var lde = (r, e) => () => (e || r((e = {
        exports: {}
    }).exports, e), e.exports),
    s$ = (r, e) => {
        for (var t in e) Vc(r, t, {
            get: e[t],
            enumerable: !0
        })
    },
    o$ = (r, e, t, n) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of r$(e)) !GR.call(r, i) && i !== t && Vc(r, i, {
                get: () => e[i],
                enumerable: !(n = e$(e, i)) || n.enumerable
            });
        return r
    };
var dde = (r, e, t) => (t = r != null ? Z2(n$(r)) : {}, o$(e || !r || !r.__esModule ? Vc(t, "default", {
    value: r,
    enumerable: !0
}) : t, r));
var vt = (r, e, t) => new Promise((n, i) => {
    var s = l => {
            try {
                u(t.next(l))
            } catch (c) {
                i(c)
            }
        },
        a = l => {
            try {
                u(t.throw(l))
            } catch (c) {
                i(c)
            }
        },
        u = l => l.done ? n(l.value) : Promise.resolve(l.value).then(s, a);
    u((t = t.apply(r, e)).next())
});
var cde = {};
s$(cde, {
    Application: () => jae,
    ApplicationInfo: () => Ore,
    Authentication: () => Wne,
    Authorization: () => Ese,
    BuiltinFunctions: () => HI,
    ClientVariables: () => rle,
    Communication: () => mse,
    CommunicationHeaders: () => ase,
    Controller: () => nue,
    DataConversion: () => sae,
    DataTypes: () => _se,
    DebuggerAPI: () => nle,
    DebuggerBase: () => tle,
    Entities: () => cue,
    ErrorHandling: () => rie,
    ErrorScreen: () => Tue,
    EventDispatcher: () => Oae,
    Exceptions: () => Mre,
    FeedbackMessageService: () => iie,
    Flow: () => Qre,
    Format: () => sse,
    GenericTypeCache: () => YI,
    IndexedDBSerializer: () => Rue,
    IndexedDBUtils: () => yae,
    Injector: () => ge,
    Interfaces: () => Eue,
    JSONUtils: () => lae,
    LanguageResources: () => bue,
    LightImmutable: () => ose,
    LocaleService: () => ale,
    Logger: () => QM,
    MappingWithDefaultService: () => Jce,
    Model: () => Cue,
    NativeHelper: () => une,
    Navigation: () => xne,
    ObjectExtensions: () => zue,
    Performance: () => Iae,
    Public: () => Yae,
    RequireManager: () => Cae,
    ScreenStateCache: () => Kue,
    ScriptsManager: () => ece,
    ServiceNames: () => J,
    SettingsNames: () => CS,
    StorageProvider: () => Lre,
    StringUtils: () => Xce,
    SystemActions: () => Yce,
    SystemStructures: () => que,
    TableInfoUtils: () => fae,
    TransitionAnimation: () => Tre,
    Transitions: () => Are,
    UrlUtils: () => nne,
    Validation: () => Jae,
    Version: () => e2,
    VersionDefinition: () => wre,
    WebSQLSerializer: () => aue,
    WebSQLUtils: () => Mue,
    WidgetNaming: () => Xae,
    runPostInitialization: () => fle,
    runPreInitialization: () => dle,
    settingsUpdatedHandler: () => ude,
    useAuthConfigsManager: () => mle,
    useBaseApplication: () => rde,
    useSettingsManager: () => vle,
    useVersionsManager: () => yle
});
var di;
(function(r) {
    r.WebHttpClientForNative = "WebHttpClientForNative", r.NoInstrumentationFactoryLogs = "NoInstrumentationFactoryLogs", r.WriteLogsOnConsoles = "WriteLogsOnConsoles", r.ServiceWorkerTraces = "ServiceWorkerTraces", r.EnableOTLV2TraceFormat = "EnableOTLV2TraceFormat", r.ReadAuthConfigsFromSettings = "ReadAuthConfigsFromSettings"
})(di || (di = {}));
var a$ = {
        ServiceWorkerTraces: "true",
        EnableOTLV2TraceFormat: "true"
    },
    u$ = {};

function c$() {
    if (typeof window != "undefined") return window;
    if (typeof global != "undefined") return global;
    if (typeof globalThis != "undefined") return globalThis;
    if (typeof self != "undefined") return self;
    throw new Error("unable to locate global object")
}
o(c$, "getGlobalScope");
var l$ = "ft-",
    zR = c$().sessionStorage,
    d$ = new Map,
    My = class My {
        static getGuard(e, t) {
            var n;
            return (n = t[e]) !== null && n !== void 0 ? n : () => ({
                value: "inherit"
            })
        }
        static readValue(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : zR;
            var n;
            return (n = t == null ? void 0 : t.getItem(this.getFeatureKey(e))) !== null && n !== void 0 ? n : void 0
        }
        static isEnabled(e) {
            let {
                featuresStorage: t = zR,
                cache: n = d$,
                defaultValues: i = a$,
                guards: s = u$,
                logMethod: a = console.warn
            } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var u;
            let l = n.get(e);
            if (l !== void 0) return l;
            let c = this.getGuard(e, s)();
            if (c.value !== "inherit") {
                let p = c.value === "forceTrue";
                return a(`FeaturesManager: Experimental flag "${e}" is forced to value "${p}"${c.reason?`: ${c.reason}`:"."}`), n.set(e, p), p
            }
            let d = i[e],
                f = (u = this.readValue(e, t)) !== null && u !== void 0 ? u : d,
                h = (f == null ? void 0 : f.toLowerCase()) === "true";
            return h !== ((d == null ? void 0 : d.toLowerCase()) === "true") && a(`FeaturesManager: Experimental flag "${e}" is overridden with value "${f}"`), n.set(e, h), h
        }
    };
o(My, "FeaturesManager");
var Hn = My;
Hn.getFeatureKey = r => `${l$}${r}`;

function Ve(r, e, t, n) {
    function i(s) {
        return s instanceof t ? s : new t(function(a) {
            a(s)
        })
    }
    return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
        function u(d) {
            try {
                c(n.next(d))
            } catch (f) {
                a(f)
            }
        }
        o(u, "fulfilled");

        function l(d) {
            try {
                c(n.throw(d))
            } catch (f) {
                a(f)
            }
        }
        o(l, "rejected");

        function c(d) {
            d.done ? s(d.value) : i(d.value).then(u, l)
        }
        o(c, "step"), c((n = n.apply(r, e || [])).next())
    })
}
o(Ve, "__awaiter");

function ne(r, e, t, n) {
    if (t === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? r !== e || !n : !e.has(r)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return t === "m" ? n : t === "a" ? n.call(r) : n ? n.value : e.get(r)
}
o(ne, "__classPrivateFieldGet");

function qe(r, e, t, n, i) {
    if (n === "m") throw new TypeError("Private method is not writable");
    if (n === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? r !== e || !i : !e.has(r)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return n === "a" ? i.call(r, t) : i ? i.value = t : e.set(r, t), t
}
o(qe, "__classPrivateFieldSet");
var J0 = class J0 extends Error {
    constructor(e, t, n, i, s) {
        super(e), this.errorCode = t, this.status = n ? `${n}` : "", this.response = i, this.category = s
    }
};
o(J0, "CommunicationError");
var Fr = J0,
    He;
(function(r) {
    r.Communication_Default = "OS-CLRT-60900", r.Communication_Bad_Request = "OS-CLRT-60901", r.Communication_Unauthorized = "OS-CLRT-60902", r.Communication_Forbidden = "OS-CLRT-60903", r.Communication_Not_Found = "OS-CLRT-60904", r.Communication_Timeout = "OS-CLRT-60905", r.Communication_Internal_Server_Error = "OS-CLRT-60906", r.Communication_Unavailable = "OS-CLRT-60907", r.Communication_Aborted = "OS-CLRT-60908"
})(He || (He = {}));
var f$ = {
        400: He.Communication_Bad_Request,
        401: He.Communication_Unauthorized,
        403: He.Communication_Forbidden,
        404: He.Communication_Not_Found,
        408: He.Communication_Timeout,
        500: He.Communication_Internal_Server_Error,
        503: He.Communication_Unavailable
    },
    Ah = o(r => {
        var e;
        return (e = f$[`${r}`]) !== null && e !== void 0 ? e : He.Communication_Default
    }, "mapErrorCodeFromStatusCode"),
    h$ = "traceparent",
    g$ = "tracestate",
    p$ = "baggage",
    m$ = 512,
    v$ = ["code.function", "outsystems.function.key", "outsystems.function.type", "outsystems.runtime.screen", "outsystems.otel.access.visibility"];

function M1() {
    return Ve(this, arguments, void 0, function() {
        let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            e = arguments.length > 1 ? arguments[1] : void 0;
        return (function*() {
            if (!e) return r;
            let t = yield e();
            return t ? y$(t, r) : r
        })()
    })
}
o(M1, "addTraceHeaders");

function y$(r, e) {
    let t = Object.assign(Object.assign({}, e), {
        [h$]: _$(r)
    });
    if (r.attributes) {
        let n = w$(r.attributes),
            i = n.length > m$ ? p$ : g$;
        t[i] = n
    }
    return t
}
o(y$, "insertTraceHeader");

function _$(r) {
    return `00-${r.traceId}-${r.spanId}-${r.sampled?"01":"00"}`
}
o(_$, "buildTraceHeader");

function w$(r) {
    return v$.map(e => r[e] ? `${e}=${r[e]}` : void 0).filter(e => e !== void 0).join(",")
}
o(w$, "buildTraceState");
var u0;
(function(r) {
    r.FormUrlEncoded = "application/x-www-form-urlencoded", r.Json = "application/json"
})(u0 || (u0 = {}));
var ir = u0,
    c0;
(function(r) {
    r[r.Unknown = 0] = "Unknown", r[r.Timeout = 1] = "Timeout", r[r.Unauthorized = 2] = "Unauthorized", r[r.Aborted = 3] = "Aborted"
})(c0 || (c0 = {}));
var ss = c0,
    qR = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};

function T$(r) {
    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r
}
o(T$, "getDefaultExportFromCjs");

function E$(r) {
    if (r.__esModule) return r;
    var e = r.default;
    if (typeof e == "function") {
        var t = o(function n() {
            return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        }, "a");
        t.prototype = e.prototype
    } else t = {};
    return Object.defineProperty(t, "__esModule", {
        value: !0
    }), Object.keys(r).forEach(function(n) {
        var i = Object.getOwnPropertyDescriptor(r, n);
        Object.defineProperty(t, n, i.get ? i : {
            enumerable: !0,
            get: o(function() {
                return r[n]
            }, "get")
        })
    }), t
}
o(E$, "getAugmentedNamespace");
var ma = TypeError,
    b$ = {},
    S$ = Object.freeze({
        __proto__: null,
        default: b$
    }),
    A$ = E$(S$),
    j0 = typeof Map == "function" && Map.prototype,
    ky = Object.getOwnPropertyDescriptor && j0 ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
    Zf = j0 && ky && typeof ky.get == "function" ? ky.get : null,
    KR = j0 && Map.prototype.forEach,
    W0 = typeof Set == "function" && Set.prototype,
    Fy = Object.getOwnPropertyDescriptor && W0 ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
    Qf = W0 && Fy && typeof Fy.get == "function" ? Fy.get : null,
    YR = W0 && Set.prototype.forEach,
    I$ = typeof WeakMap == "function" && WeakMap.prototype,
    Kc = I$ ? WeakMap.prototype.has : null,
    C$ = typeof WeakSet == "function" && WeakSet.prototype,
    Yc = C$ ? WeakSet.prototype.has : null,
    R$ = typeof WeakRef == "function" && WeakRef.prototype,
    XR = R$ ? WeakRef.prototype.deref : null,
    O$ = Boolean.prototype.valueOf,
    P$ = Object.prototype.toString,
    N$ = Function.prototype.toString,
    D$ = String.prototype.match,
    G0 = String.prototype.slice,
    as = String.prototype.replace,
    L$ = String.prototype.toUpperCase,
    JR = String.prototype.toLowerCase,
    k1 = RegExp.prototype.test,
    ZR = Array.prototype.concat,
    Gn = Array.prototype.join,
    x$ = Array.prototype.slice,
    QR = Math.floor,
    l0 = typeof BigInt == "function" ? BigInt.prototype.valueOf : null,
    $y = Object.getOwnPropertySymbols,
    d0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null,
    la = typeof Symbol == "function" && typeof Symbol.iterator == "object",
    Xc = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === la || !0) ? Symbol.toStringTag : null,
    F1 = Object.prototype.propertyIsEnumerable,
    e1 = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(r) {
        return r.__proto__
    } : null);

function t1(r, e) {
    if (r === 1 / 0 || r === -1 / 0 || r !== r || r && r > -1e3 && r < 1e3 || k1.call(/e/, e)) return e;
    var t = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof r == "number") {
        var n = r < 0 ? -QR(-r) : QR(r);
        if (n !== r) {
            var i = String(n),
                s = G0.call(e, i.length + 1);
            return as.call(i, t, "$&_") + "." + as.call(as.call(s, /([0-9]{3})/g, "$&_"), /_$/, "")
        }
    }
    return as.call(e, t, "$&_")
}
o(t1, "addNumericSeparator");
var f0 = A$,
    r1 = f0.custom,
    n1 = V1(r1) ? r1 : null,
    $1 = {
        __proto__: null,
        double: '"',
        single: "'"
    },
    U$ = {
        __proto__: null,
        double: /(["\\])/g,
        single: /(['\\])/g
    },
    Ih = o(function r(e, t, n, i) {
        var s = t || {};
        if (fi(s, "quoteStyle") && !fi($1, s.quoteStyle)) throw new TypeError('option "quoteStyle" must be "single" or "double"');
        if (fi(s, "maxStringLength") && (typeof s.maxStringLength == "number" ? s.maxStringLength < 0 && s.maxStringLength !== 1 / 0 : s.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        var a = fi(s, "customInspect") ? s.customInspect : !0;
        if (typeof a != "boolean" && a !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        if (fi(s, "indent") && s.indent !== null && s.indent !== "	" && !(parseInt(s.indent, 10) === s.indent && s.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        if (fi(s, "numericSeparator") && typeof s.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        var u = s.numericSeparator;
        if (typeof e == "undefined") return "undefined";
        if (e === null) return "null";
        if (typeof e == "boolean") return e ? "true" : "false";
        if (typeof e == "string") return j1(e, s);
        if (typeof e == "number") {
            if (e === 0) return 1 / 0 / e > 0 ? "0" : "-0";
            var l = String(e);
            return u ? t1(e, l) : l
        }
        if (typeof e == "bigint") {
            var c = String(e) + "n";
            return u ? t1(e, c) : c
        }
        var d = typeof s.depth == "undefined" ? 5 : s.depth;
        if (typeof n == "undefined" && (n = 0), n >= d && d > 0 && typeof e == "object") return h0(e) ? "[Array]" : "[Object]";
        var f = Q$(s, n);
        if (typeof i == "undefined") i = [];
        else if (H1(i, e) >= 0) return "[Circular]";

        function h(oe, S, K) {
            if (S && (i = x$.call(i), i.push(S)), K) {
                var M = {
                    depth: s.depth
                };
                return fi(s, "quoteStyle") && (M.quoteStyle = s.quoteStyle), r(oe, M, n + 1, i)
            }
            return r(oe, s, n + 1, i)
        }
        if (o(h, "inspect"), typeof e == "function" && !i1(e)) {
            var g = W$(e),
                p = $f(e, h);
            return "[Function" + (g ? ": " + g : " (anonymous)") + "]" + (p.length > 0 ? " { " + Gn.call(p, ", ") + " }" : "")
        }
        if (V1(e)) {
            var m = la ? as.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : d0.call(e);
            return typeof e == "object" && !la ? Hc(m) : m
        }
        if (X$(e)) {
            for (var w = "<" + JR.call(String(e.nodeName)), T = e.attributes || [], E = 0; E < T.length; E++) w += " " + T[E].name + "=" + B1(M$(T[E].value), "double", s);
            return w += ">", e.childNodes && e.childNodes.length && (w += "..."), w += "</" + JR.call(String(e.nodeName)) + ">", w
        }
        if (h0(e)) {
            if (e.length === 0) return "[]";
            var b = $f(e, h);
            return f && !Z$(b) ? "[" + g0(b, f) + "]" : "[ " + Gn.call(b, ", ") + " ]"
        }
        if (F$(e)) {
            var R = $f(e, h);
            return !("cause" in Error.prototype) && "cause" in e && !F1.call(e, "cause") ? "{ [" + String(e) + "] " + Gn.call(ZR.call("[cause]: " + h(e.cause), R), ", ") + " }" : R.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + Gn.call(R, ", ") + " }"
        }
        if (typeof e == "object" && a) {
            if (n1 && typeof e[n1] == "function" && f0) return f0(e, {
                depth: d - n
            });
            if (a !== "symbol" && typeof e.inspect == "function") return e.inspect()
        }
        if (G$(e)) {
            var L = [];
            return KR && KR.call(e, function(oe, S) {
                L.push(h(S, e, !0) + " => " + h(oe, e))
            }), s1("Map", Zf.call(e), L, f)
        }
        if (K$(e)) {
            var V = [];
            return YR && YR.call(e, function(oe) {
                V.push(h(oe, e))
            }), s1("Set", Qf.call(e), V, f)
        }
        if (z$(e)) return By("WeakMap");
        if (Y$(e)) return By("WeakSet");
        if (q$(e)) return By("WeakRef");
        if (B$(e)) return Hc(h(Number(e)));
        if (H$(e)) return Hc(h(l0.call(e)));
        if (V$(e)) return Hc(O$.call(e));
        if ($$(e)) return Hc(h(String(e)));
        if (typeof window != "undefined" && e === window) return "{ [object Window] }";
        if (typeof globalThis != "undefined" && e === globalThis || typeof qR != "undefined" && e === qR) return "{ [object globalThis] }";
        if (!k$(e) && !i1(e)) {
            var z = $f(e, h),
                j = e1 ? e1(e) === Object.prototype : e instanceof Object || e.constructor === Object,
                Y = e instanceof Object ? "" : "null prototype",
                q = !j && Xc && Object(e) === e && Xc in e ? G0.call(ls(e), 8, -1) : Y ? "Object" : "",
                P = j || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "",
                Z = P + (q || Y ? "[" + Gn.call(ZR.call([], q || [], Y || []), ": ") + "] " : "");
            return z.length === 0 ? Z + "{}" : f ? Z + "{" + g0(z, f) + "}" : Z + "{ " + Gn.call(z, ", ") + " }"
        }
        return String(e)
    }, "inspect_");

function B1(r, e, t) {
    var n = t.quoteStyle || e,
        i = $1[n];
    return i + r + i
}
o(B1, "wrapQuotes");

function M$(r) {
    return as.call(String(r), /"/g, "&quot;")
}
o(M$, "quote");

function io(r) {
    return !Xc || !(typeof r == "object" && (Xc in r || typeof r[Xc] != "undefined"))
}
o(io, "canTrustToString");

function h0(r) {
    return ls(r) === "[object Array]" && io(r)
}
o(h0, "isArray$3");

function k$(r) {
    return ls(r) === "[object Date]" && io(r)
}
o(k$, "isDate");

function i1(r) {
    return ls(r) === "[object RegExp]" && io(r)
}
o(i1, "isRegExp$1");

function F$(r) {
    return ls(r) === "[object Error]" && io(r)
}
o(F$, "isError");

function $$(r) {
    return ls(r) === "[object String]" && io(r)
}
o($$, "isString");

function B$(r) {
    return ls(r) === "[object Number]" && io(r)
}
o(B$, "isNumber");

function V$(r) {
    return ls(r) === "[object Boolean]" && io(r)
}
o(V$, "isBoolean");

function V1(r) {
    if (la) return r && typeof r == "object" && r instanceof Symbol;
    if (typeof r == "symbol") return !0;
    if (!r || typeof r != "object" || !d0) return !1;
    try {
        return d0.call(r), !0
    } catch (e) {}
    return !1
}
o(V1, "isSymbol");

function H$(r) {
    if (!r || typeof r != "object" || !l0) return !1;
    try {
        return l0.call(r), !0
    } catch (e) {}
    return !1
}
o(H$, "isBigInt");
var j$ = Object.prototype.hasOwnProperty || function(r) {
    return r in this
};

function fi(r, e) {
    return j$.call(r, e)
}
o(fi, "has$3");

function ls(r) {
    return P$.call(r)
}
o(ls, "toStr");

function W$(r) {
    if (r.name) return r.name;
    var e = D$.call(N$.call(r), /^function\s*([\w$]+)/);
    return e ? e[1] : null
}
o(W$, "nameOf");

function H1(r, e) {
    if (r.indexOf) return r.indexOf(e);
    for (var t = 0, n = r.length; t < n; t++)
        if (r[t] === e) return t;
    return -1
}
o(H1, "indexOf");

function G$(r) {
    if (!Zf || !r || typeof r != "object") return !1;
    try {
        Zf.call(r);
        try {
            Qf.call(r)
        } catch (e) {
            return !0
        }
        return r instanceof Map
    } catch (e) {}
    return !1
}
o(G$, "isMap");

function z$(r) {
    if (!Kc || !r || typeof r != "object") return !1;
    try {
        Kc.call(r, Kc);
        try {
            Yc.call(r, Yc)
        } catch (e) {
            return !0
        }
        return r instanceof WeakMap
    } catch (e) {}
    return !1
}
o(z$, "isWeakMap");

function q$(r) {
    if (!XR || !r || typeof r != "object") return !1;
    try {
        return XR.call(r), !0
    } catch (e) {}
    return !1
}
o(q$, "isWeakRef");

function K$(r) {
    if (!Qf || !r || typeof r != "object") return !1;
    try {
        Qf.call(r);
        try {
            Zf.call(r)
        } catch (e) {
            return !0
        }
        return r instanceof Set
    } catch (e) {}
    return !1
}
o(K$, "isSet");

function Y$(r) {
    if (!Yc || !r || typeof r != "object") return !1;
    try {
        Yc.call(r, Yc);
        try {
            Kc.call(r, Kc)
        } catch (e) {
            return !0
        }
        return r instanceof WeakSet
    } catch (e) {}
    return !1
}
o(Y$, "isWeakSet");

function X$(r) {
    return !r || typeof r != "object" ? !1 : typeof HTMLElement != "undefined" && r instanceof HTMLElement ? !0 : typeof r.nodeName == "string" && typeof r.getAttribute == "function"
}
o(X$, "isElement");

function j1(r, e) {
    if (r.length > e.maxStringLength) {
        var t = r.length - e.maxStringLength,
            n = "... " + t + " more character" + (t > 1 ? "s" : "");
        return j1(G0.call(r, 0, e.maxStringLength), e) + n
    }
    var i = U$[e.quoteStyle || "single"];
    i.lastIndex = 0;
    var s = as.call(as.call(r, i, "\\$1"), /[\x00-\x1f]/g, J$);
    return B1(s, "single", e)
}
o(j1, "inspectString");

function J$(r) {
    var e = r.charCodeAt(0),
        t = {
            8: "b",
            9: "t",
            10: "n",
            12: "f",
            13: "r"
        } [e];
    return t ? "\\" + t : "\\x" + (e < 16 ? "0" : "") + L$.call(e.toString(16))
}
o(J$, "lowbyte");

function Hc(r) {
    return "Object(" + r + ")"
}
o(Hc, "markBoxed");

function By(r) {
    return r + " { ? }"
}
o(By, "weakCollectionOf");

function s1(r, e, t, n) {
    var i = n ? g0(t, n) : Gn.call(t, ", ");
    return r + " (" + e + ") {" + i + "}"
}
o(s1, "collectionOf");

function Z$(r) {
    for (var e = 0; e < r.length; e++)
        if (H1(r[e], `
`) >= 0) return !1;
    return !0
}
o(Z$, "singleLineValues");

function Q$(r, e) {
    var t;
    if (r.indent === "	") t = "	";
    else if (typeof r.indent == "number" && r.indent > 0) t = Gn.call(Array(r.indent + 1), " ");
    else return null;
    return {
        base: t,
        prev: Gn.call(Array(e + 1), t)
    }
}
o(Q$, "getIndent");

function g0(r, e) {
    if (r.length === 0) return "";
    var t = `
` + e.prev + e.base;
    return t + Gn.call(r, "," + t) + `
` + e.prev
}
o(g0, "indentedJoin");

function $f(r, e) {
    var t = h0(r),
        n = [];
    if (t) {
        n.length = r.length;
        for (var i = 0; i < r.length; i++) n[i] = fi(r, i) ? e(r[i], r) : ""
    }
    var s = typeof $y == "function" ? $y(r) : [],
        a;
    if (la) {
        a = {};
        for (var u = 0; u < s.length; u++) a["$" + s[u]] = s[u]
    }
    for (var l in r) fi(r, l) && (t && String(Number(l)) === l && l < r.length || la && a["$" + l] instanceof Symbol || (k1.call(/[^\w$]/, l) ? n.push(e(l, r) + ": " + e(r[l], r)) : n.push(l + ": " + e(r[l], r))));
    if (typeof $y == "function")
        for (var c = 0; c < s.length; c++) F1.call(r, s[c]) && n.push("[" + e(s[c]) + "]: " + e(r[s[c]], r));
    return n
}
o($f, "arrObjKeys");
var eB = Ih,
    tB = ma,
    Ch = o(function(r, e, t) {
        for (var n = r, i;
            (i = n.next) != null; n = i)
            if (i.key === e) return n.next = i.next, t || (i.next = r.next, r.next = i), i
    }, "listGetNode"),
    rB = o(function(r, e) {
        if (r) {
            var t = Ch(r, e);
            return t && t.value
        }
    }, "listGet"),
    nB = o(function(r, e, t) {
        var n = Ch(r, e);
        n ? n.value = t : r.next = {
            key: e,
            next: r.next,
            value: t
        }
    }, "listSet"),
    iB = o(function(r, e) {
        return r ? !!Ch(r, e) : !1
    }, "listHas"),
    sB = o(function(r, e) {
        if (r) return Ch(r, e, !0)
    }, "listDelete"),
    oB = o(function() {
        var e, t = {
            assert: o(function(n) {
                if (!t.has(n)) throw new tB("Side channel does not contain " + eB(n))
            }, "assert"),
            delete: o(function(n) {
                var i = e && e.next,
                    s = sB(e, n);
                return s && i && i === s && (e = void 0), !!s
            }, "delete"),
            get: o(function(n) {
                return rB(e, n)
            }, "get"),
            has: o(function(n) {
                return iB(e, n)
            }, "has"),
            set: o(function(n, i) {
                e || (e = {
                    next: void 0
                }), nB(e, n, i)
            }, "set")
        };
        return t
    }, "getSideChannelList"),
    W1 = Object,
    aB = Error,
    uB = EvalError,
    cB = RangeError,
    lB = ReferenceError,
    dB = SyntaxError,
    fB = URIError,
    hB = Math.abs,
    gB = Math.floor,
    pB = Math.max,
    mB = Math.min,
    vB = Math.pow,
    yB = Math.round,
    _B = Number.isNaN || o(function(e) {
        return e !== e
    }, "isNaN"),
    wB = _B,
    TB = o(function(e) {
        return wB(e) || e === 0 ? e : e < 0 ? -1 : 1
    }, "sign"),
    EB = Object.getOwnPropertyDescriptor,
    Vf = EB;
if (Vf) try {
    Vf([], "length")
} catch (r) {
    Vf = null
}
var G1 = Vf,
    Hf = Object.defineProperty || !1;
if (Hf) try {
    Hf({}, "a", {
        value: 1
    })
} catch (r) {
    Hf = !1
}
var bB = Hf,
    Vy, o1;

function SB() {
    return o1 || (o1 = 1, Vy = o(function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
        if (typeof Symbol.iterator == "symbol") return !0;
        var e = {},
            t = Symbol("test"),
            n = Object(t);
        if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]") return !1;
        var i = 42;
        e[t] = i;
        for (var s in e) return !1;
        if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0) return !1;
        var a = Object.getOwnPropertySymbols(e);
        if (a.length !== 1 || a[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t)) return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var u = Object.getOwnPropertyDescriptor(e, t);
            if (u.value !== i || u.enumerable !== !0) return !1
        }
        return !0
    }, "hasSymbols")), Vy
}
o(SB, "requireShams");
var Hy, a1;

function AB() {
    if (a1) return Hy;
    a1 = 1;
    var r = typeof Symbol != "undefined" && Symbol,
        e = SB();
    return Hy = o(function() {
        return typeof r != "function" || typeof Symbol != "function" || typeof r("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : e()
    }, "hasNativeSymbols"), Hy
}
o(AB, "requireHasSymbols");
var jy, u1;

function z1() {
    return u1 || (u1 = 1, jy = typeof Reflect != "undefined" && Reflect.getPrototypeOf || null), jy
}
o(z1, "requireReflect_getPrototypeOf");
var Wy, c1;

function q1() {
    if (c1) return Wy;
    c1 = 1;
    var r = W1;
    return Wy = r.getPrototypeOf || null, Wy
}
o(q1, "requireObject_getPrototypeOf");
var Gy, l1;

function IB() {
    if (l1) return Gy;
    l1 = 1;
    var r = "Function.prototype.bind called on incompatible ",
        e = Object.prototype.toString,
        t = Math.max,
        n = "[object Function]",
        i = o(function(l, c) {
            for (var d = [], f = 0; f < l.length; f += 1) d[f] = l[f];
            for (var h = 0; h < c.length; h += 1) d[h + l.length] = c[h];
            return d
        }, "concatty"),
        s = o(function(l, c) {
            for (var d = [], f = c, h = 0; f < l.length; f += 1, h += 1) d[h] = l[f];
            return d
        }, "slicy"),
        a = o(function(u, l) {
            for (var c = "", d = 0; d < u.length; d += 1) c += u[d], d + 1 < u.length && (c += l);
            return c
        }, "joiny");
    return Gy = o(function(l) {
        var c = this;
        if (typeof c != "function" || e.apply(c) !== n) throw new TypeError(r + c);
        for (var d = s(arguments, 1), f, h = o(function() {
                if (this instanceof f) {
                    var T = c.apply(this, i(d, arguments));
                    return Object(T) === T ? T : this
                }
                return c.apply(l, i(d, arguments))
            }, "binder"), g = t(0, c.length - d.length), p = [], m = 0; m < g; m++) p[m] = "$" + m;
        if (f = Function("binder", "return function (" + a(p, ",") + "){ return binder.apply(this,arguments); }")(h), c.prototype) {
            var w = o(function() {}, "Empty");
            w.prototype = c.prototype, f.prototype = new w, w.prototype = null
        }
        return f
    }, "bind"), Gy
}
o(IB, "requireImplementation");
var zy, d1;

function Rh() {
    if (d1) return zy;
    d1 = 1;
    var r = IB();
    return zy = Function.prototype.bind || r, zy
}
o(Rh, "requireFunctionBind");
var qy, f1;

function z0() {
    return f1 || (f1 = 1, qy = Function.prototype.call), qy
}
o(z0, "requireFunctionCall");
var Ky, h1;

function K1() {
    return h1 || (h1 = 1, Ky = Function.prototype.apply), Ky
}
o(K1, "requireFunctionApply");
var CB = typeof Reflect != "undefined" && Reflect && Reflect.apply,
    RB = Rh(),
    OB = K1(),
    PB = z0(),
    NB = CB,
    DB = NB || RB.call(PB, OB),
    LB = Rh(),
    xB = ma,
    UB = z0(),
    MB = DB,
    Y1 = o(function(e) {
        if (e.length < 1 || typeof e[0] != "function") throw new xB("a function is required");
        return MB(LB, UB, e)
    }, "callBindBasic"),
    Yy, g1;

function kB() {
    if (g1) return Yy;
    g1 = 1;
    var r = Y1,
        e = G1,
        t;
    try {
        t = [].__proto__ === Array.prototype
    } catch (a) {
        if (!a || typeof a != "object" || !("code" in a) || a.code !== "ERR_PROTO_ACCESS") throw a
    }
    var n = !!t && e && e(Object.prototype, "__proto__"),
        i = Object,
        s = i.getPrototypeOf;
    return Yy = n && typeof n.get == "function" ? r([n.get]) : typeof s == "function" ? o(function(u) {
        return s(u == null ? u : i(u))
    }, "getDunder") : !1, Yy
}
o(kB, "requireGet");
var Xy, p1;

function FB() {
    if (p1) return Xy;
    p1 = 1;
    var r = z1(),
        e = q1(),
        t = kB();
    return Xy = r ? o(function(i) {
        return r(i)
    }, "getProto") : e ? o(function(i) {
        if (!i || typeof i != "object" && typeof i != "function") throw new TypeError("getProto: not an object");
        return e(i)
    }, "getProto") : t ? o(function(i) {
        return t(i)
    }, "getProto") : null, Xy
}
o(FB, "requireGetProto");
var Jy, m1;

function $B() {
    if (m1) return Jy;
    m1 = 1;
    var r = Function.prototype.call,
        e = Object.prototype.hasOwnProperty,
        t = Rh();
    return Jy = t.call(r, e), Jy
}
o($B, "requireHasown");
var ze, BB = W1,
    VB = aB,
    HB = uB,
    jB = cB,
    WB = lB,
    da = dB,
    oa = ma,
    GB = fB,
    zB = hB,
    qB = gB,
    KB = pB,
    YB = mB,
    XB = vB,
    JB = yB,
    ZB = TB,
    X1 = Function,
    Zy = o(function(r) {
        try {
            return X1('"use strict"; return (' + r + ").constructor;")()
        } catch (e) {}
    }, "getEvalledConstructor"),
    al = G1,
    QB = bB,
    Qy = o(function() {
        throw new oa
    }, "throwTypeError"),
    eV = al ? (function() {
        try {
            return arguments.callee, Qy
        } catch (r) {
            try {
                return al(arguments, "callee").get
            } catch (e) {
                return Qy
            }
        }
    })() : Qy,
    ta = AB()(),
    rr = FB(),
    tV = q1(),
    rV = z1(),
    J1 = K1(),
    ll = z0(),
    na = {},
    nV = typeof Uint8Array == "undefined" || !rr ? ze : rr(Uint8Array),
    to = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError == "undefined" ? ze : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer == "undefined" ? ze : ArrayBuffer,
        "%ArrayIteratorPrototype%": ta && rr ? rr([][Symbol.iterator]()) : ze,
        "%AsyncFromSyncIteratorPrototype%": ze,
        "%AsyncFunction%": na,
        "%AsyncGenerator%": na,
        "%AsyncGeneratorFunction%": na,
        "%AsyncIteratorPrototype%": na,
        "%Atomics%": typeof Atomics == "undefined" ? ze : Atomics,
        "%BigInt%": typeof BigInt == "undefined" ? ze : BigInt,
        "%BigInt64Array%": typeof BigInt64Array == "undefined" ? ze : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array == "undefined" ? ze : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView == "undefined" ? ze : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": VB,
        "%eval%": eval,
        "%EvalError%": HB,
        "%Float16Array%": typeof Float16Array == "undefined" ? ze : Float16Array,
        "%Float32Array%": typeof Float32Array == "undefined" ? ze : Float32Array,
        "%Float64Array%": typeof Float64Array == "undefined" ? ze : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry == "undefined" ? ze : FinalizationRegistry,
        "%Function%": X1,
        "%GeneratorFunction%": na,
        "%Int8Array%": typeof Int8Array == "undefined" ? ze : Int8Array,
        "%Int16Array%": typeof Int16Array == "undefined" ? ze : Int16Array,
        "%Int32Array%": typeof Int32Array == "undefined" ? ze : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": ta && rr ? rr(rr([][Symbol.iterator]())) : ze,
        "%JSON%": typeof JSON == "object" ? JSON : ze,
        "%Map%": typeof Map == "undefined" ? ze : Map,
        "%MapIteratorPrototype%": typeof Map == "undefined" || !ta || !rr ? ze : rr(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": BB,
        "%Object.getOwnPropertyDescriptor%": al,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise == "undefined" ? ze : Promise,
        "%Proxy%": typeof Proxy == "undefined" ? ze : Proxy,
        "%RangeError%": jB,
        "%ReferenceError%": WB,
        "%Reflect%": typeof Reflect == "undefined" ? ze : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set == "undefined" ? ze : Set,
        "%SetIteratorPrototype%": typeof Set == "undefined" || !ta || !rr ? ze : rr(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer == "undefined" ? ze : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": ta && rr ? rr("" [Symbol.iterator]()) : ze,
        "%Symbol%": ta ? Symbol : ze,
        "%SyntaxError%": da,
        "%ThrowTypeError%": eV,
        "%TypedArray%": nV,
        "%TypeError%": oa,
        "%Uint8Array%": typeof Uint8Array == "undefined" ? ze : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray == "undefined" ? ze : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array == "undefined" ? ze : Uint16Array,
        "%Uint32Array%": typeof Uint32Array == "undefined" ? ze : Uint32Array,
        "%URIError%": GB,
        "%WeakMap%": typeof WeakMap == "undefined" ? ze : WeakMap,
        "%WeakRef%": typeof WeakRef == "undefined" ? ze : WeakRef,
        "%WeakSet%": typeof WeakSet == "undefined" ? ze : WeakSet,
        "%Function.prototype.call%": ll,
        "%Function.prototype.apply%": J1,
        "%Object.defineProperty%": QB,
        "%Object.getPrototypeOf%": tV,
        "%Math.abs%": zB,
        "%Math.floor%": qB,
        "%Math.max%": KB,
        "%Math.min%": YB,
        "%Math.pow%": XB,
        "%Math.round%": JB,
        "%Math.sign%": ZB,
        "%Reflect.getPrototypeOf%": rV
    };
if (rr) try {
    null.error
} catch (r) {
    v1 = rr(rr(r)), to["%Error.prototype%"] = v1
}
var v1, iV = o(function r(e) {
        var t;
        if (e === "%AsyncFunction%") t = Zy("async function () {}");
        else if (e === "%GeneratorFunction%") t = Zy("function* () {}");
        else if (e === "%AsyncGeneratorFunction%") t = Zy("async function* () {}");
        else if (e === "%AsyncGenerator%") {
            var n = r("%AsyncGeneratorFunction%");
            n && (t = n.prototype)
        } else if (e === "%AsyncIteratorPrototype%") {
            var i = r("%AsyncGenerator%");
            i && rr && (t = rr(i.prototype))
        }
        return to[e] = t, t
    }, "doEval"),
    y1 = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
    },
    dl = Rh(),
    eh = $B(),
    sV = dl.call(ll, Array.prototype.concat),
    oV = dl.call(J1, Array.prototype.splice),
    _1 = dl.call(ll, String.prototype.replace),
    th = dl.call(ll, String.prototype.slice),
    aV = dl.call(ll, RegExp.prototype.exec),
    uV = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
    cV = /\\(\\)?/g,
    lV = o(function(e) {
        var t = th(e, 0, 1),
            n = th(e, -1);
        if (t === "%" && n !== "%") throw new da("invalid intrinsic syntax, expected closing `%`");
        if (n === "%" && t !== "%") throw new da("invalid intrinsic syntax, expected opening `%`");
        var i = [];
        return _1(e, uV, function(s, a, u, l) {
            i[i.length] = u ? _1(l, cV, "$1") : a || s
        }), i
    }, "stringToPath"),
    dV = o(function(e, t) {
        var n = e,
            i;
        if (eh(y1, n) && (i = y1[n], n = "%" + i[0] + "%"), eh(to, n)) {
            var s = to[n];
            if (s === na && (s = iV(n)), typeof s == "undefined" && !t) throw new oa("intrinsic " + e + " exists, but is not available. Please file an issue!");
            return {
                alias: i,
                name: n,
                value: s
            }
        }
        throw new da("intrinsic " + e + " does not exist!")
    }, "getBaseIntrinsic"),
    q0 = o(function(e, t) {
        if (typeof e != "string" || e.length === 0) throw new oa("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof t != "boolean") throw new oa('"allowMissing" argument must be a boolean');
        if (aV(/^%?[^%]*%?$/, e) === null) throw new da("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var n = lV(e),
            i = n.length > 0 ? n[0] : "",
            s = dV("%" + i + "%", t),
            a = s.name,
            u = s.value,
            l = !1,
            c = s.alias;
        c && (i = c[0], oV(n, sV([0, 1], c)));
        for (var d = 1, f = !0; d < n.length; d += 1) {
            var h = n[d],
                g = th(h, 0, 1),
                p = th(h, -1);
            if ((g === '"' || g === "'" || g === "`" || p === '"' || p === "'" || p === "`") && g !== p) throw new da("property names with quotes must have matching quotes");
            if ((h === "constructor" || !f) && (l = !0), i += "." + h, a = "%" + i + "%", eh(to, a)) u = to[a];
            else if (u != null) {
                if (!(h in u)) {
                    if (!t) throw new oa("base intrinsic for " + e + " exists, but the property is not available.");
                    return
                }
                if (al && d + 1 >= n.length) {
                    var m = al(u, h);
                    f = !!m, f && "get" in m && !("originalValue" in m.get) ? u = m.get : u = u[h]
                } else f = eh(u, h), u = u[h];
                f && !l && (to[a] = u)
            }
        }
        return u
    }, "GetIntrinsic"),
    Z1 = q0,
    Q1 = Y1,
    fV = Q1([Z1("%String.prototype.indexOf%")]),
    eO = o(function(e, t) {
        var n = Z1(e, !!t);
        return typeof n == "function" && fV(e, ".prototype.") > -1 ? Q1([n]) : n
    }, "callBoundIntrinsic"),
    hV = q0,
    fl = eO,
    gV = Ih,
    pV = ma,
    w1 = hV("%Map%", !0),
    mV = fl("Map.prototype.get", !0),
    vV = fl("Map.prototype.set", !0),
    yV = fl("Map.prototype.has", !0),
    _V = fl("Map.prototype.delete", !0),
    wV = fl("Map.prototype.size", !0),
    tO = !!w1 && o(function() {
        var e, t = {
            assert: o(function(n) {
                if (!t.has(n)) throw new pV("Side channel does not contain " + gV(n))
            }, "assert"),
            delete: o(function(n) {
                if (e) {
                    var i = _V(e, n);
                    return wV(e) === 0 && (e = void 0), i
                }
                return !1
            }, "delete"),
            get: o(function(n) {
                if (e) return mV(e, n)
            }, "get"),
            has: o(function(n) {
                return e ? yV(e, n) : !1
            }, "has"),
            set: o(function(n, i) {
                e || (e = new w1), vV(e, n, i)
            }, "set")
        };
        return t
    }, "getSideChannelMap"),
    TV = q0,
    Oh = eO,
    EV = Ih,
    Bf = tO,
    bV = ma,
    ra = TV("%WeakMap%", !0),
    SV = Oh("WeakMap.prototype.get", !0),
    AV = Oh("WeakMap.prototype.set", !0),
    IV = Oh("WeakMap.prototype.has", !0),
    CV = Oh("WeakMap.prototype.delete", !0),
    RV = ra ? o(function() {
        var e, t, n = {
            assert: o(function(i) {
                if (!n.has(i)) throw new bV("Side channel does not contain " + EV(i))
            }, "assert"),
            delete: o(function(i) {
                if (ra && i && (typeof i == "object" || typeof i == "function")) {
                    if (e) return CV(e, i)
                } else if (Bf && t) return t.delete(i);
                return !1
            }, "delete"),
            get: o(function(i) {
                return ra && i && (typeof i == "object" || typeof i == "function") && e ? SV(e, i) : t && t.get(i)
            }, "get"),
            has: o(function(i) {
                return ra && i && (typeof i == "object" || typeof i == "function") && e ? IV(e, i) : !!t && t.has(i)
            }, "has"),
            set: o(function(i, s) {
                ra && i && (typeof i == "object" || typeof i == "function") ? (e || (e = new ra), AV(e, i, s)) : Bf && (t || (t = Bf()), t.set(i, s))
            }, "set")
        };
        return n
    }, "getSideChannelWeakMap") : Bf,
    OV = ma,
    PV = Ih,
    NV = oB,
    DV = tO,
    LV = RV,
    xV = LV || DV || NV,
    UV = o(function() {
        var e, t = {
            assert: o(function(n) {
                if (!t.has(n)) throw new OV("Side channel does not contain " + PV(n))
            }, "assert"),
            delete: o(function(n) {
                return !!e && e.delete(n)
            }, "delete"),
            get: o(function(n) {
                return e && e.get(n)
            }, "get"),
            has: o(function(n) {
                return !!e && e.has(n)
            }, "has"),
            set: o(function(n, i) {
                e || (e = xV()), e.set(n, i)
            }, "set")
        };
        return t
    }, "getSideChannel"),
    MV = String.prototype.replace,
    kV = /%20/g,
    e0 = {
        RFC1738: "RFC1738",
        RFC3986: "RFC3986"
    },
    K0 = {
        default: e0.RFC3986,
        formatters: {
            RFC1738: o(function(r) {
                return MV.call(r, kV, "+")
            }, "RFC1738"),
            RFC3986: o(function(r) {
                return String(r)
            }, "RFC3986")
        },
        RFC1738: e0.RFC1738,
        RFC3986: e0.RFC3986
    },
    FV = K0,
    t0 = Object.prototype.hasOwnProperty,
    Js = Array.isArray,
    jn = (function() {
        for (var r = [], e = 0; e < 256; ++e) r.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
        return r
    })(),
    $V = o(function(e) {
        for (; e.length > 1;) {
            var t = e.pop(),
                n = t.obj[t.prop];
            if (Js(n)) {
                for (var i = [], s = 0; s < n.length; ++s) typeof n[s] != "undefined" && i.push(n[s]);
                t.obj[t.prop] = i
            }
        }
    }, "compactQueue"),
    rO = o(function(e, t) {
        for (var n = t && t.plainObjects ? {
                __proto__: null
            } : {}, i = 0; i < e.length; ++i) typeof e[i] != "undefined" && (n[i] = e[i]);
        return n
    }, "arrayToObject"),
    BV = o(function r(e, t, n) {
        if (!t) return e;
        if (typeof t != "object" && typeof t != "function") {
            if (Js(e)) e.push(t);
            else if (e && typeof e == "object")(n && (n.plainObjects || n.allowPrototypes) || !t0.call(Object.prototype, t)) && (e[t] = !0);
            else return [e, t];
            return e
        }
        if (!e || typeof e != "object") return [e].concat(t);
        var i = e;
        return Js(e) && !Js(t) && (i = rO(e, n)), Js(e) && Js(t) ? (t.forEach(function(s, a) {
            if (t0.call(e, a)) {
                var u = e[a];
                u && typeof u == "object" && s && typeof s == "object" ? e[a] = r(u, s, n) : e.push(s)
            } else e[a] = s
        }), e) : Object.keys(t).reduce(function(s, a) {
            var u = t[a];
            return t0.call(s, a) ? s[a] = r(s[a], u, n) : s[a] = u, s
        }, i)
    }, "merge"),
    VV = o(function(e, t) {
        return Object.keys(t).reduce(function(n, i) {
            return n[i] = t[i], n
        }, e)
    }, "assignSingleSource"),
    HV = o(function(r, e, t) {
        var n = r.replace(/\+/g, " ");
        if (t === "iso-8859-1") return n.replace(/%[0-9a-f]{2}/gi, unescape);
        try {
            return decodeURIComponent(n)
        } catch (i) {
            return n
        }
    }, "decode"),
    r0 = 1024,
    jV = o(function(e, t, n, i, s) {
        if (e.length === 0) return e;
        var a = e;
        if (typeof e == "symbol" ? a = Symbol.prototype.toString.call(e) : typeof e != "string" && (a = String(e)), n === "iso-8859-1") return escape(a).replace(/%u[0-9a-f]{4}/gi, function(g) {
            return "%26%23" + parseInt(g.slice(2), 16) + "%3B"
        });
        for (var u = "", l = 0; l < a.length; l += r0) {
            for (var c = a.length >= r0 ? a.slice(l, l + r0) : a, d = [], f = 0; f < c.length; ++f) {
                var h = c.charCodeAt(f);
                if (h === 45 || h === 46 || h === 95 || h === 126 || h >= 48 && h <= 57 || h >= 65 && h <= 90 || h >= 97 && h <= 122 || s === FV.RFC1738 && (h === 40 || h === 41)) {
                    d[d.length] = c.charAt(f);
                    continue
                }
                if (h < 128) {
                    d[d.length] = jn[h];
                    continue
                }
                if (h < 2048) {
                    d[d.length] = jn[192 | h >> 6] + jn[128 | h & 63];
                    continue
                }
                if (h < 55296 || h >= 57344) {
                    d[d.length] = jn[224 | h >> 12] + jn[128 | h >> 6 & 63] + jn[128 | h & 63];
                    continue
                }
                f += 1, h = 65536 + ((h & 1023) << 10 | c.charCodeAt(f) & 1023), d[d.length] = jn[240 | h >> 18] + jn[128 | h >> 12 & 63] + jn[128 | h >> 6 & 63] + jn[128 | h & 63]
            }
            u += d.join("")
        }
        return u
    }, "encode"),
    WV = o(function(e) {
        for (var t = [{
                obj: {
                    o: e
                },
                prop: "o"
            }], n = [], i = 0; i < t.length; ++i)
            for (var s = t[i], a = s.obj[s.prop], u = Object.keys(a), l = 0; l < u.length; ++l) {
                var c = u[l],
                    d = a[c];
                typeof d == "object" && d !== null && n.indexOf(d) === -1 && (t.push({
                    obj: a,
                    prop: c
                }), n.push(d))
            }
        return $V(t), e
    }, "compact"),
    GV = o(function(e) {
        return Object.prototype.toString.call(e) === "[object RegExp]"
    }, "isRegExp"),
    zV = o(function(e) {
        return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e))
    }, "isBuffer"),
    qV = o(function(e, t) {
        return [].concat(e, t)
    }, "combine"),
    KV = o(function(e, t) {
        if (Js(e)) {
            for (var n = [], i = 0; i < e.length; i += 1) n.push(t(e[i]));
            return n
        }
        return t(e)
    }, "maybeMap"),
    nO = {
        arrayToObject: rO,
        assign: VV,
        combine: qV,
        compact: WV,
        decode: HV,
        encode: jV,
        isBuffer: zV,
        isRegExp: GV,
        maybeMap: KV,
        merge: BV
    },
    iO = UV,
    jf = nO,
    Jc = K0,
    YV = Object.prototype.hasOwnProperty,
    sO = {
        brackets: o(function(e) {
            return e + "[]"
        }, "brackets"),
        comma: "comma",
        indices: o(function(e, t) {
            return e + "[" + t + "]"
        }, "indices"),
        repeat: o(function(e) {
            return e
        }, "repeat")
    },
    Wn = Array.isArray,
    XV = Array.prototype.push,
    oO = o(function(r, e) {
        XV.apply(r, Wn(e) ? e : [e])
    }, "pushToArray"),
    JV = Date.prototype.toISOString,
    T1 = Jc.default,
    zt = {
        addQueryPrefix: !1,
        allowDots: !1,
        allowEmptyArrays: !1,
        arrayFormat: "indices",
        charset: "utf-8",
        charsetSentinel: !1,
        commaRoundTrip: !1,
        delimiter: "&",
        encode: !0,
        encodeDotInKeys: !1,
        encoder: jf.encode,
        encodeValuesOnly: !1,
        filter: void 0,
        format: T1,
        formatter: Jc.formatters[T1],
        indices: !1,
        serializeDate: o(function(e) {
            return JV.call(e)
        }, "serializeDate"),
        skipNulls: !1,
        strictNullHandling: !1
    },
    ZV = o(function(e) {
        return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint"
    }, "isNonNullishPrimitive"),
    n0 = {},
    QV = o(function r(e, t, n, i, s, a, u, l, c, d, f, h, g, p, m, w, T, E) {
        for (var b = e, R = E, L = 0, V = !1;
            (R = R.get(n0)) !== void 0 && !V;) {
            var z = R.get(e);
            if (L += 1, typeof z != "undefined") {
                if (z === L) throw new RangeError("Cyclic object value");
                V = !0
            }
            typeof R.get(n0) == "undefined" && (L = 0)
        }
        if (typeof d == "function" ? b = d(t, b) : b instanceof Date ? b = g(b) : n === "comma" && Wn(b) && (b = jf.maybeMap(b, function(de) {
                return de instanceof Date ? g(de) : de
            })), b === null) {
            if (a) return c && !w ? c(t, zt.encoder, T, "key", p) : t;
            b = ""
        }
        if (ZV(b) || jf.isBuffer(b)) {
            if (c) {
                var j = w ? t : c(t, zt.encoder, T, "key", p);
                return [m(j) + "=" + m(c(b, zt.encoder, T, "value", p))]
            }
            return [m(t) + "=" + m(String(b))]
        }
        var Y = [];
        if (typeof b == "undefined") return Y;
        var q;
        if (n === "comma" && Wn(b)) w && c && (b = jf.maybeMap(b, c)), q = [{
            value: b.length > 0 ? b.join(",") || null : void 0
        }];
        else if (Wn(d)) q = d;
        else {
            var P = Object.keys(b);
            q = f ? P.sort(f) : P
        }
        var Z = l ? String(t).replace(/\./g, "%2E") : String(t),
            oe = i && Wn(b) && b.length === 1 ? Z + "[]" : Z;
        if (s && Wn(b) && b.length === 0) return oe + "[]";
        for (var S = 0; S < q.length; ++S) {
            var K = q[S],
                M = typeof K == "object" && K && typeof K.value != "undefined" ? K.value : b[K];
            if (!(u && M === null)) {
                var Oe = h && l ? String(K).replace(/\./g, "%2E") : String(K),
                    Ye = Wn(b) ? typeof n == "function" ? n(oe, Oe) : oe : oe + (h ? "." + Oe : "[" + Oe + "]");
                E.set(e, L);
                var Xe = iO();
                Xe.set(n0, E), oO(Y, r(M, Ye, n, i, s, a, u, l, n === "comma" && w && Wn(b) ? null : c, d, f, h, g, p, m, w, T, Xe))
            }
        }
        return Y
    }, "stringify"),
    e3 = o(function(e) {
        if (!e) return zt;
        if (typeof e.allowEmptyArrays != "undefined" && typeof e.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof e.encodeDotInKeys != "undefined" && typeof e.encodeDotInKeys != "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
        if (e.encoder !== null && typeof e.encoder != "undefined" && typeof e.encoder != "function") throw new TypeError("Encoder has to be a function.");
        var t = e.charset || zt.charset;
        if (typeof e.charset != "undefined" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var n = Jc.default;
        if (typeof e.format != "undefined") {
            if (!YV.call(Jc.formatters, e.format)) throw new TypeError("Unknown format option provided.");
            n = e.format
        }
        var i = Jc.formatters[n],
            s = zt.filter;
        (typeof e.filter == "function" || Wn(e.filter)) && (s = e.filter);
        var a;
        if (e.arrayFormat in sO ? a = e.arrayFormat : "indices" in e ? a = e.indices ? "indices" : "repeat" : a = zt.arrayFormat, "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        var u = typeof e.allowDots == "undefined" ? e.encodeDotInKeys === !0 ? !0 : zt.allowDots : !!e.allowDots;
        return {
            addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : zt.addQueryPrefix,
            allowDots: u,
            allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : zt.allowEmptyArrays,
            arrayFormat: a,
            charset: t,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : zt.charsetSentinel,
            commaRoundTrip: !!e.commaRoundTrip,
            delimiter: typeof e.delimiter == "undefined" ? zt.delimiter : e.delimiter,
            encode: typeof e.encode == "boolean" ? e.encode : zt.encode,
            encodeDotInKeys: typeof e.encodeDotInKeys == "boolean" ? e.encodeDotInKeys : zt.encodeDotInKeys,
            encoder: typeof e.encoder == "function" ? e.encoder : zt.encoder,
            encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : zt.encodeValuesOnly,
            filter: s,
            format: n,
            formatter: i,
            serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : zt.serializeDate,
            skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : zt.skipNulls,
            sort: typeof e.sort == "function" ? e.sort : null,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : zt.strictNullHandling
        }
    }, "normalizeStringifyOptions"),
    t3 = o(function(r, e) {
        var t = r,
            n = e3(e),
            i, s;
        typeof n.filter == "function" ? (s = n.filter, t = s("", t)) : Wn(n.filter) && (s = n.filter, i = s);
        var a = [];
        if (typeof t != "object" || t === null) return "";
        var u = sO[n.arrayFormat],
            l = u === "comma" && n.commaRoundTrip;
        i || (i = Object.keys(t)), n.sort && i.sort(n.sort);
        for (var c = iO(), d = 0; d < i.length; ++d) {
            var f = i[d],
                h = t[f];
            n.skipNulls && h === null || oO(a, QV(h, f, u, l, n.allowEmptyArrays, n.strictNullHandling, n.skipNulls, n.encodeDotInKeys, n.encode ? n.encoder : null, n.filter, n.sort, n.allowDots, n.serializeDate, n.format, n.formatter, n.encodeValuesOnly, n.charset, c))
        }
        var g = a.join(n.delimiter),
            p = n.addQueryPrefix === !0 ? "?" : "";
        return n.charsetSentinel && (n.charset === "iso-8859-1" ? p += "utf8=%26%2310003%3B&" : p += "utf8=%E2%9C%93&"), g.length > 0 ? p + g : ""
    }, "stringify_1"),
    ro = nO,
    p0 = Object.prototype.hasOwnProperty,
    E1 = Array.isArray,
    xt = {
        allowDots: !1,
        allowEmptyArrays: !1,
        allowPrototypes: !1,
        allowSparse: !1,
        arrayLimit: 20,
        charset: "utf-8",
        charsetSentinel: !1,
        comma: !1,
        decodeDotInKeys: !1,
        decoder: ro.decode,
        delimiter: "&",
        depth: 5,
        duplicates: "combine",
        ignoreQueryPrefix: !1,
        interpretNumericEntities: !1,
        parameterLimit: 1e3,
        parseArrays: !0,
        plainObjects: !1,
        strictDepth: !1,
        strictNullHandling: !1,
        throwOnLimitExceeded: !1
    },
    r3 = o(function(r) {
        return r.replace(/&#(\d+);/g, function(e, t) {
            return String.fromCharCode(parseInt(t, 10))
        })
    }, "interpretNumericEntities"),
    aO = o(function(r, e, t) {
        if (r && typeof r == "string" && e.comma && r.indexOf(",") > -1) return r.split(",");
        if (e.throwOnLimitExceeded && t >= e.arrayLimit) throw new RangeError("Array limit exceeded. Only " + e.arrayLimit + " element" + (e.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
        return r
    }, "parseArrayValue"),
    n3 = "utf8=%26%2310003%3B",
    i3 = "utf8=%E2%9C%93",
    s3 = o(function(e, t) {
        var n = {
                __proto__: null
            },
            i = t.ignoreQueryPrefix ? e.replace(/^\?/, "") : e;
        i = i.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
        var s = t.parameterLimit === 1 / 0 ? void 0 : t.parameterLimit,
            a = i.split(t.delimiter, t.throwOnLimitExceeded ? s + 1 : s);
        if (t.throwOnLimitExceeded && a.length > s) throw new RangeError("Parameter limit exceeded. Only " + s + " parameter" + (s === 1 ? "" : "s") + " allowed.");
        var u = -1,
            l, c = t.charset;
        if (t.charsetSentinel)
            for (l = 0; l < a.length; ++l) a[l].indexOf("utf8=") === 0 && (a[l] === i3 ? c = "utf-8" : a[l] === n3 && (c = "iso-8859-1"), u = l, l = a.length);
        for (l = 0; l < a.length; ++l)
            if (l !== u) {
                var d = a[l],
                    f = d.indexOf("]="),
                    h = f === -1 ? d.indexOf("=") : f + 1,
                    g, p;
                h === -1 ? (g = t.decoder(d, xt.decoder, c, "key"), p = t.strictNullHandling ? null : "") : (g = t.decoder(d.slice(0, h), xt.decoder, c, "key"), p = ro.maybeMap(aO(d.slice(h + 1), t, E1(n[g]) ? n[g].length : 0), function(w) {
                    return t.decoder(w, xt.decoder, c, "value")
                })), p && t.interpretNumericEntities && c === "iso-8859-1" && (p = r3(String(p))), d.indexOf("[]=") > -1 && (p = E1(p) ? [p] : p);
                var m = p0.call(n, g);
                m && t.duplicates === "combine" ? n[g] = ro.combine(n[g], p) : (!m || t.duplicates === "last") && (n[g] = p)
            } return n
    }, "parseQueryStringValues"),
    o3 = o(function(r, e, t, n) {
        var i = 0;
        if (r.length > 0 && r[r.length - 1] === "[]") {
            var s = r.slice(0, -1).join("");
            i = Array.isArray(e) && e[s] ? e[s].length : 0
        }
        for (var a = n ? e : aO(e, t, i), u = r.length - 1; u >= 0; --u) {
            var l, c = r[u];
            if (c === "[]" && t.parseArrays) l = t.allowEmptyArrays && (a === "" || t.strictNullHandling && a === null) ? [] : ro.combine([], a);
            else {
                l = t.plainObjects ? {
                    __proto__: null
                } : {};
                var d = c.charAt(0) === "[" && c.charAt(c.length - 1) === "]" ? c.slice(1, -1) : c,
                    f = t.decodeDotInKeys ? d.replace(/%2E/g, ".") : d,
                    h = parseInt(f, 10);
                !t.parseArrays && f === "" ? l = {
                    0: a
                } : !isNaN(h) && c !== f && String(h) === f && h >= 0 && t.parseArrays && h <= t.arrayLimit ? (l = [], l[h] = a) : f !== "__proto__" && (l[f] = a)
            }
            a = l
        }
        return a
    }, "parseObject"),
    a3 = o(function(e, t, n, i) {
        if (e) {
            var s = n.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e,
                a = /(\[[^[\]]*])/,
                u = /(\[[^[\]]*])/g,
                l = n.depth > 0 && a.exec(s),
                c = l ? s.slice(0, l.index) : s,
                d = [];
            if (c) {
                if (!n.plainObjects && p0.call(Object.prototype, c) && !n.allowPrototypes) return;
                d.push(c)
            }
            for (var f = 0; n.depth > 0 && (l = u.exec(s)) !== null && f < n.depth;) {
                if (f += 1, !n.plainObjects && p0.call(Object.prototype, l[1].slice(1, -1)) && !n.allowPrototypes) return;
                d.push(l[1])
            }
            if (l) {
                if (n.strictDepth === !0) throw new RangeError("Input depth exceeded depth option of " + n.depth + " and strictDepth is true");
                d.push("[" + s.slice(l.index) + "]")
            }
            return o3(d, t, n, i)
        }
    }, "parseQueryStringKeys"),
    u3 = o(function(e) {
        if (!e) return xt;
        if (typeof e.allowEmptyArrays != "undefined" && typeof e.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof e.decodeDotInKeys != "undefined" && typeof e.decodeDotInKeys != "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
        if (e.decoder !== null && typeof e.decoder != "undefined" && typeof e.decoder != "function") throw new TypeError("Decoder has to be a function.");
        if (typeof e.charset != "undefined" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        if (typeof e.throwOnLimitExceeded != "undefined" && typeof e.throwOnLimitExceeded != "boolean") throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
        var t = typeof e.charset == "undefined" ? xt.charset : e.charset,
            n = typeof e.duplicates == "undefined" ? xt.duplicates : e.duplicates;
        if (n !== "combine" && n !== "first" && n !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
        var i = typeof e.allowDots == "undefined" ? e.decodeDotInKeys === !0 ? !0 : xt.allowDots : !!e.allowDots;
        return {
            allowDots: i,
            allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : xt.allowEmptyArrays,
            allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : xt.allowPrototypes,
            allowSparse: typeof e.allowSparse == "boolean" ? e.allowSparse : xt.allowSparse,
            arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : xt.arrayLimit,
            charset: t,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : xt.charsetSentinel,
            comma: typeof e.comma == "boolean" ? e.comma : xt.comma,
            decodeDotInKeys: typeof e.decodeDotInKeys == "boolean" ? e.decodeDotInKeys : xt.decodeDotInKeys,
            decoder: typeof e.decoder == "function" ? e.decoder : xt.decoder,
            delimiter: typeof e.delimiter == "string" || ro.isRegExp(e.delimiter) ? e.delimiter : xt.delimiter,
            depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : xt.depth,
            duplicates: n,
            ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
            interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : xt.interpretNumericEntities,
            parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : xt.parameterLimit,
            parseArrays: e.parseArrays !== !1,
            plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : xt.plainObjects,
            strictDepth: typeof e.strictDepth == "boolean" ? !!e.strictDepth : xt.strictDepth,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : xt.strictNullHandling,
            throwOnLimitExceeded: typeof e.throwOnLimitExceeded == "boolean" ? e.throwOnLimitExceeded : !1
        }
    }, "normalizeParseOptions"),
    c3 = o(function(r, e) {
        var t = u3(e);
        if (r === "" || r === null || typeof r == "undefined") return t.plainObjects ? {
            __proto__: null
        } : {};
        for (var n = typeof r == "string" ? s3(r, t) : r, i = t.plainObjects ? {
                __proto__: null
            } : {}, s = Object.keys(n), a = 0; a < s.length; ++a) {
            var u = s[a],
                l = a3(u, n[u], t, typeof r == "string");
            i = ro.merge(i, l, t)
        }
        return t.allowSparse === !0 ? i : ro.compact(i)
    }, "parse$1"),
    l3 = t3,
    d3 = c3,
    f3 = K0,
    h3 = {
        formats: f3,
        parse: d3,
        stringify: l3
    },
    uO = T$(h3),
    cO = o(r => {
        let {
            payload: e,
            headers: t
        } = r;
        return !!(e && !(t != null && t["content-type"]))
    }, "missingContentType"),
    g3 = o((r, e) => {
        let t = e == null ? void 0 : e["content-type"];
        return t ? t.toLowerCase().includes(ir.FormUrlEncoded.toLowerCase()) ? ir.FormUrlEncoded : t.toLowerCase().includes(ir.Json.toLowerCase()) ? ir.Json : void 0 : r
    }, "getEffectiveContentType"),
    Y0 = o(r => {
        let {
            payload: e,
            contentType: t
        } = r;
        return t === ir.FormUrlEncoded ? uO.stringify(e) : t === ir.Json ? JSON.stringify(e) : e
    }, "stringifyPayload"),
    p3 = o(r => [...r].reduce((e, t) => {
        let [n, i] = t;
        return e[n] = i, e
    }, {}), "objectFromEntries"),
    X0 = o(r => {
        let {
            responseHeaders: e,
            localeHeader: t,
            currentLocale: n,
            setLocale: i
        } = r, s = t.toLowerCase(), a = Object.keys(e).find(l => l.toLowerCase() === s), u = a ? e[a] : void 0;
        u && n && u !== n && (i == null || i(u))
    }, "updateLocale"),
    m0 = o(r => r == null ? void 0 : r.replace("outsystems://", "https://"), "replaceNativeRequestProtocol"),
    rh = o((r, e, t) => {
        var n;
        let i;
        try {
            r && (i = JSON.parse(r))
        } catch (s) {
            (n = e == null ? void 0 : e.clientError) === null || n === void 0 || n.call(e, {
                error: s,
                category: t,
                clientMessage: `Could not parse response: ${r}`,
                internalMessage: "Could not parse response."
            })
        }
        return i
    }, "tryParseResponse"),
    m3 = o((r, e) => {
        if (!e) return r;
        let t = uO.stringify(e);
        if (t) {
            let n = r.includes("?") ? "&" : "?";
            return `${r}${n}${t}`
        }
        return r
    }, "appendQueryStringParams");

function v3() {
    if (typeof window != "undefined") return window;
    if (typeof global != "undefined") return global;
    if (typeof globalThis != "undefined") return globalThis;
    if (typeof self != "undefined") return self;
    throw new Error("unable to locate global object")
}
o(v3, "getGlobalScope");

function aa(r, e, t) {
    return Ve(this, void 0, void 0, function*() {
        return r != null && r.startActiveClientSpan ? r.startActiveClientSpan(e, n => Ve(this, void 0, void 0, function*() {
            try {
                return yield t()
            } finally {
                n == null || n.end()
            }
        })) : t()
    })
}
o(aa, "doWithSpan");
var b1 = "os-auth-retry",
    lO = o(r => {
        let {
            fetchClient: e,
            getToken: t,
            retryOnUnauthorizedResponse: n = !0
        } = r, i = e;
        return t && (i = o((s, a) => Ve(void 0, void 0, void 0, function*() {
            yield y3({
                config: a,
                getToken: t
            });
            let u = yield e(s, a);
            return n && (u.ok || (u = yield _3({
                response: u,
                fetchClient: e,
                config: Object.assign({}, a),
                getToken: t
            }))), u
        }), "result")), i
    }, "injectAuthInterceptors"),
    y3 = o(r => Ve(void 0, [r], void 0, function(e) {
        let {
            config: t = {},
            getToken: n
        } = e;
        return (function*() {
            var i;
            let s = yield n();
            return s && (t.headers = Object.assign(Object.assign({}, (i = t.headers) !== null && i !== void 0 ? i : {}), {
                Authorization: s
            })), t
        })()
    }), "setAccessTokenInRequestHeaders"),
    _3 = o(r => Ve(void 0, [r], void 0, function(e) {
        let {
            response: t,
            fetchClient: n,
            config: i = {},
            getToken: s
        } = e;
        return (function*() {
            var a;
            if (t.status !== 401 || t.headers.get(b1) === "true") return t;
            let u = yield s(!0);
            return u ? (i.headers = Object.assign(Object.assign({}, (a = i.headers) !== null && a !== void 0 ? a : {}), {
                Authorization: u,
                [b1]: "true"
            }), n(t.url, i)) : t
        })()
    }), "retryOnUnauthorized"),
    i0, s0, Mt, Zc, nh, ih, Qc, el, tl, sh, Kr, v0, o0, y0, _0, a0, oh, w0, S1, T0, A1, w3 = "",
    dO = 1e4,
    T3 = "",
    os = "FetchHttpClient",
    I1 = o(r => Ve(void 0, void 0, void 0, function*() {
        let e = yield r.text();
        return e === "" ? void 0 : JSON.parse(e)
    }), "readResponseJson");
(i0 = AbortSignal.timeout) !== null && i0 !== void 0 || (AbortSignal.timeout = o(function(e) {
    let t = new AbortController;
    return setTimeout(() => t.abort(), e), t.signal
}, "timeout"));
(s0 = AbortSignal.any) !== null && s0 !== void 0 || (AbortSignal.any = o(function(e) {
    let t = new AbortController;

    function n() {
        t.abort(), i()
    }
    o(n, "abort");

    function i() {
        for (let s of e) s.removeEventListener("abort", n)
    }
    o(i, "clean");
    for (let s of e)
        if (s.aborted) {
            t.abort(s.reason);
            break
        } else s.addEventListener("abort", n);
    return t.signal
}, "any"));
var ua, mi = (ua = class {
    constructor() {
        let {
            baseUrl: e = w3,
            headers: t = {},
            localeHeader: n = T3,
            getLocale: i,
            setLocale: s,
            fetchClient: a = v3().fetch,
            logger: u,
            loadTrace: l,
            getToken: c = o(() => Promise.resolve(void 0), "getToken")
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        Mt.add(this), Zc.set(this, void 0), nh.set(this, void 0), ih.set(this, void 0), Qc.set(this, void 0), el.set(this, void 0), tl.set(this, void 0), sh.set(this, void 0), Kr.set(this, void 0), qe(this, nh, e, "f"), qe(this, ih, t, "f"), qe(this, Qc, n, "f"), qe(this, el, i, "f"), qe(this, tl, s, "f"), qe(this, Kr, u, "f"), qe(this, sh, l, "f"), qe(this, Zc, this.addAuthInterceptors(a, c), "f")
    }
    addAuthInterceptors(e, t) {
        return lO({
            fetchClient: e,
            getToken: t
        })
    }
    post(e) {
        return Ve(this, arguments, void 0, function(t) {
            var n = this;
            let {
                url: i,
                payload: s,
                params: a,
                headers: u,
                contentType: l = ir.FormUrlEncoded,
                timeout: c,
                timeoutHandler: d,
                useLocaleInfo: f = !1,
                baseURL: h,
                abortCommand: g,
                userCancelController: p = new AbortController,
                responseHandler: m
            } = t;
            return (function*() {
                var w, T, E, b, R, L, V;
                (T = (w = ne(n, Kr, "f")) === null || w === void 0 ? void 0 : w.setActiveSpanAsNonAggregable) === null || T === void 0 || T.call(w);
                let z = f ? (E = ne(n, el, "f")) === null || E === void 0 ? void 0 : E.call(n) : void 0,
                    [j, Y] = ne(n, Mt, "m", v0).call(n, i, h, a);
                g && (g.onAbort = () => {
                    p.abort()
                });
                try {
                    (R = (b = ne(n, Kr, "f")) === null || b === void 0 ? void 0 : b.debug) === null || R === void 0 || R.call(b, {
                        category: os,
                        message: `POST ${Y}`
                    });
                    let q = g3(l, u),
                        P = {
                            body: s ? Y0({
                                payload: s,
                                contentType: q
                            }) : void 0,
                            headers: yield ne(n, Mt, "m", T0).call(n, u, z, cO({
                                payload: s,
                                headers: u
                            }) ? l : void 0),
                            method: "POST",
                            signal: AbortSignal.any([p.signal, AbortSignal.timeout(c ? c * 1e3 : dO)])
                        },
                        Z = o(() => Ve(n, void 0, void 0, function*() {
                            return ne(this, Zc, "f").call(this, j, P)
                        }), "fetch"),
                        oe = yield aa(ne(n, Kr, "f"), "POST", Z);
                    if (!oe.ok) throw yield ne(n, Mt, "m", w0).call(n, oe, i, "POST", d, p);
                    let S = yield I1(oe);
                    if (ne(n, Mt, "m", _0).call(n, oe, f, z), typeof m == "function") try {
                        let K = {};
                        oe.headers.forEach((M, Oe) => K[Oe] = M), m({
                            data: S,
                            responseHeaders: K
                        })
                    } catch (K) {
                        (V = (L = ne(n, Kr, "f")) === null || L === void 0 ? void 0 : L.error) === null || V === void 0 || V.call(L, {
                            category: os,
                            message: `Handler Error: POST ${Y}`,
                            errorCode: He.Communication_Default,
                            error: K
                        })
                    }
                    return S
                } catch (q) {
                    throw q instanceof Fr ? q : yield ne(n, Mt, "m", oh).call(n, q, i, "POST", d)
                }
            })()
        })
    }
    get(e) {
        return Ve(this, arguments, void 0, function(t) {
            var n = this;
            let {
                url: i,
                params: s,
                headers: a,
                useLocaleInfo: u,
                timeout: l,
                timeoutHandler: c,
                responseType: d = "json",
                baseURL: f
            } = t;
            return (function*() {
                let h = yield ne(n, Mt, "m", y0).call(n, {
                    url: i,
                    params: s,
                    headers: a,
                    useLocaleInfo: u,
                    timeout: l,
                    timeoutHandler: c,
                    baseURL: f
                });
                try {
                    return d === "blob" ? yield h.blob(): d === "json" ? yield I1(h): Promise.resolve()
                } catch (g) {
                    throw g instanceof Fr ? g : yield ne(n, Mt, "m", oh).call(n, g, i, "GET", c)
                }
            })()
        })
    }
    getResponseUrl(e) {
        return Ve(this, arguments, void 0, function(t) {
            var n = this;
            let {
                url: i,
                params: s,
                headers: a,
                useLocaleInfo: u,
                timeout: l,
                timeoutHandler: c,
                baseURL: d
            } = t;
            return (function*() {
                return (yield ne(n, Mt, "m", y0).call(n, {
                    url: i,
                    params: s,
                    headers: a,
                    useLocaleInfo: u,
                    timeout: l,
                    timeoutHandler: c,
                    baseURL: d
                })).url
            })()
        })
    }
}, o(ua, "FetchHttpClient"), ua);
Zc = new WeakMap, nh = new WeakMap, ih = new WeakMap, Qc = new WeakMap, el = new WeakMap, tl = new WeakMap, sh = new WeakMap, Kr = new WeakMap, Mt = new WeakSet, v0 = o(function(e, t, n) {
    var i;
    let s = (i = m0(e)) !== null && i !== void 0 ? i : "",
        a = m0(t || ne(this, nh, "f")),
        u = a && !e.includes("://") ? `${a.replace(/\/$/,"")}/${e.replace(/^\/+/,"")}` : s;
    return [m3(u, n), s]
}, "_FetchHttpClient_composeUrl"), o0 = o(function(e, t) {
    return Ve(this, void 0, void 0, function*() {
        e === ss.Timeout && t && (yield t())
    })
}, "_FetchHttpClient_handleFetchTimeout"), y0 = o(function(e) {
    return Ve(this, arguments, void 0, function(t) {
        var n = this;
        let {
            url: i,
            params: s,
            headers: a,
            useLocaleInfo: u = !1,
            timeout: l,
            timeoutHandler: c,
            baseURL: d
        } = t;
        return (function*() {
            var f, h, g, p, m;
            (h = (f = ne(n, Kr, "f")) === null || f === void 0 ? void 0 : f.setActiveSpanAsNonAggregable) === null || h === void 0 || h.call(f);
            let w = u ? (g = ne(n, el, "f")) === null || g === void 0 ? void 0 : g.call(n) : void 0,
                [T, E] = ne(n, Mt, "m", v0).call(n, i, d, s);
            try {
                (m = (p = ne(n, Kr, "f")) === null || p === void 0 ? void 0 : p.debug) === null || m === void 0 || m.call(p, {
                    category: os,
                    message: `GET ${E}`
                });
                let b = {
                        headers: yield ne(n, Mt, "m", T0).call(n, a, w),
                        signal: AbortSignal.timeout(l ? l * 1e3 : dO)
                    },
                    R = o(() => Ve(n, void 0, void 0, function*() {
                        return ne(this, Zc, "f").call(this, T, b)
                    }), "fetch"),
                    L = yield aa(ne(n, Kr, "f"), "GET", R);
                if (!L.ok) throw yield ne(n, Mt, "m", w0).call(n, L, i, "GET", c);
                return ne(n, Mt, "m", _0).call(n, L, u, w), L
            } catch (b) {
                throw b instanceof Fr ? b : yield ne(n, Mt, "m", oh).call(n, b, i, "GET", c)
            }
        })()
    })
}, "_FetchHttpClient_getResponse"), _0 = o(function(e, t, n) {
    t && ne(this, tl, "f") && (e != null && e.headers) && X0({
        responseHeaders: p3(e.headers.entries()),
        localeHeader: ne(this, Qc, "f"),
        currentLocale: n,
        setLocale: ne(this, tl, "f")
    })
}, "_FetchHttpClient_updateLocale"), a0 = o(function(e, t, n) {
    return (e == null ? void 0 : e.name) === "TimeoutError" || (e == null ? void 0 : e.name) === "AbortError" && !(t != null && t.signal.aborted) || n === 408 ? ss.Timeout : n === 401 ? ss.Unauthorized : (e == null ? void 0 : e.name) === "AbortError" && (t == null ? void 0 : t.signal.aborted) === !0 ? ss.Aborted : ss.Unknown
}, "_FetchHttpClient_parseError"), oh = o(function(e, t, n, i) {
    return Ve(this, void 0, void 0, function*() {
        var s, a;
        let u = ne(this, Mt, "m", a0).call(this, e);
        yield ne(this, Mt, "m", o0).call(this, u, i);
        let l = He.Communication_Default;
        return u === ss.Timeout ? l = He.Communication_Timeout : u === ss.Unauthorized ? l = He.Communication_Unauthorized : u === ss.Aborted && (l = He.Communication_Aborted), (a = (s = ne(this, Kr, "f")) === null || s === void 0 ? void 0 : s.error) === null || a === void 0 || a.call(s, {
            category: os,
            message: `${n} ${t} - ${e.message}`,
            errorCode: l,
            error: e
        }), new Fr(`${n} ${t} - ${e.message}`, l, void 0, void 0, os)
    })
}, "_FetchHttpClient_processFetchError"), w0 = o(function(e, t, n, i, s) {
    return Ve(this, void 0, void 0, function*() {
        var a, u, l;
        let c = ne(this, Mt, "m", a0).call(this, void 0, s, e.status);
        yield ne(this, Mt, "m", o0).call(this, c, i);
        let d = Ah((a = e.status) !== null && a !== void 0 ? a : ""),
            f = yield ne(this, Mt, "m", S1).call(this, e);
        return (l = (u = ne(this, Kr, "f")) === null || u === void 0 ? void 0 : u.error) === null || l === void 0 || l.call(u, {
            category: os,
            message: `${n} ${t} - ${e.status} ${e.statusText}`,
            errorCode: d,
            error: new Error(`Fetch ${n} Error - ${e.status} ${e.statusText}`)
        }), new Fr(`${n} ${t} - ${e.status} ${e.statusText}`, d, e.status, f, os)
    })
}, "_FetchHttpClient_processResponseError"), S1 = o(function(e) {
    return Ve(this, void 0, void 0, function*() {
        try {
            let t = /application\/.*json/i,
                n = e.headers.get("content-type");
            return n && t.test(n) ? yield e.json(): yield e.text()
        } catch (t) {
            return
        }
    })
}, "_FetchHttpClient_parseResponseData"), T0 = o(function(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    var i;
    let s = Object.assign(Object.assign(Object.assign(Object.assign({}, ne(this, ih, "f")), e), t ? {
        [ne(this, Qc, "f")]: t
    } : {}), e != null && e["content-type"] || n ? {
        "content-type": (i = e == null ? void 0 : e["content-type"]) !== null && i !== void 0 ? i : n
    } : {});
    return n && (s["content-type"] = n), ne(this, Mt, "m", A1).call(this, s)
}, "_FetchHttpClient_buildHeaders"), A1 = o(function(e) {
    return Ve(this, void 0, void 0, function*() {
        var t, n;
        try {
            return yield M1(e, () => {
                var i;
                return (i = ne(this, sh, "f")) === null || i === void 0 ? void 0 : i.call(this)
            })
        } catch (i) {
            (n = (t = ne(this, Kr, "f")) === null || t === void 0 ? void 0 : t.error) === null || n === void 0 || n.call(t, {
                category: os,
                message: "Error loading trace information",
                errorCode: He.Communication_Default,
                error: i
            })
        }
        return e
    })
}, "_FetchHttpClient_insertTraceHeaders");
var Z0 = class Z0 extends mi {
    addAuthInterceptors(e, t) {
        return lO({
            fetchClient: e,
            getToken: t,
            retryOnUnauthorizedResponse: !1
        })
    }
};
o(Z0, "LoggerHttpClient");
var ah = Z0,
    E3 = o((r, e, t) => {
        try {
            return S3(r, e, t)
        } catch (n) {
            return A3(r, e, t)
        }
    }, "buildUrl"),
    b3 = o(r => {
        try {
            return new URL(r), !0
        } catch (e) {
            return !1
        }
    }, "isUrlValid"),
    S3 = o((r, e, t) => {
        let n = b3(e != null ? e : "") ? new URL(r, e) : new URL(r);
        return Object.entries(t != null ? t : {}).forEach(i => {
            let [s, a] = i;
            n.searchParams.append(s, a != null ? a : "")
        }), n.toString()
    }, "buildAbsoluteUrl"),
    A3 = o((r, e, t) => {
        let n = `${e||""}/${r}${t?"?":""}`,
            i = "";
        return Object.entries(t != null ? t : {}).forEach(s => {
            let [a, u] = s;
            i += `${i?"&":""}${a}=${encodeURIComponent(u)}`
        }), `${n}${i}`.replace(/\/+/g, "/")
    }, "buildRelativeUrl"),
    gi, rl, uh, nl, nr, il, ch, lh, dh, C1, Wf, R1, O1, I3 = "",
    on = "NativeHttpClient",
    C3 = "",
    Q0 = class Q0 {
        constructor(e) {
            let {
                baseUrl: t = I3,
                headers: n = {},
                localeHeader: i = C3,
                getLocale: s,
                setLocale: a,
                httpClientInstance: u,
                logger: l,
                loadTrace: c,
                getToken: d
            } = e;
            gi.add(this), rl.set(this, void 0), uh.set(this, void 0), nl.set(this, void 0), nr.set(this, void 0), il.set(this, void 0), ch.set(this, void 0), lh.set(this, void 0), dh.set(this, void 0), qe(this, rl, i, "f"), qe(this, uh, s, "f"), qe(this, nl, a, "f"), qe(this, nr, l, "f"), this.httpClientInstance = u, qe(this, lh, t, "f"), qe(this, dh, n, "f"), qe(this, ch, c, "f"), qe(this, il, d != null ? d : () => Promise.resolve(void 0), "f")
        }
        post(e) {
            return Ve(this, arguments, void 0, function(t) {
                var n = this;
                let {
                    url: i,
                    payload: s,
                    params: a,
                    headers: u,
                    contentType: l = ir.FormUrlEncoded,
                    timeout: c,
                    timeoutHandler: d,
                    useLocaleInfo: f,
                    baseURL: h,
                    abortCommand: g,
                    responseHandler: p
                } = t;
                return (function*() {
                    var m, w, T;
                    let E = Y0({
                            payload: s,
                            contentType: l
                        }),
                        b = o(() => ne(n, gi, "m", Wf).call(n, {
                            method: "POST",
                            url: i,
                            params: a,
                            baseURL: h,
                            headers: u,
                            timeout: c,
                            timeoutHandler: d,
                            useLocaleInfo: f,
                            contentType: l,
                            payload: E,
                            abortControler: g
                        }), "fetch"),
                        R = yield aa(ne(n, nr, "f"), "POST", b), L = rh(R.responseText, ne(n, nr, "f"), on);
                    if (typeof p == "function") try {
                        p({
                            data: L,
                            responseHeaders: (m = R.responseHeaders) !== null && m !== void 0 ? m : {}
                        })
                    } catch (V) {
                        (T = (w = ne(n, nr, "f")) === null || w === void 0 ? void 0 : w.error) === null || T === void 0 || T.call(w, {
                            category: on,
                            message: `Handler Error: Post ${R.responseUrl}`,
                            errorCode: He.Communication_Default,
                            error: V
                        })
                    }
                    return L
                })()
            })
        }
        get(e) {
            return Ve(this, arguments, void 0, function(t) {
                var n = this;
                let {
                    url: i,
                    params: s,
                    headers: a,
                    responseType: u = "json",
                    useLocaleInfo: l,
                    timeout: c,
                    timeoutHandler: d,
                    baseURL: f
                } = t;
                return (function*() {
                    let h = u === "blob",
                        g = o(() => ne(n, gi, "m", Wf).call(n, {
                            method: "GET",
                            url: i,
                            params: s,
                            baseURL: f,
                            headers: a,
                            timeout: c,
                            timeoutHandler: d,
                            useLocaleInfo: l,
                            responseType: h ? "blob" : void 0
                        }), "fetch"),
                        p = yield aa(ne(n, nr, "f"), "GET", g);
                    return h ? p.response : u !== "none" ? rh(p.responseText, ne(n, nr, "f"), on) : void 0
                })()
            })
        }
        getResponseUrl(e) {
            return Ve(this, arguments, void 0, function(t) {
                var n = this;
                let {
                    url: i,
                    params: s,
                    headers: a,
                    useLocaleInfo: u,
                    timeout: l,
                    timeoutHandler: c,
                    baseURL: d
                } = t;
                return (function*() {
                    var f, h;
                    let g = o(() => ne(n, gi, "m", Wf).call(n, {
                            method: "GET",
                            url: i,
                            params: s,
                            baseURL: d,
                            headers: a,
                            timeout: l,
                            timeoutHandler: c,
                            useLocaleInfo: u
                        }), "fetch"),
                        p = yield aa(ne(n, nr, "f"), "GET", g);
                    if (!p.responseUrl) {
                        let m = new Error("Successful request came without a response URL");
                        throw (h = (f = ne(n, nr, "f")) === null || f === void 0 ? void 0 : f.error) === null || h === void 0 || h.call(f, {
                            error: m,
                            category: on,
                            message: "Successful request came without a response URL",
                            errorCode: He.Communication_Default
                        }), m
                    }
                    return p.responseUrl
                })()
            })
        }
    };
o(Q0, "NativeHttpClient");
var fh = Q0;
rl = new WeakMap, uh = new WeakMap, nl = new WeakMap, nr = new WeakMap, il = new WeakMap, ch = new WeakMap, lh = new WeakMap, dh = new WeakMap, gi = new WeakSet, C1 = o(function(e, t, n, i, s) {
    return Ve(this, void 0, void 0, function*() {
        var a, u, l, c, d, f, h, g;
        if (t.status === 401 && !n) {
            if (yield ne(this, il, "f").call(this, !0)) return s(); {
                let m = new Error("Unable to retrieve an authorization token");
                throw (u = (a = ne(this, nr, "f")) === null || a === void 0 ? void 0 : a.error) === null || u === void 0 || u.call(a, {
                    error: m,
                    category: on,
                    message: `${e} ${i}`,
                    errorCode: He.Communication_Unauthorized
                }), m
            }
        } else {
            let p = (d = (c = (l = t.status) === null || l === void 0 ? void 0 : l.toString) === null || c === void 0 ? void 0 : c.call(l)) !== null && d !== void 0 ? d : "",
                m = Ah(p),
                w = new Fr((f = t.responseText) !== null && f !== void 0 ? f : "Network Error", m, p, rh(t.responseText, ne(this, nr, "f"), on), on);
            throw (g = (h = ne(this, nr, "f")) === null || h === void 0 ? void 0 : h.error) === null || g === void 0 || g.call(h, {
                error: w,
                category: on,
                message: `${e} ${i}`,
                errorCode: m
            }), w
        }
    })
}, "_NativeHttpClient_onErrorHandler"), Wf = o(function r(e) {
    return Ve(this, void 0, void 0, function*() {
        var t, n, i;
        (n = (t = ne(this, nr, "f")) === null || t === void 0 ? void 0 : t.setActiveSpanAsNonAggregable) === null || n === void 0 || n.call(t);
        let {
            method: s,
            url: a,
            params: u,
            baseURL: l,
            payload: c,
            headers: d,
            useLocaleInfo: f,
            timeout: h,
            timeoutHandler: g,
            isRetry: p,
            contentType: m,
            responseType: w
        } = e, T = E3(a, l != null ? l : ne(this, lh, "f"), u), E = f ? (i = ne(this, uh, "f")) === null || i === void 0 ? void 0 : i.call(this) : void 0, b = yield ne(this, gi, "m", R1).call(this, {
            headers: d,
            locale: E,
            contentType: m
        });
        return new Promise((R, L) => {
            var V, z;
            let j = this.httpClientInstance.createRequest(s, T);
            j.onError = Y => Ve(this, void 0, void 0, function*() {
                try {
                    let q = yield ne(this, gi, "m", C1).call(this, s, Y, !!p, T, () => ne(this, gi, "m", r).call(this, Object.assign(Object.assign({}, e), {
                        isRetry: !0
                    })));
                    R(q)
                } catch (q) {
                    L(q)
                }
            }), j.onTimeout = () => {
                var Y, q;
                try {
                    g == null || g()
                } catch (Z) {
                    L(Z)
                }
                let P = new Error(`Request timed out: ${T}`);
                (q = (Y = ne(this, nr, "f")) === null || Y === void 0 ? void 0 : Y.error) === null || q === void 0 || q.call(Y, {
                    category: on,
                    message: `POST ${T}`,
                    errorCode: He.Communication_Timeout,
                    error: P
                }), L(P)
            }, j.onSuccess = Y => {
                f && ne(this, nl, "f") && Y.responseHeaders && X0({
                    responseHeaders: Y.responseHeaders,
                    localeHeader: ne(this, rl, "f"),
                    currentLocale: E,
                    setLocale: ne(this, nl, "f")
                }), R(Y)
            }, j.onAbort = () => {
                var Y, q;
                let P = new Error(`Request was aborted: ${T}`);
                (q = (Y = ne(this, nr, "f")) === null || Y === void 0 ? void 0 : Y.error) === null || q === void 0 || q.call(Y, {
                    category: on,
                    message: `POST ${T}`,
                    errorCode: He.Communication_Aborted,
                    error: P
                }), L(P)
            }, Object.entries(b).forEach(Y => {
                let [q, P] = Y;
                j.setHeader(q, P)
            }), h && j.setTimeout(h * 1e3), c && j.setBody(c), w === "blob" && (j.responseType = "blob"), (z = (V = ne(this, nr, "f")) === null || V === void 0 ? void 0 : V.debug) === null || z === void 0 || z.call(V, {
                category: on,
                message: `${s} ${a}`
            }), e.abortControler && (e.abortControler.onAbort = () => {
                j.abort()
            }), j.send()
        })
    })
}, "_NativeHttpClient_executeRequest"), R1 = o(function(e) {
    return Ve(this, arguments, void 0, function(t) {
        var n = this;
        let {
            headers: i,
            locale: s,
            contentType: a
        } = t;
        return (function*() {
            var u;
            let l = Object.assign(Object.assign(Object.assign({}, (u = ne(n, dh, "f")) !== null && u !== void 0 ? u : {}), i), s ? {
                [ne(n, rl, "f")]: s
            } : {});
            a && !l["content-type"] && (l["content-type"] = a);
            let c = yield ne(n, il, "f").call(n);
            return c && (l.authorization = c), yield ne(n, gi, "m", O1).call(n, l)
        })()
    })
}, "_NativeHttpClient_buildHeaders"), O1 = o(function(e) {
    return Ve(this, void 0, void 0, function*() {
        var t, n;
        try {
            return yield M1(e, () => {
                var i;
                return (i = ne(this, ch, "f")) === null || i === void 0 ? void 0 : i.call(this)
            })
        } catch (i) {
            (n = (t = ne(this, nr, "f")) === null || t === void 0 ? void 0 : t.error) === null || n === void 0 || n.call(t, {
                category: on,
                message: "Error loading trace information",
                errorCode: He.Communication_Default,
                error: i
            })
        }
        return e
    })
}, "_NativeHttpClient_insertTraceHeaders");
var e_ = class e_ extends Error {
    constructor(e, t) {
        let n = new.target.prototype;
        super(`${e}: Status code '${t}'`), this.statusCode = t, this.__proto__ = n
    }
};
o(e_, "HttpError");
var cs = e_,
    t_ = class t_ extends Error {
        constructor() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "A timeout occurred.",
                t = new.target.prototype;
            super(e), this.__proto__ = t
        }
    };
o(t_, "TimeoutError");
var ul = t_,
    r_ = class r_ extends Error {
        constructor() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "An abort occurred.",
                t = new.target.prototype;
            super(e), this.__proto__ = t
        }
    };
o(r_, "AbortError");
var Yr = r_,
    n_ = class n_ extends Error {
        constructor(e, t) {
            let n = new.target.prototype;
            super(e), this.transport = t, this.errorType = "UnsupportedTransportError", this.__proto__ = n
        }
    };
o(n_, "UnsupportedTransportError");
var E0 = n_,
    i_ = class i_ extends Error {
        constructor(e, t) {
            let n = new.target.prototype;
            super(e), this.transport = t, this.errorType = "DisabledTransportError", this.__proto__ = n
        }
    };
o(i_, "DisabledTransportError");
var b0 = i_,
    s_ = class s_ extends Error {
        constructor(e, t) {
            let n = new.target.prototype;
            super(e), this.transport = t, this.errorType = "FailedToStartTransportError", this.__proto__ = n
        }
    };
o(s_, "FailedToStartTransportError");
var S0 = s_,
    o_ = class o_ extends Error {
        constructor(e) {
            let t = new.target.prototype;
            super(e), this.errorType = "FailedToNegotiateWithServerError", this.__proto__ = t
        }
    };
o(o_, "FailedToNegotiateWithServerError");
var A0 = o_,
    a_ = class a_ extends Error {
        constructor(e, t) {
            let n = new.target.prototype;
            super(e), this.innerErrors = t, this.__proto__ = n
        }
    };
o(a_, "AggregateErrors");
var I0 = a_,
    u_ = class u_ {
        constructor(e, t, n) {
            this.statusCode = e, this.statusText = t, this.content = n
        }
    };
o(u_, "HttpResponse");
var hh = u_,
    c_ = class c_ {
        get(e, t) {
            return this.send(ns(Rt({}, t), {
                method: "GET",
                url: e
            }))
        }
        post(e, t) {
            return this.send(ns(Rt({}, t), {
                method: "POST",
                url: e
            }))
        }
        delete(e, t) {
            return this.send(ns(Rt({}, t), {
                method: "DELETE",
                url: e
            }))
        }
        getCookieString(e) {
            return ""
        }
    };
o(c_, "HttpClient");
var fa = c_,
    Q;
(function(r) {
    r[r.Trace = 0] = "Trace", r[r.Debug = 1] = "Debug", r[r.Information = 2] = "Information", r[r.Warning = 3] = "Warning", r[r.Error = 4] = "Error", r[r.Critical = 5] = "Critical", r[r.None = 6] = "None"
})(Q || (Q = {}));
var l_ = class l_ {
    constructor() {}
    log(e, t) {}
};
o(l_, "NullLogger");
var no = l_;
no.instance = new no;
var R3 = "7.0.12",
    d_ = class d_ {
        static isRequired(e, t) {
            if (e == null) throw new Error(`The '${t}' argument is required.`)
        }
        static isNotEmpty(e, t) {
            if (!e || e.match(/^\s*$/)) throw new Error(`The '${t}' argument should not be empty.`)
        }
        static isIn(e, t, n) {
            if (!(e in t)) throw new Error(`Unknown ${n} value: ${e}.`)
        }
    };
o(d_, "Arg");
var Vt = d_,
    f_ = class f_ {
        static get isBrowser() {
            return typeof window == "object" && typeof window.document == "object"
        }
        static get isWebWorker() {
            return typeof self == "object" && "importScripts" in self
        }
        static get isReactNative() {
            return typeof window == "object" && typeof window.document == "undefined"
        }
        static get isNode() {
            return !this.isBrowser && !this.isWebWorker && !this.isReactNative
        }
    };
o(f_, "Platform");
var Bt = f_;

function cl(r, e) {
    let t = "";
    return hl(r) ? (t = `Binary data of length ${r.byteLength}`, e && (t += `. Content: '${O3(r)}'`)) : typeof r == "string" && (t = `String data of length ${r.length}`, e && (t += `. Content: '${r}'`)), t
}
o(cl, "getDataDetail");

function O3(r) {
    let e = new Uint8Array(r),
        t = "";
    return e.forEach(n => {
        let i = n < 16 ? "0" : "";
        t += `0x${i}${n.toString(16)} `
    }), t.substr(0, t.length - 1)
}
o(O3, "formatArrayBuffer");

function hl(r) {
    return r && typeof ArrayBuffer != "undefined" && (r instanceof ArrayBuffer || r.constructor && r.constructor.name === "ArrayBuffer")
}
o(hl, "isArrayBuffer");

function fO(r, e, t, n, i, s) {
    return vt(this, null, function*() {
        let a = {},
            [u, l] = ga();
        a[u] = l, r.log(Q.Trace, `(${e} transport) sending data. ${cl(i,s.logMessageContent)}.`);
        let c = hl(i) ? "arraybuffer" : "text",
            d = yield t.post(n, {
                content: i,
                headers: Rt(Rt({}, a), s.headers),
                responseType: c,
                timeout: s.timeout,
                withCredentials: s.withCredentials
            });
        r.log(Q.Trace, `(${e} transport) request complete. Response status: ${d.statusCode}.`)
    })
}
o(fO, "sendMessage");

function P3(r) {
    return r === void 0 ? new ha(Q.Information) : r === null ? no.instance : r.log !== void 0 ? r : new ha(r)
}
o(P3, "createLogger");
var h_ = class h_ {
    constructor(e, t) {
        this._subject = e, this._observer = t
    }
    dispose() {
        let e = this._subject.observers.indexOf(this._observer);
        e > -1 && this._subject.observers.splice(e, 1), this._subject.observers.length === 0 && this._subject.cancelCallback && this._subject.cancelCallback().catch(t => {})
    }
};
o(h_, "SubjectSubscription");
var C0 = h_,
    g_ = class g_ {
        constructor(e) {
            this._minLevel = e, this.out = console
        }
        log(e, t) {
            if (e >= this._minLevel) {
                let n = `[${new Date().toISOString()}] ${Q[e]}: ${t}`;
                switch (e) {
                    case Q.Critical:
                    case Q.Error:
                        this.out.error(n);
                        break;
                    case Q.Warning:
                        this.out.warn(n);
                        break;
                    case Q.Information:
                        this.out.info(n);
                        break;
                    default:
                        this.out.log(n);
                        break
                }
            }
        }
    };
o(g_, "ConsoleLogger");
var ha = g_;

function ga() {
    let r = "X-SignalR-User-Agent";
    return Bt.isNode && (r = "User-Agent"), [r, N3(R3, D3(), x3(), L3())]
}
o(ga, "getUserAgentHeader");

function N3(r, e, t, n) {
    let i = "Microsoft SignalR/",
        s = r.split(".");
    return i += `${s[0]}.${s[1]}`, i += ` (${r}; `, e && e !== "" ? i += `${e}; ` : i += "Unknown OS; ", i += `${t}`, n ? i += `; ${n}` : i += "; Unknown Runtime Version", i += ")", i
}
o(N3, "constructUserAgent");

function D3() {
    if (Bt.isNode) switch (process.platform) {
        case "win32":
            return "Windows NT";
        case "darwin":
            return "macOS";
        case "linux":
            return "Linux";
        default:
            return process.platform
    } else return ""
}
o(D3, "getOsName");

function L3() {
    if (Bt.isNode) return process.versions.node
}
o(L3, "getRuntimeVersion");

function x3() {
    return Bt.isNode ? "NodeJS" : "Browser"
}
o(x3, "getRuntime");

function P1(r) {
    return r.stack ? r.stack : r.message ? r.message : `${r}`
}
o(P1, "getErrorString");

function U3() {
    if (typeof globalThis != "undefined") return globalThis;
    if (typeof self != "undefined") return self;
    if (typeof window != "undefined") return window;
    if (typeof global != "undefined") return global;
    throw new Error("could not find global")
}
o(U3, "getGlobalThis");
var p_ = class p_ extends fa {
    constructor(e) {
        if (super(), this._logger = e, typeof fetch == "undefined") {
            let t = typeof __webpack_require__ == "function" ? __non_webpack_require__ : is;
            this._jar = new(t("tough-cookie")).CookieJar, this._fetchType = t("node-fetch"), this._fetchType = t("fetch-cookie")(this._fetchType, this._jar)
        } else this._fetchType = fetch.bind(U3());
        if (typeof AbortController == "undefined") {
            let t = typeof __webpack_require__ == "function" ? __non_webpack_require__ : is;
            this._abortControllerType = t("abort-controller")
        } else this._abortControllerType = AbortController
    }
    send(e) {
        return vt(this, null, function*() {
            if (e.abortSignal && e.abortSignal.aborted) throw new Yr;
            if (!e.method) throw new Error("No method defined.");
            if (!e.url) throw new Error("No url defined.");
            let t = new this._abortControllerType,
                n;
            e.abortSignal && (e.abortSignal.onabort = () => {
                t.abort(), n = new Yr
            });
            let i = null;
            if (e.timeout) {
                let l = e.timeout;
                i = setTimeout(() => {
                    t.abort(), this._logger.log(Q.Warning, "Timeout from HTTP request."), n = new ul
                }, l)
            }
            e.content === "" && (e.content = void 0), e.content && (e.headers = e.headers || {}, hl(e.content) ? e.headers["Content-Type"] = "application/octet-stream" : e.headers["Content-Type"] = "text/plain;charset=UTF-8");
            let s;
            try {
                s = yield this._fetchType(e.url, {
                    body: e.content,
                    cache: "no-cache",
                    credentials: e.withCredentials === !0 ? "include" : "same-origin",
                    headers: Rt({
                        "X-Requested-With": "XMLHttpRequest"
                    }, e.headers),
                    method: e.method,
                    mode: "cors",
                    redirect: "follow",
                    signal: t.signal
                })
            } catch (l) {
                throw n || (this._logger.log(Q.Warning, `Error from HTTP request. ${l}.`), l)
            } finally {
                i && clearTimeout(i), e.abortSignal && (e.abortSignal.onabort = null)
            }
            if (!s.ok) {
                let l = yield N1(s, "text");
                throw new cs(l || s.statusText, s.status)
            }
            let u = yield N1(s, e.responseType);
            return new hh(s.status, s.statusText, u)
        })
    }
    getCookieString(e) {
        let t = "";
        return Bt.isNode && this._jar && this._jar.getCookies(e, (n, i) => t = i.join("; ")), t
    }
};
o(p_, "FetchHttpClient");
var R0 = p_;

function N1(r, e) {
    let t;
    switch (e) {
        case "arraybuffer":
            t = r.arrayBuffer();
            break;
        case "text":
            t = r.text();
            break;
        case "blob":
        case "document":
        case "json":
            throw new Error(`${e} is not supported.`);
        default:
            t = r.text();
            break
    }
    return t
}
o(N1, "deserializeContent");
var m_ = class m_ extends fa {
    constructor(e) {
        super(), this._logger = e
    }
    send(e) {
        return e.abortSignal && e.abortSignal.aborted ? Promise.reject(new Yr) : e.method ? e.url ? new Promise((t, n) => {
            let i = new XMLHttpRequest;
            i.open(e.method, e.url, !0), i.withCredentials = e.withCredentials === void 0 ? !0 : e.withCredentials, i.setRequestHeader("X-Requested-With", "XMLHttpRequest"), e.content === "" && (e.content = void 0), e.content && (hl(e.content) ? i.setRequestHeader("Content-Type", "application/octet-stream") : i.setRequestHeader("Content-Type", "text/plain;charset=UTF-8"));
            let s = e.headers;
            s && Object.keys(s).forEach(a => {
                i.setRequestHeader(a, s[a])
            }), e.responseType && (i.responseType = e.responseType), e.abortSignal && (e.abortSignal.onabort = () => {
                i.abort(), n(new Yr)
            }), e.timeout && (i.timeout = e.timeout), i.onload = () => {
                e.abortSignal && (e.abortSignal.onabort = null), i.status >= 200 && i.status < 300 ? t(new hh(i.status, i.statusText, i.response || i.responseText)) : n(new cs(i.response || i.responseText || i.statusText, i.status))
            }, i.onerror = () => {
                this._logger.log(Q.Warning, `Error from HTTP request. ${i.status}: ${i.statusText}.`), n(new cs(i.statusText, i.status))
            }, i.ontimeout = () => {
                this._logger.log(Q.Warning, "Timeout from HTTP request."), n(new ul)
            }, i.send(e.content)
        }) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."))
    }
};
o(m_, "XhrHttpClient");
var O0 = m_,
    v_ = class v_ extends fa {
        constructor(e) {
            if (super(), typeof fetch != "undefined" || Bt.isNode) this._httpClient = new R0(e);
            else if (typeof XMLHttpRequest != "undefined") this._httpClient = new O0(e);
            else throw new Error("No usable HttpClient found.")
        }
        send(e) {
            return e.abortSignal && e.abortSignal.aborted ? Promise.reject(new Yr) : e.method ? e.url ? this._httpClient.send(e) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."))
        }
        getCookieString(e) {
            return this._httpClient.getCookieString(e)
        }
    };
o(v_, "DefaultHttpClient");
var P0 = v_,
    sa = class sa {
        static write(e) {
            return `${e}${sa.RecordSeparator}`
        }
        static parse(e) {
            if (e[e.length - 1] !== sa.RecordSeparator) throw new Error("Message is incomplete.");
            let t = e.split(sa.RecordSeparator);
            return t.pop(), t
        }
    };
o(sa, "TextMessageFormat");
var In = sa;
In.RecordSeparatorCode = 30;
In.RecordSeparator = String.fromCharCode(In.RecordSeparatorCode);
var y_ = class y_ {
    writeHandshakeRequest(e) {
        return In.write(JSON.stringify(e))
    }
    parseHandshakeResponse(e) {
        let t, n;
        if (hl(e)) {
            let u = new Uint8Array(e),
                l = u.indexOf(In.RecordSeparatorCode);
            if (l === -1) throw new Error("Message is incomplete.");
            let c = l + 1;
            t = String.fromCharCode.apply(null, Array.prototype.slice.call(u.slice(0, c))), n = u.byteLength > c ? u.slice(c).buffer : null
        } else {
            let u = e,
                l = u.indexOf(In.RecordSeparator);
            if (l === -1) throw new Error("Message is incomplete.");
            let c = l + 1;
            t = u.substring(0, c), n = u.length > c ? u.substring(c) : null
        }
        let i = In.parse(t),
            s = JSON.parse(i[0]);
        if (s.type) throw new Error("Expected a handshake response from the server.");
        return [n, s]
    }
};
o(y_, "HandshakeProtocol");
var N0 = y_,
    St;
(function(r) {
    r[r.Invocation = 1] = "Invocation", r[r.StreamItem = 2] = "StreamItem", r[r.Completion = 3] = "Completion", r[r.StreamInvocation = 4] = "StreamInvocation", r[r.CancelInvocation = 5] = "CancelInvocation", r[r.Ping = 6] = "Ping", r[r.Close = 7] = "Close"
})(St || (St = {}));
var __ = class __ {
    constructor() {
        this.observers = []
    }
    next(e) {
        for (let t of this.observers) t.next(e)
    }
    error(e) {
        for (let t of this.observers) t.error && t.error(e)
    }
    complete() {
        for (let e of this.observers) e.complete && e.complete()
    }
    subscribe(e) {
        return this.observers.push(e), new C0(this, e)
    }
};
o(__, "Subject");
var D0 = __,
    M3 = 30 * 1e3,
    k3 = 15 * 1e3,
    Nt;
(function(r) {
    r.Disconnected = "Disconnected", r.Connecting = "Connecting", r.Connected = "Connected", r.Disconnecting = "Disconnecting", r.Reconnecting = "Reconnecting"
})(Nt || (Nt = {}));
var bh = class bh {
    constructor(e, t, n, i) {
        this._nextKeepAlive = 0, this._freezeEventListener = () => {
            this._logger.log(Q.Warning, "The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://docs.microsoft.com/aspnet/core/signalr/javascript-client#bsleep")
        }, Vt.isRequired(e, "connection"), Vt.isRequired(t, "logger"), Vt.isRequired(n, "protocol"), this.serverTimeoutInMilliseconds = M3, this.keepAliveIntervalInMilliseconds = k3, this._logger = t, this._protocol = n, this.connection = e, this._reconnectPolicy = i, this._handshakeProtocol = new N0, this.connection.onreceive = s => this._processIncomingData(s), this.connection.onclose = s => this._connectionClosed(s), this._callbacks = {}, this._methods = {}, this._closedCallbacks = [], this._reconnectingCallbacks = [], this._reconnectedCallbacks = [], this._invocationId = 0, this._receivedHandshakeResponse = !1, this._connectionState = Nt.Disconnected, this._connectionStarted = !1, this._cachedPingMessage = this._protocol.writeMessage({
            type: St.Ping
        })
    }
    static create(e, t, n, i) {
        return new bh(e, t, n, i)
    }
    get state() {
        return this._connectionState
    }
    get connectionId() {
        return this.connection && this.connection.connectionId || null
    }
    get baseUrl() {
        return this.connection.baseUrl || ""
    }
    set baseUrl(e) {
        if (this._connectionState !== Nt.Disconnected && this._connectionState !== Nt.Reconnecting) throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");
        if (!e) throw new Error("The HubConnection url must be a valid url.");
        this.connection.baseUrl = e
    }
    start() {
        return this._startPromise = this._startWithStateTransitions(), this._startPromise
    }
    _startWithStateTransitions() {
        return vt(this, null, function*() {
            if (this._connectionState !== Nt.Disconnected) return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));
            this._connectionState = Nt.Connecting, this._logger.log(Q.Debug, "Starting HubConnection.");
            try {
                yield this._startInternal(), Bt.isBrowser && window.document.addEventListener("freeze", this._freezeEventListener), this._connectionState = Nt.Connected, this._connectionStarted = !0, this._logger.log(Q.Debug, "HubConnection connected successfully.")
            } catch (e) {
                return this._connectionState = Nt.Disconnected, this._logger.log(Q.Debug, `HubConnection failed to start successfully because of error '${e}'.`), Promise.reject(e)
            }
        })
    }
    _startInternal() {
        return vt(this, null, function*() {
            this._stopDuringStartError = void 0, this._receivedHandshakeResponse = !1;
            let e = new Promise((t, n) => {
                this._handshakeResolver = t, this._handshakeRejecter = n
            });
            yield this.connection.start(this._protocol.transferFormat);
            try {
                let t = {
                    protocol: this._protocol.name,
                    version: this._protocol.version
                };
                if (this._logger.log(Q.Debug, "Sending handshake request."), yield this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(t)), this._logger.log(Q.Information, `Using HubProtocol '${this._protocol.name}'.`), this._cleanupTimeout(), this._resetTimeoutPeriod(), this._resetKeepAliveInterval(), yield e, this._stopDuringStartError) throw this._stopDuringStartError;
                this.connection.features.inherentKeepAlive || (yield this._sendMessage(this._cachedPingMessage))
            } catch (t) {
                throw this._logger.log(Q.Debug, `Hub handshake failed with error '${t}' during start(). Stopping HubConnection.`), this._cleanupTimeout(), this._cleanupPingTimer(), yield this.connection.stop(t), t
            }
        })
    }
    stop() {
        return vt(this, null, function*() {
            let e = this._startPromise;
            this._stopPromise = this._stopInternal(), yield this._stopPromise;
            try {
                yield e
            } catch (t) {}
        })
    }
    _stopInternal(e) {
        return this._connectionState === Nt.Disconnected ? (this._logger.log(Q.Debug, `Call to HubConnection.stop(${e}) ignored because it is already in the disconnected state.`), Promise.resolve()) : this._connectionState === Nt.Disconnecting ? (this._logger.log(Q.Debug, `Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnecting state.`), this._stopPromise) : (this._connectionState = Nt.Disconnecting, this._logger.log(Q.Debug, "Stopping HubConnection."), this._reconnectDelayHandle ? (this._logger.log(Q.Debug, "Connection stopped during reconnect delay. Done reconnecting."), clearTimeout(this._reconnectDelayHandle), this._reconnectDelayHandle = void 0, this._completeClose(), Promise.resolve()) : (this._cleanupTimeout(), this._cleanupPingTimer(), this._stopDuringStartError = e || new Yr("The connection was stopped before the hub handshake could complete."), this.connection.stop(e)))
    }
    stream(e) {
        for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
        let [s, a] = this._replaceStreamingParams(n), u = this._createStreamInvocation(e, n, a), l, c = new D0;
        return c.cancelCallback = () => {
            let d = this._createCancelInvocation(u.invocationId);
            return delete this._callbacks[u.invocationId], l.then(() => this._sendWithProtocol(d))
        }, this._callbacks[u.invocationId] = (d, f) => {
            if (f) {
                c.error(f);
                return
            } else d && (d.type === St.Completion ? d.error ? c.error(new Error(d.error)) : c.complete() : c.next(d.item))
        }, l = this._sendWithProtocol(u).catch(d => {
            c.error(d), delete this._callbacks[u.invocationId]
        }), this._launchStreams(s, l), c
    }
    _sendMessage(e) {
        return this._resetKeepAliveInterval(), this.connection.send(e)
    }
    _sendWithProtocol(e) {
        return this._sendMessage(this._protocol.writeMessage(e))
    }
    send(e) {
        for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
        let [s, a] = this._replaceStreamingParams(n), u = this._sendWithProtocol(this._createInvocation(e, n, !0, a));
        return this._launchStreams(s, u), u
    }
    invoke(e) {
        for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
        let [s, a] = this._replaceStreamingParams(n), u = this._createInvocation(e, n, !1, a);
        return new Promise((c, d) => {
            this._callbacks[u.invocationId] = (h, g) => {
                if (g) {
                    d(g);
                    return
                } else h && (h.type === St.Completion ? h.error ? d(new Error(h.error)) : c(h.result) : d(new Error(`Unexpected message type: ${h.type}`)))
            };
            let f = this._sendWithProtocol(u).catch(h => {
                d(h), delete this._callbacks[u.invocationId]
            });
            this._launchStreams(s, f)
        })
    }
    on(e, t) {
        !e || !t || (e = e.toLowerCase(), this._methods[e] || (this._methods[e] = []), this._methods[e].indexOf(t) === -1 && this._methods[e].push(t))
    }
    off(e, t) {
        if (!e) return;
        e = e.toLowerCase();
        let n = this._methods[e];
        if (n)
            if (t) {
                let i = n.indexOf(t);
                i !== -1 && (n.splice(i, 1), n.length === 0 && delete this._methods[e])
            } else delete this._methods[e]
    }
    onclose(e) {
        e && this._closedCallbacks.push(e)
    }
    onreconnecting(e) {
        e && this._reconnectingCallbacks.push(e)
    }
    onreconnected(e) {
        e && this._reconnectedCallbacks.push(e)
    }
    _processIncomingData(e) {
        if (this._cleanupTimeout(), this._receivedHandshakeResponse || (e = this._processHandshakeResponse(e), this._receivedHandshakeResponse = !0), e) {
            let t = this._protocol.parseMessages(e, this._logger);
            for (let n of t) switch (n.type) {
                case St.Invocation:
                    this._invokeClientMethod(n);
                    break;
                case St.StreamItem:
                case St.Completion: {
                    let i = this._callbacks[n.invocationId];
                    if (i) {
                        n.type === St.Completion && delete this._callbacks[n.invocationId];
                        try {
                            i(n)
                        } catch (s) {
                            this._logger.log(Q.Error, `Stream callback threw error: ${P1(s)}`)
                        }
                    }
                    break
                }
                case St.Ping:
                    break;
                case St.Close: {
                    this._logger.log(Q.Information, "Close message received from server.");
                    let i = n.error ? new Error("Server returned an error on close: " + n.error) : void 0;
                    n.allowReconnect === !0 ? this.connection.stop(i) : this._stopPromise = this._stopInternal(i);
                    break
                }
                default:
                    this._logger.log(Q.Warning, `Invalid message type: ${n.type}.`);
                    break
            }
        }
        this._resetTimeoutPeriod()
    }
    _processHandshakeResponse(e) {
        let t, n;
        try {
            [n, t] = this._handshakeProtocol.parseHandshakeResponse(e)
        } catch (i) {
            let s = "Error parsing handshake response: " + i;
            this._logger.log(Q.Error, s);
            let a = new Error(s);
            throw this._handshakeRejecter(a), a
        }
        if (t.error) {
            let i = "Server returned handshake error: " + t.error;
            this._logger.log(Q.Error, i);
            let s = new Error(i);
            throw this._handshakeRejecter(s), s
        } else this._logger.log(Q.Debug, "Server handshake complete.");
        return this._handshakeResolver(), n
    }
    _resetKeepAliveInterval() {
        this.connection.features.inherentKeepAlive || (this._nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds, this._cleanupPingTimer())
    }
    _resetTimeoutPeriod() {
        if ((!this.connection.features || !this.connection.features.inherentKeepAlive) && (this._timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds), this._pingServerHandle === void 0)) {
            let e = this._nextKeepAlive - new Date().getTime();
            e < 0 && (e = 0), this._pingServerHandle = setTimeout(() => vt(this, null, function*() {
                if (this._connectionState === Nt.Connected) try {
                    yield this._sendMessage(this._cachedPingMessage)
                } catch (t) {
                    this._cleanupPingTimer()
                }
            }), e)
        }
    }
    serverTimeout() {
        this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."))
    }
    _invokeClientMethod(e) {
        return vt(this, null, function*() {
            let t = e.target.toLowerCase(),
                n = this._methods[t];
            if (!n) {
                this._logger.log(Q.Warning, `No client method with the name '${t}' found.`), e.invocationId && (this._logger.log(Q.Warning, `No result given for '${t}' method and invocation ID '${e.invocationId}'.`), yield this._sendWithProtocol(this._createCompletionMessage(e.invocationId, "Client didn't provide a result.", null)));
                return
            }
            let i = n.slice(),
                s = !!e.invocationId,
                a, u, l;
            for (let c of i) try {
                let d = a;
                a = yield c.apply(this, e.arguments), s && a && d && (this._logger.log(Q.Error, `Multiple results provided for '${t}'. Sending error to server.`), l = this._createCompletionMessage(e.invocationId, "Client provided multiple results.", null)), u = void 0
            } catch (d) {
                u = d, this._logger.log(Q.Error, `A callback for the method '${t}' threw error '${d}'.`)
            }
            l ? yield this._sendWithProtocol(l): s ? (u ? l = this._createCompletionMessage(e.invocationId, `${u}`, null) : a !== void 0 ? l = this._createCompletionMessage(e.invocationId, null, a) : (this._logger.log(Q.Warning, `No result given for '${t}' method and invocation ID '${e.invocationId}'.`), l = this._createCompletionMessage(e.invocationId, "Client didn't provide a result.", null)), yield this._sendWithProtocol(l)) : a && this._logger.log(Q.Error, `Result given for '${t}' method but server is not expecting a result.`)
        })
    }
    _connectionClosed(e) {
        this._logger.log(Q.Debug, `HubConnection.connectionClosed(${e}) called while in state ${this._connectionState}.`), this._stopDuringStartError = this._stopDuringStartError || e || new Yr("The underlying connection was closed before the hub handshake could complete."), this._handshakeResolver && this._handshakeResolver(), this._cancelCallbacksWithError(e || new Error("Invocation canceled due to the underlying connection being closed.")), this._cleanupTimeout(), this._cleanupPingTimer(), this._connectionState === Nt.Disconnecting ? this._completeClose(e) : this._connectionState === Nt.Connected && this._reconnectPolicy ? this._reconnect(e) : this._connectionState === Nt.Connected && this._completeClose(e)
    }
    _completeClose(e) {
        if (this._connectionStarted) {
            this._connectionState = Nt.Disconnected, this._connectionStarted = !1, Bt.isBrowser && window.document.removeEventListener("freeze", this._freezeEventListener);
            try {
                this._closedCallbacks.forEach(t => t.apply(this, [e]))
            } catch (t) {
                this._logger.log(Q.Error, `An onclose callback called with error '${e}' threw error '${t}'.`)
            }
        }
    }
    _reconnect(e) {
        return vt(this, null, function*() {
            let t = Date.now(),
                n = 0,
                i = e !== void 0 ? e : new Error("Attempting to reconnect due to a unknown error."),
                s = this._getNextRetryDelay(n++, 0, i);
            if (s === null) {
                this._logger.log(Q.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."), this._completeClose(e);
                return
            }
            if (this._connectionState = Nt.Reconnecting, e ? this._logger.log(Q.Information, `Connection reconnecting because of error '${e}'.`) : this._logger.log(Q.Information, "Connection reconnecting."), this._reconnectingCallbacks.length !== 0) {
                try {
                    this._reconnectingCallbacks.forEach(a => a.apply(this, [e]))
                } catch (a) {
                    this._logger.log(Q.Error, `An onreconnecting callback called with error '${e}' threw error '${a}'.`)
                }
                if (this._connectionState !== Nt.Reconnecting) {
                    this._logger.log(Q.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");
                    return
                }
            }
            for (; s !== null;) {
                if (this._logger.log(Q.Information, `Reconnect attempt number ${n} will start in ${s} ms.`), yield new Promise(a => {
                        this._reconnectDelayHandle = setTimeout(a, s)
                    }), this._reconnectDelayHandle = void 0, this._connectionState !== Nt.Reconnecting) {
                    this._logger.log(Q.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting.");
                    return
                }
                try {
                    if (yield this._startInternal(), this._connectionState = Nt.Connected, this._logger.log(Q.Information, "HubConnection reconnected successfully."), this._reconnectedCallbacks.length !== 0) try {
                        this._reconnectedCallbacks.forEach(a => a.apply(this, [this.connection.connectionId]))
                    } catch (a) {
                        this._logger.log(Q.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${a}'.`)
                    }
                    return
                } catch (a) {
                    if (this._logger.log(Q.Information, `Reconnect attempt failed because of error '${a}'.`), this._connectionState !== Nt.Reconnecting) {
                        this._logger.log(Q.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`), this._connectionState === Nt.Disconnecting && this._completeClose();
                        return
                    }
                    i = a instanceof Error ? a : new Error(a.toString()), s = this._getNextRetryDelay(n++, Date.now() - t, i)
                }
            }
            this._logger.log(Q.Information, `Reconnect retries have been exhausted after ${Date.now()-t} ms and ${n} failed attempts. Connection disconnecting.`), this._completeClose()
        })
    }
    _getNextRetryDelay(e, t, n) {
        try {
            return this._reconnectPolicy.nextRetryDelayInMilliseconds({
                elapsedMilliseconds: t,
                previousRetryCount: e,
                retryReason: n
            })
        } catch (i) {
            return this._logger.log(Q.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${e}, ${t}) threw error '${i}'.`), null
        }
    }
    _cancelCallbacksWithError(e) {
        let t = this._callbacks;
        this._callbacks = {}, Object.keys(t).forEach(n => {
            let i = t[n];
            try {
                i(null, e)
            } catch (s) {
                this._logger.log(Q.Error, `Stream 'error' callback called with '${e}' threw error: ${P1(s)}`)
            }
        })
    }
    _cleanupPingTimer() {
        this._pingServerHandle && (clearTimeout(this._pingServerHandle), this._pingServerHandle = void 0)
    }
    _cleanupTimeout() {
        this._timeoutHandle && clearTimeout(this._timeoutHandle)
    }
    _createInvocation(e, t, n, i) {
        if (n) return i.length !== 0 ? {
            arguments: t,
            streamIds: i,
            target: e,
            type: St.Invocation
        } : {
            arguments: t,
            target: e,
            type: St.Invocation
        }; {
            let s = this._invocationId;
            return this._invocationId++, i.length !== 0 ? {
                arguments: t,
                invocationId: s.toString(),
                streamIds: i,
                target: e,
                type: St.Invocation
            } : {
                arguments: t,
                invocationId: s.toString(),
                target: e,
                type: St.Invocation
            }
        }
    }
    _launchStreams(e, t) {
        if (e.length !== 0) {
            t || (t = Promise.resolve());
            for (let n in e) e[n].subscribe({
                complete: o(() => {
                    t = t.then(() => this._sendWithProtocol(this._createCompletionMessage(n)))
                }, "complete"),
                error: o(i => {
                    let s;
                    i instanceof Error ? s = i.message : i && i.toString ? s = i.toString() : s = "Unknown error", t = t.then(() => this._sendWithProtocol(this._createCompletionMessage(n, s)))
                }, "error"),
                next: o(i => {
                    t = t.then(() => this._sendWithProtocol(this._createStreamItemMessage(n, i)))
                }, "next")
            })
        }
    }
    _replaceStreamingParams(e) {
        let t = [],
            n = [];
        for (let i = 0; i < e.length; i++) {
            let s = e[i];
            if (this._isObservable(s)) {
                let a = this._invocationId;
                this._invocationId++, t[a] = s, n.push(a.toString()), e.splice(i, 1)
            }
        }
        return [t, n]
    }
    _isObservable(e) {
        return e && e.subscribe && typeof e.subscribe == "function"
    }
    _createStreamInvocation(e, t, n) {
        let i = this._invocationId;
        return this._invocationId++, n.length !== 0 ? {
            arguments: t,
            invocationId: i.toString(),
            streamIds: n,
            target: e,
            type: St.StreamInvocation
        } : {
            arguments: t,
            invocationId: i.toString(),
            target: e,
            type: St.StreamInvocation
        }
    }
    _createCancelInvocation(e) {
        return {
            invocationId: e,
            type: St.CancelInvocation
        }
    }
    _createStreamItemMessage(e, t) {
        return {
            invocationId: e,
            item: t,
            type: St.StreamItem
        }
    }
    _createCompletionMessage(e, t, n) {
        return t ? {
            error: t,
            invocationId: e,
            type: St.Completion
        } : {
            invocationId: e,
            result: n,
            type: St.Completion
        }
    }
};
o(bh, "HubConnection");
var L0 = bh,
    F3 = [0, 2e3, 1e4, 3e4, null],
    w_ = class w_ {
        constructor(e) {
            this._retryDelays = e !== void 0 ? [...e, null] : F3
        }
        nextRetryDelayInMilliseconds(e) {
            return this._retryDelays[e.previousRetryCount]
        }
    };
o(w_, "DefaultReconnectPolicy");
var gh = w_,
    T_ = class T_ {};
o(T_, "HeaderNames");
var pi = T_;
pi.Authorization = "Authorization";
pi.Cookie = "Cookie";
var E_ = class E_ extends fa {
    constructor(e, t) {
        super(), this._innerClient = e, this._accessTokenFactory = t
    }
    send(e) {
        return vt(this, null, function*() {
            let t = !0;
            this._accessTokenFactory && (!this._accessToken || e.url && e.url.indexOf("/negotiate?") > 0) && (t = !1, this._accessToken = yield this._accessTokenFactory()), this._setAuthorizationHeader(e);
            let n = yield this._innerClient.send(e);
            return t && n.statusCode === 401 && this._accessTokenFactory ? (this._accessToken = yield this._accessTokenFactory(), this._setAuthorizationHeader(e), yield this._innerClient.send(e)) : n
        })
    }
    _setAuthorizationHeader(e) {
        e.headers || (e.headers = {}), this._accessToken ? e.headers[pi.Authorization] = `Bearer ${this._accessToken}` : this._accessTokenFactory && e.headers[pi.Authorization] && delete e.headers[pi.Authorization]
    }
    getCookieString(e) {
        return this._innerClient.getCookieString(e)
    }
};
o(E_, "AccessTokenHttpClient");
var x0 = E_,
    tr;
(function(r) {
    r[r.None = 0] = "None", r[r.WebSockets = 1] = "WebSockets", r[r.ServerSentEvents = 2] = "ServerSentEvents", r[r.LongPolling = 4] = "LongPolling"
})(tr || (tr = {}));
var _r;
(function(r) {
    r[r.Text = 1] = "Text", r[r.Binary = 2] = "Binary"
})(_r || (_r = {}));
var ca, $3 = (ca = class {
        constructor() {
            this._isAborted = !1, this.onabort = null
        }
        abort() {
            this._isAborted || (this._isAborted = !0, this.onabort && this.onabort())
        }
        get signal() {
            return this
        }
        get aborted() {
            return this._isAborted
        }
    }, o(ca, "AbortController"), ca),
    b_ = class b_ {
        constructor(e, t, n) {
            this._httpClient = e, this._logger = t, this._pollAbort = new $3, this._options = n, this._running = !1, this.onreceive = null, this.onclose = null
        }
        get pollAborted() {
            return this._pollAbort.aborted
        }
        connect(e, t) {
            return vt(this, null, function*() {
                if (Vt.isRequired(e, "url"), Vt.isRequired(t, "transferFormat"), Vt.isIn(t, _r, "transferFormat"), this._url = e, this._logger.log(Q.Trace, "(LongPolling transport) Connecting."), t === _r.Binary && typeof XMLHttpRequest != "undefined" && typeof new XMLHttpRequest().responseType != "string") throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
                let [n, i] = ga(), s = Rt({
                    [n]: i
                }, this._options.headers), a = {
                    abortSignal: this._pollAbort.signal,
                    headers: s,
                    timeout: 1e5,
                    withCredentials: this._options.withCredentials
                };
                t === _r.Binary && (a.responseType = "arraybuffer");
                let u = `${e}&_=${Date.now()}`;
                this._logger.log(Q.Trace, `(LongPolling transport) polling: ${u}.`);
                let l = yield this._httpClient.get(u, a);
                l.statusCode !== 200 ? (this._logger.log(Q.Error, `(LongPolling transport) Unexpected response code: ${l.statusCode}.`), this._closeError = new cs(l.statusText || "", l.statusCode), this._running = !1) : this._running = !0, this._receiving = this._poll(this._url, a)
            })
        }
        _poll(e, t) {
            return vt(this, null, function*() {
                try {
                    for (; this._running;) try {
                        let n = `${e}&_=${Date.now()}`;
                        this._logger.log(Q.Trace, `(LongPolling transport) polling: ${n}.`);
                        let i = yield this._httpClient.get(n, t);
                        i.statusCode === 204 ? (this._logger.log(Q.Information, "(LongPolling transport) Poll terminated by server."), this._running = !1) : i.statusCode !== 200 ? (this._logger.log(Q.Error, `(LongPolling transport) Unexpected response code: ${i.statusCode}.`), this._closeError = new cs(i.statusText || "", i.statusCode), this._running = !1) : i.content ? (this._logger.log(Q.Trace, `(LongPolling transport) data received. ${cl(i.content,this._options.logMessageContent)}.`), this.onreceive && this.onreceive(i.content)) : this._logger.log(Q.Trace, "(LongPolling transport) Poll timed out, reissuing.")
                    } catch (n) {
                        this._running ? n instanceof ul ? this._logger.log(Q.Trace, "(LongPolling transport) Poll timed out, reissuing.") : (this._closeError = n, this._running = !1) : this._logger.log(Q.Trace, `(LongPolling transport) Poll errored after shutdown: ${n.message}`)
                    }
                } finally {
                    this._logger.log(Q.Trace, "(LongPolling transport) Polling complete."), this.pollAborted || this._raiseOnClose()
                }
            })
        }
        send(e) {
            return vt(this, null, function*() {
                return this._running ? fO(this._logger, "LongPolling", this._httpClient, this._url, e, this._options) : Promise.reject(new Error("Cannot send until the transport is connected"))
            })
        }
        stop() {
            return vt(this, null, function*() {
                this._logger.log(Q.Trace, "(LongPolling transport) Stopping polling."), this._running = !1, this._pollAbort.abort();
                try {
                    yield this._receiving, this._logger.log(Q.Trace, `(LongPolling transport) sending DELETE request to ${this._url}.`);
                    let e = {},
                        [t, n] = ga();
                    e[t] = n;
                    let i = {
                        headers: Rt(Rt({}, e), this._options.headers),
                        timeout: this._options.timeout,
                        withCredentials: this._options.withCredentials
                    };
                    yield this._httpClient.delete(this._url, i), this._logger.log(Q.Trace, "(LongPolling transport) DELETE request sent.")
                } finally {
                    this._logger.log(Q.Trace, "(LongPolling transport) Stop finished."), this._raiseOnClose()
                }
            })
        }
        _raiseOnClose() {
            if (this.onclose) {
                let e = "(LongPolling transport) Firing onclose event.";
                this._closeError && (e += " Error: " + this._closeError), this._logger.log(Q.Trace, e), this.onclose(this._closeError)
            }
        }
    };
o(b_, "LongPollingTransport");
var ph = b_,
    S_ = class S_ {
        constructor(e, t, n, i) {
            this._httpClient = e, this._accessToken = t, this._logger = n, this._options = i, this.onreceive = null, this.onclose = null
        }
        connect(e, t) {
            return vt(this, null, function*() {
                return Vt.isRequired(e, "url"), Vt.isRequired(t, "transferFormat"), Vt.isIn(t, _r, "transferFormat"), this._logger.log(Q.Trace, "(SSE transport) Connecting."), this._url = e, this._accessToken && (e += (e.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(this._accessToken)}`), new Promise((n, i) => {
                    let s = !1;
                    if (t !== _r.Text) {
                        i(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));
                        return
                    }
                    let a;
                    if (Bt.isBrowser || Bt.isWebWorker) a = new this._options.EventSource(e, {
                        withCredentials: this._options.withCredentials
                    });
                    else {
                        let u = this._httpClient.getCookieString(e),
                            l = {};
                        l.Cookie = u;
                        let [c, d] = ga();
                        l[c] = d, a = new this._options.EventSource(e, {
                            withCredentials: this._options.withCredentials,
                            headers: Rt(Rt({}, l), this._options.headers)
                        })
                    }
                    try {
                        a.onmessage = u => {
                            if (this.onreceive) try {
                                this._logger.log(Q.Trace, `(SSE transport) data received. ${cl(u.data,this._options.logMessageContent)}.`), this.onreceive(u.data)
                            } catch (l) {
                                this._close(l);
                                return
                            }
                        }, a.onerror = u => {
                            s ? this._close() : i(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."))
                        }, a.onopen = () => {
                            this._logger.log(Q.Information, `SSE connected to ${this._url}`), this._eventSource = a, s = !0, n()
                        }
                    } catch (u) {
                        i(u);
                        return
                    }
                })
            })
        }
        send(e) {
            return vt(this, null, function*() {
                return this._eventSource ? fO(this._logger, "SSE", this._httpClient, this._url, e, this._options) : Promise.reject(new Error("Cannot send until the transport is connected"))
            })
        }
        stop() {
            return this._close(), Promise.resolve()
        }
        _close(e) {
            this._eventSource && (this._eventSource.close(), this._eventSource = void 0, this.onclose && this.onclose(e))
        }
    };
o(S_, "ServerSentEventsTransport");
var U0 = S_,
    A_ = class A_ {
        constructor(e, t, n, i, s, a) {
            this._logger = n, this._accessTokenFactory = t, this._logMessageContent = i, this._webSocketConstructor = s, this._httpClient = e, this.onreceive = null, this.onclose = null, this._headers = a
        }
        connect(e, t) {
            return vt(this, null, function*() {
                Vt.isRequired(e, "url"), Vt.isRequired(t, "transferFormat"), Vt.isIn(t, _r, "transferFormat"), this._logger.log(Q.Trace, "(WebSockets transport) Connecting.");
                let n;
                return this._accessTokenFactory && (n = yield this._accessTokenFactory()), new Promise((i, s) => {
                    e = e.replace(/^http/, "ws");
                    let a, u = this._httpClient.getCookieString(e),
                        l = !1;
                    if (Bt.isNode || Bt.isReactNative) {
                        let c = {},
                            [d, f] = ga();
                        c[d] = f, n && (c[pi.Authorization] = `Bearer ${n}`), u && (c[pi.Cookie] = u), a = new this._webSocketConstructor(e, void 0, {
                            headers: Rt(Rt({}, c), this._headers)
                        })
                    } else n && (e += (e.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(n)}`);
                    a || (a = new this._webSocketConstructor(e)), t === _r.Binary && (a.binaryType = "arraybuffer"), a.onopen = c => {
                        this._logger.log(Q.Information, `WebSocket connected to ${e}.`), this._webSocket = a, l = !0, i()
                    }, a.onerror = c => {
                        let d = null;
                        typeof ErrorEvent != "undefined" && c instanceof ErrorEvent ? d = c.error : d = "There was an error with the transport", this._logger.log(Q.Information, `(WebSockets transport) ${d}.`)
                    }, a.onmessage = c => {
                        if (this._logger.log(Q.Trace, `(WebSockets transport) data received. ${cl(c.data,this._logMessageContent)}.`), this.onreceive) try {
                            this.onreceive(c.data)
                        } catch (d) {
                            this._close(d);
                            return
                        }
                    }, a.onclose = c => {
                        if (l) this._close(c);
                        else {
                            let d = null;
                            typeof ErrorEvent != "undefined" && c instanceof ErrorEvent ? d = c.error : d = "WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.", s(new Error(d))
                        }
                    }
                })
            })
        }
        send(e) {
            return this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN ? (this._logger.log(Q.Trace, `(WebSockets transport) sending data. ${cl(e,this._logMessageContent)}.`), this._webSocket.send(e), Promise.resolve()) : Promise.reject("WebSocket is not in the OPEN state")
        }
        stop() {
            return this._webSocket && this._close(void 0), Promise.resolve()
        }
        _close(e) {
            this._webSocket && (this._webSocket.onclose = () => {}, this._webSocket.onmessage = () => {}, this._webSocket.onerror = () => {}, this._webSocket.close(), this._webSocket = void 0), this._logger.log(Q.Trace, "(WebSockets transport) socket closed."), this.onclose && (this._isCloseEvent(e) && (e.wasClean === !1 || e.code !== 1e3) ? this.onclose(new Error(`WebSocket closed with status code: ${e.code} (${e.reason||"no reason given"}).`)) : e instanceof Error ? this.onclose(e) : this.onclose())
        }
        _isCloseEvent(e) {
            return e && typeof e.wasClean == "boolean" && typeof e.code == "number"
        }
    };
o(A_, "WebSocketTransport");
var M0 = A_,
    D1 = 100,
    I_ = class I_ {
        constructor(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (this._stopPromiseResolver = () => {}, this.features = {}, this._negotiateVersion = 1, Vt.isRequired(e, "url"), this._logger = P3(t.logger), this.baseUrl = this._resolveUrl(e), t = t || {}, t.logMessageContent = t.logMessageContent === void 0 ? !1 : t.logMessageContent, typeof t.withCredentials == "boolean" || t.withCredentials === void 0) t.withCredentials = t.withCredentials === void 0 ? !0 : t.withCredentials;
            else throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");
            t.timeout = t.timeout === void 0 ? 100 * 1e3 : t.timeout;
            let n = null,
                i = null;
            if (Bt.isNode && typeof is != "undefined") {
                let s = typeof __webpack_require__ == "function" ? __non_webpack_require__ : is;
                n = s("ws"), i = s("eventsource")
            }!Bt.isNode && typeof WebSocket != "undefined" && !t.WebSocket ? t.WebSocket = WebSocket : Bt.isNode && !t.WebSocket && n && (t.WebSocket = n), !Bt.isNode && typeof EventSource != "undefined" && !t.EventSource ? t.EventSource = EventSource : Bt.isNode && !t.EventSource && typeof i != "undefined" && (t.EventSource = i), this._httpClient = new x0(t.httpClient || new P0(this._logger), t.accessTokenFactory), this._connectionState = "Disconnected", this._connectionStarted = !1, this._options = t, this.onreceive = null, this.onclose = null
        }
        start(e) {
            return vt(this, null, function*() {
                if (e = e || _r.Binary, Vt.isIn(e, _r, "transferFormat"), this._logger.log(Q.Debug, `Starting connection with transfer format '${_r[e]}'.`), this._connectionState !== "Disconnected") return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));
                if (this._connectionState = "Connecting", this._startInternalPromise = this._startInternal(e), yield this._startInternalPromise, this._connectionState === "Disconnecting") {
                    let t = "Failed to start the HttpConnection before stop() was called.";
                    return this._logger.log(Q.Error, t), yield this._stopPromise, Promise.reject(new Yr(t))
                } else if (this._connectionState !== "Connected") {
                    let t = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";
                    return this._logger.log(Q.Error, t), Promise.reject(new Yr(t))
                }
                this._connectionStarted = !0
            })
        }
        send(e) {
            return this._connectionState !== "Connected" ? Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")) : (this._sendQueue || (this._sendQueue = new F0(this.transport)), this._sendQueue.send(e))
        }
        stop(e) {
            return vt(this, null, function*() {
                if (this._connectionState === "Disconnected") return this._logger.log(Q.Debug, `Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnected state.`), Promise.resolve();
                if (this._connectionState === "Disconnecting") return this._logger.log(Q.Debug, `Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnecting state.`), this._stopPromise;
                this._connectionState = "Disconnecting", this._stopPromise = new Promise(t => {
                    this._stopPromiseResolver = t
                }), yield this._stopInternal(e), yield this._stopPromise
            })
        }
        _stopInternal(e) {
            return vt(this, null, function*() {
                this._stopError = e;
                try {
                    yield this._startInternalPromise
                } catch (t) {}
                if (this.transport) {
                    try {
                        yield this.transport.stop()
                    } catch (t) {
                        this._logger.log(Q.Error, `HttpConnection.transport.stop() threw error '${t}'.`), this._stopConnection()
                    }
                    this.transport = void 0
                } else this._logger.log(Q.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.")
            })
        }
        _startInternal(e) {
            return vt(this, null, function*() {
                let t = this.baseUrl;
                this._accessTokenFactory = this._options.accessTokenFactory, this._httpClient._accessTokenFactory = this._accessTokenFactory;
                try {
                    if (this._options.skipNegotiation)
                        if (this._options.transport === tr.WebSockets) this.transport = this._constructTransport(tr.WebSockets), yield this._startTransport(t, e);
                        else throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");
                    else {
                        let n = null,
                            i = 0;
                        do {
                            if (n = yield this._getNegotiationResponse(t), this._connectionState === "Disconnecting" || this._connectionState === "Disconnected") throw new Yr("The connection was stopped during negotiation.");
                            if (n.error) throw new Error(n.error);
                            if (n.ProtocolVersion) throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
                            if (n.url && (t = n.url), n.accessToken) {
                                let s = n.accessToken;
                                this._accessTokenFactory = () => s, this._httpClient._accessToken = s, this._httpClient._accessTokenFactory = void 0
                            }
                            i++
                        } while (n.url && i < D1);
                        if (i === D1 && n.url) throw new Error("Negotiate redirection limit exceeded.");
                        yield this._createTransport(t, this._options.transport, n, e)
                    }
                    this.transport instanceof ph && (this.features.inherentKeepAlive = !0), this._connectionState === "Connecting" && (this._logger.log(Q.Debug, "The HttpConnection connected successfully."), this._connectionState = "Connected")
                } catch (n) {
                    return this._logger.log(Q.Error, "Failed to start the connection: " + n), this._connectionState = "Disconnected", this.transport = void 0, this._stopPromiseResolver(), Promise.reject(n)
                }
            })
        }
        _getNegotiationResponse(e) {
            return vt(this, null, function*() {
                let t = {},
                    [n, i] = ga();
                t[n] = i;
                let s = this._resolveNegotiateUrl(e);
                this._logger.log(Q.Debug, `Sending negotiation request: ${s}.`);
                try {
                    let a = yield this._httpClient.post(s, {
                        content: "",
                        headers: Rt(Rt({}, t), this._options.headers),
                        timeout: this._options.timeout,
                        withCredentials: this._options.withCredentials
                    });
                    if (a.statusCode !== 200) return Promise.reject(new Error(`Unexpected status code returned from negotiate '${a.statusCode}'`));
                    let u = JSON.parse(a.content);
                    return (!u.negotiateVersion || u.negotiateVersion < 1) && (u.connectionToken = u.connectionId), u
                } catch (a) {
                    let u = "Failed to complete negotiation with the server: " + a;
                    return a instanceof cs && a.statusCode === 404 && (u = u + " Either this is not a SignalR endpoint or there is a proxy blocking the connection."), this._logger.log(Q.Error, u), Promise.reject(new A0(u))
                }
            })
        }
        _createConnectUrl(e, t) {
            return t ? e + (e.indexOf("?") === -1 ? "?" : "&") + `id=${t}` : e
        }
        _createTransport(e, t, n, i) {
            return vt(this, null, function*() {
                let s = this._createConnectUrl(e, n.connectionToken);
                if (this._isITransport(t)) {
                    this._logger.log(Q.Debug, "Connection was provided an instance of ITransport, using that directly."), this.transport = t, yield this._startTransport(s, i), this.connectionId = n.connectionId;
                    return
                }
                let a = [],
                    u = n.availableTransports || [],
                    l = n;
                for (let c of u) {
                    let d = this._resolveTransportOrError(c, t, i);
                    if (d instanceof Error) a.push(`${c.transport} failed:`), a.push(d);
                    else if (this._isITransport(d)) {
                        if (this.transport = d, !l) {
                            try {
                                l = yield this._getNegotiationResponse(e)
                            } catch (f) {
                                return Promise.reject(f)
                            }
                            s = this._createConnectUrl(e, l.connectionToken)
                        }
                        try {
                            yield this._startTransport(s, i), this.connectionId = l.connectionId;
                            return
                        } catch (f) {
                            if (this._logger.log(Q.Error, `Failed to start the transport '${c.transport}': ${f}`), l = void 0, a.push(new S0(`${c.transport} failed: ${f}`, tr[c.transport])), this._connectionState !== "Connecting") {
                                let h = "Failed to select transport before stop() was called.";
                                return this._logger.log(Q.Debug, h), Promise.reject(new Yr(h))
                            }
                        }
                    }
                }
                return a.length > 0 ? Promise.reject(new I0(`Unable to connect to the server with any of the available transports. ${a.join(" ")}`, a)) : Promise.reject(new Error("None of the transports supported by the client are supported by the server."))
            })
        }
        _constructTransport(e) {
            switch (e) {
                case tr.WebSockets:
                    if (!this._options.WebSocket) throw new Error("'WebSocket' is not supported in your environment.");
                    return new M0(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent, this._options.WebSocket, this._options.headers || {});
                case tr.ServerSentEvents:
                    if (!this._options.EventSource) throw new Error("'EventSource' is not supported in your environment.");
                    return new U0(this._httpClient, this._httpClient._accessToken, this._logger, this._options);
                case tr.LongPolling:
                    return new ph(this._httpClient, this._logger, this._options);
                default:
                    throw new Error(`Unknown transport: ${e}.`)
            }
        }
        _startTransport(e, t) {
            return this.transport.onreceive = this.onreceive, this.transport.onclose = n => this._stopConnection(n), this.transport.connect(e, t)
        }
        _resolveTransportOrError(e, t, n) {
            let i = tr[e.transport];
            if (i == null) return this._logger.log(Q.Debug, `Skipping transport '${e.transport}' because it is not supported by this client.`), new Error(`Skipping transport '${e.transport}' because it is not supported by this client.`);
            if (B3(t, i))
                if (e.transferFormats.map(a => _r[a]).indexOf(n) >= 0) {
                    if (i === tr.WebSockets && !this._options.WebSocket || i === tr.ServerSentEvents && !this._options.EventSource) return this._logger.log(Q.Debug, `Skipping transport '${tr[i]}' because it is not supported in your environment.'`), new E0(`'${tr[i]}' is not supported in your environment.`, i);
                    this._logger.log(Q.Debug, `Selecting transport '${tr[i]}'.`);
                    try {
                        return this._constructTransport(i)
                    } catch (a) {
                        return a
                    }
                } else return this._logger.log(Q.Debug, `Skipping transport '${tr[i]}' because it does not support the requested transfer format '${_r[n]}'.`), new Error(`'${tr[i]}' does not support ${_r[n]}.`);
            else return this._logger.log(Q.Debug, `Skipping transport '${tr[i]}' because it was disabled by the client.`), new b0(`'${tr[i]}' is disabled by the client.`, i)
        }
        _isITransport(e) {
            return e && typeof e == "object" && "connect" in e
        }
        _stopConnection(e) {
            if (this._logger.log(Q.Debug, `HttpConnection.stopConnection(${e}) called while in state ${this._connectionState}.`), this.transport = void 0, e = this._stopError || e, this._stopError = void 0, this._connectionState === "Disconnected") {
                this._logger.log(Q.Debug, `Call to HttpConnection.stopConnection(${e}) was ignored because the connection is already in the disconnected state.`);
                return
            }
            if (this._connectionState === "Connecting") throw this._logger.log(Q.Warning, `Call to HttpConnection.stopConnection(${e}) was ignored because the connection is still in the connecting state.`), new Error(`HttpConnection.stopConnection(${e}) was called while the connection is still in the connecting state.`);
            if (this._connectionState === "Disconnecting" && this._stopPromiseResolver(), e ? this._logger.log(Q.Error, `Connection disconnected with error '${e}'.`) : this._logger.log(Q.Information, "Connection disconnected."), this._sendQueue && (this._sendQueue.stop().catch(t => {
                    this._logger.log(Q.Error, `TransportSendQueue.stop() threw error '${t}'.`)
                }), this._sendQueue = void 0), this.connectionId = void 0, this._connectionState = "Disconnected", this._connectionStarted) {
                this._connectionStarted = !1;
                try {
                    this.onclose && this.onclose(e)
                } catch (t) {
                    this._logger.log(Q.Error, `HttpConnection.onclose(${e}) threw error '${t}'.`)
                }
            }
        }
        _resolveUrl(e) {
            if (e.lastIndexOf("https://", 0) === 0 || e.lastIndexOf("http://", 0) === 0) return e;
            if (!Bt.isBrowser) throw new Error(`Cannot resolve '${e}'.`);
            let t = window.document.createElement("a");
            return t.href = e, this._logger.log(Q.Information, `Normalizing '${e}' to '${t.href}'.`), t.href
        }
        _resolveNegotiateUrl(e) {
            let t = e.indexOf("?"),
                n = e.substring(0, t === -1 ? e.length : t);
            return n[n.length - 1] !== "/" && (n += "/"), n += "negotiate", n += t === -1 ? "" : e.substring(t), n.indexOf("negotiateVersion") === -1 && (n += t === -1 ? "?" : "&", n += "negotiateVersion=" + this._negotiateVersion), n
        }
    };
o(I_, "HttpConnection");
var k0 = I_;

function B3(r, e) {
    return !r || (e & r) !== 0
}
o(B3, "transportMatches");
var Sh = class Sh {
    constructor(e) {
        this._transport = e, this._buffer = [], this._executing = !0, this._sendBufferedData = new ia, this._transportResult = new ia, this._sendLoopPromise = this._sendLoop()
    }
    send(e) {
        return this._bufferData(e), this._transportResult || (this._transportResult = new ia), this._transportResult.promise
    }
    stop() {
        return this._executing = !1, this._sendBufferedData.resolve(), this._sendLoopPromise
    }
    _bufferData(e) {
        if (this._buffer.length && typeof this._buffer[0] != typeof e) throw new Error(`Expected data to be of type ${typeof this._buffer} but was of type ${typeof e}`);
        this._buffer.push(e), this._sendBufferedData.resolve()
    }
    _sendLoop() {
        return vt(this, null, function*() {
            for (;;) {
                if (yield this._sendBufferedData.promise, !this._executing) {
                    this._transportResult && this._transportResult.reject("Connection stopped.");
                    break
                }
                this._sendBufferedData = new ia;
                let e = this._transportResult;
                this._transportResult = void 0;
                let t = typeof this._buffer[0] == "string" ? this._buffer.join("") : Sh._concatBuffers(this._buffer);
                this._buffer.length = 0;
                try {
                    yield this._transport.send(t), e.resolve()
                } catch (n) {
                    e.reject(n)
                }
            }
        })
    }
    static _concatBuffers(e) {
        let t = e.map(s => s.byteLength).reduce((s, a) => s + a),
            n = new Uint8Array(t),
            i = 0;
        for (let s of e) n.set(new Uint8Array(s), i), i += s.byteLength;
        return n.buffer
    }
};
o(Sh, "TransportSendQueue");
var F0 = Sh,
    C_ = class C_ {
        constructor() {
            this.promise = new Promise((e, t) => [this._resolver, this._rejecter] = [e, t])
        }
        resolve() {
            this._resolver()
        }
        reject(e) {
            this._rejecter(e)
        }
    };
o(C_, "PromiseSource");
var ia = C_,
    V3 = "json",
    R_ = class R_ {
        constructor() {
            this.name = V3, this.version = 1, this.transferFormat = _r.Text
        }
        parseMessages(e, t) {
            if (typeof e != "string") throw new Error("Invalid input for JSON hub protocol. Expected a string.");
            if (!e) return [];
            t === null && (t = no.instance);
            let n = In.parse(e),
                i = [];
            for (let s of n) {
                let a = JSON.parse(s);
                if (typeof a.type != "number") throw new Error("Invalid payload.");
                switch (a.type) {
                    case St.Invocation:
                        this._isInvocationMessage(a);
                        break;
                    case St.StreamItem:
                        this._isStreamItemMessage(a);
                        break;
                    case St.Completion:
                        this._isCompletionMessage(a);
                        break;
                    case St.Ping:
                        break;
                    case St.Close:
                        break;
                    default:
                        t.log(Q.Information, "Unknown message type '" + a.type + "' ignored.");
                        continue
                }
                i.push(a)
            }
            return i
        }
        writeMessage(e) {
            return In.write(JSON.stringify(e))
        }
        _isInvocationMessage(e) {
            this._assertNotEmptyString(e.target, "Invalid payload for Invocation message."), e.invocationId !== void 0 && this._assertNotEmptyString(e.invocationId, "Invalid payload for Invocation message.")
        }
        _isStreamItemMessage(e) {
            if (this._assertNotEmptyString(e.invocationId, "Invalid payload for StreamItem message."), e.item === void 0) throw new Error("Invalid payload for StreamItem message.")
        }
        _isCompletionMessage(e) {
            if (e.result && e.error) throw new Error("Invalid payload for Completion message.");
            !e.result && e.error && this._assertNotEmptyString(e.error, "Invalid payload for Completion message."), this._assertNotEmptyString(e.invocationId, "Invalid payload for Completion message.")
        }
        _assertNotEmptyString(e, t) {
            if (typeof e != "string" || e === "") throw new Error(t)
        }
    };
o(R_, "JsonHubProtocol");
var $0 = R_,
    H3 = {
        trace: Q.Trace,
        debug: Q.Debug,
        info: Q.Information,
        information: Q.Information,
        warn: Q.Warning,
        warning: Q.Warning,
        error: Q.Error,
        critical: Q.Critical,
        none: Q.None
    };

function j3(r) {
    let e = H3[r.toLowerCase()];
    if (typeof e != "undefined") return e;
    throw new Error(`Unknown log level: ${r}`)
}
o(j3, "parseLogLevel");
var O_ = class O_ {
    configureLogging(e) {
        if (Vt.isRequired(e, "logging"), W3(e)) this.logger = e;
        else if (typeof e == "string") {
            let t = j3(e);
            this.logger = new ha(t)
        } else this.logger = new ha(e);
        return this
    }
    withUrl(e, t) {
        return Vt.isRequired(e, "url"), Vt.isNotEmpty(e, "url"), this.url = e, typeof t == "object" ? this.httpConnectionOptions = Rt(Rt({}, this.httpConnectionOptions), t) : this.httpConnectionOptions = ns(Rt({}, this.httpConnectionOptions), {
            transport: t
        }), this
    }
    withHubProtocol(e) {
        return Vt.isRequired(e, "protocol"), this.protocol = e, this
    }
    withAutomaticReconnect(e) {
        if (this.reconnectPolicy) throw new Error("A reconnectPolicy has already been set.");
        return e ? Array.isArray(e) ? this.reconnectPolicy = new gh(e) : this.reconnectPolicy = e : this.reconnectPolicy = new gh, this
    }
    build() {
        let e = this.httpConnectionOptions || {};
        if (e.logger === void 0 && (e.logger = this.logger), !this.url) throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
        let t = new k0(this.url, e);
        return L0.create(t, this.logger || no.instance, this.protocol || new $0, this.reconnectPolicy)
    }
};
o(O_, "HubConnectionBuilder");
var mh = O_;

function W3(r) {
    return r.log !== void 0
}
o(W3, "isLogger");

function G3(r) {
    return Ve(this, void 0, void 0, function*() {
        var e;
        return r && (e = yield r()) !== null && e !== void 0 ? e : ""
    })
}
o(G3, "ensureTokenString");
var z3 = o(r => {
        let {
            builder: e = new mh,
            hubEndpoint: t,
            appUrl: n,
            logger: i,
            getToken: s
        } = r;
        if (!n) throw new Error("The AppUrl and HubEndpoint must be defined in order to use SignalR communications");
        let a = e.withUrl(new URL(t, n).href, {
            accessTokenFactory: o(() => Ve(void 0, void 0, void 0, function*() {
                return (yield G3(s)).replace("Bearer ", "")
            }), "accessTokenFactory")
        }).withAutomaticReconnect();
        return i && a.configureLogging({
            log: o((u, l) => {
                var c, d;
                switch (u) {
                    case Q.Information:
                    case Q.Trace:
                    case Q.Debug:
                    case Q.Warning:
                        (c = i.debug) === null || c === void 0 || c.call(i, {
                            category: "SignalRHttpClient",
                            message: `HubConnection ${l}`
                        });
                        break;
                    case Q.Error:
                    case Q.Critical:
                        (d = i.error) === null || d === void 0 || d.call(i, {
                            category: "SignalRHttpClient",
                            message: `Handler Error: HubConnection ${l}`,
                            errorCode: He.Communication_Default,
                            error: new Error(l)
                        });
                        break
                }
            }, "log")
        }), a.build()
    }, "createHubConnection"),
    B0, jc, Gf, Wc, hi, Gc, zf, hO, q3 = "moduleservices/debugger/requestshub",
    K3 = "",
    Zs = "SignalRHttpClient",
    P_ = class P_ {
        constructor(e) {
            let {
                appUrl: t,
                localeHeader: n = K3,
                getLocale: i,
                setLocale: s,
                logger: a,
                getToken: u
            } = e;
            B0.add(this), jc.set(this, void 0), Gf.set(this, void 0), Wc.set(this, void 0), hi.set(this, void 0), Gc.set(this, void 0), zf.set(this, void 0), qe(this, Gc, m0(t), "f"), qe(this, jc, n, "f"), qe(this, Gf, i, "f"), qe(this, Wc, s, "f"), qe(this, hi, a, "f"), qe(this, zf, u, "f")
        }
        executeRequest(e) {
            return Ve(this, arguments, void 0, function(t) {
                var n = this;
                let {
                    url: i,
                    payload: s,
                    headers: a,
                    contentType: u = ir.FormUrlEncoded,
                    useLocaleInfo: l = !1,
                    abortCommand: c,
                    responseHandler: d,
                    hubConnectionBuilder: f = new mh
                } = t;
                return (function*() {
                    var h, g, p, m, w, T, E, b, R, L, V, z, j, Y;
                    c && (c.onAbort = () => {
                        q = !0
                    });
                    let q = !1;
                    (g = (h = ne(n, hi, "f")) === null || h === void 0 ? void 0 : h.setActiveSpanAsNonAggregable) === null || g === void 0 || g.call(h);
                    let P = z3({
                            builder: f,
                            hubEndpoint: q3,
                            appUrl: ne(n, Gc, "f"),
                            logger: ne(n, hi, "f"),
                            getToken: ne(n, zf, "f")
                        }),
                        Z = l ? (p = ne(n, Gf, "f")) === null || p === void 0 ? void 0 : p.call(n) : void 0,
                        oe = Object.assign(Object.assign(Object.assign({}, a), Z ? {
                            [ne(n, jc, "f")]: Z
                        } : {}), cO({
                            payload: s,
                            headers: a
                        }) ? {
                            "content-type": u
                        } : {});
                    try {
                        let S = s ? Y0({
                            payload: s,
                            contentType: u
                        }) : void 0;
                        yield P.start();
                        let K = yield P.invoke("ExecuteRequest", new URL(i, ne(n, Gc, "f")).pathname, S, oe);
                        yield P.stop(), (w = (m = ne(n, hi, "f")) === null || m === void 0 ? void 0 : m.debug) === null || w === void 0 || w.call(m, {
                            category: Zs,
                            message: `ExecuteRequest ${i}`
                        });
                        let M = rh(K == null ? void 0 : K.ResponseBody, ne(n, hi, "f"), Zs);
                        if (!(K != null && K.ResponseStatusCode) || K.ResponseStatusCode < 200 || K.ResponseStatusCode > 299) {
                            let Oe = (b = (E = (T = K == null ? void 0 : K.ResponseStatusCode) === null || T === void 0 ? void 0 : T.toString) === null || E === void 0 ? void 0 : E.call(T)) !== null && b !== void 0 ? b : "",
                                Ye = Ah(Oe);
                            throw new Fr((L = (R = M == null ? void 0 : M.exception) === null || R === void 0 ? void 0 : R.message) !== null && L !== void 0 ? L : "Network Error", (z = (V = M == null ? void 0 : M.exception) === null || V === void 0 ? void 0 : V.errorCode) !== null && z !== void 0 ? z : Ye, Oe, M, Zs)
                        }
                        if (q) throw new Fr("Client Aborted", He.Communication_Aborted, M, Zs);
                        if (l && ne(n, Wc, "f") && (K != null && K.ResponseHeaders) && X0({
                                responseHeaders: K.ResponseHeaders,
                                localeHeader: ne(n, jc, "f"),
                                currentLocale: Z,
                                setLocale: ne(n, Wc, "f")
                            }), typeof d == "function") try {
                            d({
                                data: M,
                                responseHeaders: K == null ? void 0 : K.ResponseHeaders
                            })
                        } catch (Oe) {
                            (Y = (j = ne(n, hi, "f")) === null || j === void 0 ? void 0 : j.error) === null || Y === void 0 || Y.call(j, {
                                category: Zs,
                                message: `ExecuteRequest ${i}`,
                                errorCode: He.Communication_Default,
                                error: Oe
                            })
                        }
                        return M
                    } catch (S) {
                        throw yield P == null ? void 0 : P.stop(), ne(n, B0, "m", hO).call(n, S, i)
                    }
                })()
            })
        }
    };
o(P_, "SignalRClient");
var V0 = P_;
jc = new WeakMap, Gf = new WeakMap, Wc = new WeakMap, hi = new WeakMap, Gc = new WeakMap, zf = new WeakMap, B0 = new WeakSet, hO = o(function(e, t) {
    var n, i, s, a;
    let u = He.Communication_Default,
        l;
    return e instanceof Fr ? (u = Ah((n = e.status) !== null && n !== void 0 ? n : ""), l = e) : l = new Fr(`ExecuteRequest ${t}`, u, void 0, void 0, Zs), (s = (i = ne(this, hi, "f")) === null || i === void 0 ? void 0 : i.error) === null || s === void 0 || s.call(i, {
        category: Zs,
        message: `ExecuteRequest ${t} - ${(a=e==null?void 0:e.message)!==null&&a!==void 0?a:""}`,
        errorCode: u,
        error: e
    }), l
}, "_SignalRClient_processError");
var qf, zc, Kf, Y3 = o(r => {
        let {
            appUrl: e,
            localeHeader: t,
            getLocale: n,
            setLocale: i,
            logger: s,
            getToken: a
        } = r;
        return new V0({
            appUrl: e,
            localeHeader: t,
            getLocale: n,
            setLocale: i,
            logger: s,
            getToken: a
        })
    }, "createSignalRInstance"),
    N_ = class N_ {
        constructor(e) {
            let {
                appUrl: t,
                localeHeader: n,
                getLocale: i,
                setLocale: s,
                logger: a,
                getToken: u,
                signalRClientInstance: l = Y3({
                    appUrl: t,
                    localeHeader: n,
                    getLocale: i,
                    setLocale: s,
                    logger: a,
                    getToken: u
                }),
                alternateHttpClientInstance: c
            } = e;
            qf.set(this, void 0), zc.set(this, void 0), Kf.set(this, void 0), qe(this, qf, l, "f"), qe(this, zc, c, "f"), qe(this, Kf, a, "f")
        }
        post(e) {
            return Ve(this, arguments, void 0, function(t) {
                var n = this;
                let {
                    url: i,
                    payload: s,
                    headers: a,
                    contentType: u,
                    timeout: l,
                    timeoutHandler: c,
                    useLocaleInfo: d,
                    abortCommand: f,
                    responseHandler: h
                } = t;
                return (function*() {
                    let g = o(() => ne(n, qf, "f").executeRequest({
                        url: i,
                        payload: s,
                        headers: a,
                        contentType: u,
                        useLocaleInfo: d,
                        timeout: l,
                        timeoutHandler: c,
                        abortCommand: f,
                        responseHandler: h
                    }), "fetch");
                    return aa(ne(n, Kf, "f"), "POST", g)
                })()
            })
        }
        get(e) {
            return Ve(this, arguments, void 0, function(t) {
                var n = this;
                let {
                    url: i,
                    params: s,
                    headers: a,
                    responseType: u,
                    useLocaleInfo: l,
                    timeout: c,
                    timeoutHandler: d,
                    baseURL: f
                } = t;
                return (function*() {
                    return ne(n, zc, "f").get({
                        url: i,
                        params: s,
                        headers: a,
                        responseType: u,
                        useLocaleInfo: l,
                        timeout: c,
                        timeoutHandler: d,
                        baseURL: f
                    })
                })()
            })
        }
        getResponseUrl(e) {
            return Ve(this, arguments, void 0, function(t) {
                var n = this;
                let {
                    url: i,
                    params: s,
                    headers: a,
                    useLocaleInfo: u,
                    timeout: l,
                    timeoutHandler: c,
                    baseURL: d
                } = t;
                return (function*() {
                    return ne(n, zc, "f").getResponseUrl({
                        url: i,
                        params: s,
                        headers: a,
                        useLocaleInfo: u,
                        timeout: l,
                        timeoutHandler: c,
                        baseURL: d
                    })
                })()
            })
        }
    };
o(N_, "DebuggerHttpClient");
var vh = N_;
qf = new WeakMap, zc = new WeakMap, Kf = new WeakMap;
var us, Qs, sl, ol, yh, _h, eo, wh, L1, x1, U1, Yf, X3 = "HttpClientWithHealthCheck",
    J3 = 1800,
    Z3 = "ping",
    Q3 = 30,
    D_ = class D_ {
        constructor(e) {
            let {
                isHealthy: t = !1,
                healthCheckIntervalInSeconds: n = J3,
                healthCheckEndpoint: i = Z3,
                healingTimeoutDelayInSeconds: s = Q3,
                healthCheckNeededPathFilter: a,
                logger: u
            } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            us.add(this), Qs.set(this, void 0), sl.set(this, void 0), ol.set(this, void 0), yh.set(this, void 0), _h.set(this, void 0), eo.set(this, void 0), wh.set(this, void 0), qe(this, Qs, e, "f"), qe(this, sl, n * 1e3, "f"), qe(this, ol, i, "f"), qe(this, yh, s, "f"), qe(this, _h, a, "f"), t && qe(this, eo, Date.now(), "f"), qe(this, wh, u, "f")
        }
        setHealthCheckInterval(e) {
            qe(this, sl, e * 1e3, "f")
        }
        post(e) {
            return Ve(this, arguments, void 0, function(t) {
                var n = this;
                let {
                    url: i,
                    payload: s,
                    params: a,
                    headers: u,
                    contentType: l,
                    timeout: c,
                    timeoutHandler: d,
                    useLocaleInfo: f,
                    baseURL: h,
                    abortCommand: g,
                    responseHandler: p
                } = t;
                return (function*() {
                    return ne(n, us, "m", Yf).call(n, m => ne(n, Qs, "f").post({
                        url: i,
                        payload: s,
                        params: a,
                        headers: u,
                        contentType: l,
                        timeout: m,
                        timeoutHandler: d,
                        useLocaleInfo: f,
                        baseURL: h,
                        abortCommand: g,
                        responseHandler: p
                    }), i, h, c)
                })()
            })
        }
        get(e) {
            return Ve(this, arguments, void 0, function(t) {
                var n = this;
                let {
                    url: i,
                    params: s,
                    headers: a,
                    useLocaleInfo: u,
                    timeout: l,
                    timeoutHandler: c,
                    responseType: d,
                    baseURL: f
                } = t;
                return (function*() {
                    return ne(n, us, "m", Yf).call(n, h => ne(n, Qs, "f").get({
                        url: i,
                        params: s,
                        headers: a,
                        useLocaleInfo: u,
                        timeout: h,
                        timeoutHandler: c,
                        responseType: d,
                        baseURL: f
                    }), i, f, l)
                })()
            })
        }
        getResponseUrl(e) {
            return Ve(this, arguments, void 0, function(t) {
                var n = this;
                let {
                    url: i,
                    params: s,
                    headers: a,
                    useLocaleInfo: u,
                    timeout: l,
                    timeoutHandler: c,
                    baseURL: d
                } = t;
                return (function*() {
                    return ne(n, us, "m", Yf).call(n, f => ne(n, Qs, "f").getResponseUrl({
                        url: i,
                        params: s,
                        headers: a,
                        useLocaleInfo: u,
                        timeout: f,
                        timeoutHandler: c,
                        baseURL: d
                    }), i, d, l)
                })()
            })
        }
    };
o(D_, "HttpClientWithHealthCheck");
var pa = D_;
Qs = new WeakMap, sl = new WeakMap, ol = new WeakMap, yh = new WeakMap, _h = new WeakMap, eo = new WeakMap, wh = new WeakMap, us = new WeakSet, L1 = o(function(e, t) {
    var n, i;
    let s = (i = (n = ne(this, _h, "f")) === null || n === void 0 ? void 0 : n.isPathAcceptable(e, t)) !== null && i !== void 0 ? i : !0,
        a = !ne(this, eo, "f") || Date.now() - ne(this, eo, "f") > ne(this, sl, "f");
    return s && a
}, "_HttpClientWithHealthCheck_needsHealthCheck"), x1 = o(function() {
    return Ve(this, void 0, void 0, function*() {
        var e, t;
        (t = (e = ne(this, wh, "f")) === null || e === void 0 ? void 0 : e.debug) === null || t === void 0 || t.call(e, {
            category: X3,
            message: `Checking healthiness at ${ne(this,ol,"f")}`
        });
        try {
            return yield ne(this, Qs, "f").get({
                url: ne(this, ol, "f"),
                timeout: 2
            }), qe(this, eo, Date.now(), "f"), !0
        } catch (n) {
            return !1
        }
    })
}, "_HttpClientWithHealthCheck_isHealthy"), U1 = o(function(e, t, n) {
    return Ve(this, void 0, void 0, function*() {
        return n === void 0 || (ne(this, us, "m", L1).call(this, e, t) ? yield ne(this, us, "m", x1).call(this): !0) ? n : n + ne(this, yh, "f")
    })
}, "_HttpClientWithHealthCheck_getEffectiveTimeout"), Yf = o(function(e, t, n, i) {
    return Ve(this, void 0, void 0, function*() {
        let s = yield ne(this, us, "m", U1).call(this, t, n, i);
        try {
            return yield e(s)
        } finally {
            qe(this, eo, Date.now(), "f")
        }
    })
}, "_HttpClientWithHealthCheck_doWithHealthManagement");
var L_ = class L_ {
    abort() {
        var e;
        (e = this.onAbort) === null || e === void 0 || e.call(this)
    }
};
o(L_, "AbortRequest");
var Th = L_;

function gO(r) {
    return r.errorCode === He.Communication_Timeout || r.errorCode === He.Communication_Unavailable || r.errorCode === He.Communication_Internal_Server_Error || r.errorCode === He.Communication_Aborted
}
o(gO, "isNetworkOrServerError");
var Xf, qc, Jf, H0, x_ = class x_ {
    constructor() {
        let {
            acceptionRules: e = [],
            rejectionRules: t = []
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        Xf.add(this), qc.set(this, void 0), Jf.set(this, void 0), qe(this, qc, e, "f"), qe(this, Jf, t, "f")
    }
    isPathAcceptable(e, t) {
        let n = (t ? `${t}/${e}` : e).replace(/\/+/g, "/"),
            i = ne(this, qc, "f").length === 0 || ne(this, qc, "f").some(a => ne(this, Xf, "m", H0).call(this, a, n)),
            s = ne(this, Jf, "f").some(a => ne(this, Xf, "m", H0).call(this, a, n));
        return i && !s
    }
};
o(x_, "PathFilter");
var Eh = x_;
qc = new WeakMap, Jf = new WeakMap, Xf = new WeakSet, H0 = o(function(e, t) {
    return e instanceof RegExp ? e.test(t) : e ? t.startsWith(e) : !1
}, "_PathFilter_isMatch");
var U_;

function fr(r, e, t) {
    return (e = eH(e)) in r ? Object.defineProperty(r, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : r[e] = t, r
}
o(fr, "_defineProperty2");

function eH(r) {
    var e = tH(r, "string");
    return typeof e == "symbol" ? e : e + ""
}
o(eH, "_toPropertyKey");

function tH(r, e) {
    if (typeof r != "object" || !r) return r;
    var t = r[Symbol.toPrimitive];
    if (t !== void 0) {
        var n = t.call(r, e || "default");
        if (typeof n != "object") return n;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(r)
}
o(tH, "_toPrimitive");

function he(r, e, t, n) {
    function i(s) {
        return s instanceof t ? s : new t(function(a) {
            a(s)
        })
    }
    return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
        function u(d) {
            try {
                c(n.next(d))
            } catch (f) {
                a(f)
            }
        }
        o(u, "fulfilled");

        function l(d) {
            try {
                c(n.throw(d))
            } catch (f) {
                a(f)
            }
        }
        o(l, "rejected");

        function c(d) {
            d.done ? s(d.value) : i(d.value).then(u, l)
        }
        o(c, "step"), c((n = n.apply(r, e || [])).next())
    })
}
o(he, "__awaiter$3");

function O(r, e, t, n) {
    if (t === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? r !== e || !n : !e.has(r)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return t === "m" ? n : t === "a" ? n.call(r) : n ? n.value : e.get(r)
}
o(O, "__classPrivateFieldGet");

function ye(r, e, t, n, i) {
    if (n === "m") throw new TypeError("Private method is not writable");
    if (n === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? r !== e || !i : !e.has(r)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return n === "a" ? i.call(r, t) : i ? i.value = t : e.set(r, t), t
}
o(ye, "__classPrivateFieldSet");
var rH = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof global == "object" ? global : {},
    fo = "1.9.0",
    pO = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;

function nH(r) {
    var e = new Set([r]),
        t = new Set,
        n = r.match(pO);
    if (!n) return function() {
        return !1
    };
    var i = {
        major: +n[1],
        minor: +n[2],
        patch: +n[3],
        prerelease: n[4]
    };
    if (i.prerelease != null) return o(function(l) {
        return l === r
    }, "isExactmatch");

    function s(u) {
        return t.add(u), !1
    }
    o(s, "_reject");

    function a(u) {
        return e.add(u), !0
    }
    return o(a, "_accept"), o(function(l) {
        if (e.has(l)) return !0;
        if (t.has(l)) return !1;
        var c = l.match(pO);
        if (!c) return s(l);
        var d = {
            major: +c[1],
            minor: +c[2],
            patch: +c[3],
            prerelease: c[4]
        };
        return d.prerelease != null || i.major !== d.major ? s(l) : i.major === 0 ? i.minor === d.minor && i.patch <= d.patch ? a(l) : s(l) : i.minor <= d.minor ? a(l) : s(l)
    }, "isCompatible")
}
o(nH, "_makeCompatibilityCheck");
var iH = nH(fo),
    sH = fo.split(".")[0],
    Ml = Symbol.for("opentelemetry.js.api." + sH),
    kl = rH;

function jl(r, e, t, n) {
    var i;
    n === void 0 && (n = !1);
    var s = kl[Ml] = (i = kl[Ml]) !== null && i !== void 0 ? i : {
        version: fo
    };
    if (!n && s[r]) {
        var a = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + r);
        return t.error(a.stack || a.message), !1
    }
    if (s.version !== fo) {
        var a = new Error("@opentelemetry/api: Registration of version v" + s.version + " for " + r + " does not match previously registered API v" + fo);
        return t.error(a.stack || a.message), !1
    }
    return s[r] = e, t.debug("@opentelemetry/api: Registered a global for " + r + " v" + fo + "."), !0
}
o(jl, "registerGlobal");

function mo(r) {
    var e, t, n = (e = kl[Ml]) === null || e === void 0 ? void 0 : e.version;
    if (!(!n || !iH(n))) return (t = kl[Ml]) === null || t === void 0 ? void 0 : t[r]
}
o(mo, "getGlobal");

function Wl(r, e) {
    e.debug("@opentelemetry/api: Unregistering a global for " + r + " v" + fo + ".");
    var t = kl[Ml];
    t && delete t[r]
}
o(Wl, "unregisterGlobal");
var oH = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    },
    aH = function(r, e, t) {
        if (t || arguments.length === 2)
            for (var n = 0, i = e.length, s; n < i; n++)(s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
        return r.concat(s || Array.prototype.slice.call(e))
    },
    uH = (function() {
        function r(e) {
            this._namespace = e.namespace || "DiagComponentLogger"
        }
        return o(r, "DiagComponentLogger"), r.prototype.debug = function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return gl("debug", this._namespace, e)
        }, r.prototype.error = function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return gl("error", this._namespace, e)
        }, r.prototype.info = function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return gl("info", this._namespace, e)
        }, r.prototype.warn = function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return gl("warn", this._namespace, e)
        }, r.prototype.verbose = function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return gl("verbose", this._namespace, e)
        }, r
    })();

function gl(r, e, t) {
    var n = mo("diag");
    if (n) return t.unshift(e), n[r].apply(n, aH([], oH(t), !1))
}
o(gl, "logProxy");
var kt;
(function(r) {
    r[r.NONE = 0] = "NONE", r[r.ERROR = 30] = "ERROR", r[r.WARN = 50] = "WARN", r[r.INFO = 60] = "INFO", r[r.DEBUG = 70] = "DEBUG", r[r.VERBOSE = 80] = "VERBOSE", r[r.ALL = 9999] = "ALL"
})(kt || (kt = {}));

function cH(r, e) {
    r < kt.NONE ? r = kt.NONE : r > kt.ALL && (r = kt.ALL), e = e || {};

    function t(n, i) {
        var s = e[n];
        return typeof s == "function" && r >= i ? s.bind(e) : function() {}
    }
    return o(t, "_filterFunc"), {
        error: t("error", kt.ERROR),
        warn: t("warn", kt.WARN),
        info: t("info", kt.INFO),
        debug: t("debug", kt.DEBUG),
        verbose: t("verbose", kt.VERBOSE)
    }
}
o(cH, "createLogLevelDiagLogger");
var lH = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    },
    dH = function(r, e, t) {
        if (t || arguments.length === 2)
            for (var n = 0, i = e.length, s; n < i; n++)(s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
        return r.concat(s || Array.prototype.slice.call(e))
    },
    fH = "diag",
    Xn = (function() {
        function r() {
            function e(i) {
                return function() {
                    for (var s = [], a = 0; a < arguments.length; a++) s[a] = arguments[a];
                    var u = mo("diag");
                    if (u) return u[i].apply(u, dH([], lH(s), !1))
                }
            }
            o(e, "_logProxy");
            var t = this,
                n = o(function(i, s) {
                    var a, u, l;
                    if (s === void 0 && (s = {
                            logLevel: kt.INFO
                        }), i === t) {
                        var c = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
                        return t.error((a = c.stack) !== null && a !== void 0 ? a : c.message), !1
                    }
                    typeof s == "number" && (s = {
                        logLevel: s
                    });
                    var d = mo("diag"),
                        f = cH((u = s.logLevel) !== null && u !== void 0 ? u : kt.INFO, i);
                    if (d && !s.suppressOverrideMessage) {
                        var h = (l = new Error().stack) !== null && l !== void 0 ? l : "<failed to generate stacktrace>";
                        d.warn("Current logger will be overwritten from " + h), f.warn("Current logger will overwrite one already registered from " + h)
                    }
                    return jl("diag", f, t, !0)
                }, "setLogger");
            t.setLogger = n, t.disable = function() {
                Wl(fH, t)
            }, t.createComponentLogger = function(i) {
                return new uH(i)
            }, t.verbose = e("verbose"), t.debug = e("debug"), t.info = e("info"), t.warn = e("warn"), t.error = e("error")
        }
        return o(r, "DiagAPI"), r.instance = function() {
            return this._instance || (this._instance = new r), this._instance
        }, r
    })(),
    hH = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    },
    gH = function(r) {
        var e = typeof Symbol == "function" && Symbol.iterator,
            t = e && r[e],
            n = 0;
        if (t) return t.call(r);
        if (r && typeof r.length == "number") return {
            next: o(function() {
                return r && n >= r.length && (r = void 0), {
                    value: r && r[n++],
                    done: !r
                }
            }, "next")
        };
        throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
    },
    pH = (function() {
        function r(e) {
            this._entries = e ? new Map(e) : new Map
        }
        return o(r, "BaggageImpl"), r.prototype.getEntry = function(e) {
            var t = this._entries.get(e);
            if (t) return Object.assign({}, t)
        }, r.prototype.getAllEntries = function() {
            return Array.from(this._entries.entries()).map(function(e) {
                var t = hH(e, 2),
                    n = t[0],
                    i = t[1];
                return [n, i]
            })
        }, r.prototype.setEntry = function(e, t) {
            var n = new r(this._entries);
            return n._entries.set(e, t), n
        }, r.prototype.removeEntry = function(e) {
            var t = new r(this._entries);
            return t._entries.delete(e), t
        }, r.prototype.removeEntries = function() {
            for (var e, t, n = [], i = 0; i < arguments.length; i++) n[i] = arguments[i];
            var s = new r(this._entries);
            try {
                for (var a = gH(n), u = a.next(); !u.done; u = a.next()) {
                    var l = u.value;
                    s._entries.delete(l)
                }
            } catch (c) {
                e = {
                    error: c
                }
            } finally {
                try {
                    u && !u.done && (t = a.return) && t.call(a)
                } finally {
                    if (e) throw e.error
                }
            }
            return s
        }, r.prototype.clear = function() {
            return new r
        }, r
    })(),
    mH = Symbol("BaggageEntryMetadata"),
    vH = Xn.instance();

function yH(r) {
    return r === void 0 && (r = {}), new pH(new Map(Object.entries(r)))
}
o(yH, "createBaggage");

function _H(r) {
    return typeof r != "string" && (vH.error("Cannot create baggage metadata from unknown type: " + typeof r), r = ""), {
        __TYPE__: mH,
        toString: o(function() {
            return r
        }, "toString")
    }
}
o(_H, "baggageEntryMetadataFromString");

function pT(r) {
    return Symbol.for(r)
}
o(pT, "createContextKey");
var wH = (function() {
        function r(e) {
            var t = this;
            t._currentContext = e ? new Map(e) : new Map, t.getValue = function(n) {
                return t._currentContext.get(n)
            }, t.setValue = function(n, i) {
                var s = new r(t._currentContext);
                return s._currentContext.set(n, i), s
            }, t.deleteValue = function(n) {
                var i = new r(t._currentContext);
                return i._currentContext.delete(n), i
            }
        }
        return o(r, "BaseContext"), r
    })(),
    _i = new wH,
    vo = (function() {
        var r = o(function(e, t) {
            return r = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array && function(n, i) {
                n.__proto__ = i
            } || function(n, i) {
                for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s])
            }, r(e, t)
        }, "extendStatics");
        return function(e, t) {
            if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
            r(e, t);

            function n() {
                this.constructor = e
            }
            o(n, "__"), e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n)
        }
    })(),
    TH = (function() {
        function r() {}
        return o(r, "NoopMeter"), r.prototype.createGauge = function(e, t) {
            return NH
        }, r.prototype.createHistogram = function(e, t) {
            return DH
        }, r.prototype.createCounter = function(e, t) {
            return PH
        }, r.prototype.createUpDownCounter = function(e, t) {
            return LH
        }, r.prototype.createObservableGauge = function(e, t) {
            return UH
        }, r.prototype.createObservableCounter = function(e, t) {
            return xH
        }, r.prototype.createObservableUpDownCounter = function(e, t) {
            return MH
        }, r.prototype.addBatchObservableCallback = function(e, t) {}, r.prototype.removeBatchObservableCallback = function(e) {}, r
    })(),
    Gg = (function() {
        function r() {}
        return o(r, "NoopMetric"), r
    })(),
    EH = (function(r) {
        vo(e, r);

        function e() {
            return r !== null && r.apply(this, arguments) || this
        }
        return o(e, "NoopCounterMetric"), e.prototype.add = function(t, n) {}, e
    })(Gg),
    bH = (function(r) {
        vo(e, r);

        function e() {
            return r !== null && r.apply(this, arguments) || this
        }
        return o(e, "NoopUpDownCounterMetric"), e.prototype.add = function(t, n) {}, e
    })(Gg),
    SH = (function(r) {
        vo(e, r);

        function e() {
            return r !== null && r.apply(this, arguments) || this
        }
        return o(e, "NoopGaugeMetric"), e.prototype.record = function(t, n) {}, e
    })(Gg),
    AH = (function(r) {
        vo(e, r);

        function e() {
            return r !== null && r.apply(this, arguments) || this
        }
        return o(e, "NoopHistogramMetric"), e.prototype.record = function(t, n) {}, e
    })(Gg),
    mT = (function() {
        function r() {}
        return o(r, "NoopObservableMetric"), r.prototype.addCallback = function(e) {}, r.prototype.removeCallback = function(e) {}, r
    })(),
    IH = (function(r) {
        vo(e, r);

        function e() {
            return r !== null && r.apply(this, arguments) || this
        }
        return o(e, "NoopObservableCounterMetric"), e
    })(mT),
    CH = (function(r) {
        vo(e, r);

        function e() {
            return r !== null && r.apply(this, arguments) || this
        }
        return o(e, "NoopObservableGaugeMetric"), e
    })(mT),
    RH = (function(r) {
        vo(e, r);

        function e() {
            return r !== null && r.apply(this, arguments) || this
        }
        return o(e, "NoopObservableUpDownCounterMetric"), e
    })(mT),
    OH = new TH,
    PH = new EH,
    NH = new SH,
    DH = new AH,
    LH = new bH,
    xH = new IH,
    UH = new CH,
    MH = new RH,
    kH = {
        get: o(function(r, e) {
            if (r != null) return r[e]
        }, "get"),
        keys: o(function(r) {
            return r == null ? [] : Object.keys(r)
        }, "keys")
    },
    FH = {
        set: o(function(r, e, t) {
            r != null && (r[e] = t)
        }, "set")
    },
    $H = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    },
    BH = function(r, e, t) {
        if (t || arguments.length === 2)
            for (var n = 0, i = e.length, s; n < i; n++)(s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
        return r.concat(s || Array.prototype.slice.call(e))
    },
    VH = (function() {
        function r() {}
        return o(r, "NoopContextManager"), r.prototype.active = function() {
            return _i
        }, r.prototype.with = function(e, t, n) {
            for (var i = [], s = 3; s < arguments.length; s++) i[s - 3] = arguments[s];
            return t.call.apply(t, BH([n], $H(i), !1))
        }, r.prototype.bind = function(e, t) {
            return t
        }, r.prototype.enable = function() {
            return this
        }, r.prototype.disable = function() {
            return this
        }, r
    })(),
    HH = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    },
    jH = function(r, e, t) {
        if (t || arguments.length === 2)
            for (var n = 0, i = e.length, s; n < i; n++)(s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
        return r.concat(s || Array.prototype.slice.call(e))
    },
    M_ = "context",
    WH = new VH,
    zg = (function() {
        function r() {}
        return o(r, "ContextAPI"), r.getInstance = function() {
            return this._instance || (this._instance = new r), this._instance
        }, r.prototype.setGlobalContextManager = function(e) {
            return jl(M_, e, Xn.instance())
        }, r.prototype.active = function() {
            return this._getContextManager().active()
        }, r.prototype.with = function(e, t, n) {
            for (var i, s = [], a = 3; a < arguments.length; a++) s[a - 3] = arguments[a];
            return (i = this._getContextManager()).with.apply(i, jH([e, t, n], HH(s), !1))
        }, r.prototype.bind = function(e, t) {
            return this._getContextManager().bind(e, t)
        }, r.prototype._getContextManager = function() {
            return mo(M_) || WH
        }, r.prototype.disable = function() {
            this._getContextManager().disable(), Wl(M_, Xn.instance())
        }, r
    })(),
    Ai;
(function(r) {
    r[r.NONE = 0] = "NONE", r[r.SAMPLED = 1] = "SAMPLED"
})(Ai || (Ai = {}));
var AP = "0000000000000000",
    IP = "00000000000000000000000000000000",
    CP = {
        traceId: IP,
        spanId: AP,
        traceFlags: Ai.NONE
    },
    Ll = (function() {
        function r(e) {
            e === void 0 && (e = CP), this._spanContext = e
        }
        return o(r, "NonRecordingSpan"), r.prototype.spanContext = function() {
            return this._spanContext
        }, r.prototype.setAttribute = function(e, t) {
            return this
        }, r.prototype.setAttributes = function(e) {
            return this
        }, r.prototype.addEvent = function(e, t) {
            return this
        }, r.prototype.addLink = function(e) {
            return this
        }, r.prototype.addLinks = function(e) {
            return this
        }, r.prototype.setStatus = function(e) {
            return this
        }, r.prototype.updateName = function(e) {
            return this
        }, r.prototype.end = function(e) {}, r.prototype.isRecording = function() {
            return !1
        }, r.prototype.recordException = function(e, t) {}, r
    })(),
    vT = pT("OpenTelemetry Context Key SPAN");

function yT(r) {
    return r.getValue(vT) || void 0
}
o(yT, "getSpan");

function GH() {
    return yT(zg.getInstance().active())
}
o(GH, "getActiveSpan");

function _T(r, e) {
    return r.setValue(vT, e)
}
o(_T, "setSpan");

function zH(r) {
    return r.deleteValue(vT)
}
o(zH, "deleteSpan");

function qH(r, e) {
    return _T(r, new Ll(e))
}
o(qH, "setSpanContext");

function RP(r) {
    var e;
    return (e = yT(r)) === null || e === void 0 ? void 0 : e.spanContext()
}
o(RP, "getSpanContext");
var KH = /^([0-9a-f]{32})$/i,
    YH = /^[0-9a-f]{16}$/i;

function OP(r) {
    return KH.test(r) && r !== IP
}
o(OP, "isValidTraceId");

function XH(r) {
    return YH.test(r) && r !== AP
}
o(XH, "isValidSpanId");

function qg(r) {
    return OP(r.traceId) && XH(r.spanId)
}
o(qg, "isSpanContextValid");

function JH(r) {
    return new Ll(r)
}
o(JH, "wrapSpanContext");
var k_ = zg.getInstance(),
    PP = (function() {
        function r() {}
        return o(r, "NoopTracer"), r.prototype.startSpan = function(e, t, n) {
            n === void 0 && (n = k_.active());
            var i = !!(t != null && t.root);
            if (i) return new Ll;
            var s = n && RP(n);
            return ZH(s) && qg(s) ? new Ll(s) : new Ll
        }, r.prototype.startActiveSpan = function(e, t, n, i) {
            var s, a, u;
            if (!(arguments.length < 2)) {
                arguments.length === 2 ? u = t : arguments.length === 3 ? (s = t, u = n) : (s = t, a = n, u = i);
                var l = a != null ? a : k_.active(),
                    c = this.startSpan(e, s, l),
                    d = _T(l, c);
                return k_.with(d, u, void 0, c)
            }
        }, r
    })();

function ZH(r) {
    return typeof r == "object" && typeof r.spanId == "string" && typeof r.traceId == "string" && typeof r.traceFlags == "number"
}
o(ZH, "isSpanContext");
var QH = new PP,
    e4 = (function() {
        function r(e, t, n, i) {
            this._provider = e, this.name = t, this.version = n, this.options = i
        }
        return o(r, "ProxyTracer"), r.prototype.startSpan = function(e, t, n) {
            return this._getTracer().startSpan(e, t, n)
        }, r.prototype.startActiveSpan = function(e, t, n, i) {
            var s = this._getTracer();
            return Reflect.apply(s.startActiveSpan, s, arguments)
        }, r.prototype._getTracer = function() {
            if (this._delegate) return this._delegate;
            var e = this._provider.getDelegateTracer(this.name, this.version, this.options);
            return e ? (this._delegate = e, this._delegate) : QH
        }, r
    })(),
    t4 = (function() {
        function r() {}
        return o(r, "NoopTracerProvider"), r.prototype.getTracer = function(e, t, n) {
            return new PP
        }, r
    })(),
    r4 = new t4,
    mO = (function() {
        function r() {}
        return o(r, "ProxyTracerProvider"), r.prototype.getTracer = function(e, t, n) {
            var i;
            return (i = this.getDelegateTracer(e, t, n)) !== null && i !== void 0 ? i : new e4(this, e, t, n)
        }, r.prototype.getDelegate = function() {
            var e;
            return (e = this._delegate) !== null && e !== void 0 ? e : r4
        }, r.prototype.setDelegate = function(e) {
            this._delegate = e
        }, r.prototype.getDelegateTracer = function(e, t, n) {
            var i;
            return (i = this._delegate) === null || i === void 0 ? void 0 : i.getTracer(e, t, n)
        }, r
    })(),
    cg;
(function(r) {
    r[r.NOT_RECORD = 0] = "NOT_RECORD", r[r.RECORD = 1] = "RECORD", r[r.RECORD_AND_SAMPLED = 2] = "RECORD_AND_SAMPLED"
})(cg || (cg = {}));
var lg;
(function(r) {
    r[r.INTERNAL = 0] = "INTERNAL", r[r.SERVER = 1] = "SERVER", r[r.CLIENT = 2] = "CLIENT", r[r.PRODUCER = 3] = "PRODUCER", r[r.CONSUMER = 4] = "CONSUMER"
})(lg || (lg = {}));
var Fl;
(function(r) {
    r[r.UNSET = 0] = "UNSET", r[r.OK = 1] = "OK", r[r.ERROR = 2] = "ERROR"
})(Fl || (Fl = {}));
var Hr = zg.getInstance(),
    ot = Xn.instance(),
    n4 = (function() {
        function r() {}
        return o(r, "NoopMeterProvider"), r.prototype.getMeter = function(e, t, n) {
            return OH
        }, r
    })(),
    i4 = new n4,
    F_ = "metrics",
    s4 = (function() {
        function r() {}
        return o(r, "MetricsAPI"), r.getInstance = function() {
            return this._instance || (this._instance = new r), this._instance
        }, r.prototype.setGlobalMeterProvider = function(e) {
            return jl(F_, e, Xn.instance())
        }, r.prototype.getMeterProvider = function() {
            return mo(F_) || i4
        }, r.prototype.getMeter = function(e, t, n) {
            return this.getMeterProvider().getMeter(e, t, n)
        }, r.prototype.disable = function() {
            Wl(F_, Xn.instance())
        }, r
    })(),
    o4 = s4.getInstance(),
    a4 = (function() {
        function r() {}
        return o(r, "NoopTextMapPropagator"), r.prototype.inject = function(e, t) {}, r.prototype.extract = function(e, t) {
            return e
        }, r.prototype.fields = function() {
            return []
        }, r
    })(),
    wT = pT("OpenTelemetry Baggage Key");

function NP(r) {
    return r.getValue(wT) || void 0
}
o(NP, "getBaggage");

function u4() {
    return NP(zg.getInstance().active())
}
o(u4, "getActiveBaggage");

function c4(r, e) {
    return r.setValue(wT, e)
}
o(c4, "setBaggage");

function l4(r) {
    return r.deleteValue(wT)
}
o(l4, "deleteBaggage");
var $_ = "propagation",
    d4 = new a4,
    f4 = (function() {
        function r() {
            this.createBaggage = yH, this.getBaggage = NP, this.getActiveBaggage = u4, this.setBaggage = c4, this.deleteBaggage = l4
        }
        return o(r, "PropagationAPI"), r.getInstance = function() {
            return this._instance || (this._instance = new r), this._instance
        }, r.prototype.setGlobalPropagator = function(e) {
            return jl($_, e, Xn.instance())
        }, r.prototype.inject = function(e, t, n) {
            return n === void 0 && (n = FH), this._getGlobalPropagator().inject(e, t, n)
        }, r.prototype.extract = function(e, t, n) {
            return n === void 0 && (n = kH), this._getGlobalPropagator().extract(e, t, n)
        }, r.prototype.fields = function() {
            return this._getGlobalPropagator().fields()
        }, r.prototype.disable = function() {
            Wl($_, Xn.instance())
        }, r.prototype._getGlobalPropagator = function() {
            return mo($_) || d4
        }, r
    })(),
    wi = f4.getInstance(),
    B_ = "trace",
    h4 = (function() {
        function r() {
            this._proxyTracerProvider = new mO, this.wrapSpanContext = JH, this.isSpanContextValid = qg, this.deleteSpan = zH, this.getSpan = yT, this.getActiveSpan = GH, this.getSpanContext = RP, this.setSpan = _T, this.setSpanContext = qH
        }
        return o(r, "TraceAPI"), r.getInstance = function() {
            return this._instance || (this._instance = new r), this._instance
        }, r.prototype.setGlobalTracerProvider = function(e) {
            var t = jl(B_, this._proxyTracerProvider, Xn.instance());
            return t && this._proxyTracerProvider.setDelegate(e), t
        }, r.prototype.getTracerProvider = function() {
            return mo(B_) || this._proxyTracerProvider
        }, r.prototype.getTracer = function(e, t) {
            return this.getTracerProvider().getTracer(e, t)
        }, r.prototype.disable = function() {
            Wl(B_, Xn.instance()), this._proxyTracerProvider = new mO
        }, r
    })(),
    Nr = h4.getInstance(),
    DP = pT("OpenTelemetry SDK Context Key SUPPRESS_TRACING");

function g4(r) {
    return r.setValue(DP, !0)
}
o(g4, "suppressTracing");

function TT(r) {
    return r.getValue(DP) === !0
}
o(TT, "isTracingSuppressed");
var p4 = "=",
    lw = ";",
    dw = ",",
    V_ = "baggage",
    m4 = 180,
    v4 = 4096,
    y4 = 8192,
    _4 = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    };

function w4(r) {
    return r.reduce(function(e, t) {
        var n = "" + e + (e !== "" ? dw : "") + t;
        return n.length > y4 ? e : n
    }, "")
}
o(w4, "serializeKeyPairs");

function T4(r) {
    return r.getAllEntries().map(function(e) {
        var t = _4(e, 2),
            n = t[0],
            i = t[1],
            s = encodeURIComponent(n) + "=" + encodeURIComponent(i.value);
        return i.metadata !== void 0 && (s += lw + i.metadata.toString()), s
    })
}
o(T4, "getKeyPairs");

function E4(r) {
    var e = r.split(lw);
    if (!(e.length <= 0)) {
        var t = e.shift();
        if (t) {
            var n = t.indexOf(p4);
            if (!(n <= 0)) {
                var i = decodeURIComponent(t.substring(0, n).trim()),
                    s = decodeURIComponent(t.substring(n + 1).trim()),
                    a;
                return e.length > 0 && (a = _H(e.join(lw))), {
                    key: i,
                    value: s,
                    metadata: a
                }
            }
        }
    }
}
o(E4, "parsePairKeyValue");
var b4 = (function() {
        function r() {}
        return o(r, "W3CBaggagePropagator"), r.prototype.inject = function(e, t, n) {
            var i = wi.getBaggage(e);
            if (!(!i || TT(e))) {
                var s = T4(i).filter(function(u) {
                        return u.length <= v4
                    }).slice(0, m4),
                    a = w4(s);
                a.length > 0 && n.set(t, V_, a)
            }
        }, r.prototype.extract = function(e, t, n) {
            var i = n.get(t, V_),
                s = Array.isArray(i) ? i.join(dw) : i;
            if (!s) return e;
            var a = {};
            if (s.length === 0) return e;
            var u = s.split(dw);
            return u.forEach(function(l) {
                var c = E4(l);
                if (c) {
                    var d = {
                        value: c.value
                    };
                    c.metadata && (d.metadata = c.metadata), a[c.key] = d
                }
            }), Object.entries(a).length === 0 ? e : wi.setBaggage(e, wi.createBaggage(a))
        }, r.prototype.fields = function() {
            return [V_]
        }, r
    })(),
    LP = function(r) {
        var e = typeof Symbol == "function" && Symbol.iterator,
            t = e && r[e],
            n = 0;
        if (t) return t.call(r);
        if (r && typeof r.length == "number") return {
            next: o(function() {
                return r && n >= r.length && (r = void 0), {
                    value: r && r[n++],
                    done: !r
                }
            }, "next")
        };
        throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
    },
    S4 = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    };

function Uh(r) {
    var e, t, n = {};
    if (typeof r != "object" || r == null) return n;
    try {
        for (var i = LP(Object.entries(r)), s = i.next(); !s.done; s = i.next()) {
            var a = S4(s.value, 2),
                u = a[0],
                l = a[1];
            if (!A4(u)) {
                ot.warn("Invalid attribute key: " + u);
                continue
            }
            if (!xP(l)) {
                ot.warn("Invalid attribute value set for key: " + u);
                continue
            }
            Array.isArray(l) ? n[u] = l.slice() : n[u] = l
        }
    } catch (c) {
        e = {
            error: c
        }
    } finally {
        try {
            s && !s.done && (t = i.return) && t.call(i)
        } finally {
            if (e) throw e.error
        }
    }
    return n
}
o(Uh, "sanitizeAttributes");

function A4(r) {
    return typeof r == "string" && r.length > 0
}
o(A4, "isAttributeKey");

function xP(r) {
    return r == null ? !0 : Array.isArray(r) ? I4(r) : UP(r)
}
o(xP, "isAttributeValue");

function I4(r) {
    var e, t, n;
    try {
        for (var i = LP(r), s = i.next(); !s.done; s = i.next()) {
            var a = s.value;
            if (a != null) {
                if (!n) {
                    if (UP(a)) {
                        n = typeof a;
                        continue
                    }
                    return !1
                }
                if (typeof a !== n) return !1
            }
        }
    } catch (u) {
        e = {
            error: u
        }
    } finally {
        try {
            s && !s.done && (t = i.return) && t.call(i)
        } finally {
            if (e) throw e.error
        }
    }
    return !0
}
o(I4, "isHomogeneousAttributeValueArray");

function UP(r) {
    switch (typeof r) {
        case "number":
        case "boolean":
        case "string":
            return !0
    }
    return !1
}
o(UP, "isValidPrimitiveAttributeValue");

function C4() {
    return function(r) {
        ot.error(R4(r))
    }
}
o(C4, "loggingErrorHandler");

function R4(r) {
    return typeof r == "string" ? r : JSON.stringify(O4(r))
}
o(R4, "stringifyException");

function O4(r) {
    for (var e = {}, t = r; t !== null;) Object.getOwnPropertyNames(t).forEach(function(n) {
        if (!e[n]) {
            var i = t[n];
            i && (e[n] = String(i))
        }
    }), t = Object.getPrototypeOf(t);
    return e
}
o(O4, "flattenException");
var P4 = C4();

function dg(r) {
    try {
        P4(r)
    } catch (e) {}
}
o(dg, "globalErrorHandler");
var Yn;
(function(r) {
    r.AlwaysOff = "always_off", r.AlwaysOn = "always_on", r.ParentBasedAlwaysOff = "parentbased_always_off", r.ParentBasedAlwaysOn = "parentbased_always_on", r.ParentBasedTraceIdRatio = "parentbased_traceidratio", r.TraceIdRatio = "traceidratio"
})(Yn || (Yn = {}));
var N4 = ",",
    D4 = ["OTEL_SDK_DISABLED"];

function L4(r) {
    return D4.indexOf(r) > -1
}
o(L4, "isEnvVarABoolean");
var x4 = ["OTEL_BSP_EXPORT_TIMEOUT", "OTEL_BSP_MAX_EXPORT_BATCH_SIZE", "OTEL_BSP_MAX_QUEUE_SIZE", "OTEL_BSP_SCHEDULE_DELAY", "OTEL_BLRP_EXPORT_TIMEOUT", "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE", "OTEL_BLRP_MAX_QUEUE_SIZE", "OTEL_BLRP_SCHEDULE_DELAY", "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT", "OTEL_ATTRIBUTE_COUNT_LIMIT", "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT", "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT", "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT", "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT", "OTEL_SPAN_EVENT_COUNT_LIMIT", "OTEL_SPAN_LINK_COUNT_LIMIT", "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT", "OTEL_EXPORTER_OTLP_TIMEOUT", "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT", "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT", "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT", "OTEL_EXPORTER_JAEGER_AGENT_PORT"];

function U4(r) {
    return x4.indexOf(r) > -1
}
o(U4, "isEnvVarANumber");
var M4 = ["OTEL_NO_PATCH_MODULES", "OTEL_PROPAGATORS"];

function k4(r) {
    return M4.indexOf(r) > -1
}
o(k4, "isEnvVarAList");
var Mh = 1 / 0,
    kh = 128,
    F4 = 128,
    $4 = 128,
    MP = {
        OTEL_SDK_DISABLED: !1,
        CONTAINER_NAME: "",
        ECS_CONTAINER_METADATA_URI_V4: "",
        ECS_CONTAINER_METADATA_URI: "",
        HOSTNAME: "",
        KUBERNETES_SERVICE_HOST: "",
        NAMESPACE: "",
        OTEL_BSP_EXPORT_TIMEOUT: 3e4,
        OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
        OTEL_BSP_MAX_QUEUE_SIZE: 2048,
        OTEL_BSP_SCHEDULE_DELAY: 5e3,
        OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
        OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
        OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
        OTEL_BLRP_SCHEDULE_DELAY: 5e3,
        OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
        OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
        OTEL_EXPORTER_JAEGER_ENDPOINT: "",
        OTEL_EXPORTER_JAEGER_PASSWORD: "",
        OTEL_EXPORTER_JAEGER_USER: "",
        OTEL_EXPORTER_OTLP_ENDPOINT: "",
        OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
        OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
        OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
        OTEL_EXPORTER_OTLP_HEADERS: "",
        OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
        OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
        OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
        OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
        OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
        OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
        OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
        OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
        OTEL_LOG_LEVEL: kt.INFO,
        OTEL_NO_PATCH_MODULES: [],
        OTEL_PROPAGATORS: ["tracecontext", "baggage"],
        OTEL_RESOURCE_ATTRIBUTES: "",
        OTEL_SERVICE_NAME: "",
        OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: Mh,
        OTEL_ATTRIBUTE_COUNT_LIMIT: kh,
        OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: Mh,
        OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: kh,
        OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: Mh,
        OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: kh,
        OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
        OTEL_SPAN_LINK_COUNT_LIMIT: 128,
        OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: F4,
        OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: $4,
        OTEL_TRACES_EXPORTER: "",
        OTEL_TRACES_SAMPLER: Yn.ParentBasedAlwaysOn,
        OTEL_TRACES_SAMPLER_ARG: "",
        OTEL_LOGS_EXPORTER: "",
        OTEL_EXPORTER_OTLP_INSECURE: "",
        OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
        OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
        OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
        OTEL_EXPORTER_OTLP_CERTIFICATE: "",
        OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
        OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
        OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
        OTEL_EXPORTER_OTLP_COMPRESSION: "",
        OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
        OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
        OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
        OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
        OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
        OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
        OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
        OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
        OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
        OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
        OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
        OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
        OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
        OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
        OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
        OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
    };

function B4(r, e, t) {
    if (typeof t[r] != "undefined") {
        var n = String(t[r]);
        e[r] = n.toLowerCase() === "true"
    }
}
o(B4, "parseBoolean");

function V4(r, e, t, n, i) {
    if (n === void 0 && (n = -1 / 0), i === void 0 && (i = 1 / 0), typeof t[r] != "undefined") {
        var s = Number(t[r]);
        isNaN(s) || (s < n ? e[r] = n : s > i ? e[r] = i : e[r] = s)
    }
}
o(V4, "parseNumber");

function H4(r, e, t, n) {
    n === void 0 && (n = N4);
    var i = t[r];
    typeof i == "string" && (e[r] = i.split(n).map(function(s) {
        return s.trim()
    }))
}
o(H4, "parseStringList");
var j4 = {
    ALL: kt.ALL,
    VERBOSE: kt.VERBOSE,
    DEBUG: kt.DEBUG,
    INFO: kt.INFO,
    WARN: kt.WARN,
    ERROR: kt.ERROR,
    NONE: kt.NONE
};

function W4(r, e, t) {
    var n = t[r];
    if (typeof n == "string") {
        var i = j4[n.toUpperCase()];
        i != null && (e[r] = i)
    }
}
o(W4, "setLogLevelFromEnv");

function kP(r) {
    var e = {};
    for (var t in MP) {
        var n = t;
        switch (n) {
            case "OTEL_LOG_LEVEL":
                W4(n, e, r);
                break;
            default:
                if (L4(n)) B4(n, e, r);
                else if (U4(n)) V4(n, e, r);
                else if (k4(n)) H4(n, e, r);
                else {
                    var i = r[n];
                    typeof i != "undefined" && i !== null && (e[n] = String(i))
                }
        }
    }
    return e
}
o(kP, "parseEnvironment");
var FP = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof global == "object" ? global : {};

function Ba() {
    var r = kP(FP);
    return Object.assign({}, MP, r)
}
o(Ba, "getEnv");

function G4() {
    return kP(FP)
}
o(G4, "getEnvWithoutDefaults");
var Fa = performance,
    z4 = "1.26.0",
    q4 = "exception.type",
    K4 = "exception.message",
    Y4 = "exception.stacktrace",
    H_ = q4,
    j_ = K4,
    X4 = Y4,
    J4 = "process.runtime.name",
    Z4 = "service.name",
    Q4 = "telemetry.sdk.name",
    ej = "telemetry.sdk.language",
    tj = "telemetry.sdk.version",
    rj = J4,
    nj = Z4,
    fw = Q4,
    hw = ej,
    gw = tj,
    ij = "webjs",
    sj = ij,
    va, W_ = (va = {}, va[fw] = "opentelemetry", va[rj] = "browser", va[hw] = sj, va[gw] = z4, va);
var $P = 9,
    oj = 6,
    aj = Math.pow(10, oj),
    fg = Math.pow(10, $P);

function Da(r) {
    var e = r / 1e3,
        t = Math.trunc(e),
        n = Math.round(r % 1e3 * aj);
    return [t, n]
}
o(Da, "millisToHrTime$1");

function BP() {
    var r = Fa.timeOrigin;
    if (typeof r != "number") {
        var e = Fa;
        r = e.timing && e.timing.fetchStart
    }
    return r
}
o(BP, "getTimeOrigin$1");

function VP(r) {
    var e = Da(BP()),
        t = Da(typeof r == "number" ? r : Fa.now());
    return jP(e, t)
}
o(VP, "hrTime$1");

function uj(r, e) {
    var t = e[0] - r[0],
        n = e[1] - r[1];
    return n < 0 && (t -= 1, n += fg), [t, n]
}
o(uj, "hrTimeDuration");

function cj(r) {
    var e = $P,
        t = "" + "0".repeat(e) + r[1] + "Z",
        n = t.substr(t.length - e - 1),
        i = new Date(r[0] * 1e3).toISOString();
    return i.replace("000Z", n)
}
o(cj, "hrTimeToTimeStamp");

function lj(r) {
    return r[0] * fg + r[1]
}
o(lj, "hrTimeToNanoseconds$1");

function HP(r) {
    return Array.isArray(r) && r.length === 2 && typeof r[0] == "number" && typeof r[1] == "number"
}
o(HP, "isTimeInputHrTime$1");

function vO(r) {
    return HP(r) || typeof r == "number" || r instanceof Date
}
o(vO, "isTimeInput");

function jP(r, e) {
    var t = [r[0] + e[0], r[1] + e[1]];
    return t[1] >= fg && (t[1] -= fg, t[0] += 1), t
}
o(jP, "addHrTimes$1");
var pw;
(function(r) {
    r[r.SUCCESS = 0] = "SUCCESS", r[r.FAILED = 1] = "FAILED"
})(pw || (pw = {}));
var dj = function(r) {
        var e = typeof Symbol == "function" && Symbol.iterator,
            t = e && r[e],
            n = 0;
        if (t) return t.call(r);
        if (r && typeof r.length == "number") return {
            next: o(function() {
                return r && n >= r.length && (r = void 0), {
                    value: r && r[n++],
                    done: !r
                }
            }, "next")
        };
        throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
    },
    fj = (function() {
        function r(e) {
            e === void 0 && (e = {});
            var t;
            this._propagators = (t = e.propagators) !== null && t !== void 0 ? t : [], this._fields = Array.from(new Set(this._propagators.map(function(n) {
                return typeof n.fields == "function" ? n.fields() : []
            }).reduce(function(n, i) {
                return n.concat(i)
            }, [])))
        }
        return o(r, "CompositePropagator"), r.prototype.inject = function(e, t, n) {
            var i, s;
            try {
                for (var a = dj(this._propagators), u = a.next(); !u.done; u = a.next()) {
                    var l = u.value;
                    try {
                        l.inject(e, t, n)
                    } catch (c) {
                        ot.warn("Failed to inject with " + l.constructor.name + ". Err: " + c.message)
                    }
                }
            } catch (c) {
                i = {
                    error: c
                }
            } finally {
                try {
                    u && !u.done && (s = a.return) && s.call(a)
                } finally {
                    if (i) throw i.error
                }
            }
        }, r.prototype.extract = function(e, t, n) {
            return this._propagators.reduce(function(i, s) {
                try {
                    return s.extract(i, t, n)
                } catch (a) {
                    ot.warn("Failed to inject with " + s.constructor.name + ". Err: " + a.message)
                }
                return i
            }, e)
        }, r.prototype.fields = function() {
            return this._fields.slice()
        }, r
    })(),
    mw = "[_0-9a-z-*/]",
    hj = "[a-z]" + mw + "{0,255}",
    gj = "[a-z0-9]" + mw + "{0,240}@[a-z]" + mw + "{0,13}",
    pj = new RegExp("^(?:" + hj + "|" + gj + ")$"),
    mj = /^[ -~]{0,255}[!-~]$/,
    vj = /,|=/;

function yj(r) {
    return pj.test(r)
}
o(yj, "validateKey");

function _j(r) {
    return mj.test(r) && !vj.test(r)
}
o(_j, "validateValue");
var yO = 32,
    wj = 512,
    _O = ",",
    wO = "=",
    Tj = (function() {
        function r(e) {
            this._internalState = new Map, e && this._parse(e)
        }
        return o(r, "TraceState"), r.prototype.set = function(e, t) {
            var n = this._clone();
            return n._internalState.has(e) && n._internalState.delete(e), n._internalState.set(e, t), n
        }, r.prototype.unset = function(e) {
            var t = this._clone();
            return t._internalState.delete(e), t
        }, r.prototype.get = function(e) {
            return this._internalState.get(e)
        }, r.prototype.serialize = function() {
            var e = this;
            return this._keys().reduce(function(t, n) {
                return t.push(n + wO + e.get(n)), t
            }, []).join(_O)
        }, r.prototype._parse = function(e) {
            e.length > wj || (this._internalState = e.split(_O).reverse().reduce(function(t, n) {
                var i = n.trim(),
                    s = i.indexOf(wO);
                if (s !== -1) {
                    var a = i.slice(0, s),
                        u = i.slice(s + 1, n.length);
                    yj(a) && _j(u) && t.set(a, u)
                }
                return t
            }, new Map), this._internalState.size > yO && (this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, yO))))
        }, r.prototype._keys = function() {
            return Array.from(this._internalState.keys()).reverse()
        }, r.prototype._clone = function() {
            var e = new r;
            return e._internalState = new Map(this._internalState), e
        }, r
    })(),
    G_ = "traceparent",
    z_ = "tracestate",
    Ej = "00",
    bj = "(?!ff)[\\da-f]{2}",
    Sj = "(?![0]{32})[\\da-f]{32}",
    Aj = "(?![0]{16})[\\da-f]{16}",
    Ij = "[\\da-f]{2}",
    Cj = new RegExp("^\\s?(" + bj + ")-(" + Sj + ")-(" + Aj + ")-(" + Ij + ")(-.*)?\\s?$");

function Rj(r) {
    var e = Cj.exec(r);
    return !e || e[1] === "00" && e[5] ? null : {
        traceId: e[2],
        spanId: e[3],
        traceFlags: parseInt(e[4], 16)
    }
}
o(Rj, "parseTraceParent");
var Oj = (function() {
        function r() {}
        return o(r, "W3CTraceContextPropagator"), r.prototype.inject = function(e, t, n) {
            var i = Nr.getSpanContext(e);
            if (!(!i || TT(e) || !qg(i))) {
                var s = Ej + "-" + i.traceId + "-" + i.spanId + "-0" + Number(i.traceFlags || Ai.NONE).toString(16);
                n.set(t, G_, s), i.traceState && n.set(t, z_, i.traceState.serialize())
            }
        }, r.prototype.extract = function(e, t, n) {
            var i = n.get(t, G_);
            if (!i) return e;
            var s = Array.isArray(i) ? i[0] : i;
            if (typeof s != "string") return e;
            var a = Rj(s);
            if (!a) return e;
            a.isRemote = !0;
            var u = n.get(t, z_);
            if (u) {
                var l = Array.isArray(u) ? u.join(",") : u;
                a.traceState = new Tj(typeof l == "string" ? l : void 0)
            }
            return Nr.setSpanContext(e, a)
        }, r.prototype.fields = function() {
            return [G_, z_]
        }, r
    })(),
    Pj = "[object Object]",
    Nj = "[object Null]",
    Dj = "[object Undefined]",
    Lj = Function.prototype,
    WP = Lj.toString,
    xj = WP.call(Object),
    Uj = Mj(Object.getPrototypeOf, Object),
    GP = Object.prototype,
    zP = GP.hasOwnProperty,
    co = Symbol ? Symbol.toStringTag : void 0,
    qP = GP.toString;

function Mj(r, e) {
    return function(t) {
        return r(e(t))
    }
}
o(Mj, "overArg$3");

function TO(r) {
    if (!kj(r) || Fj(r) !== Pj) return !1;
    var e = Uj(r);
    if (e === null) return !0;
    var t = zP.call(e, "constructor") && e.constructor;
    return typeof t == "function" && t instanceof t && WP.call(t) === xj
}
o(TO, "isPlainObject");

function kj(r) {
    return r != null && typeof r == "object"
}
o(kj, "isObjectLike$6");

function Fj(r) {
    return r == null ? r === void 0 ? Dj : Nj : co && co in Object(r) ? $j(r) : Bj(r)
}
o(Fj, "baseGetTag$6");

function $j(r) {
    var e = zP.call(r, co),
        t = r[co],
        n = !1;
    try {
        r[co] = void 0, n = !0
    } catch (s) {}
    var i = qP.call(r);
    return n && (e ? r[co] = t : delete r[co]), i
}
o($j, "getRawTag$2");

function Bj(r) {
    return qP.call(r)
}
o(Bj, "objectToString$2");
var Vj = 20;

function Hj() {
    for (var r = [], e = 0; e < arguments.length; e++) r[e] = arguments[e];
    for (var t = r.shift(), n = new WeakMap; r.length > 0;) t = KP(t, r.shift(), 0, n);
    return t
}
o(Hj, "merge");

function q_(r) {
    return hg(r) ? r.slice() : r
}
o(q_, "takeValue");

function KP(r, e, t, n) {
    t === void 0 && (t = 0);
    var i;
    if (!(t > Vj)) {
        if (t++, Fh(r) || Fh(e) || YP(e)) i = q_(e);
        else if (hg(r)) {
            if (i = r.slice(), hg(e))
                for (var s = 0, a = e.length; s < a; s++) i.push(q_(e[s]));
            else if (pl(e))
                for (var u = Object.keys(e), s = 0, a = u.length; s < a; s++) {
                    var l = u[s];
                    i[l] = q_(e[l])
                }
        } else if (pl(r))
            if (pl(e)) {
                if (!jj(r, e)) return e;
                i = Object.assign({}, r);
                for (var u = Object.keys(e), s = 0, a = u.length; s < a; s++) {
                    var l = u[s],
                        c = e[l];
                    if (Fh(c)) typeof c == "undefined" ? delete i[l] : i[l] = c;
                    else {
                        var d = i[l],
                            f = c;
                        if (EO(r, l, n) || EO(e, l, n)) delete i[l];
                        else {
                            if (pl(d) && pl(f)) {
                                var h = n.get(d) || [],
                                    g = n.get(f) || [];
                                h.push({
                                    obj: r,
                                    key: l
                                }), g.push({
                                    obj: e,
                                    key: l
                                }), n.set(d, h), n.set(f, g)
                            }
                            i[l] = KP(i[l], c, t, n)
                        }
                    }
                }
            } else i = e;
        return i
    }
}
o(KP, "mergeTwoObjects");

function EO(r, e, t) {
    for (var n = t.get(r[e]) || [], i = 0, s = n.length; i < s; i++) {
        var a = n[i];
        if (a.key === e && a.obj === r) return !0
    }
    return !1
}
o(EO, "wasObjectReferenced");

function hg(r) {
    return Array.isArray(r)
}
o(hg, "isArray$9");

function YP(r) {
    return typeof r == "function"
}
o(YP, "isFunction$4");

function pl(r) {
    return !Fh(r) && !hg(r) && !YP(r) && typeof r == "object"
}
o(pl, "isObject$6");

function Fh(r) {
    return typeof r == "string" || typeof r == "number" || typeof r == "boolean" || typeof r == "undefined" || r instanceof Date || r instanceof RegExp || r === null
}
o(Fh, "isPrimitive");

function jj(r, e) {
    return !(!TO(r) || !TO(e))
}
o(jj, "shouldMerge");
var Wj = (function() {
        function r() {
            var e = this;
            this._promise = new Promise(function(t, n) {
                e._resolve = t, e._reject = n
            })
        }
        return o(r, "Deferred"), Object.defineProperty(r.prototype, "promise", {
            get: o(function() {
                return this._promise
            }, "get"),
            enumerable: !1,
            configurable: !0
        }), r.prototype.resolve = function(e) {
            this._resolve(e)
        }, r.prototype.reject = function(e) {
            this._reject(e)
        }, r
    })(),
    Gj = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    },
    zj = function(r, e, t) {
        if (t || arguments.length === 2)
            for (var n = 0, i = e.length, s; n < i; n++)(s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
        return r.concat(s || Array.prototype.slice.call(e))
    },
    qj = (function() {
        function r(e, t) {
            this._callback = e, this._that = t, this._isCalled = !1, this._deferred = new Wj
        }
        return o(r, "BindOnceFuture"), Object.defineProperty(r.prototype, "isCalled", {
            get: o(function() {
                return this._isCalled
            }, "get"),
            enumerable: !1,
            configurable: !0
        }), Object.defineProperty(r.prototype, "promise", {
            get: o(function() {
                return this._deferred.promise
            }, "get"),
            enumerable: !1,
            configurable: !0
        }), r.prototype.call = function() {
            for (var e, t = this, n = [], i = 0; i < arguments.length; i++) n[i] = arguments[i];
            if (!this._isCalled) {
                this._isCalled = !0;
                try {
                    Promise.resolve((e = this._callback).call.apply(e, zj([this._that], Gj(n), !1))).then(function(s) {
                        return t._deferred.resolve(s)
                    }, function(s) {
                        return t._deferred.reject(s)
                    })
                } catch (s) {
                    this._deferred.reject(s)
                }
            }
            return this._deferred.promise
        }, r
    })(),
    jT = class jT {
        constructor() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : VP();
            this.instant = e
        }
        static toISOString(e) {
            return cj(e.instant)
        }
        static toNanoSeconds(e) {
            return lj(e.instant)
        }
    };
o(jT, "Instant");
var Rn = jT,
    La = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};

function ET(r) {
    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r
}
o(ET, "getDefaultExportFromCjs");
var XP = {
        exports: {}
    },
    K_ = {
        exports: {}
    },
    bO;

function Kj() {
    return bO || (bO = 1, (function(r, e) {
        (function(t, n) {
            r.exports = n()
        })(La, function() {
            function t(m) {
                return !isNaN(parseFloat(m)) && isFinite(m)
            }
            o(t, "_isNumber");

            function n(m) {
                return m.charAt(0).toUpperCase() + m.substring(1)
            }
            o(n, "_capitalize");

            function i(m) {
                return function() {
                    return this[m]
                }
            }
            o(i, "_getter");
            var s = ["isConstructor", "isEval", "isNative", "isToplevel"],
                a = ["columnNumber", "lineNumber"],
                u = ["fileName", "functionName", "source"],
                l = ["args"],
                c = ["evalOrigin"],
                d = s.concat(a, u, l, c);

            function f(m) {
                if (m)
                    for (var w = 0; w < d.length; w++) m[d[w]] !== void 0 && this["set" + n(d[w])](m[d[w]])
            }
            o(f, "StackFrame"), f.prototype = {
                getArgs: o(function() {
                    return this.args
                }, "getArgs"),
                setArgs: o(function(m) {
                    if (Object.prototype.toString.call(m) !== "[object Array]") throw new TypeError("Args must be an Array");
                    this.args = m
                }, "setArgs"),
                getEvalOrigin: o(function() {
                    return this.evalOrigin
                }, "getEvalOrigin"),
                setEvalOrigin: o(function(m) {
                    if (m instanceof f) this.evalOrigin = m;
                    else if (m instanceof Object) this.evalOrigin = new f(m);
                    else throw new TypeError("Eval Origin must be an Object or StackFrame")
                }, "setEvalOrigin"),
                toString: o(function() {
                    var m = this.getFileName() || "",
                        w = this.getLineNumber() || "",
                        T = this.getColumnNumber() || "",
                        E = this.getFunctionName() || "";
                    return this.getIsEval() ? m ? "[eval] (" + m + ":" + w + ":" + T + ")" : "[eval]:" + w + ":" + T : E ? E + " (" + m + ":" + w + ":" + T + ")" : m + ":" + w + ":" + T
                }, "toString")
            }, f.fromString = o(function(w) {
                var T = w.indexOf("("),
                    E = w.lastIndexOf(")"),
                    b = w.substring(0, T),
                    R = w.substring(T + 1, E).split(","),
                    L = w.substring(E + 1);
                if (L.indexOf("@") === 0) var V = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(L, ""),
                    z = V[1],
                    j = V[2],
                    Y = V[3];
                return new f({
                    functionName: b,
                    args: R || void 0,
                    fileName: z,
                    lineNumber: j || void 0,
                    columnNumber: Y || void 0
                })
            }, "StackFrame$$fromString");
            for (var h = 0; h < s.length; h++) f.prototype["get" + n(s[h])] = i(s[h]), f.prototype["set" + n(s[h])] = (function(m) {
                return function(w) {
                    this[m] = !!w
                }
            })(s[h]);
            for (var g = 0; g < a.length; g++) f.prototype["get" + n(a[g])] = i(a[g]), f.prototype["set" + n(a[g])] = (function(m) {
                return function(w) {
                    if (!t(w)) throw new TypeError(m + " must be a Number");
                    this[m] = Number(w)
                }
            })(a[g]);
            for (var p = 0; p < u.length; p++) f.prototype["get" + n(u[p])] = i(u[p]), f.prototype["set" + n(u[p])] = (function(m) {
                return function(w) {
                    this[m] = String(w)
                }
            })(u[p]);
            return f
        })
    })(K_)), K_.exports
}
o(Kj, "requireStackframe");
(function(r, e) {
    (function(t, n) {
        r.exports = n(Kj())
    })(La, o(function(n) {
        var i = /(^|@)\S+:\d+/,
            s = /^\s*at .*(\S+:\d+|\(native\))/m,
            a = /^(eval@)?(\[native code])?$/;
        return {
            parse: o(function(l) {
                if (typeof l.stacktrace != "undefined" || typeof l["opera#sourceloc"] != "undefined") return this.parseOpera(l);
                if (l.stack && l.stack.match(s)) return this.parseV8OrIE(l);
                if (l.stack) return this.parseFFOrSafari(l);
                throw new Error("Cannot parse given Error object")
            }, "ErrorStackParser$$parse"),
            extractLocation: o(function(l) {
                if (l.indexOf(":") === -1) return [l];
                var c = /(.+?)(?::(\d+))?(?::(\d+))?$/,
                    d = c.exec(l.replace(/[()]/g, ""));
                return [d[1], d[2] || void 0, d[3] || void 0]
            }, "ErrorStackParser$$extractLocation"),
            parseV8OrIE: o(function(l) {
                var c = l.stack.split(`
`).filter(function(d) {
                    return !!d.match(s)
                }, this);
                return c.map(function(d) {
                    d.indexOf("(eval ") > -1 && (d = d.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, ""));
                    var f = d.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, ""),
                        h = f.match(/ (\(.+\)$)/);
                    f = h ? f.replace(h[0], "") : f;
                    var g = this.extractLocation(h ? h[1] : f),
                        p = h && f || void 0,
                        m = ["eval", "<anonymous>"].indexOf(g[0]) > -1 ? void 0 : g[0];
                    return new n({
                        functionName: p,
                        fileName: m,
                        lineNumber: g[1],
                        columnNumber: g[2],
                        source: d
                    })
                }, this)
            }, "ErrorStackParser$$parseV8OrIE"),
            parseFFOrSafari: o(function(l) {
                var c = l.stack.split(`
`).filter(function(d) {
                    return !d.match(a)
                }, this);
                return c.map(function(d) {
                    if (d.indexOf(" > eval") > -1 && (d = d.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1")), d.indexOf("@") === -1 && d.indexOf(":") === -1) return new n({
                        functionName: d
                    });
                    var f = /((.*".+"[^@]*)?[^@]*)(?:@)/,
                        h = d.match(f),
                        g = h && h[1] ? h[1] : void 0,
                        p = this.extractLocation(d.replace(f, ""));
                    return new n({
                        functionName: g,
                        fileName: p[0],
                        lineNumber: p[1],
                        columnNumber: p[2],
                        source: d
                    })
                }, this)
            }, "ErrorStackParser$$parseFFOrSafari"),
            parseOpera: o(function(l) {
                return !l.stacktrace || l.message.indexOf(`
`) > -1 && l.message.split(`
`).length > l.stacktrace.split(`
`).length ? this.parseOpera9(l) : l.stack ? this.parseOpera11(l) : this.parseOpera10(l)
            }, "ErrorStackParser$$parseOpera"),
            parseOpera9: o(function(l) {
                for (var c = /Line (\d+).*script (?:in )?(\S+)/i, d = l.message.split(`
`), f = [], h = 2, g = d.length; h < g; h += 2) {
                    var p = c.exec(d[h]);
                    p && f.push(new n({
                        fileName: p[2],
                        lineNumber: p[1],
                        source: d[h]
                    }))
                }
                return f
            }, "ErrorStackParser$$parseOpera9"),
            parseOpera10: o(function(l) {
                for (var c = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i, d = l.stacktrace.split(`
`), f = [], h = 0, g = d.length; h < g; h += 2) {
                    var p = c.exec(d[h]);
                    p && f.push(new n({
                        functionName: p[3] || void 0,
                        fileName: p[2],
                        lineNumber: p[1],
                        source: d[h]
                    }))
                }
                return f
            }, "ErrorStackParser$$parseOpera10"),
            parseOpera11: o(function(l) {
                var c = l.stack.split(`
`).filter(function(d) {
                    return !!d.match(i) && !d.match(/^Error created at/)
                }, this);
                return c.map(function(d) {
                    var f = d.split("@"),
                        h = this.extractLocation(f.pop()),
                        g = f.shift() || "",
                        p = g.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || void 0,
                        m;
                    g.match(/\(([^)]*)\)/) && (m = g.replace(/^[^(]+\(([^)]*)\)$/, "$1"));
                    var w = m === void 0 || m === "[arguments not available]" ? void 0 : m.split(",");
                    return new n({
                        functionName: p,
                        args: w,
                        fileName: h[0],
                        lineNumber: h[1],
                        columnNumber: h[2],
                        source: d
                    })
                }, this)
            }, "ErrorStackParser$$parseOpera11")
        }
    }, "ErrorStackParser"))
})(XP);
var Yj = XP.exports,
    Xj = ET(Yj),
    $h, JP, WT = class WT {
        constructor(e) {
            this.name = e.name, this.message = e.message, e.stack && (this.stack = O($h, $h, "m", JP).call($h, e))
        }
    };
o(WT, "ErrorRecord");
var gg = WT;
$h = gg, JP = o(function(e) {
    let t = Xj.parse(e),
        n = e,
        i = n != null && n.extraStack ? `ExtraStack: ${n.extraStack}` : "",
        s = t.map(a => a.source).join(`
`);
    return `${e.name}: ${e.message}
${s}
${i}`
}, "_ErrorRecord_sanitizeErrorStack");
var GT = class GT {
    constructor(e) {
        let {
            type: t,
            category: n,
            message: i,
            error: s,
            visibility: a,
            timestamp: u = new Rn,
            span: l,
            errorCode: c,
            attributes: d
        } = e;
        this.type = t, this.category = n, this.message = i, s && (this.error = new gg(s)), this.visibility = a, this.timestamp = u, this.span = l, this.errorCode = c, this.attributes = d
    }
};
o(GT, "Log");
var xa = GT,
    xl, Ua, SO, ZP, QP, AO = 5,
    Jj = 10,
    zT = class zT {
        constructor() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Map;
            xl.add(this), Ua.set(this, void 0), ye(this, Ua, e, "f")
        }
        closeCircuit(e) {
            O(this, Ua, "f").delete(e)
        }
        run(e, t) {
            return he(this, void 0, void 0, function*() {
                let n = O(this, Ua, "f").get(e);
                return n === void 0 ? O(this, xl, "m", ZP).call(this, e, t) : n.iterationsUntilRetry > 0 ? (n.iterationsUntilRetry--, 2) : O(this, xl, "m", QP).call(this, e, n, t)
            })
        }
    };
o(zT, "CircuitBreakerRunner");
var vw = zT;
Ua = new WeakMap, xl = new WeakSet, SO = o(function(e) {
    O(this, Ua, "f").set(e, {
        retriesFailed: 0,
        iterationsUntilRetry: AO
    })
}, "_CircuitBreakerRunner_openCircuit"), ZP = o(function(e, t) {
    return he(this, void 0, void 0, function*() {
        try {
            return yield t(), 0
        } catch (n) {
            return O(this, xl, "m", SO).call(this, e), console.debug(`Circuit breaker ${e} was opened: ${n}`), 1
        }
    })
}, "_CircuitBreakerRunner_runClosedCircuit"), QP = o(function(e, t, n) {
    return he(this, void 0, void 0, function*() {
        try {
            return yield n(), this.closeCircuit(e), console.debug(`Circuit breaker ${e} was closed`), 0
        } catch (i) {
            return t.retriesFailed++, t.iterationsUntilRetry = Math.min(t.retriesFailed * AO, Jj), 1
        }
    })
}, "_CircuitBreakerRunner_runOpenedCircuit");
var Zj = new Error("request for lock canceled"),
    Qj = o(function(r, e, t, n) {
        function i(s) {
            return s instanceof t ? s : new t(function(a) {
                a(s)
            })
        }
        return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
            function u(d) {
                try {
                    c(n.next(d))
                } catch (f) {
                    a(f)
                }
            }
            o(u, "fulfilled");

            function l(d) {
                try {
                    c(n.throw(d))
                } catch (f) {
                    a(f)
                }
            }
            o(l, "rejected");

            function c(d) {
                d.done ? s(d.value) : i(d.value).then(u, l)
            }
            o(c, "step"), c((n = n.apply(r, e || [])).next())
        })
    }, "__awaiter$2"),
    qT = class qT {
        constructor(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Zj;
            this._value = e, this._cancelError = t, this._queue = [], this._weightedWaiters = []
        }
        acquire() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1,
                t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            if (e <= 0) throw new Error(`invalid weight ${e}: must be positive`);
            return new Promise((n, i) => {
                let s = {
                        resolve: n,
                        reject: i,
                        weight: e,
                        priority: t
                    },
                    a = eN(this._queue, u => t <= u.priority);
                a === -1 && e <= this._value ? this._dispatchItem(s) : this._queue.splice(a + 1, 0, s)
            })
        }
        runExclusive(e) {
            return Qj(this, arguments, void 0, function(t) {
                var n = this;
                let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1,
                    s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                return (function*() {
                    let [a, u] = yield n.acquire(i, s);
                    try {
                        return yield t(a)
                    } finally {
                        u()
                    }
                })()
            })
        }
        waitForUnlock() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1,
                t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            if (e <= 0) throw new Error(`invalid weight ${e}: must be positive`);
            return this._couldLockImmediately(e, t) ? Promise.resolve() : new Promise(n => {
                this._weightedWaiters[e - 1] || (this._weightedWaiters[e - 1] = []), eW(this._weightedWaiters[e - 1], {
                    resolve: n,
                    priority: t
                })
            })
        }
        isLocked() {
            return this._value <= 0
        }
        getValue() {
            return this._value
        }
        setValue(e) {
            this._value = e, this._dispatchQueue()
        }
        release() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
            if (e <= 0) throw new Error(`invalid weight ${e}: must be positive`);
            this._value += e, this._dispatchQueue()
        }
        cancel() {
            this._queue.forEach(e => e.reject(this._cancelError)), this._queue = []
        }
        _dispatchQueue() {
            for (this._drainUnlockWaiters(); this._queue.length > 0 && this._queue[0].weight <= this._value;) this._dispatchItem(this._queue.shift()), this._drainUnlockWaiters()
        }
        _dispatchItem(e) {
            let t = this._value;
            this._value -= e.weight, e.resolve([t, this._newReleaser(e.weight)])
        }
        _newReleaser(e) {
            let t = !1;
            return () => {
                t || (t = !0, this.release(e))
            }
        }
        _drainUnlockWaiters() {
            if (this._queue.length === 0)
                for (let e = this._value; e > 0; e--) {
                    let t = this._weightedWaiters[e - 1];
                    t && (t.forEach(n => n.resolve()), this._weightedWaiters[e - 1] = [])
                } else {
                    let e = this._queue[0].priority;
                    for (let t = this._value; t > 0; t--) {
                        let n = this._weightedWaiters[t - 1];
                        if (!n) continue;
                        let i = n.findIndex(s => s.priority <= e);
                        (i === -1 ? n : n.splice(0, i)).forEach(s => s.resolve())
                    }
                }
        }
        _couldLockImmediately(e, t) {
            return (this._queue.length === 0 || this._queue[0].priority < t) && e <= this._value
        }
    };
o(qT, "Semaphore");
var yw = qT;

function eW(r, e) {
    let t = eN(r, n => e.priority <= n.priority);
    r.splice(t + 1, 0, e)
}
o(eW, "insertSorted");

function eN(r, e) {
    for (let t = r.length - 1; t >= 0; t--)
        if (e(r[t])) return t;
    return -1
}
o(eN, "findIndexFromEnd");
var tW = o(function(r, e, t, n) {
        function i(s) {
            return s instanceof t ? s : new t(function(a) {
                a(s)
            })
        }
        return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
            function u(d) {
                try {
                    c(n.next(d))
                } catch (f) {
                    a(f)
                }
            }
            o(u, "fulfilled");

            function l(d) {
                try {
                    c(n.throw(d))
                } catch (f) {
                    a(f)
                }
            }
            o(l, "rejected");

            function c(d) {
                d.done ? s(d.value) : i(d.value).then(u, l)
            }
            o(c, "step"), c((n = n.apply(r, e || [])).next())
        })
    }, "__awaiter$1"),
    KT = class KT {
        constructor(e) {
            this._semaphore = new yw(1, e)
        }
        acquire() {
            return tW(this, arguments, void 0, function() {
                var e = this;
                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                return (function*() {
                    let [, n] = yield e._semaphore.acquire(1, t);
                    return n
                })()
            })
        }
        runExclusive(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            return this._semaphore.runExclusive(() => e(), 1, t)
        }
        isLocked() {
            return this._semaphore.isLocked()
        }
        waitForUnlock() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return this._semaphore.waitForUnlock(1, e)
        }
        release() {
            this._semaphore.isLocked() && this._semaphore.release()
        }
        cancel() {
            return this._semaphore.cancel()
        }
    };
o(KT, "Mutex");
var pg = KT,
    ms;
(function(r) {
    r[r.Debug = 1] = "Debug", r[r.Info = 2] = "Info", r[r.Warning = 3] = "Warning", r[r.Error = 4] = "Error", r[r.Trace = 5] = "Trace"
})(ms || (ms = {}));
var rW = {
        Debug: ms.Debug,
        Info: ms.Info,
        Warning: ms.Warning,
        Error: ms.Error,
        Trace: ms.Trace
    },
    Je = ms,
    YT = class YT {
        constructor(e, t, n, i) {
            this.logId = e, this.log = t, this.logType = n, this.transportId = i
        }
    };
o(YT, "LogRecord");
var _w = YT,
    tN = "logger-offline-db",
    nW = "logs",
    iW = "spans",
    sW = "byLogType",
    rN = "byTransportId",
    oW = "byAggregateSignature",
    aW = "byParentId",
    uW = "logType",
    nN = "transportId",
    cW = "aggregateSignature",
    lW = "parentId",
    dW = o((r, e) => e.some(t => r instanceof t), "instanceOfAny"),
    IO, CO;

function fW() {
    return IO || (IO = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])
}
o(fW, "getIdbProxyableTypes");

function hW() {
    return CO || (CO = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])
}
o(hW, "getCursorAdvanceMethods");
var iN = new WeakMap,
    ww = new WeakMap,
    sN = new WeakMap,
    Y_ = new WeakMap,
    bT = new WeakMap;

function gW(r) {
    let e = new Promise((t, n) => {
        let i = o(() => {
                r.removeEventListener("success", s), r.removeEventListener("error", a)
            }, "unlisten"),
            s = o(() => {
                t(ys(r.result)), i()
            }, "success"),
            a = o(() => {
                n(r.error), i()
            }, "error");
        r.addEventListener("success", s), r.addEventListener("error", a)
    });
    return e.then(t => {
        t instanceof IDBCursor && iN.set(t, r)
    }).catch(() => {}), bT.set(e, r), e
}
o(gW, "promisifyRequest");

function pW(r) {
    if (ww.has(r)) return;
    let e = new Promise((t, n) => {
        let i = o(() => {
                r.removeEventListener("complete", s), r.removeEventListener("error", a), r.removeEventListener("abort", a)
            }, "unlisten"),
            s = o(() => {
                t(), i()
            }, "complete"),
            a = o(() => {
                n(r.error || new DOMException("AbortError", "AbortError")), i()
            }, "error");
        r.addEventListener("complete", s), r.addEventListener("error", a), r.addEventListener("abort", a)
    });
    ww.set(r, e)
}
o(pW, "cacheDonePromiseForTransaction");
var Tw = {
    get(r, e, t) {
        if (r instanceof IDBTransaction) {
            if (e === "done") return ww.get(r);
            if (e === "objectStoreNames") return r.objectStoreNames || sN.get(r);
            if (e === "store") return t.objectStoreNames[1] ? void 0 : t.objectStore(t.objectStoreNames[0])
        }
        return ys(r[e])
    },
    set(r, e, t) {
        return r[e] = t, !0
    },
    has(r, e) {
        return r instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in r
    }
};

function mW(r) {
    Tw = r(Tw)
}
o(mW, "replaceTraps");

function vW(r) {
    return r === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e) {
        for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
        let s = r.call(X_(this), e, ...n);
        return sN.set(s, e.sort ? e.sort() : [e]), ys(s)
    } : hW().includes(r) ? function() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
        return r.apply(X_(this), t), ys(iN.get(this))
    } : function() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
        return ys(r.apply(X_(this), t))
    }
}
o(vW, "wrapFunction");

function yW(r) {
    return typeof r == "function" ? vW(r) : (r instanceof IDBTransaction && pW(r), dW(r, fW()) ? new Proxy(r, Tw) : r)
}
o(yW, "transformCachableValue");

function ys(r) {
    if (r instanceof IDBRequest) return gW(r);
    if (Y_.has(r)) return Y_.get(r);
    let e = yW(r);
    return e !== r && (Y_.set(r, e), bT.set(e, r)), e
}
o(ys, "wrap$1");
var X_ = o(r => bT.get(r), "unwrap$1");

function _W(r, e) {
    let {
        blocked: t,
        upgrade: n,
        blocking: i,
        terminated: s
    } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = indexedDB.open(r, e), u = ys(a);
    return n && a.addEventListener("upgradeneeded", l => {
        n(ys(a.result), l.oldVersion, l.newVersion, ys(a.transaction), l)
    }), t && a.addEventListener("blocked", l => t(l.oldVersion, l.newVersion, l)), u.then(l => {
        s && l.addEventListener("close", () => s()), i && l.addEventListener("versionchange", c => i(c.oldVersion, c.newVersion, c))
    }).catch(() => {}), u
}
o(_W, "openDB");
var wW = ["get", "getKey", "getAll", "getAllKeys", "count"],
    TW = ["put", "add", "delete", "clear"],
    J_ = new Map;

function RO(r, e) {
    if (!(r instanceof IDBDatabase && !(e in r) && typeof e == "string")) return;
    if (J_.get(e)) return J_.get(e);
    let t = e.replace(/FromIndex$/, ""),
        n = e !== t,
        i = TW.includes(t);
    if (!(t in (n ? IDBIndex : IDBObjectStore).prototype) || !(i || wW.includes(t))) return;
    let s = o(function(u) {
        return vt(this, arguments, function*(a) {
            let l = this.transaction(a, i ? "readwrite" : "readonly"),
                c = l.store;
            for (var d = arguments.length, f = new Array(d > 1 ? d - 1 : 0), h = 1; h < d; h++) f[h - 1] = arguments[h];
            return n && (c = c.index(f.shift())), (yield Promise.all([c[t](...f), i && l.done]))[0]
        })
    }, "method");
    return J_.set(e, s), s
}
o(RO, "getMethod");
mW(r => ns(Rt({}, r), {
    get: o((e, t, n) => RO(e, t) || r.get(e, t, n), "get"),
    has: o((e, t) => !!RO(e, t) || r.has(e, t), "has")
}));
var wa, Bh, dr, _l, Vh, Hh, mg, Ew, bw, wl = 100,
    OO = "next",
    EW = "prev",
    XT = class XT {
        constructor(e) {
            let {
                dbName: t,
                tableName: n,
                version: i,
                indices: s,
                cursorToRecord: a,
                propertyKey: u
            } = e;
            wa.add(this), Bh.set(this, void 0), dr.set(this, void 0), _l.set(this, void 0), Vh.set(this, void 0), Hh.set(this, void 0), mg.set(this, void 0), ye(this, Bh, t, "f"), ye(this, dr, n, "f"), ye(this, Vh, i, "f"), ye(this, Hh, s, "f"), ye(this, mg, a, "f"), ye(this, _l, u, "f")
        }
        open() {
            return he(this, void 0, void 0, function*() {
                let e = O(this, dr, "f"),
                    t = O(this, Hh, "f"),
                    n = {
                        keyPath: O(this, _l, "f"),
                        autoIncrement: !O(this, _l, "f")
                    };
                return _W(O(this, Bh, "f"), O(this, Vh, "f"), {
                    upgrade(i, s) {
                        if (s < 1) {
                            let a = i.createObjectStore(e, n);
                            for (let u of t) a.createIndex(u.name, u.field)
                        }
                    }
                })
            })
        }
        getAll() {
            return he(this, arguments, void 0, function() {
                var e = this;
                let {
                    maxRecords: t = wl,
                    sortAsc: n = !0
                } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                return (function*() {
                    let i = yield e.open();
                    try {
                        let a = i.transaction(O(e, dr, "f")).objectStore(O(e, dr, "f"));
                        return yield O(e, wa, "m", Ew).call(e, yield a.openCursor(null, n ? OO : EW), t)
                    } finally {
                        i.close()
                    }
                })()
            })
        }
        getByIndex(e, t) {
            return he(this, arguments, void 0, function(n, i) {
                var s = this;
                let a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : wl,
                    u = arguments.length > 3 ? arguments[3] : void 0;
                return (function*() {
                    let l = yield s.open();
                    try {
                        let d = l.transaction(O(s, dr, "f")).objectStore(O(s, dr, "f"));
                        return yield O(s, wa, "m", Ew).call(s, yield d.index(n).openCursor(i), a, u)
                    } finally {
                        l.close()
                    }
                })()
            })
        }
        put(e) {
            return he(this, void 0, void 0, function*() {
                let t = yield this.open();
                try {
                    let i = t.transaction(O(this, dr, "f"), "readwrite").objectStore(O(this, dr, "f"));
                    for (let s of e) yield i.put(s)
                } finally {
                    t.close()
                }
            })
        }
        count() {
            return he(this, void 0, void 0, function*() {
                let e = yield this.open();
                try {
                    return yield e.count(O(this, dr, "f"))
                } finally {
                    e.close()
                }
            })
        }
        delete(e) {
            return he(this, void 0, void 0, function*() {
                let t = yield this.open();
                try {
                    yield t.delete(O(this, dr, "f"), e)
                } finally {
                    t.close()
                }
            })
        }
        deleteMultiple(e) {
            return he(this, void 0, void 0, function*() {
                let t = yield this.open();
                try {
                    let n = e.map(i => t.delete(O(this, dr, "f"), i));
                    yield Promise.all(n)
                } finally {
                    t.close()
                }
            })
        }
        deleteByIndex(e, t) {
            return he(this, arguments, void 0, function(n, i) {
                var s = this;
                let a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : wl;
                return (function*() {
                    let u = yield s.open();
                    try {
                        let c = u.transaction(O(s, dr, "f"), "readwrite").objectStore(O(s, dr, "f"));
                        return yield O(s, wa, "m", bw).call(s, yield c.index(n).openCursor(i), a)
                    } finally {
                        u.close()
                    }
                })()
            })
        }
        deleteRecords() {
            return he(this, arguments, void 0, function() {
                var e = this;
                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : wl;
                return (function*() {
                    let n = yield e.open();
                    try {
                        let s = n.transaction(O(e, dr, "f"), "readwrite").objectStore(O(e, dr, "f"));
                        return yield O(e, wa, "m", bw).call(e, yield s.openCursor(null, OO), t)
                    } finally {
                        n.close()
                    }
                })()
            })
        }
    };
o(XT, "IndexedDB");
var vg = XT;
Bh = new WeakMap, dr = new WeakMap, _l = new WeakMap, Vh = new WeakMap, Hh = new WeakMap, mg = new WeakMap, wa = new WeakSet, Ew = o(function(e) {
    return he(this, arguments, void 0, function(t) {
        var n = this;
        let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : wl,
            s = arguments.length > 2 ? arguments[2] : void 0;
        return (function*() {
            let a = [];
            for (; t && a.length < i;) {
                let u = O(n, mg, "f").call(n, t);
                (!s || s(u)) && a.push(u), t = yield t.continue()
            }
            return a
        })()
    })
}, "_IndexedDB_mapCursorToRecords"), bw = o(function(e, t) {
    return he(this, void 0, void 0, function*() {
        let n = 0;
        for (; e && n < t;) yield e.delete(), n++, e = yield e.continue();
        return n
    })
}, "_IndexedDB_deleteWithCursor");
var bW = 1,
    JT = class JT extends vg {
        constructor() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : tN;
            super({
                dbName: e,
                tableName: nW,
                cursorToRecord: o(t => new _w(t.primaryKey, t.value.log, t.value.logType, t.value.transportId), "cursorToRecord"),
                indices: [{
                    name: rN,
                    field: nN
                }, {
                    name: sW,
                    field: uW
                }],
                version: bW
            })
        }
        getByTransportId(e, t) {
            return he(this, void 0, void 0, function*() {
                return this.getByIndex("byTransportId", e, t)
            })
        }
        getByLogType(e, t) {
            return he(this, void 0, void 0, function*() {
                return this.getByIndex("byLogType", e, t)
            })
        }
        putLog(e, t) {
            return he(this, void 0, void 0, function*() {
                return this.put([{
                    log: e,
                    logType: e.type,
                    transportId: t
                }])
            })
        }
        deleteByLogType(e, t) {
            return he(this, void 0, void 0, function*() {
                return this.deleteByIndex("byLogType", e, t)
            })
        }
    };
o(JT, "LogsIndexedDB");
var Sw = JT,
    zn, SW = 200,
    AW = 1e4,
    ZT = class ZT {
        constructor(e) {
            let {
                databaseName: t,
                database: n = new Sw(t)
            } = e;
            zn.set(this, void 0), ye(this, zn, n, "f")
        }
        readLogs(e) {
            return he(this, void 0, void 0, function*() {
                return O(this, zn, "f").getAll({
                    sortAsc: !0,
                    maxRecords: e
                })
            })
        }
        readLogsByTransport(e, t) {
            return he(this, void 0, void 0, function*() {
                return O(this, zn, "f").getByTransportId(e, t)
            })
        }
        removeLogs(e) {
            return he(this, void 0, void 0, function*() {
                return O(this, zn, "f").deleteMultiple(e)
            })
        }
        insertLog(e, t) {
            return he(this, void 0, void 0, function*() {
                return O(this, zn, "f").putLog(e, t)
            })
        }
        countLogs() {
            return he(this, void 0, void 0, function*() {
                return O(this, zn, "f").count()
            })
        }
        isFull() {
            return he(this, void 0, void 0, function*() {
                return (yield O(this, zn, "f").count()) >= AW
            })
        }
        discardLogs() {
            return he(this, arguments, void 0, function() {
                var e = this;
                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : SW;
                return (function*() {
                    let n = Object.keys(Je).filter(s => isNaN(Number(s))),
                        i = t;
                    for (let s of n) {
                        let a = rW[s],
                            u = yield O(e, zn, "f").deleteByLogType(a, i);
                        if (i -= u, i <= 0) break
                    }
                    return i
                })()
            })
        }
    };
o(ZT, "LogsStorage");
var Aw = ZT;
zn = new WeakMap;
var yt;
(function(r) {
    r.IsAggregateProxy = "outsystems.aggregation.proxy", r.AggregationSize = "outsystems.aggregation.size", r.IsOutlier = "outsystems.aggregation.outlier", r.AverageDuration = "outsystems.aggregation.duration.average", r.MaxDuration = "outsystems.aggregation.duration.max", r.MinDuration = "outsystems.aggregation.duration.min", r.IsNonAggregable = "osinternal.spanIsNonAggregable", r.ChildrenNames = "osinternal.childrenNames", r.functionKey = "outsystems.function.key"
})(yt || (yt = {}));
var IW = "NonAggregable";

function CW(r, e) {
    return r < e ? -1 : e < r ? 1 : 0
}
o(CW, "compareStrings");

function RW(r) {
    return r.attributes[yt.functionKey]
}
o(RW, "defaultGetSpanObjectId");

function oN(r, e, t) {
    var n;
    let i = r.name,
        s = t == null ? void 0 : t(r),
        a = (n = r.attributes[yt.ChildrenNames]) !== null && n !== void 0 ? n : [];
    return a.sort(CW), `${r.attributes[yt.IsNonAggregable]?`${IW}.`:""}${e}.${i}.${s}(${a.join(",")})`
}
o(oN, "makeAggregateSignature");

function OW(r, e) {
    return !(r.attributes[yt.IsNonAggregable] || e.some(t => t.attributes[yt.IsNonAggregable]))
}
o(OW, "canAggregateSpan");
var Iw = {
    absolute: o((r, e) => {
        let {
            min: t,
            max: n
        } = r, i = typeof t == "number" && e < t, s = typeof n == "number" && e > n;
        return i || s
    }, "absolute"),
    relative: o((r, e, t) => {
        let {
            min: n,
            max: i
        } = r;
        return Iw.absolute({
            min: typeof n == "number" ? t + n : void 0,
            max: typeof i == "number" ? t + i : void 0
        }, e)
    }, "relative"),
    ratio: o((r, e, t) => {
        let {
            lower: n,
            upper: i,
            max: s,
            min: a
        } = r;
        return Iw.relative({
            min: typeof n == "number" ? Math.min(t * n, a != null ? a : 1 / 0) : void 0,
            max: typeof i == "number" ? Math.max(t * i, s != null ? s : -1 / 0) : void 0
        }, e, t)
    }, "ratio")
};

function PW(r, e, t) {
    return Iw[r.type](r, e, t)
}
o(PW, "applyThreshold");
var jh, QT = class QT {
    constructor(e) {
        jh.set(this, void 0), ye(this, jh, e, "f")
    }
    isOutlier(e, t) {
        for (let [n, i] of Object.entries(O(this, jh, "f"))) {
            let s = e.attributes[n],
                a = t.attributes[n];
            if (!(s === void 0 && a === void 0) && (s === void 0 || a === void 0 || PW(i, s, a))) return !0
        }
        return !1
    }
};
o(QT, "ThresholdOutlierDetector");
var Cw = QT;
jh = new WeakMap;
var ds, yi, Wh, yg, aN, uN, cN, lN, dN, fN, eE = class eE {
    constructor(e) {
        let {
            storage: t,
            outlierDetector: n = new Cw({
                [yt.AverageDuration]: {
                    type: "ratio",
                    upper: .1,
                    max: 5e7
                }
            }),
            getSpanObjectId: i = RW
        } = e;
        ds.add(this), yi.set(this, void 0), Wh.set(this, void 0), yg.set(this, void 0), ye(this, yi, t, "f"), ye(this, Wh, n, "f"), ye(this, yg, i, "f")
    }
    aggregate(e, t) {
        return he(this, void 0, void 0, function*() {
            let n = yield O(this, yi, "f").readSpansByParentId(e.spanId), i = O(this, ds, "m", cN).call(this, e);
            if (!OW(i, n)) {
                yield O(this, yi, "f").insertSpans([O(this, ds, "m", dN).call(this, i)], t);
                return
            }
            let a = yield O(this, ds, "m", aN).call(this, i, t);
            if (!a) yield O(this, yi, "f").insertSpans([i], t);
            else if (O(this, Wh, "f").isOutlier(i, a)) yield O(this, yi, "f").insertSpans([O(this, ds, "m", lN).call(this, i)], t);
            else {
                let u = O(this, ds, "m", uN).call(this, e, a),
                    l = O(this, ds, "m", fN).call(this, n, u);
                yield O(this, yi, "f").insertSpans([u, ...l], t)
            }
        })
    }
};
o(eE, "SpanAggregator");
var Rw = eE;
yi = new WeakMap, Wh = new WeakMap, yg = new WeakMap, ds = new WeakSet, aN = o(function(e, t) {
    return he(this, void 0, void 0, function*() {
        let n = oN(e, t, O(this, yg, "f")),
            [i] = yield O(this, yi, "f").readSpansByAggregateSignature(n);
        return i
    })
}, "_SpanAggregator_findProxy"), uN = o(function(e, t) {
    var n;
    let i = (n = t.attributes[yt.AggregationSize]) !== null && n !== void 0 ? n : 1,
        s = t.attributes[yt.AverageDuration],
        a = t.attributes[yt.MaxDuration],
        u = t.attributes[yt.MinDuration],
        l = e.endTimeUnixNano - e.startTimeUnixNano;
    return Object.assign(Object.assign({}, t), {
        attributes: Object.assign(Object.assign({}, t.attributes), {
            [yt.IsAggregateProxy]: !0,
            [yt.AggregationSize]: i + 1,
            [yt.AverageDuration]: (s * i + l) / (i + 1),
            [yt.MaxDuration]: Math.max(a, l),
            [yt.MinDuration]: Math.min(u, l)
        }),
        parentSpanId: t.parentSpanId === e.spanId ? e.parentSpanId : t.parentSpanId
    })
}, "_SpanAggregator_updateProxy"), cN = o(function(e) {
    let t = e.endTimeUnixNano - e.startTimeUnixNano;
    return Object.assign(Object.assign({}, e), {
        attributes: Object.assign(Object.assign({}, e.attributes), {
            [yt.IsAggregateProxy]: !1,
            [yt.AverageDuration]: t,
            [yt.MaxDuration]: t,
            [yt.MinDuration]: t
        })
    })
}, "_SpanAggregator_createEnrichedSpan"), lN = o(function(e) {
    return Object.assign(Object.assign({}, e), {
        attributes: Object.assign(Object.assign({}, e.attributes), {
            [yt.IsOutlier]: !0,
            [yt.IsNonAggregable]: !0
        })
    })
}, "_SpanAggregator_toOutlierSpan"), dN = o(function(e) {
    return Object.assign(Object.assign({}, e), {
        attributes: Object.assign(Object.assign({}, e.attributes), {
            [yt.IsNonAggregable]: !0
        })
    })
}, "_SpanAggregator_toNonAggregableSpan"), fN = o(function(e, t) {
    return e.flatMap(n => n.spanId !== t.spanId ? [Object.assign(Object.assign({}, n), {
        parentSpanId: t.spanId
    })] : [])
}, "_SpanAggregator_adopt");
var tE = class tE {
    constructor(e) {
        let {
            spanId: t,
            span: n,
            transportId: i,
            aggregateSignature: s
        } = e;
        this.spanId = t, this.span = n, this.transportId = i, this.parentId = n.parentSpanId, this.aggregateSignature = s != null ? s : ""
    }
};
o(tE, "SpanRecord");
var Ow = tE,
    Pw, hN, NW = 1,
    rE = class rE extends vg {
        constructor() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : tN,
                t = arguments.length > 1 ? arguments[1] : void 0;
            super({
                dbName: e,
                tableName: iW,
                version: NW,
                propertyKey: t,
                cursorToRecord: o(n => new Ow({
                    spanId: n.primaryKey,
                    span: n.value.span,
                    transportId: n.value.transportId,
                    aggregateSignature: n.value.aggregateSignature
                }), "cursorToRecord"),
                indices: [{
                    name: rN,
                    field: nN
                }, {
                    name: oW,
                    field: cW
                }, {
                    name: aW,
                    field: lW
                }]
            }), Pw.add(this)
        }
        getByAggregateSignature(e, t) {
            return this.getByIndex("byAggregateSignature", e, t)
        }
        getByParentId(e, t) {
            return this.getByIndex("byParentId", e, t)
        }
        getByTransportId(e, t) {
            return this.getByIndex("byTransportId", e, t)
        }
        getTopLevelByTransportId(e, t) {
            return this.getByIndex("byTransportId", e, t, n => n.parentId === void 0)
        }
        putSpans(e, t) {
            return this.put(e.map(n => O(this, Pw, "m", hN).call(this, n, t)))
        }
    };
o(rE, "TracesIndexedDB");
var _g = rE;
Pw = new WeakSet, hN = o(function(e, t) {
    return {
        span: e,
        transportId: t,
        spanId: e.spanId,
        aggregateSignature: oN(e, t, n => n.attributes["outsystems.function.key"]),
        parentId: e.parentSpanId
    }
}, "_TracesIndexedDB_spanToRecord");
var $r, DW = 200,
    LW = 1e4,
    nE = class nE {
        constructor(e) {
            let {
                databaseName: t,
                autoincrement: n = !0,
                database: i = n ? new _g(t) : new _g(t, "spanId")
            } = e;
            $r.set(this, void 0), ye(this, $r, i, "f")
        }
        readSpans(e) {
            return he(this, void 0, void 0, function*() {
                return O(this, $r, "f").getAll({
                    sortAsc: !0,
                    maxRecords: e
                })
            })
        }
        readSpansByTransport(e, t) {
            return he(this, void 0, void 0, function*() {
                let n = yield O(this, $r, "f").getTopLevelByTransportId(e, t);
                return n.length > 0 ? n : O(this, $r, "f").getByTransportId(e, t)
            })
        }
        readSpansByParentId(e, t) {
            return he(this, void 0, void 0, function*() {
                return O(this, $r, "f").getByParentId(e, t)
            })
        }
        readSpansByAggregateSignature(e, t) {
            return he(this, void 0, void 0, function*() {
                return O(this, $r, "f").getByAggregateSignature(e, t)
            })
        }
        removeSpans(e) {
            return he(this, void 0, void 0, function*() {
                return O(this, $r, "f").deleteMultiple(e)
            })
        }
        insertSpan(e, t) {
            return he(this, void 0, void 0, function*() {
                return O(this, $r, "f").putSpans([e], t)
            })
        }
        insertSerializableSpans(e, t) {
            return he(this, void 0, void 0, function*() {
                return O(this, $r, "f").putSpans(e, t)
            })
        }
        countSpans() {
            return he(this, void 0, void 0, function*() {
                return O(this, $r, "f").count()
            })
        }
        isFull() {
            return he(this, void 0, void 0, function*() {
                return (yield O(this, $r, "f").count()) >= LW
            })
        }
        discardSpans() {
            return he(this, arguments, void 0, function() {
                var e = this;
                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DW;
                return (function*() {
                    return O(e, $r, "f").deleteRecords(t)
                })()
            })
        }
    };
o(nE, "TracesStorage");
var wg = nE;
$r = new WeakMap;

function xW(r) {
    return new Rw({
        storage: {
            insertSpans: o((e, t) => he(this, void 0, void 0, function*() {
                yield r.insertSerializableSpans(e, t)
            }), "insertSpans"),
            readSpansByAggregateSignature: o(e => he(this, void 0, void 0, function*() {
                return (yield r.readSpansByAggregateSignature(e)).map(n => n.span)
            }), "readSpansByAggregateSignature"),
            readSpansByParentId: o(e => he(this, void 0, void 0, function*() {
                return (yield r.readSpansByParentId(e)).map(n => n.span)
            }), "readSpansByParentId")
        },
        getSpanObjectId: o(e => e.attributes["outsystems.function.key"], "getSpanObjectId")
    })
}
o(xW, "makeSpanAggregator");
var qn, fs, Gh, Tl, El, bl, zh, Ta, Sl, Z_ = 100,
    Q_ = 1e3,
    UW = new pg,
    MW = new pg,
    kW = "logs",
    FW = "spans_v2",
    $W = "spans",
    iE = class iE {
        constructor(e) {
            let {
                databaseNameSuffix: t,
                isOnline: n = o(() => !0, "isOnline"),
                offlineLogsStorage: i = new Aw({
                    databaseName: `${kW}-${t}`
                }),
                offlineTracesStorage: s = new wg({
                    databaseName: `${FW}-${t}`,
                    autoincrement: !1
                }),
                legacyOfflineTracesStorage: a = new wg({
                    databaseName: `${$W}-${t}`
                }),
                flushLegacyTraces: u = !1,
                aggregateSpans: l = !1,
                spanAggregator: c = xW(s),
                mutexDispatchLogs: d = UW,
                mutexDispatchSpans: f = MW
            } = e;
            qn.set(this, void 0), fs.set(this, void 0), Gh.set(this, void 0), Tl.set(this, !0), El.set(this, void 0), bl.set(this, void 0), zh.set(this, void 0), Ta.set(this, void 0), Sl.set(this, void 0), ye(this, qn, i, "f"), ye(this, fs, s, "f"), ye(this, Gh, a, "f"), ye(this, El, n, "f"), ye(this, Tl, u, "f"), ye(this, bl, l, "f"), ye(this, zh, c, "f"), ye(this, Sl, d, "f"), ye(this, Ta, f, "f")
        }
        setAggregateSpansStatus(e) {
            ye(this, bl, e, "f")
        }
        writeLog(e, t) {
            return he(this, arguments, void 0, function(n, i) {
                var s = this;
                let a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Z_;
                return (function*() {
                    try {
                        (yield O(s, qn, "f").isFull()) && (yield O(s, qn, "f").discardLogs()), yield O(s, qn, "f").insertLog(n, i.getTransportId()), (yield O(s, qn, "f").countLogs()) >= a && (yield s.flushTransportLogs(i))
                    } catch (u) {
                        console.debug("Error writing log to storage", u)
                    }
                })()
            })
        }
        writeSpan(e, t) {
            return he(this, arguments, void 0, function(n, i) {
                var s = this;
                let a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Q_;
                return (function*() {
                    try {
                        (yield O(s, fs, "f").isFull()) && (yield O(s, fs, "f").discardSpans()), yield O(s, Ta, "f").runExclusive(() => he(s, void 0, void 0, function*() {
                            O(this, bl, "f") ? yield O(this, zh, "f").aggregate(n, i.getTransportId()): yield O(this, fs, "f").insertSpan(n, i.getTransportId())
                        })), (yield O(s, fs, "f").countSpans()) >= a && (yield s.flushTransportSpans(i))
                    } catch (u) {
                        console.debug("Error writing trace to storage", u)
                    }
                })()
            })
        }
        processTransportLogs(e) {
            return he(this, arguments, void 0, function(t) {
                var n = this;
                let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Z_;
                return (function*() {
                    yield O(n, Sl, "f").runExclusive(() => he(n, void 0, void 0, function*() {
                        yield this.internalLogProcess(t, i, !0)
                    }))
                })()
            })
        }
        flushTransportLogs(e) {
            return he(this, arguments, void 0, function(t) {
                var n = this;
                let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Z_;
                return (function*() {
                    yield O(n, Sl, "f").runExclusive(() => he(n, void 0, void 0, function*() {
                        yield this.internalLogProcess(t, i, !1)
                    }))
                })()
            })
        }
        internalLogProcess(e, t, n) {
            return he(this, void 0, void 0, function*() {
                if (!(e.requiresConnectivity() && !O(this, El, "f").call(this))) try {
                    let i = n ? t : 1,
                        s = yield O(this, qn, "f").readLogsByTransport(e.getTransportId(), t);
                    for (; s.length >= i;) yield e.writeAll(s.map(a => a.log)), yield O(this, qn, "f").removeLogs(s.map(a => a.logId)), s = yield O(this, qn, "f").readLogsByTransport(e.getTransportId(), t)
                } catch (i) {
                    throw console.debug("Error in internal log processing", i), i
                }
            })
        }
        processTransportSpans(e) {
            return he(this, arguments, void 0, function(t) {
                var n = this;
                let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Q_;
                return (function*() {
                    yield O(n, Ta, "f").runExclusive(() => he(n, void 0, void 0, function*() {
                        yield this.internalSpanProcess(t, i, !0)
                    }))
                })()
            })
        }
        flushTransportSpans(e) {
            return he(this, arguments, void 0, function(t) {
                var n = this;
                let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Q_;
                return (function*() {
                    yield O(n, Ta, "f").runExclusive(() => he(n, void 0, void 0, function*() {
                        yield this.internalSpanProcess(t, i, !1)
                    }))
                })()
            })
        }
        internalSpanProcess(e, t, n) {
            return he(this, void 0, void 0, function*() {
                if (!(e.requiresConnectivity() && !O(this, El, "f").call(this))) {
                    if (O(this, Tl, "f")) try {
                        let i = yield this.writeSpansToTransport({
                            transport: e,
                            spansBatchSize: t,
                            storage: O(this, Gh, "f"),
                            processCompleteBatchOnly: !1
                        });
                        ye(this, Tl, i > 0, "f")
                    } catch (i) {
                        console.warn("Error in processing legacy spans", i)
                    }
                    yield this.writeSpansToTransport({
                        transport: e,
                        spansBatchSize: t,
                        processCompleteBatchOnly: n,
                        storage: O(this, fs, "f")
                    })
                }
            })
        }
        writeSpansToTransport(e) {
            return he(this, arguments, void 0, function(t) {
                let {
                    transport: n,
                    spansBatchSize: i,
                    processCompleteBatchOnly: s,
                    storage: a
                } = t;
                return (function*() {
                    try {
                        let u = s ? i : 1,
                            l = yield a.readSpansByTransport(n.getTransportId(), i);
                        if (l.length === 0) return 0;
                        for (; l.length >= u;) yield n.writeAll(l.map(c => c.span)), yield a.removeSpans(l.map(c => c.spanId)), l = yield a.readSpansByTransport(n.getTransportId(), i);
                        return yield a.countSpans()
                    } catch (u) {
                        throw console.debug("Error processing spans", u), u
                    }
                })()
            })
        }
    };
o(iE, "OfflineManager");
var Nw = iE;
qn = new WeakMap, fs = new WeakMap, Gh = new WeakMap, Tl = new WeakMap, El = new WeakMap, bl = new WeakMap, zh = new WeakMap, Ta = new WeakMap, Sl = new WeakMap;
var BW = 6e4,
    sE = class sE {
        constructor() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : BW;
            this.timerInterval = e, this.tasksToRun = new Map
        }
        scheduleNextRun() {
            this.currentTaskTimeout && clearTimeout(this.currentTaskTimeout), this.currentTaskTimeout = setTimeout(() => this.runTask(), this.timerInterval)
        }
        runTask() {
            return he(this, void 0, void 0, function*() {
                if (this.currentTaskTimeout) {
                    this.stop();
                    let t = Array.from(this.tasksToRun.values()).map(n => n());
                    yield Promise.all(t), this.scheduleNextRun()
                }
            })
        }
        start() {
            this.scheduleNextRun()
        }
        stop() {
            this.currentTaskTimeout && (clearTimeout(this.currentTaskTimeout), this.currentTaskTimeout = void 0)
        }
        addTask(e, t) {
            this.tasksToRun.set(e, t)
        }
        deleteTask(e) {
            this.tasksToRun.delete(e)
        }
        getTask(e) {
            return this.tasksToRun.get(e)
        }
        setTimerInterval(e) {
            this.timerInterval = e, this.start()
        }
    };
o(sE, "TaskScheduler");
var Dw = sE,
    oE = class oE {
        constructor(e) {
            let {
                logTransports: t = [],
                traceTransports: n = [],
                databaseNameSuffix: i,
                isOnline: s,
                aggregateSpans: a,
                offlineManager: u = new Nw({
                    databaseNameSuffix: i,
                    isOnline: s,
                    flushLegacyTraces: !0,
                    aggregateSpans: a
                }),
                taskScheduler: l = new Dw,
                circuitBreakerRunner: c = new vw
            } = e;
            this.logTransports = t, this.traceTransports = n, this.offlineManager = u, this.taskScheduler = l, this.circuitBreakerRunner = c, this.taskScheduler.addTask("flush-logs", () => he(this, void 0, void 0, function*() {
                return this.flushLogs()
            })), this.taskScheduler.addTask("flush-spans", () => he(this, void 0, void 0, function*() {
                return this.flushSpans()
            })), this.taskScheduler.start()
        }
        addLogTransport(e) {
            let t = e.getTransportId(),
                n = o(i => i.getTransportId() === t, "predicate");
            this.logTransports.some(n) || this.logTransports.push(e)
        }
        addTraceTransport(e) {
            let t = e.getTransportId(),
                n = o(i => i.getTransportId() === t, "predicate");
            this.traceTransports.some(n) || this.traceTransports.push(e)
        }
        removeLogTransport(e) {
            let t = o(i => i.getTransportId() === e, "predicate"),
                n = this.logTransports.findIndex(t);
            n !== -1 && (this.logTransports.splice(n, 1), this.circuitBreakerRunner.closeCircuit(e))
        }
        removeTraceTransport(e) {
            let t = o(i => i.getTransportId() === e, "predicate"),
                n = this.traceTransports.findIndex(t);
            n !== -1 && (this.traceTransports.splice(n, 1), this.circuitBreakerRunner.closeCircuit(e))
        }
        setAllLogTypeBaselines(e) {
            for (let t of this.logTransports) t.setLogTypeBaseline(e)
        }
        setTagId(e) {
            var t, n;
            for (let i of this.traceTransports)(t = i.setTagId) === null || t === void 0 || t.call(i, e);
            for (let i of this.logTransports)(n = i.setTagId) === null || n === void 0 || n.call(i, e)
        }
        setResourceAttributes(e) {
            var t, n;
            for (let i of this.traceTransports)(t = i.setResourceAttributes) === null || t === void 0 || t.call(i, e);
            for (let i of this.logTransports)(n = i.setResourceAttributes) === null || n === void 0 || n.call(i, e)
        }
        enableTracing() {
            for (let e of this.traceTransports) e.enableTracing()
        }
        disableTracing() {
            for (let e of this.traceTransports) e.disableTracing()
        }
        flushLogs() {
            return he(this, void 0, void 0, function*() {
                let e = this.logTransports.map(t => he(this, void 0, void 0, function*() {
                    let n = t.getTransportId();
                    yield this.circuitBreakerRunner.run(n, () => this.offlineManager.flushTransportLogs(t))
                }));
                yield Promise.all(e)
            })
        }
        flushSpans() {
            return he(this, void 0, void 0, function*() {
                let e = this.traceTransports.map(t => he(this, void 0, void 0, function*() {
                    let n = t.getTransportId();
                    yield this.circuitBreakerRunner.run(n, () => !t.hasWriteBuffer() && typeof t.flush == "function" ? t.flush() : this.offlineManager.flushTransportSpans(t))
                }));
                yield Promise.all(e)
            })
        }
        processLog(e) {
            return he(this, void 0, void 0, function*() {
                let t = this.logTransports.filter(n => n.getLogTypeBaseline() <= e.type);
                for (let n of t)
                    if (n.hasWriteBuffer()) yield this.offlineManager.writeLog(e, n);
                    else {
                        let i = n.getTransportId();
                        (yield this.circuitBreakerRunner.run(i, () => n.write(e))) !== 0 && (yield this.offlineManager.writeLog(e, n))
                    }
            })
        }
        processSpan(e) {
            return he(this, void 0, void 0, function*() {
                let t = this.traceTransports.filter(n => n.isTracingEnabled());
                for (let n of t)
                    if (n.hasWriteBuffer()) yield this.offlineManager.writeSpan(e, n);
                    else {
                        let i = n.getTransportId();
                        (yield this.circuitBreakerRunner.run(i, () => n.write(e))) !== 0 && (yield this.offlineManager.writeSpan(e, n))
                    }
            })
        }
        setSchedulerTimerInterval(e) {
            this.taskScheduler.setTimerInterval(e)
        }
        setAggregateSpansStatus(e) {
            this.offlineManager.setAggregateSpansStatus(e)
        }
    };
o(oE, "TransportManager");
var $l = oE,
    Lw;
(function(r) {
    r[r.Internal = 0] = "Internal", r[r.External = 1] = "External", r[r.Client = 2] = "Client"
})(Lw || (Lw = {}));
var Pe = Lw,
    VW = typeof La == "object" && La && La.Object === Object && La,
    gN = VW,
    HW = gN,
    jW = typeof self == "object" && self && self.Object === Object && self,
    WW = HW || jW || Function("return this")(),
    Ii = WW,
    GW = Ii,
    zW = GW.Symbol,
    Kg = zW,
    PO = Kg,
    pN = Object.prototype,
    qW = pN.hasOwnProperty,
    KW = pN.toString,
    ml = PO ? PO.toStringTag : void 0;

function YW(r) {
    var e = qW.call(r, ml),
        t = r[ml];
    try {
        r[ml] = void 0;
        var n = !0
    } catch (s) {}
    var i = KW.call(r);
    return n && (e ? r[ml] = t : delete r[ml]), i
}
o(YW, "getRawTag$1");
var XW = YW,
    JW = Object.prototype,
    ZW = JW.toString;

function QW(r) {
    return ZW.call(r)
}
o(QW, "objectToString$1");
var e6 = QW,
    NO = Kg,
    t6 = XW,
    r6 = e6,
    n6 = "[object Null]",
    i6 = "[object Undefined]",
    DO = NO ? NO.toStringTag : void 0;

function s6(r) {
    return r == null ? r === void 0 ? i6 : n6 : DO && DO in Object(r) ? t6(r) : r6(r)
}
o(s6, "baseGetTag$5");
var Gl = s6;

function o6(r) {
    var e = typeof r;
    return r != null && (e == "object" || e == "function")
}
o(o6, "isObject$5");
var zl = o6,
    a6 = Gl,
    u6 = zl,
    c6 = "[object AsyncFunction]",
    l6 = "[object Function]",
    d6 = "[object GeneratorFunction]",
    f6 = "[object Proxy]";

function h6(r) {
    if (!u6(r)) return !1;
    var e = a6(r);
    return e == l6 || e == d6 || e == c6 || e == f6
}
o(h6, "isFunction$3");
var mN = h6,
    g6 = Ii,
    p6 = g6["__core-js_shared__"],
    m6 = p6,
    ew = m6,
    LO = (function() {
        var r = /[^.]+$/.exec(ew && ew.keys && ew.keys.IE_PROTO || "");
        return r ? "Symbol(src)_1." + r : ""
    })();

function v6(r) {
    return !!LO && LO in r
}
o(v6, "isMasked$1");
var y6 = v6,
    _6 = Function.prototype,
    w6 = _6.toString;

function T6(r) {
    if (r != null) {
        try {
            return w6.call(r)
        } catch (e) {}
        try {
            return r + ""
        } catch (e) {}
    }
    return ""
}
o(T6, "toSource$2");
var vN = T6,
    E6 = mN,
    b6 = y6,
    S6 = zl,
    A6 = vN,
    I6 = /[\\^$.*+?()[\]{}|]/g,
    C6 = /^\[object .+?Constructor\]$/,
    R6 = Function.prototype,
    O6 = Object.prototype,
    P6 = R6.toString,
    N6 = O6.hasOwnProperty,
    D6 = RegExp("^" + P6.call(N6).replace(I6, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

function L6(r) {
    if (!S6(r) || b6(r)) return !1;
    var e = E6(r) ? D6 : C6;
    return e.test(A6(r))
}
o(L6, "baseIsNative$1");
var x6 = L6;

function U6(r, e) {
    return r == null ? void 0 : r[e]
}
o(U6, "getValue$1");
var M6 = U6,
    k6 = x6,
    F6 = M6;

function $6(r, e) {
    var t = F6(r, e);
    return k6(t) ? t : void 0
}
o($6, "getNative$7");
var yo = $6,
    B6 = yo,
    V6 = (function() {
        try {
            var r = B6(Object, "defineProperty");
            return r({}, "", {}), r
        } catch (e) {}
    })(),
    H6 = V6,
    xO = H6;

function j6(r, e, t) {
    e == "__proto__" && xO ? xO(r, e, {
        configurable: !0,
        enumerable: !0,
        value: t,
        writable: !0
    }) : r[e] = t
}
o(j6, "baseAssignValue$2");
var yN = j6;

function W6(r) {
    return function(e, t, n) {
        for (var i = -1, s = Object(e), a = n(e), u = a.length; u--;) {
            var l = a[r ? u : ++i];
            if (t(s[l], l, s) === !1) break
        }
        return e
    }
}
o(W6, "createBaseFor$1");
var G6 = W6,
    z6 = G6,
    q6 = z6(),
    K6 = q6;

function Y6(r, e) {
    for (var t = -1, n = Array(r); ++t < r;) n[t] = e(t);
    return n
}
o(Y6, "baseTimes$1");
var X6 = Y6;

function J6(r) {
    return r != null && typeof r == "object"
}
o(J6, "isObjectLike$5");
var ql = J6,
    Z6 = Gl,
    Q6 = ql,
    eG = "[object Arguments]";

function tG(r) {
    return Q6(r) && Z6(r) == eG
}
o(tG, "baseIsArguments$1");
var rG = tG,
    UO = rG,
    nG = ql,
    _N = Object.prototype,
    iG = _N.hasOwnProperty,
    sG = _N.propertyIsEnumerable,
    oG = UO((function() {
        return arguments
    })()) ? UO : function(r) {
        return nG(r) && iG.call(r, "callee") && !sG.call(r, "callee")
    },
    wN = oG,
    aG = Array.isArray,
    _s = aG,
    Tg = {
        exports: {}
    };

function uG() {
    return !1
}
o(uG, "stubFalse");
var cG = uG;
Tg.exports;
(function(r, e) {
    var t = Ii,
        n = cG,
        i = e && !e.nodeType && e,
        s = i && !0 && r && !r.nodeType && r,
        a = s && s.exports === i,
        u = a ? t.Buffer : void 0,
        l = u ? u.isBuffer : void 0,
        c = l || n;
    r.exports = c
})(Tg, Tg.exports);
var TN = Tg.exports,
    lG = 9007199254740991,
    dG = /^(?:0|[1-9]\d*)$/;

function fG(r, e) {
    var t = typeof r;
    return e = e == null ? lG : e, !!e && (t == "number" || t != "symbol" && dG.test(r)) && r > -1 && r % 1 == 0 && r < e
}
o(fG, "isIndex$3");
var ST = fG,
    hG = 9007199254740991;

function gG(r) {
    return typeof r == "number" && r > -1 && r % 1 == 0 && r <= hG
}
o(gG, "isLength$3");
var AT = gG,
    pG = Gl,
    mG = AT,
    vG = ql,
    yG = "[object Arguments]",
    _G = "[object Array]",
    wG = "[object Boolean]",
    TG = "[object Date]",
    EG = "[object Error]",
    bG = "[object Function]",
    SG = "[object Map]",
    AG = "[object Number]",
    IG = "[object Object]",
    CG = "[object RegExp]",
    RG = "[object Set]",
    OG = "[object String]",
    PG = "[object WeakMap]",
    NG = "[object ArrayBuffer]",
    DG = "[object DataView]",
    LG = "[object Float32Array]",
    xG = "[object Float64Array]",
    UG = "[object Int8Array]",
    MG = "[object Int16Array]",
    kG = "[object Int32Array]",
    FG = "[object Uint8Array]",
    $G = "[object Uint8ClampedArray]",
    BG = "[object Uint16Array]",
    VG = "[object Uint32Array]",
    It = {};
It[LG] = It[xG] = It[UG] = It[MG] = It[kG] = It[FG] = It[$G] = It[BG] = It[VG] = !0;
It[yG] = It[_G] = It[NG] = It[wG] = It[DG] = It[TG] = It[EG] = It[bG] = It[SG] = It[AG] = It[IG] = It[CG] = It[RG] = It[OG] = It[PG] = !1;

function HG(r) {
    return vG(r) && mG(r.length) && !!It[pG(r)]
}
o(HG, "baseIsTypedArray$1");
var jG = HG;

function WG(r) {
    return function(e) {
        return r(e)
    }
}
o(WG, "baseUnary$1");
var GG = WG,
    Eg = {
        exports: {}
    };
Eg.exports;
(function(r, e) {
    var t = gN,
        n = e && !e.nodeType && e,
        i = n && !0 && r && !r.nodeType && r,
        s = i && i.exports === n,
        a = s && t.process,
        u = (function() {
            try {
                var l = i && i.require && i.require("util").types;
                return l || a && a.binding && a.binding("util")
            } catch (c) {}
        })();
    r.exports = u
})(Eg, Eg.exports);
var zG = Eg.exports,
    qG = jG,
    KG = GG,
    MO = zG,
    kO = MO && MO.isTypedArray,
    YG = kO ? KG(kO) : qG,
    EN = YG,
    XG = X6,
    JG = wN,
    ZG = _s,
    QG = TN,
    e8 = ST,
    t8 = EN,
    r8 = Object.prototype,
    n8 = r8.hasOwnProperty;

function i8(r, e) {
    var t = ZG(r),
        n = !t && JG(r),
        i = !t && !n && QG(r),
        s = !t && !n && !i && t8(r),
        a = t || n || i || s,
        u = a ? XG(r.length, String) : [],
        l = u.length;
    for (var c in r)(e || n8.call(r, c)) && !(a && (c == "length" || i && (c == "offset" || c == "parent") || s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || e8(c, l))) && u.push(c);
    return u
}
o(i8, "arrayLikeKeys$2");
var bN = i8,
    s8 = Object.prototype;

function o8(r) {
    var e = r && r.constructor,
        t = typeof e == "function" && e.prototype || s8;
    return r === t
}
o(o8, "isPrototype$2");
var SN = o8;

function a8(r, e) {
    return function(t) {
        return r(e(t))
    }
}
o(a8, "overArg$2");
var AN = a8,
    u8 = AN,
    c8 = u8(Object.keys, Object),
    l8 = c8,
    d8 = SN,
    f8 = l8,
    h8 = Object.prototype,
    g8 = h8.hasOwnProperty;

function p8(r) {
    if (!d8(r)) return f8(r);
    var e = [];
    for (var t in Object(r)) g8.call(r, t) && t != "constructor" && e.push(t);
    return e
}
o(p8, "baseKeys$1");
var m8 = p8,
    v8 = mN,
    y8 = AT;

function _8(r) {
    return r != null && y8(r.length) && !v8(r)
}
o(_8, "isArrayLike$2");
var IN = _8,
    w8 = bN,
    T8 = m8,
    E8 = IN;

function b8(r) {
    return E8(r) ? w8(r) : T8(r)
}
o(b8, "keys$3");
var IT = b8,
    S8 = K6,
    A8 = IT;

function I8(r, e) {
    return r && S8(r, e, A8)
}
o(I8, "baseForOwn$1");
var C8 = I8;

function R8() {
    this.__data__ = [], this.size = 0
}
o(R8, "listCacheClear$1");
var O8 = R8;

function P8(r, e) {
    return r === e || r !== r && e !== e
}
o(P8, "eq$3");
var CT = P8,
    N8 = CT;

function D8(r, e) {
    for (var t = r.length; t--;)
        if (N8(r[t][0], e)) return t;
    return -1
}
o(D8, "assocIndexOf$4");
var Yg = D8,
    L8 = Yg,
    x8 = Array.prototype,
    U8 = x8.splice;

function M8(r) {
    var e = this.__data__,
        t = L8(e, r);
    if (t < 0) return !1;
    var n = e.length - 1;
    return t == n ? e.pop() : U8.call(e, t, 1), --this.size, !0
}
o(M8, "listCacheDelete$1");
var k8 = M8,
    F8 = Yg;

function $8(r) {
    var e = this.__data__,
        t = F8(e, r);
    return t < 0 ? void 0 : e[t][1]
}
o($8, "listCacheGet$1");
var B8 = $8,
    V8 = Yg;

function H8(r) {
    return V8(this.__data__, r) > -1
}
o(H8, "listCacheHas$1");
var j8 = H8,
    W8 = Yg;

function G8(r, e) {
    var t = this.__data__,
        n = W8(t, r);
    return n < 0 ? (++this.size, t.push([r, e])) : t[n][1] = e, this
}
o(G8, "listCacheSet$1");
var z8 = G8,
    q8 = O8,
    K8 = k8,
    Y8 = B8,
    X8 = j8,
    J8 = z8;

function Ha(r) {
    var e = -1,
        t = r == null ? 0 : r.length;
    for (this.clear(); ++e < t;) {
        var n = r[e];
        this.set(n[0], n[1])
    }
}
o(Ha, "ListCache$4");
Ha.prototype.clear = q8;
Ha.prototype.delete = K8;
Ha.prototype.get = Y8;
Ha.prototype.has = X8;
Ha.prototype.set = J8;
var Xg = Ha,
    Z8 = Xg;

function Q8() {
    this.__data__ = new Z8, this.size = 0
}
o(Q8, "stackClear$1");
var ez = Q8;

function tz(r) {
    var e = this.__data__,
        t = e.delete(r);
    return this.size = e.size, t
}
o(tz, "stackDelete$1");
var rz = tz;

function nz(r) {
    return this.__data__.get(r)
}
o(nz, "stackGet$1");
var iz = nz;

function sz(r) {
    return this.__data__.has(r)
}
o(sz, "stackHas$1");
var oz = sz,
    az = yo,
    uz = Ii,
    cz = az(uz, "Map"),
    RT = cz,
    lz = yo,
    dz = lz(Object, "create"),
    Jg = dz,
    FO = Jg;

function fz() {
    this.__data__ = FO ? FO(null) : {}, this.size = 0
}
o(fz, "hashClear$1");
var hz = fz;

function gz(r) {
    var e = this.has(r) && delete this.__data__[r];
    return this.size -= e ? 1 : 0, e
}
o(gz, "hashDelete$1");
var pz = gz,
    mz = Jg,
    vz = "__lodash_hash_undefined__",
    yz = Object.prototype,
    _z = yz.hasOwnProperty;

function wz(r) {
    var e = this.__data__;
    if (mz) {
        var t = e[r];
        return t === vz ? void 0 : t
    }
    return _z.call(e, r) ? e[r] : void 0
}
o(wz, "hashGet$1");
var Tz = wz,
    Ez = Jg,
    bz = Object.prototype,
    Sz = bz.hasOwnProperty;

function Az(r) {
    var e = this.__data__;
    return Ez ? e[r] !== void 0 : Sz.call(e, r)
}
o(Az, "hashHas$1");
var Iz = Az,
    Cz = Jg,
    Rz = "__lodash_hash_undefined__";

function Oz(r, e) {
    var t = this.__data__;
    return this.size += this.has(r) ? 0 : 1, t[r] = Cz && e === void 0 ? Rz : e, this
}
o(Oz, "hashSet$1");
var Pz = Oz,
    Nz = hz,
    Dz = pz,
    Lz = Tz,
    xz = Iz,
    Uz = Pz;

function ja(r) {
    var e = -1,
        t = r == null ? 0 : r.length;
    for (this.clear(); ++e < t;) {
        var n = r[e];
        this.set(n[0], n[1])
    }
}
o(ja, "Hash$1");
ja.prototype.clear = Nz;
ja.prototype.delete = Dz;
ja.prototype.get = Lz;
ja.prototype.has = xz;
ja.prototype.set = Uz;
var Mz = ja,
    $O = Mz,
    kz = Xg,
    Fz = RT;

function $z() {
    this.size = 0, this.__data__ = {
        hash: new $O,
        map: new(Fz || kz),
        string: new $O
    }
}
o($z, "mapCacheClear$1");
var Bz = $z;

function Vz(r) {
    var e = typeof r;
    return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? r !== "__proto__" : r === null
}
o(Vz, "isKeyable$1");
var Hz = Vz,
    jz = Hz;

function Wz(r, e) {
    var t = r.__data__;
    return jz(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map
}
o(Wz, "getMapData$4");
var Zg = Wz,
    Gz = Zg;

function zz(r) {
    var e = Gz(this, r).delete(r);
    return this.size -= e ? 1 : 0, e
}
o(zz, "mapCacheDelete$1");
var qz = zz,
    Kz = Zg;

function Yz(r) {
    return Kz(this, r).get(r)
}
o(Yz, "mapCacheGet$1");
var Xz = Yz,
    Jz = Zg;

function Zz(r) {
    return Jz(this, r).has(r)
}
o(Zz, "mapCacheHas$1");
var Qz = Zz,
    e5 = Zg;

function t5(r, e) {
    var t = e5(this, r),
        n = t.size;
    return t.set(r, e), this.size += t.size == n ? 0 : 1, this
}
o(t5, "mapCacheSet$1");
var r5 = t5,
    n5 = Bz,
    i5 = qz,
    s5 = Xz,
    o5 = Qz,
    a5 = r5;

function Wa(r) {
    var e = -1,
        t = r == null ? 0 : r.length;
    for (this.clear(); ++e < t;) {
        var n = r[e];
        this.set(n[0], n[1])
    }
}
o(Wa, "MapCache$3");
Wa.prototype.clear = n5;
Wa.prototype.delete = i5;
Wa.prototype.get = s5;
Wa.prototype.has = o5;
Wa.prototype.set = a5;
var OT = Wa,
    u5 = Xg,
    c5 = RT,
    l5 = OT,
    d5 = 200;

function f5(r, e) {
    var t = this.__data__;
    if (t instanceof u5) {
        var n = t.__data__;
        if (!c5 || n.length < d5 - 1) return n.push([r, e]), this.size = ++t.size, this;
        t = this.__data__ = new l5(n)
    }
    return t.set(r, e), this.size = t.size, this
}
o(f5, "stackSet$1");
var h5 = f5,
    g5 = Xg,
    p5 = ez,
    m5 = rz,
    v5 = iz,
    y5 = oz,
    _5 = h5;

function Ga(r) {
    var e = this.__data__ = new g5(r);
    this.size = e.size
}
o(Ga, "Stack$2");
Ga.prototype.clear = p5;
Ga.prototype.delete = m5;
Ga.prototype.get = v5;
Ga.prototype.has = y5;
Ga.prototype.set = _5;
var CN = Ga,
    w5 = "__lodash_hash_undefined__";

function T5(r) {
    return this.__data__.set(r, w5), this
}
o(T5, "setCacheAdd$1");
var E5 = T5;

function b5(r) {
    return this.__data__.has(r)
}
o(b5, "setCacheHas$1");
var S5 = b5,
    A5 = OT,
    I5 = E5,
    C5 = S5;

function bg(r) {
    var e = -1,
        t = r == null ? 0 : r.length;
    for (this.__data__ = new A5; ++e < t;) this.add(r[e])
}
o(bg, "SetCache$1");
bg.prototype.add = bg.prototype.push = I5;
bg.prototype.has = C5;
var R5 = bg;

function O5(r, e) {
    for (var t = -1, n = r == null ? 0 : r.length; ++t < n;)
        if (e(r[t], t, r)) return !0;
    return !1
}
o(O5, "arraySome$1");
var P5 = O5;

function N5(r, e) {
    return r.has(e)
}
o(N5, "cacheHas$1");
var D5 = N5,
    L5 = R5,
    x5 = P5,
    U5 = D5,
    M5 = 1,
    k5 = 2;

function F5(r, e, t, n, i, s) {
    var a = t & M5,
        u = r.length,
        l = e.length;
    if (u != l && !(a && l > u)) return !1;
    var c = s.get(r),
        d = s.get(e);
    if (c && d) return c == e && d == r;
    var f = -1,
        h = !0,
        g = t & k5 ? new L5 : void 0;
    for (s.set(r, e), s.set(e, r); ++f < u;) {
        var p = r[f],
            m = e[f];
        if (n) var w = a ? n(m, p, f, e, r, s) : n(p, m, f, r, e, s);
        if (w !== void 0) {
            if (w) continue;
            h = !1;
            break
        }
        if (g) {
            if (!x5(e, function(T, E) {
                    if (!U5(g, E) && (p === T || i(p, T, t, n, s))) return g.push(E)
                })) {
                h = !1;
                break
            }
        } else if (!(p === m || i(p, m, t, n, s))) {
            h = !1;
            break
        }
    }
    return s.delete(r), s.delete(e), h
}
o(F5, "equalArrays$2");
var RN = F5,
    $5 = Ii,
    B5 = $5.Uint8Array,
    V5 = B5;

function H5(r) {
    var e = -1,
        t = Array(r.size);
    return r.forEach(function(n, i) {
        t[++e] = [i, n]
    }), t
}
o(H5, "mapToArray$1");
var j5 = H5;

function W5(r) {
    var e = -1,
        t = Array(r.size);
    return r.forEach(function(n) {
        t[++e] = n
    }), t
}
o(W5, "setToArray$1");
var G5 = W5,
    BO = Kg,
    VO = V5,
    z5 = CT,
    q5 = RN,
    K5 = j5,
    Y5 = G5,
    X5 = 1,
    J5 = 2,
    Z5 = "[object Boolean]",
    Q5 = "[object Date]",
    eq = "[object Error]",
    tq = "[object Map]",
    rq = "[object Number]",
    nq = "[object RegExp]",
    iq = "[object Set]",
    sq = "[object String]",
    oq = "[object Symbol]",
    aq = "[object ArrayBuffer]",
    uq = "[object DataView]",
    HO = BO ? BO.prototype : void 0,
    tw = HO ? HO.valueOf : void 0;

function cq(r, e, t, n, i, s, a) {
    switch (t) {
        case uq:
            if (r.byteLength != e.byteLength || r.byteOffset != e.byteOffset) return !1;
            r = r.buffer, e = e.buffer;
        case aq:
            return !(r.byteLength != e.byteLength || !s(new VO(r), new VO(e)));
        case Z5:
        case Q5:
        case rq:
            return z5(+r, +e);
        case eq:
            return r.name == e.name && r.message == e.message;
        case nq:
        case sq:
            return r == e + "";
        case tq:
            var u = K5;
        case iq:
            var l = n & X5;
            if (u || (u = Y5), r.size != e.size && !l) return !1;
            var c = a.get(r);
            if (c) return c == e;
            n |= J5, a.set(r, e);
            var d = q5(u(r), u(e), n, i, s, a);
            return a.delete(r), d;
        case oq:
            if (tw) return tw.call(r) == tw.call(e)
    }
    return !1
}
o(cq, "equalByTag$1");
var lq = cq;

function dq(r, e) {
    for (var t = -1, n = e.length, i = r.length; ++t < n;) r[i + t] = e[t];
    return r
}
o(dq, "arrayPush$2");
var ON = dq,
    fq = ON,
    hq = _s;

function gq(r, e, t) {
    var n = e(r);
    return hq(r) ? n : fq(n, t(r))
}
o(gq, "baseGetAllKeys$2");
var PN = gq;

function pq(r, e) {
    for (var t = -1, n = r == null ? 0 : r.length, i = 0, s = []; ++t < n;) {
        var a = r[t];
        e(a, t, r) && (s[i++] = a)
    }
    return s
}
o(pq, "arrayFilter$1");
var mq = pq;

function vq() {
    return []
}
o(vq, "stubArray$2");
var NN = vq,
    yq = mq,
    _q = NN,
    wq = Object.prototype,
    Tq = wq.propertyIsEnumerable,
    jO = Object.getOwnPropertySymbols,
    Eq = jO ? function(r) {
        return r == null ? [] : (r = Object(r), yq(jO(r), function(e) {
            return Tq.call(r, e)
        }))
    } : _q,
    DN = Eq,
    bq = PN,
    Sq = DN,
    Aq = IT;

function Iq(r) {
    return bq(r, Aq, Sq)
}
o(Iq, "getAllKeys$1");
var Cq = Iq,
    WO = Cq,
    Rq = 1,
    Oq = Object.prototype,
    Pq = Oq.hasOwnProperty;

function Nq(r, e, t, n, i, s) {
    var a = t & Rq,
        u = WO(r),
        l = u.length,
        c = WO(e),
        d = c.length;
    if (l != d && !a) return !1;
    for (var f = l; f--;) {
        var h = u[f];
        if (!(a ? h in e : Pq.call(e, h))) return !1
    }
    var g = s.get(r),
        p = s.get(e);
    if (g && p) return g == e && p == r;
    var m = !0;
    s.set(r, e), s.set(e, r);
    for (var w = a; ++f < l;) {
        h = u[f];
        var T = r[h],
            E = e[h];
        if (n) var b = a ? n(E, T, h, e, r, s) : n(T, E, h, r, e, s);
        if (!(b === void 0 ? T === E || i(T, E, t, n, s) : b)) {
            m = !1;
            break
        }
        w || (w = h == "constructor")
    }
    if (m && !w) {
        var R = r.constructor,
            L = e.constructor;
        R != L && "constructor" in r && "constructor" in e && !(typeof R == "function" && R instanceof R && typeof L == "function" && L instanceof L) && (m = !1)
    }
    return s.delete(r), s.delete(e), m
}
o(Nq, "equalObjects$1");
var Dq = Nq,
    Lq = yo,
    xq = Ii,
    Uq = Lq(xq, "DataView"),
    Mq = Uq,
    kq = yo,
    Fq = Ii,
    $q = kq(Fq, "Promise"),
    Bq = $q,
    Vq = yo,
    Hq = Ii,
    jq = Vq(Hq, "Set"),
    Wq = jq,
    Gq = yo,
    zq = Ii,
    qq = Gq(zq, "WeakMap"),
    Kq = qq,
    xw = Mq,
    Uw = RT,
    Mw = Bq,
    kw = Wq,
    Fw = Kq,
    LN = Gl,
    za = vN,
    GO = "[object Map]",
    Yq = "[object Object]",
    zO = "[object Promise]",
    qO = "[object Set]",
    KO = "[object WeakMap]",
    YO = "[object DataView]",
    Xq = za(xw),
    Jq = za(Uw),
    Zq = za(Mw),
    Qq = za(kw),
    e9 = za(Fw),
    so = LN;
(xw && so(new xw(new ArrayBuffer(1))) != YO || Uw && so(new Uw) != GO || Mw && so(Mw.resolve()) != zO || kw && so(new kw) != qO || Fw && so(new Fw) != KO) && (so = o(function(r) {
    var e = LN(r),
        t = e == Yq ? r.constructor : void 0,
        n = t ? za(t) : "";
    if (n) switch (n) {
        case Xq:
            return YO;
        case Jq:
            return GO;
        case Zq:
            return zO;
        case Qq:
            return qO;
        case e9:
            return KO
    }
    return e
}, "getTag$1"));
var t9 = so,
    rw = CN,
    r9 = RN,
    n9 = lq,
    i9 = Dq,
    XO = t9,
    JO = _s,
    ZO = TN,
    s9 = EN,
    o9 = 1,
    QO = "[object Arguments]",
    eP = "[object Array]",
    Ph = "[object Object]",
    a9 = Object.prototype,
    tP = a9.hasOwnProperty;

function u9(r, e, t, n, i, s) {
    var a = JO(r),
        u = JO(e),
        l = a ? eP : XO(r),
        c = u ? eP : XO(e);
    l = l == QO ? Ph : l, c = c == QO ? Ph : c;
    var d = l == Ph,
        f = c == Ph,
        h = l == c;
    if (h && ZO(r)) {
        if (!ZO(e)) return !1;
        a = !0, d = !1
    }
    if (h && !d) return s || (s = new rw), a || s9(r) ? r9(r, e, t, n, i, s) : n9(r, e, l, t, n, i, s);
    if (!(t & o9)) {
        var g = d && tP.call(r, "__wrapped__"),
            p = f && tP.call(e, "__wrapped__");
        if (g || p) {
            var m = g ? r.value() : r,
                w = p ? e.value() : e;
            return s || (s = new rw), i(m, w, t, n, s)
        }
    }
    return h ? (s || (s = new rw), i9(r, e, t, n, i, s)) : !1
}
o(u9, "baseIsEqualDeep$1");
var c9 = u9,
    l9 = c9,
    rP = ql;

function xN(r, e, t, n, i) {
    return r === e ? !0 : r == null || e == null || !rP(r) && !rP(e) ? r !== r && e !== e : l9(r, e, t, n, xN, i)
}
o(xN, "baseIsEqual$2");
var UN = xN,
    d9 = CN,
    f9 = UN,
    h9 = 1,
    g9 = 2;

function p9(r, e, t, n) {
    var i = t.length,
        s = i,
        a = !n;
    if (r == null) return !s;
    for (r = Object(r); i--;) {
        var u = t[i];
        if (a && u[2] ? u[1] !== r[u[0]] : !(u[0] in r)) return !1
    }
    for (; ++i < s;) {
        u = t[i];
        var l = u[0],
            c = r[l],
            d = u[1];
        if (a && u[2]) {
            if (c === void 0 && !(l in r)) return !1
        } else {
            var f = new d9;
            if (n) var h = n(c, d, l, r, e, f);
            if (!(h === void 0 ? f9(d, c, h9 | g9, n, f) : h)) return !1
        }
    }
    return !0
}
o(p9, "baseIsMatch$1");
var m9 = p9,
    v9 = zl;

function y9(r) {
    return r === r && !v9(r)
}
o(y9, "isStrictComparable$2");
var MN = y9,
    _9 = MN,
    w9 = IT;

function T9(r) {
    for (var e = w9(r), t = e.length; t--;) {
        var n = e[t],
            i = r[n];
        e[t] = [n, i, _9(i)]
    }
    return e
}
o(T9, "getMatchData$1");
var E9 = T9;

function b9(r, e) {
    return function(t) {
        return t == null ? !1 : t[r] === e && (e !== void 0 || r in Object(t))
    }
}
o(b9, "matchesStrictComparable$2");
var kN = b9,
    S9 = m9,
    A9 = E9,
    I9 = kN;

function C9(r) {
    var e = A9(r);
    return e.length == 1 && e[0][2] ? I9(e[0][0], e[0][1]) : function(t) {
        return t === r || S9(t, r, e)
    }
}
o(C9, "baseMatches$1");
var R9 = C9,
    O9 = Gl,
    P9 = ql,
    N9 = "[object Symbol]";

function D9(r) {
    return typeof r == "symbol" || P9(r) && O9(r) == N9
}
o(D9, "isSymbol$3");
var PT = D9,
    L9 = _s,
    x9 = PT,
    U9 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    M9 = /^\w*$/;

function k9(r, e) {
    if (L9(r)) return !1;
    var t = typeof r;
    return t == "number" || t == "symbol" || t == "boolean" || r == null || x9(r) ? !0 : M9.test(r) || !U9.test(r) || e != null && r in Object(e)
}
o(k9, "isKey$3");
var NT = k9,
    FN = OT,
    F9 = "Expected a function";

function DT(r, e) {
    if (typeof r != "function" || e != null && typeof e != "function") throw new TypeError(F9);
    var t = o(function() {
        var n = arguments,
            i = e ? e.apply(this, n) : n[0],
            s = t.cache;
        if (s.has(i)) return s.get(i);
        var a = r.apply(this, n);
        return t.cache = s.set(i, a) || s, a
    }, "memoized");
    return t.cache = new(DT.Cache || FN), t
}
o(DT, "memoize$1");
DT.Cache = FN;
var $9 = DT,
    B9 = $9,
    V9 = 500;

function H9(r) {
    var e = B9(r, function(n) {
            return t.size === V9 && t.clear(), n
        }),
        t = e.cache;
    return e
}
o(H9, "memoizeCapped$1");
var j9 = H9,
    W9 = j9,
    G9 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
    z9 = /\\(\\)?/g,
    q9 = W9(function(r) {
        var e = [];
        return r.charCodeAt(0) === 46 && e.push(""), r.replace(G9, function(t, n, i, s) {
            e.push(i ? s.replace(z9, "$1") : n || t)
        }), e
    }),
    K9 = q9;

function Y9(r, e) {
    for (var t = -1, n = r == null ? 0 : r.length, i = Array(n); ++t < n;) i[t] = e(r[t], t, r);
    return i
}
o(Y9, "arrayMap$2");
var $N = Y9,
    nP = Kg,
    X9 = $N,
    J9 = _s,
    Z9 = PT,
    iP = nP ? nP.prototype : void 0,
    sP = iP ? iP.toString : void 0;

function BN(r) {
    if (typeof r == "string") return r;
    if (J9(r)) return X9(r, BN) + "";
    if (Z9(r)) return sP ? sP.call(r) : "";
    var e = r + "";
    return e == "0" && 1 / r == -1 / 0 ? "-0" : e
}
o(BN, "baseToString$1");
var Q9 = BN,
    eK = Q9;

function tK(r) {
    return r == null ? "" : eK(r)
}
o(tK, "toString$1");
var rK = tK,
    nK = _s,
    iK = NT,
    sK = K9,
    oK = rK;

function aK(r, e) {
    return nK(r) ? r : iK(r, e) ? [r] : sK(oK(r))
}
o(aK, "castPath$4");
var Qg = aK,
    uK = PT;

function cK(r) {
    if (typeof r == "string" || uK(r)) return r;
    var e = r + "";
    return e == "0" && 1 / r == -1 / 0 ? "-0" : e
}
o(cK, "toKey$5");
var Kl = cK,
    lK = Qg,
    dK = Kl;

function fK(r, e) {
    e = lK(e, r);
    for (var t = 0, n = e.length; r != null && t < n;) r = r[dK(e[t++])];
    return t && t == n ? r : void 0
}
o(fK, "baseGet$3");
var LT = fK,
    hK = LT;

function gK(r, e, t) {
    var n = r == null ? void 0 : hK(r, e);
    return n === void 0 ? t : n
}
o(gK, "get$1");
var pK = gK;

function mK(r, e) {
    return r != null && e in Object(r)
}
o(mK, "baseHasIn$1");
var vK = mK,
    yK = Qg,
    _K = wN,
    wK = _s,
    TK = ST,
    EK = AT,
    bK = Kl;

function SK(r, e, t) {
    e = yK(e, r);
    for (var n = -1, i = e.length, s = !1; ++n < i;) {
        var a = bK(e[n]);
        if (!(s = r != null && t(r, a))) break;
        r = r[a]
    }
    return s || ++n != i ? s : (i = r == null ? 0 : r.length, !!i && EK(i) && TK(a, i) && (wK(r) || _K(r)))
}
o(SK, "hasPath$1");
var AK = SK,
    IK = vK,
    CK = AK;

function RK(r, e) {
    return r != null && CK(r, e, IK)
}
o(RK, "hasIn$1");
var OK = RK,
    PK = UN,
    NK = pK,
    DK = OK,
    LK = NT,
    xK = MN,
    UK = kN,
    MK = Kl,
    kK = 1,
    FK = 2;

function $K(r, e) {
    return LK(r) && xK(e) ? UK(MK(r), e) : function(t) {
        var n = NK(t, r);
        return n === void 0 && n === e ? DK(t, r) : PK(e, n, kK | FK)
    }
}
o($K, "baseMatchesProperty$1");
var BK = $K;

function VK(r) {
    return r
}
o(VK, "identity$1");
var HK = VK;

function jK(r) {
    return function(e) {
        return e == null ? void 0 : e[r]
    }
}
o(jK, "baseProperty$1");
var WK = jK,
    GK = LT;

function zK(r) {
    return function(e) {
        return GK(e, r)
    }
}
o(zK, "basePropertyDeep$1");
var qK = zK,
    KK = WK,
    YK = qK,
    XK = NT,
    JK = Kl;

function ZK(r) {
    return XK(r) ? KK(JK(r)) : YK(r)
}
o(ZK, "property$1");
var QK = ZK,
    e7 = R9,
    t7 = BK,
    r7 = HK,
    n7 = _s,
    i7 = QK;

function s7(r) {
    return typeof r == "function" ? r : r == null ? r7 : typeof r == "object" ? n7(r) ? t7(r[0], r[1]) : e7(r) : i7(r)
}
o(s7, "baseIteratee$2");
var VN = s7,
    o7 = yN,
    a7 = C8,
    u7 = VN;

function c7(r, e) {
    var t = {};
    return e = u7(e), a7(r, function(n, i, s) {
        o7(t, i, e(n, i, s))
    }), t
}
o(c7, "mapValues");
var l7 = c7,
    d7 = ET(l7),
    f7 = yN,
    h7 = CT,
    g7 = Object.prototype,
    p7 = g7.hasOwnProperty;

function m7(r, e, t) {
    var n = r[e];
    (!(p7.call(r, e) && h7(n, t)) || t === void 0 && !(e in r)) && f7(r, e, t)
}
o(m7, "assignValue$1");
var v7 = m7,
    y7 = v7,
    _7 = Qg,
    w7 = ST,
    oP = zl,
    T7 = Kl;

function E7(r, e, t, n) {
    if (!oP(r)) return r;
    e = _7(e, r);
    for (var i = -1, s = e.length, a = s - 1, u = r; u != null && ++i < s;) {
        var l = T7(e[i]),
            c = t;
        if (l === "__proto__" || l === "constructor" || l === "prototype") return r;
        if (i != a) {
            var d = u[l];
            c = n ? n(d, l, u) : void 0, c === void 0 && (c = oP(d) ? d : w7(e[i + 1]) ? [] : {})
        }
        y7(u, l, c), u = u[l]
    }
    return r
}
o(E7, "baseSet$1");
var b7 = E7,
    S7 = LT,
    A7 = b7,
    I7 = Qg;

function C7(r, e, t) {
    for (var n = -1, i = e.length, s = {}; ++n < i;) {
        var a = e[n],
            u = S7(r, a);
        t(u, a) && A7(s, I7(a, r), u)
    }
    return s
}
o(C7, "basePickBy$1");
var R7 = C7,
    O7 = AN,
    P7 = O7(Object.getPrototypeOf, Object),
    N7 = P7,
    D7 = ON,
    L7 = N7,
    x7 = DN,
    U7 = NN,
    M7 = Object.getOwnPropertySymbols,
    k7 = M7 ? function(r) {
        for (var e = []; r;) D7(e, x7(r)), r = L7(r);
        return e
    } : U7,
    F7 = k7;

function $7(r) {
    var e = [];
    if (r != null)
        for (var t in Object(r)) e.push(t);
    return e
}
o($7, "nativeKeysIn$1");
var B7 = $7,
    V7 = zl,
    H7 = SN,
    j7 = B7,
    W7 = Object.prototype,
    G7 = W7.hasOwnProperty;

function z7(r) {
    if (!V7(r)) return j7(r);
    var e = H7(r),
        t = [];
    for (var n in r) n == "constructor" && (e || !G7.call(r, n)) || t.push(n);
    return t
}
o(z7, "baseKeysIn$1");
var q7 = z7,
    K7 = bN,
    Y7 = q7,
    X7 = IN;

function J7(r) {
    return X7(r) ? K7(r, !0) : Y7(r)
}
o(J7, "keysIn$1");
var Z7 = J7,
    Q7 = PN,
    eY = F7,
    tY = Z7;

function rY(r) {
    return Q7(r, tY, eY)
}
o(rY, "getAllKeysIn$1");
var nY = rY,
    iY = $N,
    sY = VN,
    oY = R7,
    aY = nY;

function uY(r, e) {
    if (r == null) return {};
    var t = iY(aY(r), function(n) {
        return [n]
    });
    return e = sY(e), oY(r, t, function(n, i) {
        return e(n, i[0])
    })
}
o(uY, "pickBy");
var cY = uY,
    lY = ET(cY),
    HN = "OS-CLRT-00000",
    Al = o(r => {
        let e = d7(r, n => n());
        return lY(e, n => n != null)
    }, "evaluateObjFuncValues"),
    ep = {
        [Pe.Internal]: 1,
        [Pe.External]: 2,
        [Pe.Client]: 3
    },
    jN = o(r => {
        var e, t, n;
        let i = {};
        return r.type === Je.Error && r.error && (i["exception.type"] = r.error.name, i["exception.message"] = WN(r.error.message), i["exception.stacktrace"] = (e = r.error.stack) !== null && e !== void 0 ? e : "", i["outsystems.error.code"] = (n = (t = r.errorCode) === null || t === void 0 ? void 0 : t.toString()) !== null && n !== void 0 ? n : HN.toString()), i
    }, "getExceptionAttributes"),
    dY = o(r => {
        let e = {},
            t = r.span;
        return t && (e.traceId = t.traceId, e.spanId = t.spanId), e
    }, "getTraceFields"),
    Sg = o(r => {
        let e = o(n => typeof n == "boolean" ? "boolValue" : typeof n == "number" ? n % 1 === 0 ? "intValue" : "doubleValue" : "stringValue", "mapTypeToValueName");
        return Object.entries(r).map(n => {
            let [i, s] = n;
            return {
                key: i,
                value: {
                    [e(s)]: s
                }
            }
        })
    }, "convertObjectToAttributesList"),
    xT = o(r => (r["http.url"] && (r["http.url"] = WN(r["http.url"])), r), "sanitizeUrlAttribute"),
    WN = o(r => r.replace(/((outsystems|https|http):\/\/[^ ]*?)\?[^ ]*/g, "$1"), "removeQueryParametersUrl"),
    Xr, oo, ao, jg = class jg {
        constructor(e) {
            let {
                baseAttributes: t = {},
                transportManager: n,
                getTimestamp: i
            } = e;
            Xr.set(this, void 0), oo.set(this, void 0), ao.set(this, void 0), ye(this, Xr, n, "f"), ye(this, oo, i, "f"), ye(this, ao, t, "f")
        }
        static build(e) {
            return he(this, arguments, void 0, function(t) {
                let {
                    transports: n = [],
                    baseAttributes: i,
                    databaseNameSuffix: s,
                    transportManager: a = new $l({
                        databaseNameSuffix: s,
                        logTransports: n
                    }),
                    getTimestamp: u = o(() => new Rn, "getTimestamp")
                } = t;
                return (function*() {
                    return new jg({
                        baseAttributes: i,
                        transportManager: a,
                        getTimestamp: u
                    })
                })()
            })
        }
        addTransport(e) {
            O(this, Xr, "f").addLogTransport(e)
        }
        removeTransport(e) {
            O(this, Xr, "f").removeLogTransport(e)
        }
        setLogTypeBaseline() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Je.Error;
            O(this, Xr, "f").setAllLogTypeBaselines(e)
        }
        flush() {
            return he(this, void 0, void 0, function*() {
                O(this, Xr, "f").flushLogs()
            })
        }
        setSchedulerTimerInterval(e) {
            O(this, Xr, "f").setSchedulerTimerInterval(e)
        }
        error(e) {
            let {
                category: t,
                message: n,
                error: i,
                errorCode: s,
                visibility: a = Pe.Internal,
                span: u,
                attributes: l
            } = e, c = new xa({
                type: Je.Error,
                category: t,
                message: n,
                error: i,
                visibility: a,
                timestamp: O(this, oo, "f").call(this),
                errorCode: s,
                span: u,
                attributes: Object.assign(Object.assign({}, Al(O(this, ao, "f"))), l)
            });
            O(this, Xr, "f").processLog(c)
        }
        warning(e) {
            let {
                category: t,
                message: n,
                visibility: i = Pe.Internal,
                span: s,
                attributes: a
            } = e, u = new xa({
                type: Je.Warning,
                category: t,
                message: n,
                visibility: i,
                timestamp: O(this, oo, "f").call(this),
                span: s,
                attributes: Object.assign(Object.assign({}, Al(O(this, ao, "f"))), a)
            });
            O(this, Xr, "f").processLog(u)
        }
        info(e) {
            let {
                category: t,
                message: n,
                visibility: i = Pe.External,
                span: s,
                attributes: a
            } = e, u = new xa({
                type: Je.Info,
                category: t,
                message: n,
                visibility: i,
                timestamp: O(this, oo, "f").call(this),
                span: s,
                attributes: Object.assign(Object.assign({}, Al(O(this, ao, "f"))), a)
            });
            O(this, Xr, "f").processLog(u)
        }
        debug(e) {
            let {
                category: t,
                message: n,
                visibility: i = Pe.Internal,
                span: s,
                attributes: a
            } = e, u = new xa({
                type: Je.Debug,
                category: t,
                message: n,
                visibility: i,
                timestamp: O(this, oo, "f").call(this),
                span: s,
                attributes: Object.assign(Object.assign({}, Al(O(this, ao, "f"))), a)
            });
            O(this, Xr, "f").processLog(u)
        }
        log(e) {
            return he(this, void 0, void 0, function*() {
                yield O(this, Xr, "f").processLog(e)
            })
        }
    };
o(jg, "Logger");
var $w = jg;
Xr = new WeakMap, oo = new WeakMap, ao = new WeakMap;

function fY(r) {
    return r === void 0 && (r = {}), typeof r.addEventListener == "function" && typeof r.removeEventListener == "function"
}
o(fY, "isListenerObject");
var aP = "OT_ZONE_CONTEXT",
    hY = (function() {
        function r() {
            this._enabled = !1, this._zoneCounter = 0
        }
        return o(r, "ZoneContextManager"), r.prototype._activeContextFromZone = function(e) {
            return e && e.get(aP) || _i
        }, r.prototype._bindFunction = function(e, t) {
            var n = this,
                i = o(function() {
                    for (var s = this, a = [], u = 0; u < arguments.length; u++) a[u] = arguments[u];
                    return n.with(e, function() {
                        return t.apply(s, a)
                    })
                }, "contextWrapper");
            return Object.defineProperty(i, "length", {
                enumerable: !1,
                configurable: !0,
                writable: !1,
                value: t.length
            }), i
        }, r.prototype._bindListener = function(e, t) {
            var n = t;
            return n.__ot_listeners !== void 0 || (n.__ot_listeners = {}, typeof n.addEventListener == "function" && (n.addEventListener = this._patchAddEventListener(n, n.addEventListener, e)), typeof n.removeEventListener == "function" && (n.removeEventListener = this._patchRemoveEventListener(n, n.removeEventListener))), t
        }, r.prototype._createZoneName = function() {
            this._zoneCounter++;
            var e = Math.random();
            return this._zoneCounter + "-" + e
        }, r.prototype._createZone = function(e, t) {
            var n;
            return Zone.current.fork({
                name: e,
                properties: (n = {}, n[aP] = t, n)
            })
        }, r.prototype._getActiveZone = function() {
            return Zone.current
        }, r.prototype._patchAddEventListener = function(e, t, n) {
            var i = this;
            return function(s, a, u) {
                e.__ot_listeners === void 0 && (e.__ot_listeners = {});
                var l = e.__ot_listeners[s];
                l === void 0 && (l = new WeakMap, e.__ot_listeners[s] = l);
                var c = i.bind(n, a);
                return l.set(a, c), t.call(this, s, c, u)
            }
        }, r.prototype._patchRemoveEventListener = function(e, t) {
            return function(n, i) {
                if (e.__ot_listeners === void 0 || e.__ot_listeners[n] === void 0) return t.call(this, n, i);
                var s = e.__ot_listeners[n],
                    a = s.get(i);
                return s.delete(i), t.call(this, n, a || i)
            }
        }, r.prototype.active = function() {
            if (!this._enabled) return _i;
            var e = this._getActiveZone(),
                t = this._activeContextFromZone(e);
            return t || _i
        }, r.prototype.bind = function(e, t) {
            return e === void 0 && (e = this.active()), typeof t == "function" ? this._bindFunction(e, t) : (fY(t) && this._bindListener(e, t), t)
        }, r.prototype.disable = function() {
            return this._enabled = !1, this
        }, r.prototype.enable = function() {
            return this._enabled = !0, this
        }, r.prototype.with = function(e, t, n) {
            for (var i = [], s = 3; s < arguments.length; s++) i[s - 3] = arguments[s];
            var a = this._createZoneName(),
                u = this._createZone(a, e);
            return u.run(t, n, i)
        }, r
    })();
var Kn = globalThis;

function an(r) {
    return (Kn.__Zone_symbol_prefix || "__zone_symbol__") + r
}
o(an, "__symbol__");

function gY() {
    var r;
    let e = Kn.performance;

    function t(de) {
        e && e.mark && e.mark(de)
    }
    o(t, "mark");

    function n(de, N) {
        e && e.measure && e.measure(de, N)
    }
    o(n, "performanceMeasure"), t("Zone");
    let Oe = class Oe {
        static assertZonePatched() {
            if (Kn.Promise !== P.ZoneAwarePromise) throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)")
        }
        static get root() {
            let N = Oe.current;
            for (; N.parent;) N = N.parent;
            return N
        }
        static get current() {
            return oe.zone
        }
        static get currentTask() {
            return S
        }
        static __load_patch(N, x) {
            let U = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
            if (P.hasOwnProperty(N)) {
                let ve = Kn[an("forceDuplicateZoneCheck")] === !0;
                if (!U && ve) throw Error("Already loaded patch: " + N)
            } else if (!Kn["__Zone_disable_" + N]) {
                let ve = "Zone:" + N;
                t(ve), P[N] = x(Kn, Oe, Z), n(ve, ve)
            }
        }
        get parent() {
            return this._parent
        }
        get name() {
            return this._name
        }
        constructor(N, x) {
            this._parent = N, this._name = x ? x.name || "unnamed" : "<root>", this._properties = x && x.properties || {}, this._zoneDelegate = new a(this, this._parent && this._parent._zoneDelegate, x)
        }
        get(N) {
            let x = this.getZoneWith(N);
            if (x) return x._properties[N]
        }
        getZoneWith(N) {
            let x = this;
            for (; x;) {
                if (x._properties.hasOwnProperty(N)) return x;
                x = x._parent
            }
            return null
        }
        fork(N) {
            if (!N) throw new Error("ZoneSpec required!");
            return this._zoneDelegate.fork(this, N)
        }
        wrap(N, x) {
            if (typeof N != "function") throw new Error("Expecting function got: " + N);
            let U = this._zoneDelegate.intercept(this, N, x),
                ve = this;
            return function() {
                return ve.runGuarded(U, this, arguments, x)
            }
        }
        run(N, x, U, ve) {
            oe = {
                parent: oe,
                zone: this
            };
            try {
                return this._zoneDelegate.invoke(this, N, x, U, ve)
            } finally {
                oe = oe.parent
            }
        }
        runGuarded(N) {
            let x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
                U = arguments.length > 2 ? arguments[2] : void 0,
                ve = arguments.length > 3 ? arguments[3] : void 0;
            oe = {
                parent: oe,
                zone: this
            };
            try {
                try {
                    return this._zoneDelegate.invoke(this, N, x, U, ve)
                } catch (Te) {
                    if (this._zoneDelegate.handleError(this, Te)) throw Te
                }
            } finally {
                oe = oe.parent
            }
        }
        runTask(N, x, U) {
            if (N.zone != this) throw new Error("A task can only be run in the zone of creation! (Creation: " + (N.zone || T).name + "; Execution: " + this.name + ")");
            let ve = N,
                {
                    type: Te,
                    data: {
                        isPeriodic: Fe = !1,
                        isRefreshable: rt = !1
                    } = {}
                } = N;
            if (N.state === E && (Te === q || Te === Y)) return;
            let xe = N.state != L;
            xe && ve._transitionTo(L, R);
            let fe = S;
            S = ve, oe = {
                parent: oe,
                zone: this
            };
            try {
                Te == Y && N.data && !Fe && !rt && (N.cancelFn = void 0);
                try {
                    return this._zoneDelegate.invokeTask(this, ve, x, U)
                } catch ($) {
                    if (this._zoneDelegate.handleError(this, $)) throw $
                }
            } finally {
                let $ = N.state;
                if ($ !== E && $ !== z)
                    if (Te == q || Fe || rt && $ === b) xe && ve._transitionTo(R, L, b);
                    else {
                        let X = ve._zoneDelegates;
                        this._updateTaskCount(ve, -1), xe && ve._transitionTo(E, L, E), rt && (ve._zoneDelegates = X)
                    } oe = oe.parent, S = fe
            }
        }
        scheduleTask(N) {
            if (N.zone && N.zone !== this) {
                let U = this;
                for (; U;) {
                    if (U === N.zone) throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${N.zone.name}`);
                    U = U.parent
                }
            }
            N._transitionTo(b, E);
            let x = [];
            N._zoneDelegates = x, N._zone = this;
            try {
                N = this._zoneDelegate.scheduleTask(this, N)
            } catch (U) {
                throw N._transitionTo(z, b, E), this._zoneDelegate.handleError(this, U), U
            }
            return N._zoneDelegates === x && this._updateTaskCount(N, 1), N.state == b && N._transitionTo(R, b), N
        }
        scheduleMicroTask(N, x, U, ve) {
            return this.scheduleTask(new u(j, N, x, U, ve, void 0))
        }
        scheduleMacroTask(N, x, U, ve, Te) {
            return this.scheduleTask(new u(Y, N, x, U, ve, Te))
        }
        scheduleEventTask(N, x, U, ve, Te) {
            return this.scheduleTask(new u(q, N, x, U, ve, Te))
        }
        cancelTask(N) {
            if (N.zone != this) throw new Error("A task can only be cancelled in the zone of creation! (Creation: " + (N.zone || T).name + "; Execution: " + this.name + ")");
            if (!(N.state !== R && N.state !== L)) {
                N._transitionTo(V, R, L);
                try {
                    this._zoneDelegate.cancelTask(this, N)
                } catch (x) {
                    throw N._transitionTo(z, V), this._zoneDelegate.handleError(this, x), x
                }
                return this._updateTaskCount(N, -1), N._transitionTo(E, V), N.runCount = -1, N
            }
        }
        _updateTaskCount(N, x) {
            let U = N._zoneDelegates;
            x == -1 && (N._zoneDelegates = null);
            for (let ve = 0; ve < U.length; ve++) U[ve]._updateTaskCount(N.type, x)
        }
    };
    o(Oe, "ZoneImpl");
    let i = Oe;
    r = i, r.__symbol__ = an;
    let s = {
            name: "",
            onHasTask: o((de, N, x, U) => de.hasTask(x, U), "onHasTask"),
            onScheduleTask: o((de, N, x, U) => de.scheduleTask(x, U), "onScheduleTask"),
            onInvokeTask: o((de, N, x, U, ve, Te) => de.invokeTask(x, U, ve, Te), "onInvokeTask"),
            onCancelTask: o((de, N, x, U) => de.cancelTask(x, U), "onCancelTask")
        },
        Ye = class Ye {
            get zone() {
                return this._zone
            }
            constructor(N, x, U) {
                this._taskCounts = {
                    microTask: 0,
                    macroTask: 0,
                    eventTask: 0
                }, this._zone = N, this._parentDelegate = x, this._forkZS = U && (U && U.onFork ? U : x._forkZS), this._forkDlgt = U && (U.onFork ? x : x._forkDlgt), this._forkCurrZone = U && (U.onFork ? this._zone : x._forkCurrZone), this._interceptZS = U && (U.onIntercept ? U : x._interceptZS), this._interceptDlgt = U && (U.onIntercept ? x : x._interceptDlgt), this._interceptCurrZone = U && (U.onIntercept ? this._zone : x._interceptCurrZone), this._invokeZS = U && (U.onInvoke ? U : x._invokeZS), this._invokeDlgt = U && (U.onInvoke ? x : x._invokeDlgt), this._invokeCurrZone = U && (U.onInvoke ? this._zone : x._invokeCurrZone), this._handleErrorZS = U && (U.onHandleError ? U : x._handleErrorZS), this._handleErrorDlgt = U && (U.onHandleError ? x : x._handleErrorDlgt), this._handleErrorCurrZone = U && (U.onHandleError ? this._zone : x._handleErrorCurrZone), this._scheduleTaskZS = U && (U.onScheduleTask ? U : x._scheduleTaskZS), this._scheduleTaskDlgt = U && (U.onScheduleTask ? x : x._scheduleTaskDlgt), this._scheduleTaskCurrZone = U && (U.onScheduleTask ? this._zone : x._scheduleTaskCurrZone), this._invokeTaskZS = U && (U.onInvokeTask ? U : x._invokeTaskZS), this._invokeTaskDlgt = U && (U.onInvokeTask ? x : x._invokeTaskDlgt), this._invokeTaskCurrZone = U && (U.onInvokeTask ? this._zone : x._invokeTaskCurrZone), this._cancelTaskZS = U && (U.onCancelTask ? U : x._cancelTaskZS), this._cancelTaskDlgt = U && (U.onCancelTask ? x : x._cancelTaskDlgt), this._cancelTaskCurrZone = U && (U.onCancelTask ? this._zone : x._cancelTaskCurrZone), this._hasTaskZS = null, this._hasTaskDlgt = null, this._hasTaskDlgtOwner = null, this._hasTaskCurrZone = null;
                let ve = U && U.onHasTask,
                    Te = x && x._hasTaskZS;
                (ve || Te) && (this._hasTaskZS = ve ? U : s, this._hasTaskDlgt = x, this._hasTaskDlgtOwner = this, this._hasTaskCurrZone = this._zone, U.onScheduleTask || (this._scheduleTaskZS = s, this._scheduleTaskDlgt = x, this._scheduleTaskCurrZone = this._zone), U.onInvokeTask || (this._invokeTaskZS = s, this._invokeTaskDlgt = x, this._invokeTaskCurrZone = this._zone), U.onCancelTask || (this._cancelTaskZS = s, this._cancelTaskDlgt = x, this._cancelTaskCurrZone = this._zone))
            }
            fork(N, x) {
                return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, N, x) : new i(N, x)
            }
            intercept(N, x, U) {
                return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, N, x, U) : x
            }
            invoke(N, x, U, ve, Te) {
                return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, N, x, U, ve, Te) : x.apply(U, ve)
            }
            handleError(N, x) {
                return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, N, x) : !0
            }
            scheduleTask(N, x) {
                let U = x;
                if (this._scheduleTaskZS) this._hasTaskZS && U._zoneDelegates.push(this._hasTaskDlgtOwner), U = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, N, x), U || (U = x);
                else if (x.scheduleFn) x.scheduleFn(x);
                else if (x.type == j) m(x);
                else throw new Error("Task is missing scheduleFn.");
                return U
            }
            invokeTask(N, x, U, ve) {
                return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, N, x, U, ve) : x.callback.apply(U, ve)
            }
            cancelTask(N, x) {
                let U;
                if (this._cancelTaskZS) U = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, N, x);
                else {
                    if (!x.cancelFn) throw Error("Task is not cancelable");
                    U = x.cancelFn(x)
                }
                return U
            }
            hasTask(N, x) {
                try {
                    this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, N, x)
                } catch (U) {
                    this.handleError(N, U)
                }
            }
            _updateTaskCount(N, x) {
                let U = this._taskCounts,
                    ve = U[N],
                    Te = U[N] = ve + x;
                if (Te < 0) throw new Error("More tasks executed then were scheduled.");
                if (ve == 0 || Te == 0) {
                    let Fe = {
                        microTask: U.microTask > 0,
                        macroTask: U.macroTask > 0,
                        eventTask: U.eventTask > 0,
                        change: N
                    };
                    this.hasTask(this._zone, Fe)
                }
            }
        };
    o(Ye, "_ZoneDelegate");
    let a = Ye,
        Xe = class Xe {
            constructor(N, x, U, ve, Te, Fe) {
                if (this._zone = null, this.runCount = 0, this._zoneDelegates = null, this._state = "notScheduled", this.type = N, this.source = x, this.data = ve, this.scheduleFn = Te, this.cancelFn = Fe, !U) throw new Error("callback is not defined");
                this.callback = U;
                let rt = this;
                N === q && ve && ve.useG ? this.invoke = Xe.invokeTask : this.invoke = function() {
                    return Xe.invokeTask.call(Kn, rt, this, arguments)
                }
            }
            static invokeTask(N, x, U) {
                N || (N = this), K++;
                try {
                    return N.runCount++, N.zone.runTask(N, x, U)
                } finally {
                    K == 1 && w(), K--
                }
            }
            get zone() {
                return this._zone
            }
            get state() {
                return this._state
            }
            cancelScheduleRequest() {
                this._transitionTo(E, b)
            }
            _transitionTo(N, x, U) {
                if (this._state === x || this._state === U) this._state = N, N == E && (this._zoneDelegates = null);
                else throw new Error(`${this.type} '${this.source}': can not transition to '${N}', expecting state '${x}'${U?" or '"+U+"'":""}, was '${this._state}'.`)
            }
            toString() {
                return this.data && typeof this.data.handleId != "undefined" ? this.data.handleId.toString() : Object.prototype.toString.call(this)
            }
            toJSON() {
                return {
                    type: this.type,
                    state: this.state,
                    source: this.source,
                    zone: this.zone.name,
                    runCount: this.runCount
                }
            }
        };
    o(Xe, "ZoneTask");
    let u = Xe,
        l = an("setTimeout"),
        c = an("Promise"),
        d = an("then"),
        f = [],
        h = !1,
        g;

    function p(de) {
        if (g || Kn[c] && (g = Kn[c].resolve(0)), g) {
            let N = g[d];
            N || (N = g.then), N.call(g, de)
        } else Kn[l](de, 0)
    }
    o(p, "nativeScheduleMicroTask");

    function m(de) {
        K === 0 && f.length === 0 && p(w), de && f.push(de)
    }
    o(m, "scheduleMicroTask");

    function w() {
        if (!h) {
            for (h = !0; f.length;) {
                let de = f;
                f = [];
                for (let N = 0; N < de.length; N++) {
                    let x = de[N];
                    try {
                        x.zone.runTask(x, null, null)
                    } catch (U) {
                        Z.onUnhandledError(U)
                    }
                }
            }
            Z.microtaskDrainDone(), h = !1
        }
    }
    o(w, "drainMicroTaskQueue");
    let T = {
            name: "NO ZONE"
        },
        E = "notScheduled",
        b = "scheduling",
        R = "scheduled",
        L = "running",
        V = "canceling",
        z = "unknown",
        j = "microTask",
        Y = "macroTask",
        q = "eventTask",
        P = {},
        Z = {
            symbol: an,
            currentZoneFrame: o(() => oe, "currentZoneFrame"),
            onUnhandledError: M,
            microtaskDrainDone: M,
            scheduleMicroTask: m,
            showUncaughtError: o(() => !i[an("ignoreConsoleErrorUncaughtError")], "showUncaughtError"),
            patchEventTarget: o(() => [], "patchEventTarget"),
            patchOnProperties: M,
            patchMethod: o(() => M, "patchMethod"),
            bindArguments: o(() => [], "bindArguments"),
            patchThen: o(() => M, "patchThen"),
            patchMacroTask: o(() => M, "patchMacroTask"),
            patchEventPrototype: o(() => M, "patchEventPrototype"),
            isIEOrEdge: o(() => !1, "isIEOrEdge"),
            getGlobalObjects: o(() => {}, "getGlobalObjects"),
            ObjectDefineProperty: o(() => M, "ObjectDefineProperty"),
            ObjectGetOwnPropertyDescriptor: o(() => {}, "ObjectGetOwnPropertyDescriptor"),
            ObjectCreate: o(() => {}, "ObjectCreate"),
            ArraySlice: o(() => [], "ArraySlice"),
            patchClass: o(() => M, "patchClass"),
            wrapWithCurrentZone: o(() => M, "wrapWithCurrentZone"),
            filterProperties: o(() => [], "filterProperties"),
            attachOriginToPatched: o(() => M, "attachOriginToPatched"),
            _redefineProperty: o(() => M, "_redefineProperty"),
            patchCallbacks: o(() => M, "patchCallbacks"),
            nativeScheduleMicroTask: p
        },
        oe = {
            parent: null,
            zone: new i(null, null)
        },
        S = null,
        K = 0;

    function M() {}
    return o(M, "noop"), n("Zone", "Zone"), i
}
o(gY, "initZone");

function pY() {
    var r, e;
    let t = globalThis,
        n = t[an("forceDuplicateZoneCheck")] === !0;
    if (t.Zone && (n || typeof t.Zone.__symbol__ != "function")) throw new Error("Zone already loaded.");
    return (e = t[r = "Zone"]) !== null && e !== void 0 || (t[r] = gY()), t.Zone
}
o(pY, "loadZone");
var Bl = Object.getOwnPropertyDescriptor,
    UT = Object.defineProperty,
    MT = Object.getPrototypeOf,
    mY = Object.create,
    vY = Array.prototype.slice,
    kT = "addEventListener",
    FT = "removeEventListener",
    nw = an(kT),
    iw = an(FT),
    Ti = "true",
    Ei = "false",
    Vl = an("");

function $T(r, e) {
    return Zone.current.wrap(r, e)
}
o($T, "wrapWithCurrentZone");

function BT(r, e, t, n, i) {
    return Zone.current.scheduleMacroTask(r, e, t, n, i)
}
o(BT, "scheduleMacroTaskWithCurrentZone");
var lt = an,
    tp = typeof window != "undefined",
    qa = tp ? window : void 0,
    qt = tp && qa || globalThis,
    yY = "removeAttribute";

function VT(r, e) {
    for (let t = r.length - 1; t >= 0; t--) typeof r[t] == "function" && (r[t] = $T(r[t], e + "_" + t));
    return r
}
o(VT, "bindArguments");

function _Y(r, e) {
    let t = r.constructor.name;
    for (let n = 0; n < e.length; n++) {
        let i = e[n],
            s = r[i];
        if (s) {
            let a = Bl(r, i);
            if (!GN(a)) continue;
            r[i] = (u => {
                let l = o(function() {
                    return u.apply(this, VT(arguments, t + "." + i))
                }, "patched");
                return Si(l, u), l
            })(s)
        }
    }
}
o(_Y, "patchPrototype");

function GN(r) {
    return r ? r.writable === !1 ? !1 : !(typeof r.get == "function" && typeof r.set == "undefined") : !0
}
o(GN, "isPropertyWritable");
var zN = typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope,
    rp = !("nw" in qt) && typeof qt.process != "undefined" && qt.process.toString() === "[object process]",
    HT = !rp && !zN && !!(tp && qa.HTMLElement),
    qN = typeof qt.process != "undefined" && qt.process.toString() === "[object process]" && !zN && !!(tp && qa.HTMLElement),
    Ag = {},
    wY = lt("enable_beforeunload"),
    uP = o(function(r) {
        if (r = r || qt.event, !r) return;
        let e = Ag[r.type];
        e || (e = Ag[r.type] = lt("ON_PROPERTY" + r.type));
        let t = this || r.target || qt,
            n = t[e],
            i;
        if (HT && t === qa && r.type === "error") {
            let s = r;
            i = n && n.call(this, s.message, s.filename, s.lineno, s.colno, s.error), i === !0 && r.preventDefault()
        } else i = n && n.apply(this, arguments), r.type === "beforeunload" && qt[wY] && typeof i == "string" ? r.returnValue = i : i != null && !i && r.preventDefault();
        return i
    }, "wrapFn");

function cP(r, e, t) {
    let n = Bl(r, e);
    if (!n && t && Bl(t, e) && (n = {
            enumerable: !0,
            configurable: !0
        }), !n || !n.configurable) return;
    let i = lt("on" + e + "patched");
    if (r.hasOwnProperty(i) && r[i]) return;
    delete n.writable, delete n.value;
    let s = n.get,
        a = n.set,
        u = e.slice(2),
        l = Ag[u];
    l || (l = Ag[u] = lt("ON_PROPERTY" + u)), n.set = function(c) {
        let d = this;
        if (!d && r === qt && (d = qt), !d) return;
        typeof d[l] == "function" && d.removeEventListener(u, uP), a && a.call(d, null), d[l] = c, typeof c == "function" && d.addEventListener(u, uP, !1)
    }, n.get = function() {
        let c = this;
        if (!c && r === qt && (c = qt), !c) return null;
        let d = c[l];
        if (d) return d;
        if (s) {
            let f = s.call(this);
            if (f) return n.set.call(this, f), typeof c[yY] == "function" && c.removeAttribute(e), f
        }
        return null
    }, UT(r, e, n), r[i] = !0
}
o(cP, "patchProperty");

function KN(r, e, t) {
    if (e)
        for (let n = 0; n < e.length; n++) cP(r, "on" + e[n], t);
    else {
        let n = [];
        for (let i in r) i.slice(0, 2) == "on" && n.push(i);
        for (let i = 0; i < n.length; i++) cP(r, n[i], t)
    }
}
o(KN, "patchOnProperties");
var Cn = lt("originalInstance");

function Il(r) {
    let e = qt[r];
    if (!e) return;
    qt[lt(r)] = e, qt[r] = function() {
        let i = VT(arguments, r);
        switch (i.length) {
            case 0:
                this[Cn] = new e;
                break;
            case 1:
                this[Cn] = new e(i[0]);
                break;
            case 2:
                this[Cn] = new e(i[0], i[1]);
                break;
            case 3:
                this[Cn] = new e(i[0], i[1], i[2]);
                break;
            case 4:
                this[Cn] = new e(i[0], i[1], i[2], i[3]);
                break;
            default:
                throw new Error("Arg list too long.")
        }
    }, Si(qt[r], e);
    let t = new e(function() {}),
        n;
    for (n in t) r === "XMLHttpRequest" && n === "responseBlob" || (function(i) {
        typeof t[i] == "function" ? qt[r].prototype[i] = function() {
            return this[Cn][i].apply(this[Cn], arguments)
        } : UT(qt[r].prototype, i, {
            set: o(function(s) {
                typeof s == "function" ? (this[Cn][i] = $T(s, r + "." + i), Si(this[Cn][i], s)) : this[Cn][i] = s
            }, "set"),
            get: o(function() {
                return this[Cn][i]
            }, "get")
        })
    })(n);
    for (n in e) n !== "prototype" && e.hasOwnProperty(n) && (qt[r][n] = e[n])
}
o(Il, "patchClass");

function bi(r, e, t) {
    let n = r;
    for (; n && !n.hasOwnProperty(e);) n = MT(n);
    !n && r[e] && (n = r);
    let i = lt(e),
        s = null;
    if (n && (!(s = n[i]) || !n.hasOwnProperty(i))) {
        s = n[i] = n[e];
        let a = n && Bl(n, e);
        if (GN(a)) {
            let u = t(s, i, e);
            n[e] = function() {
                return u(this, arguments)
            }, Si(n[e], s)
        }
    }
    return s
}
o(bi, "patchMethod");

function TY(r, e, t) {
    let n = null;

    function i(s) {
        let a = s.data;
        return a.args[a.cbIdx] = function() {
            s.invoke.apply(this, arguments)
        }, n.apply(a.target, a.args), s
    }
    o(i, "scheduleTask"), n = bi(r, e, s => function(a, u) {
        let l = t(a, u);
        return l.cbIdx >= 0 && typeof u[l.cbIdx] == "function" ? BT(l.name, u[l.cbIdx], l, i) : s.apply(a, u)
    })
}
o(TY, "patchMacroTask");

function Si(r, e) {
    r[lt("OriginalDelegate")] = e
}
o(Si, "attachOriginToPatched");
var lP = !1,
    sw = !1;

function EY() {
    try {
        let r = qa.navigator.userAgent;
        if (r.indexOf("MSIE ") !== -1 || r.indexOf("Trident/") !== -1) return !0
    } catch (r) {}
    return !1
}
o(EY, "isIE");

function bY() {
    if (lP) return sw;
    lP = !0;
    try {
        let r = qa.navigator.userAgent;
        (r.indexOf("MSIE ") !== -1 || r.indexOf("Trident/") !== -1 || r.indexOf("Edge/") !== -1) && (sw = !0)
    } catch (r) {}
    return sw
}
o(bY, "isIEOrEdge");

function dP(r) {
    return typeof r == "function"
}
o(dP, "isFunction");

function fP(r) {
    return typeof r == "number"
}
o(fP, "isNumber");
var Ma = !1;
if (typeof window != "undefined") try {
    let r = Object.defineProperty({}, "passive", {
        get: o(function() {
            Ma = !0
        }, "get")
    });
    window.addEventListener("test", r, r), window.removeEventListener("test", r, r)
} catch (r) {
    Ma = !1
}
var SY = {
        useG: !0
    },
    un = {},
    YN = {},
    XN = new RegExp("^" + Vl + "(\\w+)(true|false)$"),
    JN = lt("propagationStopped");

function ZN(r, e) {
    let t = (e ? e(r) : r) + Ei,
        n = (e ? e(r) : r) + Ti,
        i = Vl + t,
        s = Vl + n;
    un[r] = {}, un[r][Ei] = i, un[r][Ti] = s
}
o(ZN, "prepareEventNames");

function AY(r, e, t, n) {
    let i = n && n.add || kT,
        s = n && n.rm || FT,
        a = n && n.listeners || "eventListeners",
        u = n && n.rmAll || "removeAllListeners",
        l = lt(i),
        c = "." + i + ":",
        d = "prependListener",
        f = "." + d + ":",
        h = o(function(E, b, R) {
            if (E.isRemoved) return;
            let L = E.callback;
            typeof L == "object" && L.handleEvent && (E.callback = j => L.handleEvent(j), E.originalDelegate = L);
            let V;
            try {
                E.invoke(E, b, [R])
            } catch (j) {
                V = j
            }
            let z = E.options;
            if (z && typeof z == "object" && z.once) {
                let j = E.originalDelegate ? E.originalDelegate : E.callback;
                b[s].call(b, R.type, j, z)
            }
            return V
        }, "invokeTask");

    function g(E, b, R) {
        if (b = b || r.event, !b) return;
        let L = E || b.target || r,
            V = L[un[b.type][R ? Ti : Ei]];
        if (V) {
            let z = [];
            if (V.length === 1) {
                let j = h(V[0], L, b);
                j && z.push(j)
            } else {
                let j = V.slice();
                for (let Y = 0; Y < j.length && !(b && b[JN] === !0); Y++) {
                    let q = h(j[Y], L, b);
                    q && z.push(q)
                }
            }
            if (z.length === 1) throw z[0];
            for (let j = 0; j < z.length; j++) {
                let Y = z[j];
                e.nativeScheduleMicroTask(() => {
                    throw Y
                })
            }
        }
    }
    o(g, "globalCallback");
    let p = o(function(E) {
            return g(this, E, !1)
        }, "globalZoneAwareCallback"),
        m = o(function(E) {
            return g(this, E, !0)
        }, "globalZoneAwareCaptureCallback");

    function w(E, b) {
        if (!E) return !1;
        let R = !0;
        b && b.useG !== void 0 && (R = b.useG);
        let L = b && b.vh,
            V = !0;
        b && b.chkDup !== void 0 && (V = b.chkDup);
        let z = !1;
        b && b.rt !== void 0 && (z = b.rt);
        let j = E;
        for (; j && !j.hasOwnProperty(i);) j = MT(j);
        if (!j && E[i] && (j = E), !j || j[l]) return !1;
        let Y = b && b.eventNameToString,
            q = {},
            P = j[l] = j[i],
            Z = j[lt(s)] = j[s],
            oe = j[lt(a)] = j[a],
            S = j[lt(u)] = j[u],
            K;
        b && b.prepend && (K = j[lt(b.prepend)] = j[b.prepend]);

        function M($, X) {
            return !Ma && typeof $ == "object" && $ ? !!$.capture : !Ma || !X ? $ : typeof $ == "boolean" ? {
                capture: $,
                passive: !0
            } : $ ? typeof $ == "object" && $.passive !== !1 ? ns(Rt({}, $), {
                passive: !0
            }) : $ : {
                passive: !0
            }
        }
        o(M, "buildEventListenerOptions");
        let Oe = o(function($) {
                if (!q.isExisting) return P.call(q.target, q.eventName, q.capture ? m : p, q.options)
            }, "customScheduleGlobal"),
            Ye = o(function($) {
                if (!$.isRemoved) {
                    let X = un[$.eventName],
                        W;
                    X && (W = X[$.capture ? Ti : Ei]);
                    let te = W && $.target[W];
                    if (te) {
                        for (let _e = 0; _e < te.length; _e++)
                            if (te[_e] === $) {
                                te.splice(_e, 1), $.isRemoved = !0, $.removeAbortListener && ($.removeAbortListener(), $.removeAbortListener = null), te.length === 0 && ($.allRemoved = !0, $.target[W] = null);
                                break
                            }
                    }
                }
                if ($.allRemoved) return Z.call($.target, $.eventName, $.capture ? m : p, $.options)
            }, "customCancelGlobal"),
            Xe = o(function($) {
                return P.call(q.target, q.eventName, $.invoke, q.options)
            }, "customScheduleNonGlobal"),
            de = o(function($) {
                return K.call(q.target, q.eventName, $.invoke, q.options)
            }, "customSchedulePrepend"),
            N = o(function($) {
                return Z.call($.target, $.eventName, $.invoke, $.options)
            }, "customCancelNonGlobal"),
            x = R ? Oe : Xe,
            U = R ? Ye : N,
            ve = o(function($, X) {
                let W = typeof X;
                return W === "function" && $.callback === X || W === "object" && $.originalDelegate === X
            }, "compareTaskCallbackVsDelegate"),
            Te = b && b.diff ? b.diff : ve,
            Fe = Zone[lt("UNPATCHED_EVENTS")],
            rt = r[lt("PASSIVE_EVENTS")];

        function xe($) {
            if (typeof $ == "object" && $ !== null) {
                let X = Rt({}, $);
                return $.signal && (X.signal = $.signal), X
            }
            return $
        }
        o(xe, "copyEventListenerOptions");
        let fe = o(function($, X, W, te) {
            let _e = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1,
                we = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
            return function() {
                let Ie = this || r,
                    Me = arguments[0];
                b && b.transferEventName && (Me = b.transferEventName(Me));
                let A = arguments[1];
                if (!A) return $.apply(this, arguments);
                if (rp && Me === "uncaughtException") return $.apply(this, arguments);
                let v = !1;
                if (typeof A != "function") {
                    if (!A.handleEvent) return $.apply(this, arguments);
                    v = !0
                }
                if (L && !L($, A, Ie, arguments)) return;
                let y = Ma && !!rt && rt.indexOf(Me) !== -1,
                    C = xe(M(arguments[2], y)),
                    B = C == null ? void 0 : C.signal;
                if (B != null && B.aborted) return;
                if (Fe) {
                    for (let Pr = 0; Pr < Fe.length; Pr++)
                        if (Me === Fe[Pr]) return y ? $.call(Ie, Me, A, C) : $.apply(this, arguments)
                }
                let se = C ? typeof C == "boolean" ? !0 : C.capture : !1,
                    ce = C && typeof C == "object" ? C.once : !1,
                    Ge = Zone.current,
                    it = un[Me];
                it || (ZN(Me, Y), it = un[Me]);
                let st = it[se ? Ti : Ei],
                    _t = Ie[st],
                    mt = !1;
                if (_t) {
                    if (mt = !0, V) {
                        for (let Pr = 0; Pr < _t.length; Pr++)
                            if (Te(_t[Pr], A)) return
                    }
                } else _t = Ie[st] = [];
                let $t, Zi = Ie.constructor.name,
                    Qi = YN[Zi];
                Qi && ($t = Qi[Me]), $t || ($t = Zi + X + (Y ? Y(Me) : Me)), q.options = C, ce && (q.options.once = !1), q.target = Ie, q.capture = se, q.eventName = Me, q.isExisting = mt;
                let Gs = R ? SY : void 0;
                Gs && (Gs.taskData = q), B && (q.options.signal = void 0);
                let kr = Ge.scheduleEventTask($t, A, Gs, W, te);
                if (B) {
                    q.options.signal = B;
                    let Pr = o(() => kr.zone.cancelTask(kr), "onAbort");
                    $.call(B, "abort", Pr, {
                        once: !0
                    }), kr.removeAbortListener = () => B.removeEventListener("abort", Pr)
                }
                if (q.target = null, Gs && (Gs.taskData = null), ce && (q.options.once = !0), !Ma && typeof kr.options == "boolean" || (kr.options = C), kr.target = Ie, kr.capture = se, kr.eventName = Me, v && (kr.originalDelegate = A), we ? _t.unshift(kr) : _t.push(kr), _e) return Ie
            }
        }, "makeAddListener");
        return j[i] = fe(P, c, x, U, z), K && (j[d] = fe(K, f, de, U, z, !0)), j[s] = function() {
            let $ = this || r,
                X = arguments[0];
            b && b.transferEventName && (X = b.transferEventName(X));
            let W = arguments[2],
                te = W ? typeof W == "boolean" ? !0 : W.capture : !1,
                _e = arguments[1];
            if (!_e) return Z.apply(this, arguments);
            if (L && !L(Z, _e, $, arguments)) return;
            let we = un[X],
                Ie;
            we && (Ie = we[te ? Ti : Ei]);
            let Me = Ie && $[Ie];
            if (Me)
                for (let A = 0; A < Me.length; A++) {
                    let v = Me[A];
                    if (Te(v, _e)) {
                        if (Me.splice(A, 1), v.isRemoved = !0, Me.length === 0 && (v.allRemoved = !0, $[Ie] = null, !te && typeof X == "string")) {
                            let y = Vl + "ON_PROPERTY" + X;
                            $[y] = null
                        }
                        return v.zone.cancelTask(v), z ? $ : void 0
                    }
                }
            return Z.apply(this, arguments)
        }, j[a] = function() {
            let $ = this || r,
                X = arguments[0];
            b && b.transferEventName && (X = b.transferEventName(X));
            let W = [],
                te = QN($, Y ? Y(X) : X);
            for (let _e = 0; _e < te.length; _e++) {
                let we = te[_e],
                    Ie = we.originalDelegate ? we.originalDelegate : we.callback;
                W.push(Ie)
            }
            return W
        }, j[u] = function() {
            let $ = this || r,
                X = arguments[0];
            if (X) {
                b && b.transferEventName && (X = b.transferEventName(X));
                let W = un[X];
                if (W) {
                    let te = W[Ei],
                        _e = W[Ti],
                        we = $[te],
                        Ie = $[_e];
                    if (we) {
                        let Me = we.slice();
                        for (let A = 0; A < Me.length; A++) {
                            let v = Me[A],
                                y = v.originalDelegate ? v.originalDelegate : v.callback;
                            this[s].call(this, X, y, v.options)
                        }
                    }
                    if (Ie) {
                        let Me = Ie.slice();
                        for (let A = 0; A < Me.length; A++) {
                            let v = Me[A],
                                y = v.originalDelegate ? v.originalDelegate : v.callback;
                            this[s].call(this, X, y, v.options)
                        }
                    }
                }
            } else {
                let W = Object.keys($);
                for (let te = 0; te < W.length; te++) {
                    let _e = W[te],
                        we = XN.exec(_e),
                        Ie = we && we[1];
                    Ie && Ie !== "removeListener" && this[u].call(this, Ie)
                }
                this[u].call(this, "removeListener")
            }
            if (z) return this
        }, Si(j[i], P), Si(j[s], Z), S && Si(j[u], S), oe && Si(j[a], oe), !0
    }
    o(w, "patchEventTargetMethods");
    let T = [];
    for (let E = 0; E < t.length; E++) T[E] = w(t[E], n);
    return T
}
o(AY, "patchEventTarget");

function QN(r, e) {
    if (!e) {
        let s = [];
        for (let a in r) {
            let u = XN.exec(a),
                l = u && u[1];
            if (l && (!e || l === e)) {
                let c = r[a];
                if (c)
                    for (let d = 0; d < c.length; d++) s.push(c[d])
            }
        }
        return s
    }
    let t = un[e];
    t || (ZN(e), t = un[e]);
    let n = r[t[Ei]],
        i = r[t[Ti]];
    return n ? i ? n.concat(i) : n.slice() : i ? i.slice() : []
}
o(QN, "findEventTasks");

function IY(r, e) {
    let t = r.Event;
    t && t.prototype && e.patchMethod(t.prototype, "stopImmediatePropagation", n => function(i, s) {
        i[JN] = !0, n && n.apply(i, s)
    })
}
o(IY, "patchEventPrototype");

function CY(r, e) {
    e.patchMethod(r, "queueMicrotask", t => function(n, i) {
        Zone.current.scheduleMicroTask("queueMicrotask", i[0])
    })
}
o(CY, "patchQueueMicrotask");
var Nh = lt("zoneTask");

function ya(r, e, t, n) {
    let i = null,
        s = null;
    e += n, t += n;
    let a = {};

    function u(c) {
        let d = c.data;
        d.args[0] = function() {
            return c.invoke.apply(this, arguments)
        };
        let f = i.apply(r, d.args);
        return fP(f) ? d.handleId = f : (d.handle = f, d.isRefreshable = dP(f.refresh)), c
    }
    o(u, "scheduleTask");

    function l(c) {
        let {
            handle: d,
            handleId: f
        } = c.data;
        return s.call(r, d != null ? d : f)
    }
    o(l, "clearTask"), i = bi(r, e, c => function(d, f) {
        if (dP(f[0])) {
            var h;
            let g = {
                    isRefreshable: !1,
                    isPeriodic: n === "Interval",
                    delay: n === "Timeout" || n === "Interval" ? f[1] || 0 : void 0,
                    args: f
                },
                p = f[0];
            f[0] = o(function() {
                try {
                    return p.apply(this, arguments)
                } finally {
                    let {
                        handle: L,
                        handleId: V,
                        isPeriodic: z,
                        isRefreshable: j
                    } = g;
                    !z && !j && (V ? delete a[V] : L && (L[Nh] = null))
                }
            }, "timer");
            let m = BT(e, f[0], g, u, l);
            if (!m) return m;
            let {
                handleId: w,
                handle: T,
                isRefreshable: E,
                isPeriodic: b
            } = m.data;
            if (w) a[w] = m;
            else if (T && (T[Nh] = m, E && !b)) {
                let R = T.refresh;
                T.refresh = function() {
                    let {
                        zone: L,
                        state: V
                    } = m;
                    return V === "notScheduled" ? (m._state = "scheduled", L._updateTaskCount(m, 1)) : V === "running" && (m._state = "scheduling"), R.call(this)
                }
            }
            return (h = T != null ? T : w) !== null && h !== void 0 ? h : m
        } else return c.apply(r, f)
    }), s = bi(r, t, c => function(d, f) {
        var h;
        let g = f[0],
            p;
        fP(g) ? (p = a[g], delete a[g]) : (p = g == null ? void 0 : g[Nh], p ? g[Nh] = null : p = g), (h = p) !== null && h !== void 0 && h.type ? p.cancelFn && p.zone.cancelTask(p) : c.apply(r, f)
    })
}
o(ya, "patchTimer");

function RY(r, e) {
    let {
        isBrowser: t,
        isMix: n
    } = e.getGlobalObjects();
    if (!t && !n || !r.customElements || !("customElements" in r)) return;
    let i = ["connectedCallback", "disconnectedCallback", "adoptedCallback", "attributeChangedCallback", "formAssociatedCallback", "formDisabledCallback", "formResetCallback", "formStateRestoreCallback"];
    e.patchCallbacks(e, r.customElements, "customElements", "define", i)
}
o(RY, "patchCustomElements");

function OY(r, e) {
    if (Zone[e.symbol("patchEventTarget")]) return;
    let {
        eventNames: t,
        zoneSymbolEventNames: n,
        TRUE_STR: i,
        FALSE_STR: s,
        ZONE_SYMBOL_PREFIX: a
    } = e.getGlobalObjects();
    for (let l = 0; l < t.length; l++) {
        let c = t[l],
            d = c + s,
            f = c + i,
            h = a + d,
            g = a + f;
        n[c] = {}, n[c][s] = h, n[c][i] = g
    }
    let u = r.EventTarget;
    if (!(!u || !u.prototype)) return e.patchEventTarget(r, e, [u && u.prototype]), !0
}
o(OY, "eventTargetPatch");

function PY(r, e) {
    e.patchEventPrototype(r, e)
}
o(PY, "patchEvent");

function eD(r, e, t) {
    if (!t || t.length === 0) return e;
    let n = t.filter(s => s.target === r);
    if (!n || n.length === 0) return e;
    let i = n[0].ignoreProperties;
    return e.filter(s => i.indexOf(s) === -1)
}
o(eD, "filterProperties");

function hP(r, e, t, n) {
    if (!r) return;
    let i = eD(r, e, t);
    KN(r, i, n)
}
o(hP, "patchFilteredProperties");

function Bw(r) {
    return Object.getOwnPropertyNames(r).filter(e => e.startsWith("on") && e.length > 2).map(e => e.substring(2))
}
o(Bw, "getOnEventNames");

function NY(r, e) {
    if (rp && !qN || Zone[r.symbol("patchEvents")]) return;
    let t = e.__Zone_ignore_on_properties,
        n = [];
    if (HT) {
        let i = window;
        n = n.concat(["Document", "SVGElement", "Element", "HTMLElement", "HTMLBodyElement", "HTMLMediaElement", "HTMLFrameSetElement", "HTMLFrameElement", "HTMLIFrameElement", "HTMLMarqueeElement", "Worker"]);
        let s = EY() ? [{
            target: i,
            ignoreProperties: ["error"]
        }] : [];
        hP(i, Bw(i), t && t.concat(s), MT(i))
    }
    n = n.concat(["XMLHttpRequest", "XMLHttpRequestEventTarget", "IDBIndex", "IDBRequest", "IDBOpenDBRequest", "IDBDatabase", "IDBTransaction", "IDBCursor", "WebSocket"]);
    for (let i = 0; i < n.length; i++) {
        let s = e[n[i]];
        s && s.prototype && hP(s.prototype, Bw(s.prototype), t)
    }
}
o(NY, "propertyDescriptorPatch");

function DY(r) {
    r.__load_patch("legacy", e => {
        let t = e[r.__symbol__("legacyPatch")];
        t && t()
    }), r.__load_patch("timers", e => {
        let n = "clear";
        ya(e, "set", n, "Timeout"), ya(e, "set", n, "Interval"), ya(e, "set", n, "Immediate")
    }), r.__load_patch("requestAnimationFrame", e => {
        ya(e, "request", "cancel", "AnimationFrame"), ya(e, "mozRequest", "mozCancel", "AnimationFrame"), ya(e, "webkitRequest", "webkitCancel", "AnimationFrame")
    }), r.__load_patch("blocking", (e, t) => {
        let n = ["alert", "prompt", "confirm"];
        for (let i = 0; i < n.length; i++) {
            let s = n[i];
            bi(e, s, (a, u, l) => function(c, d) {
                return t.current.run(a, e, d, l)
            })
        }
    }), r.__load_patch("EventTarget", (e, t, n) => {
        PY(e, n), OY(e, n);
        let i = e.XMLHttpRequestEventTarget;
        i && i.prototype && n.patchEventTarget(e, n, [i.prototype])
    }), r.__load_patch("MutationObserver", (e, t, n) => {
        Il("MutationObserver"), Il("WebKitMutationObserver")
    }), r.__load_patch("IntersectionObserver", (e, t, n) => {
        Il("IntersectionObserver")
    }), r.__load_patch("FileReader", (e, t, n) => {
        Il("FileReader")
    }), r.__load_patch("on_property", (e, t, n) => {
        NY(n, e)
    }), r.__load_patch("customElements", (e, t, n) => {
        RY(e, n)
    }), r.__load_patch("XHR", (e, t) => {
        c(e);
        let n = lt("xhrTask"),
            i = lt("xhrSync"),
            s = lt("xhrListener"),
            a = lt("xhrScheduled"),
            u = lt("xhrURL"),
            l = lt("xhrErrorBeforeScheduled");

        function c(d) {
            let f = d.XMLHttpRequest;
            if (!f) return;
            let h = f.prototype;

            function g(P) {
                return P[n]
            }
            o(g, "findPendingTask");
            let p = h[nw],
                m = h[iw];
            if (!p) {
                let P = d.XMLHttpRequestEventTarget;
                if (P) {
                    let Z = P.prototype;
                    p = Z[nw], m = Z[iw]
                }
            }
            let w = "readystatechange",
                T = "scheduled";

            function E(P) {
                let Z = P.data,
                    oe = Z.target;
                oe[a] = !1, oe[l] = !1;
                let S = oe[s];
                p || (p = oe[nw], m = oe[iw]), S && m.call(oe, w, S);
                let K = oe[s] = () => {
                    if (oe.readyState === oe.DONE)
                        if (!Z.aborted && oe[a] && P.state === T) {
                            let Oe = oe[t.__symbol__("loadfalse")];
                            if (oe.status !== 0 && Oe && Oe.length > 0) {
                                let Ye = P.invoke;
                                P.invoke = function() {
                                    let Xe = oe[t.__symbol__("loadfalse")];
                                    for (let de = 0; de < Xe.length; de++) Xe[de] === P && Xe.splice(de, 1);
                                    !Z.aborted && P.state === T && Ye.call(P)
                                }, Oe.push(P)
                            } else P.invoke()
                        } else !Z.aborted && oe[a] === !1 && (oe[l] = !0)
                };
                return p.call(oe, w, K), oe[n] || (oe[n] = P), Y.apply(oe, Z.args), oe[a] = !0, P
            }
            o(E, "scheduleTask");

            function b() {}
            o(b, "placeholderCallback");

            function R(P) {
                let Z = P.data;
                return Z.aborted = !0, q.apply(Z.target, Z.args)
            }
            o(R, "clearTask");
            let L = bi(h, "open", () => function(P, Z) {
                    return P[i] = Z[2] == !1, P[u] = Z[1], L.apply(P, Z)
                }),
                V = "XMLHttpRequest.send",
                z = lt("fetchTaskAborting"),
                j = lt("fetchTaskScheduling"),
                Y = bi(h, "send", () => function(P, Z) {
                    if (t.current[j] === !0 || P[i]) return Y.apply(P, Z); {
                        let oe = {
                                target: P,
                                url: P[u],
                                isPeriodic: !1,
                                args: Z,
                                aborted: !1
                            },
                            S = BT(V, b, oe, E, R);
                        P && P[l] === !0 && !oe.aborted && S.state === T && S.invoke()
                    }
                }),
                q = bi(h, "abort", () => function(P, Z) {
                    let oe = g(P);
                    if (oe && typeof oe.type == "string") {
                        if (oe.cancelFn == null || oe.data && oe.data.aborted) return;
                        oe.zone.cancelTask(oe)
                    } else if (t.current[z] === !0) return q.apply(P, Z)
                })
        }
        o(c, "patchXHR")
    }), r.__load_patch("geolocation", e => {
        e.navigator && e.navigator.geolocation && _Y(e.navigator.geolocation, ["getCurrentPosition", "watchPosition"])
    }), r.__load_patch("PromiseRejectionEvent", (e, t) => {
        function n(i) {
            return function(s) {
                QN(e, i).forEach(u => {
                    let l = e.PromiseRejectionEvent;
                    if (l) {
                        let c = new l(i, {
                            promise: s.promise,
                            reason: s.rejection
                        });
                        u.invoke(c)
                    }
                })
            }
        }
        o(n, "findPromiseRejectionHandler"), e.PromiseRejectionEvent && (t[lt("unhandledPromiseRejectionHandler")] = n("unhandledrejection"), t[lt("rejectionHandledHandler")] = n("rejectionhandled"))
    }), r.__load_patch("queueMicrotask", (e, t, n) => {
        CY(e, n)
    })
}
o(DY, "patchBrowser");

function LY(r) {
    r.__load_patch("ZoneAwarePromise", (e, t, n) => {
        let i = Object.getOwnPropertyDescriptor,
            s = Object.defineProperty;

        function a(fe) {
            if (fe && fe.toString === Object.prototype.toString) {
                let $ = fe.constructor && fe.constructor.name;
                return ($ || "") + ": " + JSON.stringify(fe)
            }
            return fe ? fe.toString() : Object.prototype.toString.call(fe)
        }
        o(a, "readableObjectToString");
        let u = n.symbol,
            l = [],
            c = e[u("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")] !== !1,
            d = u("Promise"),
            f = u("then"),
            h = "__creationTrace__";
        n.onUnhandledError = fe => {
            if (n.showUncaughtError()) {
                let $ = fe && fe.rejection;
                $ ? console.error("Unhandled Promise rejection:", $ instanceof Error ? $.message : $, "; Zone:", fe.zone.name, "; Task:", fe.task && fe.task.source, "; Value:", $, $ instanceof Error ? $.stack : void 0) : console.error(fe)
            }
        }, n.microtaskDrainDone = () => {
            for (; l.length;) {
                let fe = l.shift();
                try {
                    fe.zone.runGuarded(() => {
                        throw fe.throwOriginal ? fe.rejection : fe
                    })
                } catch ($) {
                    p($)
                }
            }
        };
        let g = u("unhandledPromiseRejectionHandler");

        function p(fe) {
            n.onUnhandledError(fe);
            try {
                let $ = t[g];
                typeof $ == "function" && $.call(this, fe)
            } catch ($) {}
        }
        o(p, "handleUnhandledRejection");

        function m(fe) {
            return fe && fe.then
        }
        o(m, "isThenable");

        function w(fe) {
            return fe
        }
        o(w, "forwardResolution");

        function T(fe) {
            return U.reject(fe)
        }
        o(T, "forwardRejection");
        let E = u("state"),
            b = u("value"),
            R = u("finally"),
            L = u("parentPromiseValue"),
            V = u("parentPromiseState"),
            z = "Promise.then",
            j = null,
            Y = !0,
            q = !1,
            P = 0;

        function Z(fe, $) {
            return X => {
                try {
                    M(fe, $, X)
                } catch (W) {
                    M(fe, !1, W)
                }
            }
        }
        o(Z, "makeResolver");
        let oe = o(function() {
                let fe = !1;
                return o(function(X) {
                    return function() {
                        fe || (fe = !0, X.apply(null, arguments))
                    }
                }, "wrapper")
            }, "once"),
            S = "Promise resolved with itself",
            K = u("currentTaskTrace");

        function M(fe, $, X) {
            let W = oe();
            if (fe === X) throw new TypeError(S);
            if (fe[E] === j) {
                let te = null;
                try {
                    (typeof X == "object" || typeof X == "function") && (te = X && X.then)
                } catch (_e) {
                    return W(() => {
                        M(fe, !1, _e)
                    })(), fe
                }
                if ($ !== q && X instanceof U && X.hasOwnProperty(E) && X.hasOwnProperty(b) && X[E] !== j) Ye(X), M(fe, X[E], X[b]);
                else if ($ !== q && typeof te == "function") try {
                    te.call(X, W(Z(fe, $)), W(Z(fe, !1)))
                } catch (_e) {
                    W(() => {
                        M(fe, !1, _e)
                    })()
                } else {
                    fe[E] = $;
                    let _e = fe[b];
                    if (fe[b] = X, fe[R] === R && $ === Y && (fe[E] = fe[V], fe[b] = fe[L]), $ === q && X instanceof Error) {
                        let we = t.currentTask && t.currentTask.data && t.currentTask.data[h];
                        we && s(X, K, {
                            configurable: !0,
                            enumerable: !1,
                            writable: !0,
                            value: we
                        })
                    }
                    for (let we = 0; we < _e.length;) Xe(fe, _e[we++], _e[we++], _e[we++], _e[we++]);
                    if (_e.length == 0 && $ == q) {
                        fe[E] = P;
                        let we = X;
                        try {
                            throw new Error("Uncaught (in promise): " + a(X) + (X && X.stack ? `
` + X.stack : ""))
                        } catch (Ie) {
                            we = Ie
                        }
                        c && (we.throwOriginal = !0), we.rejection = X, we.promise = fe, we.zone = t.current, we.task = t.currentTask, l.push(we), n.scheduleMicroTask()
                    }
                }
            }
            return fe
        }
        o(M, "resolvePromise");
        let Oe = u("rejectionHandledHandler");

        function Ye(fe) {
            if (fe[E] === P) {
                try {
                    let $ = t[Oe];
                    $ && typeof $ == "function" && $.call(this, {
                        rejection: fe[b],
                        promise: fe
                    })
                } catch ($) {}
                fe[E] = q;
                for (let $ = 0; $ < l.length; $++) fe === l[$].promise && l.splice($, 1)
            }
        }
        o(Ye, "clearRejectedNoCatch");

        function Xe(fe, $, X, W, te) {
            Ye(fe);
            let _e = fe[E],
                we = _e ? typeof W == "function" ? W : w : typeof te == "function" ? te : T;
            $.scheduleMicroTask(z, () => {
                try {
                    let Ie = fe[b],
                        Me = !!X && R === X[R];
                    Me && (X[L] = Ie, X[V] = _e);
                    let A = $.run(we, void 0, Me && we !== T && we !== w ? [] : [Ie]);
                    M(X, !0, A)
                } catch (Ie) {
                    M(X, !1, Ie)
                }
            }, X)
        }
        o(Xe, "scheduleResolveOrReject");
        let de = "function ZoneAwarePromise() { [native code] }",
            N = o(function() {}, "noop"),
            x = e.AggregateError,
            xe = class xe {
                static toString() {
                    return de
                }
                static resolve($) {
                    return $ instanceof xe ? $ : M(new this(null), Y, $)
                }
                static reject($) {
                    return M(new this(null), q, $)
                }
                static withResolvers() {
                    let $ = {};
                    return $.promise = new xe((X, W) => {
                        $.resolve = X, $.reject = W
                    }), $
                }
                static any($) {
                    if (!$ || typeof $[Symbol.iterator] != "function") return Promise.reject(new x([], "All promises were rejected"));
                    let X = [],
                        W = 0;
                    try {
                        for (let we of $) W++, X.push(xe.resolve(we))
                    } catch (we) {
                        return Promise.reject(new x([], "All promises were rejected"))
                    }
                    if (W === 0) return Promise.reject(new x([], "All promises were rejected"));
                    let te = !1,
                        _e = [];
                    return new xe((we, Ie) => {
                        for (let Me = 0; Me < X.length; Me++) X[Me].then(A => {
                            te || (te = !0, we(A))
                        }, A => {
                            _e.push(A), W--, W === 0 && (te = !0, Ie(new x(_e, "All promises were rejected")))
                        })
                    })
                }
                static race($) {
                    let X, W, te = new this((Ie, Me) => {
                        X = Ie, W = Me
                    });

                    function _e(Ie) {
                        X(Ie)
                    }
                    o(_e, "onResolve");

                    function we(Ie) {
                        W(Ie)
                    }
                    o(we, "onReject");
                    for (let Ie of $) m(Ie) || (Ie = this.resolve(Ie)), Ie.then(_e, we);
                    return te
                }
                static all($) {
                    return xe.allWithCallback($)
                }
                static allSettled($) {
                    return (this && this.prototype instanceof xe ? this : xe).allWithCallback($, {
                        thenCallback: o(W => ({
                            status: "fulfilled",
                            value: W
                        }), "thenCallback"),
                        errorCallback: o(W => ({
                            status: "rejected",
                            reason: W
                        }), "errorCallback")
                    })
                }
                static allWithCallback($, X) {
                    let W, te, _e = new this((A, v) => {
                            W = A, te = v
                        }),
                        we = 2,
                        Ie = 0,
                        Me = [];
                    for (let A of $) {
                        m(A) || (A = this.resolve(A));
                        let v = Ie;
                        try {
                            A.then(y => {
                                Me[v] = X ? X.thenCallback(y) : y, we--, we === 0 && W(Me)
                            }, y => {
                                X ? (Me[v] = X.errorCallback(y), we--, we === 0 && W(Me)) : te(y)
                            })
                        } catch (y) {
                            te(y)
                        }
                        we++, Ie++
                    }
                    return we -= 2, we === 0 && W(Me), _e
                }
                constructor($) {
                    let X = this;
                    if (!(X instanceof xe)) throw new Error("Must be an instanceof Promise.");
                    X[E] = j, X[b] = [];
                    try {
                        let W = oe();
                        $ && $(W(Z(X, Y)), W(Z(X, q)))
                    } catch (W) {
                        M(X, !1, W)
                    }
                }
                get[Symbol.toStringTag]() {
                    return "Promise"
                }
                get[Symbol.species]() {
                    return xe
                }
                then($, X) {
                    var W;
                    let te = (W = this.constructor) === null || W === void 0 ? void 0 : W[Symbol.species];
                    (!te || typeof te != "function") && (te = this.constructor || xe);
                    let _e = new te(N),
                        we = t.current;
                    return this[E] == j ? this[b].push(we, _e, $, X) : Xe(this, we, _e, $, X), _e
                } catch ($) {
                    return this.then(null, $)
                } finally($) {
                    var X;
                    let W = (X = this.constructor) === null || X === void 0 ? void 0 : X[Symbol.species];
                    (!W || typeof W != "function") && (W = xe);
                    let te = new W(N);
                    te[R] = R;
                    let _e = t.current;
                    return this[E] == j ? this[b].push(_e, te, $, $) : Xe(this, _e, te, $, $), te
                }
            };
        o(xe, "ZoneAwarePromise");
        let U = xe;
        U.resolve = U.resolve, U.reject = U.reject, U.race = U.race, U.all = U.all;
        let ve = e[d] = e.Promise;
        e.Promise = U;
        let Te = u("thenPatched");

        function Fe(fe) {
            let $ = fe.prototype,
                X = i($, "then");
            if (X && (X.writable === !1 || !X.configurable)) return;
            let W = $.then;
            $[f] = W, fe.prototype.then = function(te, _e) {
                return new U((Ie, Me) => {
                    W.call(this, Ie, Me)
                }).then(te, _e)
            }, fe[Te] = !0
        }
        o(Fe, "patchThen"), n.patchThen = Fe;

        function rt(fe) {
            return function($, X) {
                let W = fe.apply($, X);
                if (W instanceof U) return W;
                let te = W.constructor;
                return te[Te] || Fe(te), W
            }
        }
        return o(rt, "zoneify"), ve && (Fe(ve), bi(e, "fetch", fe => rt(fe))), Promise[t.__symbol__("uncaughtPromiseErrors")] = l, U
    })
}
o(LY, "patchPromise");

function xY(r) {
    r.__load_patch("toString", e => {
        let t = Function.prototype.toString,
            n = lt("OriginalDelegate"),
            i = lt("Promise"),
            s = lt("Error"),
            a = o(function() {
                if (typeof this == "function") {
                    let d = this[n];
                    if (d) return typeof d == "function" ? t.call(d) : Object.prototype.toString.call(d);
                    if (this === Promise) {
                        let f = e[i];
                        if (f) return t.call(f)
                    }
                    if (this === Error) {
                        let f = e[s];
                        if (f) return t.call(f)
                    }
                }
                return t.call(this)
            }, "toString");
        a[n] = t, Function.prototype.toString = a;
        let u = Object.prototype.toString,
            l = "[object Promise]";
        Object.prototype.toString = function() {
            return typeof Promise == "function" && this instanceof Promise ? l : u.call(this)
        }
    })
}
o(xY, "patchToString");

function UY(r, e, t, n, i) {
    let s = Zone.__symbol__(n);
    if (e[s]) return;
    let a = e[s] = e[n];
    e[n] = function(u, l, c) {
        return l && l.prototype && i.forEach(function(d) {
            let f = `${t}.${n}::` + d,
                h = l.prototype;
            try {
                if (h.hasOwnProperty(d)) {
                    let g = r.ObjectGetOwnPropertyDescriptor(h, d);
                    g && g.value ? (g.value = r.wrapWithCurrentZone(g.value, f), r._redefineProperty(l.prototype, d, g)) : h[d] && (h[d] = r.wrapWithCurrentZone(h[d], f))
                } else h[d] && (h[d] = r.wrapWithCurrentZone(h[d], f))
            } catch (g) {}
        }), a.call(e, u, l, c)
    }, r.attachOriginToPatched(e[n], a)
}
o(UY, "patchCallbacks");

function MY(r) {
    r.__load_patch("util", (e, t, n) => {
        let i = Bw(e);
        n.patchOnProperties = KN, n.patchMethod = bi, n.bindArguments = VT, n.patchMacroTask = TY;
        let s = t.__symbol__("BLACK_LISTED_EVENTS"),
            a = t.__symbol__("UNPATCHED_EVENTS");
        e[a] && (e[s] = e[a]), e[s] && (t[s] = t[a] = e[s]), n.patchEventPrototype = IY, n.patchEventTarget = AY, n.isIEOrEdge = bY, n.ObjectDefineProperty = UT, n.ObjectGetOwnPropertyDescriptor = Bl, n.ObjectCreate = mY, n.ArraySlice = vY, n.patchClass = Il, n.wrapWithCurrentZone = $T, n.filterProperties = eD, n.attachOriginToPatched = Si, n._redefineProperty = Object.defineProperty, n.patchCallbacks = UY, n.getGlobalObjects = () => ({
            globalSources: YN,
            zoneSymbolEventNames: un,
            eventNames: i,
            isBrowser: HT,
            isMix: qN,
            isNode: rp,
            TRUE_STR: Ti,
            FALSE_STR: Ei,
            ZONE_SYMBOL_PREFIX: Vl,
            ADD_EVENT_LISTENER_STR: kT,
            REMOVE_EVENT_LISTENER_STR: FT
        })
    })
}
o(MY, "patchUtil");

function kY(r) {
    LY(r), xY(r), MY(r)
}
o(kY, "patchCommon");
var tD = pY();
kY(tD);
DY(tD);
var aE = class aE {
    emit(e) {}
};
o(aE, "NoopLogger");
var Ig = aE,
    FY = new Ig,
    uE = class uE {
        getLogger(e, t, n) {
            return new Ig
        }
    };
o(uE, "NoopLoggerProvider");
var Vw = uE,
    rD = new Vw,
    cE = class cE {
        constructor(e, t, n, i) {
            this._provider = e, this.name = t, this.version = n, this.options = i
        }
        emit(e) {
            this._getLogger().emit(e)
        }
        _getLogger() {
            if (this._delegate) return this._delegate;
            let e = this._provider._getDelegateLogger(this.name, this.version, this.options);
            return e ? (this._delegate = e, this._delegate) : FY
        }
    };
o(cE, "ProxyLogger");
var Hw = cE,
    lE = class lE {
        getLogger(e, t, n) {
            var i;
            return (i = this._getDelegateLogger(e, t, n)) !== null && i !== void 0 ? i : new Hw(this, e, t, n)
        }
        _getDelegate() {
            var e;
            return (e = this._delegate) !== null && e !== void 0 ? e : rD
        }
        _setDelegate(e) {
            this._delegate = e
        }
        _getDelegateLogger(e, t, n) {
            var i;
            return (i = this._delegate) === null || i === void 0 ? void 0 : i.getLogger(e, t, n)
        }
    };
o(lE, "ProxyLoggerProvider");
var Cg = lE,
    $Y = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof global == "object" ? global : {},
    Dh = Symbol.for("io.opentelemetry.js.api.logs"),
    vl = $Y;

function BY(r, e, t) {
    return n => n === r ? e : t
}
o(BY, "makeGetter");
var gP = 1,
    Wg = class Wg {
        constructor() {
            this._proxyLoggerProvider = new Cg
        }
        static getInstance() {
            return this._instance || (this._instance = new Wg), this._instance
        }
        setGlobalLoggerProvider(e) {
            return vl[Dh] ? this.getLoggerProvider() : (vl[Dh] = BY(gP, e, rD), this._proxyLoggerProvider._setDelegate(e), e)
        }
        getLoggerProvider() {
            var e, t;
            return (t = (e = vl[Dh]) === null || e === void 0 ? void 0 : e.call(vl, gP)) !== null && t !== void 0 ? t : this._proxyLoggerProvider
        }
        getLogger(e, t, n) {
            return this.getLoggerProvider().getLogger(e, t, n)
        }
        disable() {
            delete vl[Dh], this._proxyLoggerProvider = new Cg
        }
    };
o(Wg, "LogsAPI");
var jw = Wg,
    VY = jw.getInstance(),
    Jr = console.error.bind(console);

function yl(r, e, t) {
    let n = !!r[e] && Object.prototype.propertyIsEnumerable.call(r, e);
    Object.defineProperty(r, e, {
        configurable: !0,
        enumerable: n,
        writable: !0,
        value: t
    })
}
o(yl, "defineProperty");
var nD = o((r, e, t) => {
        if (!r || !r[e]) {
            Jr("no original function " + String(e) + " to wrap");
            return
        }
        if (!t) {
            Jr("no wrapper function"), Jr(new Error().stack);
            return
        }
        let n = r[e];
        if (typeof n != "function" || typeof t != "function") {
            Jr("original object and wrapper must be functions");
            return
        }
        let i = t(n, e);
        return yl(i, "__original", n), yl(i, "__unwrap", () => {
            r[e] === i && yl(r, e, n)
        }), yl(i, "__wrapped", !0), yl(r, e, i), i
    }, "wrap"),
    HY = o((r, e, t) => {
        if (r) Array.isArray(r) || (r = [r]);
        else {
            Jr("must provide one or more modules to patch"), Jr(new Error().stack);
            return
        }
        if (!(e && Array.isArray(e))) {
            Jr("must provide one or more functions to wrap on modules");
            return
        }
        r.forEach(n => {
            e.forEach(i => {
                nD(n, i, t)
            })
        })
    }, "massWrap"),
    iD = o((r, e) => {
        if (!r || !r[e]) {
            Jr("no function to unwrap."), Jr(new Error().stack);
            return
        }
        let t = r[e];
        if (!t.__unwrap) Jr("no original to unwrap to -- has " + String(e) + " already been unwrapped?");
        else {
            t.__unwrap();
            return
        }
    }, "unwrap"),
    jY = o((r, e) => {
        if (r) Array.isArray(r) || (r = [r]);
        else {
            Jr("must provide one or more modules to patch"), Jr(new Error().stack);
            return
        }
        if (!(e && Array.isArray(e))) {
            Jr("must provide one or more functions to unwrap on modules");
            return
        }
        r.forEach(t => {
            e.forEach(n => {
                iD(t, n)
            })
        })
    }, "massUnwrap"),
    dE = class dE {
        constructor(e, t, n) {
            fr(this, "instrumentationName", void 0), fr(this, "instrumentationVersion", void 0), fr(this, "_config", {}), fr(this, "_tracer", void 0), fr(this, "_meter", void 0), fr(this, "_logger", void 0), fr(this, "_diag", void 0), fr(this, "_wrap", nD), fr(this, "_unwrap", iD), fr(this, "_massWrap", HY), fr(this, "_massUnwrap", jY), this.instrumentationName = e, this.instrumentationVersion = t, this.setConfig(n), this._diag = ot.createComponentLogger({
                namespace: e
            }), this._tracer = Nr.getTracer(e, t), this._meter = o4.getMeter(e, t), this._logger = VY.getLogger(e, t), this._updateMetricInstruments()
        }
        get meter() {
            return this._meter
        }
        setMeterProvider(e) {
            this._meter = e.getMeter(this.instrumentationName, this.instrumentationVersion), this._updateMetricInstruments()
        }
        get logger() {
            return this._logger
        }
        setLoggerProvider(e) {
            this._logger = e.getLogger(this.instrumentationName, this.instrumentationVersion)
        }
        getModuleDefinitions() {
            var e;
            let t = (e = this.init()) !== null && e !== void 0 ? e : [];
            return Array.isArray(t) ? t : [t]
        }
        _updateMetricInstruments() {}
        getConfig() {
            return this._config
        }
        setConfig(e) {
            this._config = Rt({
                enabled: !0
            }, e)
        }
        setTracerProvider(e) {
            this._tracer = e.getTracer(this.instrumentationName, this.instrumentationVersion)
        }
        get tracer() {
            return this._tracer
        }
        _runSpanCustomizationHook(e, t, n, i) {
            if (e) try {
                e(n, i)
            } catch (s) {
                this._diag.error("Error running span customization hook due to exception in handler", {
                    triggerName: t
                }, s)
            }
        }
    };
o(dE, "InstrumentationAbstract");
var Ww = dE,
    fE = class fE extends Ww {
        constructor(e, t, n) {
            super(e, t, n), this._config.enabled && this.enable()
        }
    };
o(fE, "InstrumentationBase");
var Gw = fE;

function pP(r, e, t) {
    let n, i;
    try {
        i = r()
    } catch (s) {
        n = s
    } finally {
        return e(n, i), i
    }
}
o(pP, "safeExecuteInTheMiddle");

function WY(r) {
    return typeof r == "function" && typeof r.__original == "function" && typeof r.__unwrap == "function" && r.__wrapped === !0
}
o(WY, "isWrapped");
var Vr;
(function(r) {
    r[r.STABLE = 1] = "STABLE", r[r.OLD = 2] = "OLD", r[r.DUPLICATE = 3] = "DUPLICATE"
})(Vr || (Vr = {}));

function GY(r, e) {
    let t = Vr.OLD,
        n = e == null ? void 0 : e.split(",").map(i => i.trim()).filter(i => i !== "");
    for (let i of n != null ? n : [])
        if (i.toLowerCase() === r + "/dup") {
            t = Vr.DUPLICATE;
            break
        } else i.toLowerCase() === r && (t = Vr.STABLE);
    return t
}
o(GY, "semconvStabilityFromStr");
var ow = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof global == "object" ? global : {},
    zw = performance,
    zY = "error.type",
    qY = "http.request.method",
    KY = "http.request.method_original",
    YY = "http.response.status_code",
    XY = "server.address",
    JY = "server.port",
    ZY = "url.full",
    QY = 9,
    eX = 6,
    tX = Math.pow(10, eX),
    qw = Math.pow(10, QY);

function Hl(r) {
    let e = r / 1e3,
        t = Math.trunc(e),
        n = Math.round(r % 1e3 * tX);
    return [t, n]
}
o(Hl, "millisToHrTime");

function sD() {
    let r = zw.timeOrigin;
    if (typeof r != "number") {
        let e = zw;
        r = e.timing && e.timing.fetchStart
    }
    return r
}
o(sD, "getTimeOrigin");

function Kw(r) {
    let e = Hl(sD()),
        t = Hl(typeof r == "number" ? r : zw.now());
    return nX(e, t)
}
o(Kw, "hrTime");

function Ul(r) {
    if (rX(r)) return r;
    if (typeof r == "number") return r < sD() ? Kw(r) : Hl(r);
    if (r instanceof Date) return Hl(r.getTime());
    throw TypeError("Invalid input type")
}
o(Ul, "timeInputToHrTime");

function vs(r) {
    return r[0] * qw + r[1]
}
o(vs, "hrTimeToNanoseconds");

function rX(r) {
    return Array.isArray(r) && r.length === 2 && typeof r[0] == "number" && typeof r[1] == "number"
}
o(rX, "isTimeInputHrTime");

function nX(r, e) {
    let t = [r[0] + e[0], r[1] + e[1]];
    return t[1] >= qw && (t[1] -= qw, t[0] += 1), t
}
o(nX, "addHrTimes");

function oD(r, e) {
    return typeof e == "string" ? r === e : !!r.match(e)
}
o(oD, "urlMatches");

function iX(r, e) {
    if (!e) return !1;
    for (let t of e)
        if (oD(r, t)) return !0;
    return !1
}
o(iX, "isUrlIgnored");
var Ct;
(function(r) {
    r.CONNECT_END = "connectEnd", r.CONNECT_START = "connectStart", r.DECODED_BODY_SIZE = "decodedBodySize", r.DOM_COMPLETE = "domComplete", r.DOM_CONTENT_LOADED_EVENT_END = "domContentLoadedEventEnd", r.DOM_CONTENT_LOADED_EVENT_START = "domContentLoadedEventStart", r.DOM_INTERACTIVE = "domInteractive", r.DOMAIN_LOOKUP_END = "domainLookupEnd", r.DOMAIN_LOOKUP_START = "domainLookupStart", r.ENCODED_BODY_SIZE = "encodedBodySize", r.FETCH_START = "fetchStart", r.LOAD_EVENT_END = "loadEventEnd", r.LOAD_EVENT_START = "loadEventStart", r.NAVIGATION_START = "navigationStart", r.REDIRECT_END = "redirectEnd", r.REDIRECT_START = "redirectStart", r.REQUEST_START = "requestStart", r.RESPONSE_END = "responseEnd", r.RESPONSE_START = "responseStart", r.SECURE_CONNECTION_START = "secureConnectionStart", r.START_TIME = "startTime", r.UNLOAD_EVENT_END = "unloadEventEnd", r.UNLOAD_EVENT_START = "unloadEventStart"
})(Ct || (Ct = {}));
var sX = "http.response_content_length",
    oX = "http.response_content_length_uncompressed",
    aw;

function aX() {
    return aw || (aw = document.createElement("a")), aw
}
o(aX, "getUrlNormalizingAnchor");

function uX(r, e) {
    return e in r
}
o(uX, "hasKey");

function vi(r, e, t) {
    let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0;
    if (uX(t, e) && typeof t[e] == "number" && !(n && t[e] === 0)) return r.addEvent(e, t[e])
}
o(vi, "addSpanNetworkEvent");

function mP(r, e) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
        n = arguments.length > 3 ? arguments[3] : void 0,
        i = arguments.length > 4 ? arguments[4] : void 0;
    if (n === void 0 && (n = e[Ct.START_TIME] !== 0), t || (vi(r, Ct.FETCH_START, e, n), vi(r, Ct.DOMAIN_LOOKUP_START, e, n), vi(r, Ct.DOMAIN_LOOKUP_END, e, n), vi(r, Ct.CONNECT_START, e, n), vi(r, Ct.SECURE_CONNECTION_START, e, n), vi(r, Ct.CONNECT_END, e, n), vi(r, Ct.REQUEST_START, e, n), vi(r, Ct.RESPONSE_START, e, n), vi(r, Ct.RESPONSE_END, e, n)), !i) {
        let s = e[Ct.ENCODED_BODY_SIZE];
        s !== void 0 && r.setAttribute(sX, s);
        let a = e[Ct.DECODED_BODY_SIZE];
        a !== void 0 && s !== a && r.setAttribute(oX, a)
    }
}
o(mP, "addSpanNetworkEvents");

function cX(r) {
    return r.slice().sort((e, t) => {
        let n = e[Ct.FETCH_START],
            i = t[Ct.FETCH_START];
        return n > i ? 1 : n < i ? -1 : 0
    })
}
o(cX, "sortResources");

function aD() {
    return typeof location != "undefined" ? location.origin : void 0
}
o(aD, "getOrigin");

function lX(r, e, t, n) {
    let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : new WeakSet,
        s = arguments.length > 5 ? arguments[5] : void 0,
        a = Rg(r);
    r = a.toString();
    let u = fX(r, e, t, n, i, s);
    if (u.length === 0) return {
        mainRequest: void 0
    };
    if (u.length === 1) return {
        mainRequest: u[0]
    };
    let l = cX(u);
    if (a.origin !== aD() && l.length > 1) {
        let c = l[0],
            d = dX(l, c[Ct.RESPONSE_END], t),
            f = c[Ct.RESPONSE_END];
        return d[Ct.FETCH_START] < f && (d = c, c = void 0), {
            corsPreFlightRequest: c,
            mainRequest: d
        }
    } else return {
        mainRequest: u[0]
    }
}
o(lX, "getResource");

function dX(r, e, t) {
    let n = vs(t),
        i = vs(Ul(e)),
        s = r[1],
        a, u = r.length;
    for (let l = 1; l < u; l++) {
        let c = r[l],
            d = vs(Ul(c[Ct.FETCH_START])),
            f = vs(Ul(c[Ct.RESPONSE_END])),
            h = n - f;
        d >= i && (!a || h < a) && (a = h, s = c)
    }
    return s
}
o(dX, "findMainRequest");

function fX(r, e, t, n, i, s) {
    let a = vs(e),
        u = vs(t),
        l = n.filter(c => {
            let d = vs(Ul(c[Ct.FETCH_START])),
                f = vs(Ul(c[Ct.RESPONSE_END]));
            return c.initiatorType.toLowerCase() === s && c.name === r && d >= a && f <= u
        });
    return l.length > 0 && (l = l.filter(c => !i.has(c))), l
}
o(fX, "filterResourcesForSpan");

function Rg(r) {
    if (typeof URL == "function") return new URL(r, typeof document != "undefined" ? document.baseURI : typeof location != "undefined" ? location.href : void 0);
    let e = aX();
    return e.href = r, e
}
o(Rg, "parseUrl");

function hX(r, e) {
    let t = e || [];
    return (typeof t == "string" || t instanceof RegExp) && (t = [t]), Rg(r).origin === aD() ? !0 : t.some(i => oD(r, i))
}
o(hX, "shouldPropagateTraceHeaders");
var Og;
(function(r) {
    r.COMPONENT = "component", r.HTTP_STATUS_TEXT = "http.status_text"
})(Og || (Og = {}));
var gX = "http.host",
    pX = "http.method",
    mX = "http.request.body.size",
    vX = "http.request_content_length_uncompressed",
    yX = "http.scheme",
    _X = "http.status_code",
    wX = "http.url",
    TX = "http.user_agent",
    uD = ot.createComponentLogger({
        namespace: "@opentelemetry/opentelemetry-instrumentation-fetch/utils"
    });

function EX() {
    if ((arguments.length <= 0 ? void 0 : arguments[0]) instanceof URL || typeof(arguments.length <= 0 ? void 0 : arguments[0]) == "string") {
        let r = arguments.length <= 1 ? void 0 : arguments[1];
        if (!(r != null && r.body)) return Promise.resolve();
        if (r.body instanceof ReadableStream) {
            let {
                body: e,
                length: t
            } = bX(r.body);
            return r.body = e, t
        } else return Promise.resolve(AX(r.body))
    } else {
        let r = arguments.length <= 0 ? void 0 : arguments[0];
        return r != null && r.body ? r.clone().text().then(e => Yw(e)) : Promise.resolve()
    }
}
o(EX, "getFetchBodyLength");

function bX(r) {
    if (!r.pipeThrough) return uD.warn("Platform has ReadableStream but not pipeThrough!"), {
        body: r,
        length: Promise.resolve(void 0)
    };
    let e = 0,
        t, n = new Promise(a => {
            t = a
        }),
        i = new TransformStream({
            start() {},
            transform(a, u) {
                return vt(this, null, function*() {
                    let l = yield a;
                    e += l.byteLength, u.enqueue(a)
                })
            },
            flush() {
                t(e)
            }
        });
    return {
        body: r.pipeThrough(i),
        length: n
    }
}
o(bX, "_getBodyNonDestructively");

function SX(r) {
    return typeof Document != "undefined" && r instanceof Document
}
o(SX, "isDocument");

function AX(r) {
    if (SX(r)) return new XMLSerializer().serializeToString(document).length;
    if (typeof r == "string") return Yw(r);
    if (r instanceof Blob) return r.size;
    if (r instanceof FormData) return CX(r);
    if (r instanceof URLSearchParams) return Yw(r.toString());
    if (r.byteLength !== void 0) return r.byteLength;
    uD.warn("unknown body type")
}
o(AX, "getXHRBodyLength");
var IX = new TextEncoder;

function Yw(r) {
    return IX.encode(r).byteLength
}
o(Yw, "getByteLength");

function CX(r) {
    let e = 0;
    for (let [t, n] of r.entries()) e += t.length, n instanceof Blob ? e += n.size : e += n.length;
    return e
}
o(CX, "getFormDataSize");

function RX(r) {
    let e = PX(),
        t = r.toUpperCase();
    return t in e ? t : "_OTHER"
}
o(RX, "normalizeHttpRequestMethod");
var OX = {
        CONNECT: !0,
        DELETE: !0,
        GET: !0,
        HEAD: !0,
        OPTIONS: !0,
        PATCH: !0,
        POST: !0,
        PUT: !0,
        TRACE: !0
    },
    uw;

function PX() {
    return uw === void 0 && (uw = OX), uw
}
o(PX, "getKnownMethods");
var NX = {
    "https:": "443",
    "http:": "80"
};

function DX(r) {
    let e = Number(r.port || NX[r.protocol]);
    if (e && !isNaN(e)) return e
}
o(DX, "serverPortFromUrl");
var vP = "0.206.0",
    LX = 300,
    yP = typeof process == "object" && ((U_ = process.release) === null || U_ === void 0 ? void 0 : U_.name) === "node",
    hE = class hE extends Gw {
        constructor() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            super("@opentelemetry/instrumentation-fetch", vP, e), fr(this, "component", "fetch"), fr(this, "version", vP), fr(this, "moduleName", this.component), fr(this, "_usedResources", new WeakSet), fr(this, "_tasksCount", 0), fr(this, "_semconvStability", void 0), this._semconvStability = GY("http", e == null ? void 0 : e.semconvStabilityOptIn)
        }
        init() {}
        _addChildSpan(e, t) {
            let n = this.tracer.startSpan("CORS Preflight", {
                    startTime: t[Ct.FETCH_START]
                }, Nr.setSpan(Hr.active(), e)),
                i = !(this._semconvStability & Vr.OLD);
            mP(n, t, this.getConfig().ignoreNetworkEvents, void 0, i), n.end(t[Ct.RESPONSE_END])
        }
        _addFinalSpanAttributes(e, t) {
            let n = Rg(t.url);
            if (this._semconvStability & Vr.OLD && (e.setAttribute(_X, t.status), t.statusText != null && e.setAttribute(Og.HTTP_STATUS_TEXT, t.statusText), e.setAttribute(gX, n.host), e.setAttribute(yX, n.protocol.replace(":", "")), typeof navigator != "undefined" && e.setAttribute(TX, navigator.userAgent)), this._semconvStability & Vr.STABLE) {
                e.setAttribute(YY, t.status), e.setAttribute(XY, n.hostname);
                let i = DX(n);
                i && e.setAttribute(JY, i)
            }
        }
        _addHeaders(e, t) {
            if (!hX(t, this.getConfig().propagateTraceHeaderCorsUrls)) {
                let n = {};
                wi.inject(Hr.active(), n), Object.keys(n).length > 0 && this._diag.debug("headers inject skipped due to CORS policy");
                return
            }
            if (e instanceof Request) wi.inject(Hr.active(), e.headers, {
                set: o((n, i, s) => n.set(i, typeof s == "string" ? s : String(s)), "set")
            });
            else if (e.headers instanceof Headers) wi.inject(Hr.active(), e.headers, {
                set: o((n, i, s) => n.set(i, typeof s == "string" ? s : String(s)), "set")
            });
            else if (e.headers instanceof Map) wi.inject(Hr.active(), e.headers, {
                set: o((n, i, s) => n.set(i, typeof s == "string" ? s : String(s)), "set")
            });
            else {
                let n = {};
                wi.inject(Hr.active(), n), e.headers = Object.assign({}, n, e.headers || {})
            }
        }
        _clearResources() {
            this._tasksCount === 0 && this.getConfig().clearTimingResources && (performance.clearResourceTimings(), this._usedResources = new WeakSet)
        }
        _createSpan(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (iX(e, this.getConfig().ignoreUrls)) {
                this._diag.debug("ignoring span as url matches ignored url");
                return
            }
            let n = "",
                i = {};
            if (this._semconvStability & Vr.OLD) {
                let s = (t.method || "GET").toUpperCase();
                n = `HTTP ${s}`, i[Og.COMPONENT] = this.moduleName, i[pX] = s, i[wX] = e
            }
            if (this._semconvStability & Vr.STABLE) {
                let s = t.method,
                    a = RX(t.method || "GET");
                n || (n = a), i[qY] = a, a !== s && (i[KY] = s), i[ZY] = e
            }
            return this.tracer.startSpan(n, {
                kind: lg.CLIENT,
                attributes: i
            })
        }
        _findResourceAndAddNetworkEvents(e, t, n) {
            let i = t.entries;
            if (!i.length) {
                if (!performance.getEntriesByType) return;
                i = performance.getEntriesByType("resource")
            }
            let s = lX(t.spanUrl, t.startTime, n, i, this._usedResources, "fetch");
            if (s.mainRequest) {
                let a = s.mainRequest;
                this._markResourceAsUsed(a);
                let u = s.corsPreFlightRequest;
                u && (this._addChildSpan(e, u), this._markResourceAsUsed(u));
                let l = !(this._semconvStability & Vr.OLD);
                mP(e, a, this.getConfig().ignoreNetworkEvents, void 0, l)
            }
        }
        _markResourceAsUsed(e) {
            this._usedResources.add(e)
        }
        _endSpan(e, t, n) {
            let i = Hl(Date.now()),
                s = Kw();
            this._addFinalSpanAttributes(e, n), this._semconvStability & Vr.STABLE && n.status >= 400 && (e.setStatus({
                code: Fl.ERROR
            }), e.setAttribute(zY, String(n.status))), setTimeout(() => {
                var a;
                (a = t.observer) === null || a === void 0 || a.disconnect(), this._findResourceAndAddNetworkEvents(e, t, s), this._tasksCount--, this._clearResources(), e.end(i)
            }, LX)
        }
        _patchConstructor() {
            return e => {
                let t = this;
                return o(function() {
                    let i = this;
                    for (var s = arguments.length, a = new Array(s), u = 0; u < s; u++) a[u] = arguments[u];
                    let l = Rg(a[0] instanceof Request ? a[0].url : String(a[0])).href,
                        c = a[0] instanceof Request ? a[0] : a[1] || {},
                        d = t._createSpan(l, c);
                    if (!d) return e.apply(this, a);
                    let f = t._prepareSpanData(l);
                    t.getConfig().measureRequestSize && EX(...a).then(T => {
                        T && (t._semconvStability & Vr.OLD && d.setAttribute(vX, T), t._semconvStability & Vr.STABLE && d.setAttribute(mX, T))
                    }).catch(T => {
                        t._diag.warn("getFetchBodyLength", T)
                    });

                    function h(T, E) {
                        t._applyAttributesAfterFetch(T, c, E), t._endSpan(T, f, {
                            status: E.status || 0,
                            statusText: E.message,
                            url: l
                        })
                    }
                    o(h, "endSpanOnError");

                    function g(T, E) {
                        t._applyAttributesAfterFetch(T, c, E), E.status >= 200 && E.status < 400 ? t._endSpan(T, f, E) : t._endSpan(T, f, {
                            status: E.status,
                            statusText: E.statusText,
                            url: l
                        })
                    }
                    o(g, "endSpanOnSuccess");

                    function p(T, E) {
                        if (!T) return null;
                        let b = T.getReader();
                        return new ReadableStream({
                            pull(L) {
                                return vt(this, null, function*() {
                                    try {
                                        let {
                                            value: V,
                                            done: z
                                        } = yield b.read();
                                        z ? (b.releaseLock(), L.close()) : L.enqueue(V)
                                    } catch (V) {
                                        L.error(V), b.cancel(V).catch(z => {});
                                        try {
                                            b.releaseLock()
                                        } catch (z) {}
                                    }
                                })
                            },
                            cancel(L) {
                                return E.cancel(L).catch(V => {}), b.cancel(L)
                            }
                        })
                    }
                    o(p, "withCancelPropagation");

                    function m(T, E, b) {
                        let R = null;
                        try {
                            let V = b.clone().body;
                            if (V) {
                                let z = V.getReader(),
                                    j = p(b.body, z);
                                R = new Response(j, {
                                    status: b.status,
                                    statusText: b.statusText,
                                    headers: b.headers
                                });
                                let Y = o(() => {
                                    z.read().then(q => {
                                        let {
                                            done: P
                                        } = q;
                                        P ? g(T, b) : Y()
                                    }, q => {
                                        h(T, q)
                                    })
                                }, "read");
                                Y()
                            } else g(T, b)
                        } finally {
                            E(R != null ? R : b)
                        }
                    }
                    o(m, "onSuccess");

                    function w(T, E, b) {
                        try {
                            h(T, b)
                        } finally {
                            E(b)
                        }
                    }
                    return o(w, "onError"), new Promise((T, E) => Hr.with(Nr.setSpan(Hr.active(), d), () => (t._addHeaders(c, l), t._callRequestHook(d, c), t._tasksCount++, e.apply(i, c instanceof Request ? [c] : [l, c]).then(m.bind(i, d, T), w.bind(i, d, E)))))
                }, "patchConstructor")
            }
        }
        _applyAttributesAfterFetch(e, t, n) {
            let i = this.getConfig().applyCustomAttributesOnSpan;
            i && pP(() => i(e, t, n), s => {
                s && this._diag.error("applyCustomAttributesOnSpan", s)
            })
        }
        _callRequestHook(e, t) {
            let n = this.getConfig().requestHook;
            n && pP(() => n(e, t), i => {
                i && this._diag.error("requestHook", i)
            })
        }
        _prepareSpanData(e) {
            let t = Kw(),
                n = [];
            if (typeof PerformanceObserver != "function") return {
                entries: n,
                startTime: t,
                spanUrl: e
            };
            let i = new PerformanceObserver(s => {
                s.getEntries().forEach(u => {
                    u.initiatorType === "fetch" && u.name === e && n.push(u)
                })
            });
            return i.observe({
                entryTypes: ["resource"]
            }), {
                entries: n,
                observer: i,
                startTime: t,
                spanUrl: e
            }
        }
        enable() {
            if (yP) {
                this._diag.warn("this instrumentation is intended for web usage only, it does not instrument Node.js's fetch()");
                return
            }
            WY(fetch) && (this._unwrap(ow, "fetch"), this._diag.debug("removing previous patch for constructor")), this._wrap(ow, "fetch", this._patchConstructor())
        }
        disable() {
            yP || (this._unwrap(ow, "fetch"), this._usedResources = new WeakSet)
        }
    };
o(hE, "FetchInstrumentation");
var Xw = hE,
    xX = "exception",
    UX = function(r) {
        var e = typeof Symbol == "function" && Symbol.iterator,
            t = e && r[e],
            n = 0;
        if (t) return t.call(r);
        if (r && typeof r.length == "number") return {
            next: o(function() {
                return r && n >= r.length && (r = void 0), {
                    value: r && r[n++],
                    done: !r
                }
            }, "next")
        };
        throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
    },
    _P = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    },
    MX = function(r, e, t) {
        if (t || arguments.length === 2)
            for (var n = 0, i = e.length, s; n < i; n++)(s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
        return r.concat(s || Array.prototype.slice.call(e))
    },
    kX = (function() {
        function r(e, t, n, i, s, a, u, l, c, d) {
            u === void 0 && (u = []), this.attributes = {}, this.links = [], this.events = [], this._droppedAttributesCount = 0, this._droppedEventsCount = 0, this._droppedLinksCount = 0, this.status = {
                code: Fl.UNSET
            }, this.endTime = [0, 0], this._ended = !1, this._duration = [-1, -1], this.name = n, this._spanContext = i, this.parentSpanId = a, this.kind = s, this.links = u;
            var f = Date.now();
            this._performanceStartTime = Fa.now(), this._performanceOffset = f - (this._performanceStartTime + BP()), this._startTimeProvided = l != null, this.startTime = this._getTime(l != null ? l : f), this.resource = e.resource, this.instrumentationLibrary = e.instrumentationLibrary, this._spanLimits = e.getSpanLimits(), this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0, d != null && this.setAttributes(d), this._spanProcessor = e.getActiveSpanProcessor(), this._spanProcessor.onStart(this, t)
        }
        return o(r, "Span"), r.prototype.spanContext = function() {
            return this._spanContext
        }, r.prototype.setAttribute = function(e, t) {
            return t == null || this._isSpanEnded() ? this : e.length === 0 ? (ot.warn("Invalid attribute key: " + e), this) : xP(t) ? Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, e) ? (this._droppedAttributesCount++, this) : (this.attributes[e] = this._truncateToSize(t), this) : (ot.warn("Invalid attribute value set for key: " + e), this)
        }, r.prototype.setAttributes = function(e) {
            var t, n;
            try {
                for (var i = UX(Object.entries(e)), s = i.next(); !s.done; s = i.next()) {
                    var a = _P(s.value, 2),
                        u = a[0],
                        l = a[1];
                    this.setAttribute(u, l)
                }
            } catch (c) {
                t = {
                    error: c
                }
            } finally {
                try {
                    s && !s.done && (n = i.return) && n.call(i)
                } finally {
                    if (t) throw t.error
                }
            }
            return this
        }, r.prototype.addEvent = function(e, t, n) {
            if (this._isSpanEnded()) return this;
            if (this._spanLimits.eventCountLimit === 0) return ot.warn("No events allowed."), this._droppedEventsCount++, this;
            this.events.length >= this._spanLimits.eventCountLimit && (this._droppedEventsCount === 0 && ot.debug("Dropping extra events."), this.events.shift(), this._droppedEventsCount++), vO(t) && (vO(n) || (n = t), t = void 0);
            var i = Uh(t);
            return this.events.push({
                name: e,
                attributes: i,
                time: this._getTime(n),
                droppedAttributesCount: 0
            }), this
        }, r.prototype.addLink = function(e) {
            return this.links.push(e), this
        }, r.prototype.addLinks = function(e) {
            var t;
            return (t = this.links).push.apply(t, MX([], _P(e), !1)), this
        }, r.prototype.setStatus = function(e) {
            return this._isSpanEnded() ? this : (this.status = e, this)
        }, r.prototype.updateName = function(e) {
            return this._isSpanEnded() ? this : (this.name = e, this)
        }, r.prototype.end = function(e) {
            if (this._isSpanEnded()) {
                ot.error(this.name + " " + this._spanContext.traceId + "-" + this._spanContext.spanId + " - You can only call end() on a span once.");
                return
            }
            this._ended = !0, this.endTime = this._getTime(e), this._duration = uj(this.startTime, this.endTime), this._duration[0] < 0 && (ot.warn("Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.", this.startTime, this.endTime), this.endTime = this.startTime.slice(), this._duration = [0, 0]), this._droppedEventsCount > 0 && ot.warn("Dropped " + this._droppedEventsCount + " events because eventCountLimit reached"), this._spanProcessor.onEnd(this)
        }, r.prototype._getTime = function(e) {
            if (typeof e == "number" && e < Fa.now()) return VP(e + this._performanceOffset);
            if (typeof e == "number") return Da(e);
            if (e instanceof Date) return Da(e.getTime());
            if (HP(e)) return e;
            if (this._startTimeProvided) return Da(Date.now());
            var t = Fa.now() - this._performanceStartTime;
            return jP(this.startTime, Da(t))
        }, r.prototype.isRecording = function() {
            return this._ended === !1
        }, r.prototype.recordException = function(e, t) {
            var n = {};
            typeof e == "string" ? n[j_] = e : e && (e.code ? n[H_] = e.code.toString() : e.name && (n[H_] = e.name), e.message && (n[j_] = e.message), e.stack && (n[X4] = e.stack)), n[H_] || n[j_] ? this.addEvent(xX, n, t) : ot.warn("Failed to record an exception " + e)
        }, Object.defineProperty(r.prototype, "duration", {
            get: o(function() {
                return this._duration
            }, "get"),
            enumerable: !1,
            configurable: !0
        }), Object.defineProperty(r.prototype, "ended", {
            get: o(function() {
                return this._ended
            }, "get"),
            enumerable: !1,
            configurable: !0
        }), Object.defineProperty(r.prototype, "droppedAttributesCount", {
            get: o(function() {
                return this._droppedAttributesCount
            }, "get"),
            enumerable: !1,
            configurable: !0
        }), Object.defineProperty(r.prototype, "droppedEventsCount", {
            get: o(function() {
                return this._droppedEventsCount
            }, "get"),
            enumerable: !1,
            configurable: !0
        }), Object.defineProperty(r.prototype, "droppedLinksCount", {
            get: o(function() {
                return this._droppedLinksCount
            }, "get"),
            enumerable: !1,
            configurable: !0
        }), r.prototype._isSpanEnded = function() {
            return this._ended && ot.warn("Can not execute the operation on ended Span {traceId: " + this._spanContext.traceId + ", spanId: " + this._spanContext.spanId + "}"), this._ended
        }, r.prototype._truncateToLimitUtil = function(e, t) {
            return e.length <= t ? e : e.substr(0, t)
        }, r.prototype._truncateToSize = function(e) {
            var t = this,
                n = this._attributeValueLengthLimit;
            return n <= 0 ? (ot.warn("Attribute value limit must be positive, got " + n), e) : typeof e == "string" ? this._truncateToLimitUtil(e, n) : Array.isArray(e) ? e.map(function(i) {
                return typeof i == "string" ? t._truncateToLimitUtil(i, n) : i
            }) : e
        }, r
    })(),
    Va;
(function(r) {
    r[r.NOT_RECORD = 0] = "NOT_RECORD", r[r.RECORD = 1] = "RECORD", r[r.RECORD_AND_SAMPLED = 2] = "RECORD_AND_SAMPLED"
})(Va || (Va = {}));
var Pg = (function() {
        function r() {}
        return o(r, "AlwaysOffSampler"), r.prototype.shouldSample = function() {
            return {
                decision: Va.NOT_RECORD
            }
        }, r.prototype.toString = function() {
            return "AlwaysOffSampler"
        }, r
    })(),
    $a = (function() {
        function r() {}
        return o(r, "AlwaysOnSampler"), r.prototype.shouldSample = function() {
            return {
                decision: Va.RECORD_AND_SAMPLED
            }
        }, r.prototype.toString = function() {
            return "AlwaysOnSampler"
        }, r
    })(),
    cw = (function() {
        function r(e) {
            var t, n, i, s;
            this._root = e.root, this._root || (dg(new Error("ParentBasedSampler must have a root sampler configured")), this._root = new $a), this._remoteParentSampled = (t = e.remoteParentSampled) !== null && t !== void 0 ? t : new $a, this._remoteParentNotSampled = (n = e.remoteParentNotSampled) !== null && n !== void 0 ? n : new Pg, this._localParentSampled = (i = e.localParentSampled) !== null && i !== void 0 ? i : new $a, this._localParentNotSampled = (s = e.localParentNotSampled) !== null && s !== void 0 ? s : new Pg
        }
        return o(r, "ParentBasedSampler"), r.prototype.shouldSample = function(e, t, n, i, s, a) {
            var u = Nr.getSpanContext(e);
            return !u || !qg(u) ? this._root.shouldSample(e, t, n, i, s, a) : u.isRemote ? u.traceFlags & Ai.SAMPLED ? this._remoteParentSampled.shouldSample(e, t, n, i, s, a) : this._remoteParentNotSampled.shouldSample(e, t, n, i, s, a) : u.traceFlags & Ai.SAMPLED ? this._localParentSampled.shouldSample(e, t, n, i, s, a) : this._localParentNotSampled.shouldSample(e, t, n, i, s, a)
        }, r.prototype.toString = function() {
            return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}"
        }, r
    })(),
    wP = (function() {
        function r(e) {
            e === void 0 && (e = 0), this._ratio = e, this._ratio = this._normalize(e), this._upperBound = Math.floor(this._ratio * 4294967295)
        }
        return o(r, "TraceIdRatioBasedSampler"), r.prototype.shouldSample = function(e, t) {
            return {
                decision: OP(t) && this._accumulate(t) < this._upperBound ? Va.RECORD_AND_SAMPLED : Va.NOT_RECORD
            }
        }, r.prototype.toString = function() {
            return "TraceIdRatioBased{" + this._ratio + "}"
        }, r.prototype._normalize = function(e) {
            return typeof e != "number" || isNaN(e) ? 0 : e >= 1 ? 1 : e <= 0 ? 0 : e
        }, r.prototype._accumulate = function(e) {
            for (var t = 0, n = 0; n < e.length / 8; n++) {
                var i = n * 8,
                    s = parseInt(e.slice(i, i + 8), 16);
                t = (t ^ s) >>> 0
            }
            return t
        }, r
    })(),
    FX = Ba(),
    $X = Yn.AlwaysOn,
    _a = 1;

function cD() {
    var r = Ba();
    return {
        sampler: lD(FX),
        forceFlushTimeoutMillis: 3e4,
        generalLimits: {
            attributeValueLengthLimit: r.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
            attributeCountLimit: r.OTEL_ATTRIBUTE_COUNT_LIMIT
        },
        spanLimits: {
            attributeValueLengthLimit: r.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
            attributeCountLimit: r.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
            linkCountLimit: r.OTEL_SPAN_LINK_COUNT_LIMIT,
            eventCountLimit: r.OTEL_SPAN_EVENT_COUNT_LIMIT,
            attributePerEventCountLimit: r.OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
            attributePerLinkCountLimit: r.OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT
        }
    }
}
o(cD, "loadDefaultConfig");

function lD(r) {
    switch (r === void 0 && (r = Ba()), r.OTEL_TRACES_SAMPLER) {
        case Yn.AlwaysOn:
            return new $a;
        case Yn.AlwaysOff:
            return new Pg;
        case Yn.ParentBasedAlwaysOn:
            return new cw({
                root: new $a
            });
        case Yn.ParentBasedAlwaysOff:
            return new cw({
                root: new Pg
            });
        case Yn.TraceIdRatio:
            return new wP(TP(r));
        case Yn.ParentBasedTraceIdRatio:
            return new cw({
                root: new wP(TP(r))
            });
        default:
            return ot.error('OTEL_TRACES_SAMPLER value "' + r.OTEL_TRACES_SAMPLER + " invalid, defaulting to " + $X + '".'), new $a
    }
}
o(lD, "buildSamplerFromEnv");

function TP(r) {
    if (r.OTEL_TRACES_SAMPLER_ARG === void 0 || r.OTEL_TRACES_SAMPLER_ARG === "") return ot.error("OTEL_TRACES_SAMPLER_ARG is blank, defaulting to " + _a + "."), _a;
    var e = Number(r.OTEL_TRACES_SAMPLER_ARG);
    return isNaN(e) ? (ot.error("OTEL_TRACES_SAMPLER_ARG=" + r.OTEL_TRACES_SAMPLER_ARG + " was given, but it is invalid, defaulting to " + _a + "."), _a) : e < 0 || e > 1 ? (ot.error("OTEL_TRACES_SAMPLER_ARG=" + r.OTEL_TRACES_SAMPLER_ARG + " was given, but it is out of range ([0..1]), defaulting to " + _a + "."), _a) : e
}
o(TP, "getSamplerProbabilityFromEnv");

function BX(r) {
    var e = {
            sampler: lD()
        },
        t = cD(),
        n = Object.assign({}, t, e, r);
    return n.generalLimits = Object.assign({}, t.generalLimits, r.generalLimits || {}), n.spanLimits = Object.assign({}, t.spanLimits, r.spanLimits || {}), n
}
o(BX, "mergeConfig");

function VX(r) {
    var e, t, n, i, s, a, u, l, c, d, f, h, g = Object.assign({}, r.spanLimits),
        p = G4();
    return g.attributeCountLimit = (a = (s = (i = (t = (e = r.spanLimits) === null || e === void 0 ? void 0 : e.attributeCountLimit) !== null && t !== void 0 ? t : (n = r.generalLimits) === null || n === void 0 ? void 0 : n.attributeCountLimit) !== null && i !== void 0 ? i : p.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && s !== void 0 ? s : p.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && a !== void 0 ? a : kh, g.attributeValueLengthLimit = (h = (f = (d = (l = (u = r.spanLimits) === null || u === void 0 ? void 0 : u.attributeValueLengthLimit) !== null && l !== void 0 ? l : (c = r.generalLimits) === null || c === void 0 ? void 0 : c.attributeValueLengthLimit) !== null && d !== void 0 ? d : p.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && f !== void 0 ? f : p.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && h !== void 0 ? h : Mh, Object.assign({}, r, {
        spanLimits: g
    })
}
o(VX, "reconfigureLimits");
var HX = (function() {
        function r(e, t) {
            this._exporter = e, this._isExporting = !1, this._finishedSpans = [], this._droppedSpansCount = 0;
            var n = Ba();
            this._maxExportBatchSize = typeof(t == null ? void 0 : t.maxExportBatchSize) == "number" ? t.maxExportBatchSize : n.OTEL_BSP_MAX_EXPORT_BATCH_SIZE, this._maxQueueSize = typeof(t == null ? void 0 : t.maxQueueSize) == "number" ? t.maxQueueSize : n.OTEL_BSP_MAX_QUEUE_SIZE, this._scheduledDelayMillis = typeof(t == null ? void 0 : t.scheduledDelayMillis) == "number" ? t.scheduledDelayMillis : n.OTEL_BSP_SCHEDULE_DELAY, this._exportTimeoutMillis = typeof(t == null ? void 0 : t.exportTimeoutMillis) == "number" ? t.exportTimeoutMillis : n.OTEL_BSP_EXPORT_TIMEOUT, this._shutdownOnce = new qj(this._shutdown, this), this._maxExportBatchSize > this._maxQueueSize && (ot.warn("BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize"), this._maxExportBatchSize = this._maxQueueSize)
        }
        return o(r, "BatchSpanProcessorBase"), r.prototype.forceFlush = function() {
            return this._shutdownOnce.isCalled ? this._shutdownOnce.promise : this._flushAll()
        }, r.prototype.onStart = function(e, t) {}, r.prototype.onEnd = function(e) {
            this._shutdownOnce.isCalled || (e.spanContext().traceFlags & Ai.SAMPLED) !== 0 && this._addToBuffer(e)
        }, r.prototype.shutdown = function() {
            return this._shutdownOnce.call()
        }, r.prototype._shutdown = function() {
            var e = this;
            return Promise.resolve().then(function() {
                return e.onShutdown()
            }).then(function() {
                return e._flushAll()
            }).then(function() {
                return e._exporter.shutdown()
            })
        }, r.prototype._addToBuffer = function(e) {
            if (this._finishedSpans.length >= this._maxQueueSize) {
                this._droppedSpansCount === 0 && ot.debug("maxQueueSize reached, dropping spans"), this._droppedSpansCount++;
                return
            }
            this._droppedSpansCount > 0 && (ot.warn("Dropped " + this._droppedSpansCount + " spans because maxQueueSize reached"), this._droppedSpansCount = 0), this._finishedSpans.push(e), this._maybeStartTimer()
        }, r.prototype._flushAll = function() {
            var e = this;
            return new Promise(function(t, n) {
                for (var i = [], s = Math.ceil(e._finishedSpans.length / e._maxExportBatchSize), a = 0, u = s; a < u; a++) i.push(e._flushOneBatch());
                Promise.all(i).then(function() {
                    t()
                }).catch(n)
            })
        }, r.prototype._flushOneBatch = function() {
            var e = this;
            return this._clearTimer(), this._finishedSpans.length === 0 ? Promise.resolve() : new Promise(function(t, n) {
                var i = setTimeout(function() {
                    n(new Error("Timeout"))
                }, e._exportTimeoutMillis);
                Hr.with(g4(Hr.active()), function() {
                    var s;
                    e._finishedSpans.length <= e._maxExportBatchSize ? (s = e._finishedSpans, e._finishedSpans = []) : s = e._finishedSpans.splice(0, e._maxExportBatchSize);
                    for (var a = o(function() {
                            return e._exporter.export(s, function(f) {
                                var h;
                                clearTimeout(i), f.code === pw.SUCCESS ? t() : n((h = f.error) !== null && h !== void 0 ? h : new Error("BatchSpanProcessor: span export failed"))
                            })
                        }, "doExport"), u = null, l = 0, c = s.length; l < c; l++) {
                        var d = s[l];
                        d.resource.asyncAttributesPending && d.resource.waitForAsyncAttributes && (u != null || (u = []), u.push(d.resource.waitForAsyncAttributes()))
                    }
                    u === null ? a() : Promise.all(u).then(a, function(f) {
                        dg(f), n(f)
                    })
                })
            })
        }, r.prototype._maybeStartTimer = function() {
            var e = this;
            if (!this._isExporting) {
                var t = o(function() {
                    e._isExporting = !0, e._flushOneBatch().finally(function() {
                        e._isExporting = !1, e._finishedSpans.length > 0 && (e._clearTimer(), e._maybeStartTimer())
                    }).catch(function(n) {
                        e._isExporting = !1, dg(n)
                    })
                }, "flush");
                if (this._finishedSpans.length >= this._maxExportBatchSize) return t();
                this._timer === void 0 && (this._timer = setTimeout(function() {
                    return t()
                }, this._scheduledDelayMillis), this._timer, void 0)
            }
        }, r.prototype._clearTimer = function() {
            this._timer !== void 0 && (clearTimeout(this._timer), this._timer = void 0)
        }, r
    })(),
    jX = (function() {
        var r = o(function(e, t) {
            return r = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array && function(n, i) {
                n.__proto__ = i
            } || function(n, i) {
                for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s])
            }, r(e, t)
        }, "extendStatics");
        return function(e, t) {
            if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
            r(e, t);

            function n() {
                this.constructor = e
            }
            o(n, "__"), e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n)
        }
    })(),
    WX = (function(r) {
        jX(e, r);

        function e(t, n) {
            var i = r.call(this, t, n) || this;
            return i.onInit(n), i
        }
        return o(e, "BatchSpanProcessor"), e.prototype.onInit = function(t) {
            var n = this;
            (t == null ? void 0 : t.disableAutoFlushOnDocumentHide) !== !0 && typeof document != "undefined" && (this._visibilityChangeListener = function() {
                document.visibilityState === "hidden" && n.forceFlush()
            }, this._pageHideListener = function() {
                n.forceFlush()
            }, document.addEventListener("visibilitychange", this._visibilityChangeListener), document.addEventListener("pagehide", this._pageHideListener))
        }, e.prototype.onShutdown = function() {
            typeof document != "undefined" && (this._visibilityChangeListener && document.removeEventListener("visibilitychange", this._visibilityChangeListener), this._pageHideListener && document.removeEventListener("pagehide", this._pageHideListener))
        }, e
    })(HX),
    GX = 8,
    zX = 16,
    qX = (function() {
        function r() {
            this.generateTraceId = EP(zX), this.generateSpanId = EP(GX)
        }
        return o(r, "RandomIdGenerator"), r
    })(),
    Lh = Array(32);

function EP(r) {
    return o(function() {
        for (var t = 0; t < r * 2; t++) Lh[t] = Math.floor(Math.random() * 16) + 48, Lh[t] >= 58 && (Lh[t] += 39);
        return String.fromCharCode.apply(null, Lh.slice(0, r * 2))
    }, "generateId")
}
o(EP, "getIdGenerator");
var KX = (function() {
    function r(e, t, n) {
        this._tracerProvider = n;
        var i = BX(t);
        this._sampler = i.sampler, this._generalLimits = i.generalLimits, this._spanLimits = i.spanLimits, this._idGenerator = t.idGenerator || new qX, this.resource = n.resource, this.instrumentationLibrary = e
    }
    return o(r, "Tracer"), r.prototype.startSpan = function(e, t, n) {
        var i, s, a;
        t === void 0 && (t = {}), n === void 0 && (n = Hr.active()), t.root && (n = Nr.deleteSpan(n));
        var u = Nr.getSpan(n);
        if (TT(n)) {
            ot.debug("Instrumentation suppressed, returning Noop Span");
            var l = Nr.wrapSpanContext(CP);
            return l
        }
        var c = u == null ? void 0 : u.spanContext(),
            d = this._idGenerator.generateSpanId(),
            f, h, g;
        !c || !Nr.isSpanContextValid(c) ? f = this._idGenerator.generateTraceId() : (f = c.traceId, h = c.traceState, g = c.spanId);
        var p = (i = t.kind) !== null && i !== void 0 ? i : lg.INTERNAL,
            m = ((s = t.links) !== null && s !== void 0 ? s : []).map(function(V) {
                return {
                    context: V.context,
                    attributes: Uh(V.attributes)
                }
            }),
            w = Uh(t.attributes),
            T = this._sampler.shouldSample(n, f, e, p, w, m);
        h = (a = T.traceState) !== null && a !== void 0 ? a : h;
        var E = T.decision === cg.RECORD_AND_SAMPLED ? Ai.SAMPLED : Ai.NONE,
            b = {
                traceId: f,
                spanId: d,
                traceFlags: E,
                traceState: h
            };
        if (T.decision === cg.NOT_RECORD) {
            ot.debug("Recording is off, propagating context in a non-recording span");
            var l = Nr.wrapSpanContext(b);
            return l
        }
        var R = Uh(Object.assign(w, T.attributes)),
            L = new kX(this, n, e, b, p, g, m, t.startTime, void 0, R);
        return L
    }, r.prototype.startActiveSpan = function(e, t, n, i) {
        var s, a, u;
        if (!(arguments.length < 2)) {
            arguments.length === 2 ? u = t : arguments.length === 3 ? (s = t, u = n) : (s = t, a = n, u = i);
            var l = a != null ? a : Hr.active(),
                c = this.startSpan(e, s, l),
                d = Nr.setSpan(l, c);
            return Hr.with(d, u, void 0, c)
        }
    }, r.prototype.getGeneralLimits = function() {
        return this._generalLimits
    }, r.prototype.getSpanLimits = function() {
        return this._spanLimits
    }, r.prototype.getActiveSpanProcessor = function() {
        return this._tracerProvider.getActiveSpanProcessor()
    }, r
})();

function YX() {
    return "unknown_service"
}
o(YX, "defaultServiceName");
var ps = function() {
        return ps = Object.assign || function(r) {
            for (var e, t = 1, n = arguments.length; t < n; t++) {
                e = arguments[t];
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (r[i] = e[i])
            }
            return r
        }, ps.apply(this, arguments)
    },
    XX = function(r, e, t, n) {
        function i(s) {
            return s instanceof t ? s : new t(function(a) {
                a(s)
            })
        }
        return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
            function u(d) {
                try {
                    c(n.next(d))
                } catch (f) {
                    a(f)
                }
            }
            o(u, "fulfilled");

            function l(d) {
                try {
                    c(n.throw(d))
                } catch (f) {
                    a(f)
                }
            }
            o(l, "rejected");

            function c(d) {
                d.done ? s(d.value) : i(d.value).then(u, l)
            }
            o(c, "step"), c((n = n.apply(r, e || [])).next())
        })
    },
    JX = function(r, e) {
        var t = {
                label: 0,
                sent: o(function() {
                    if (s[0] & 1) throw s[1];
                    return s[1]
                }, "sent"),
                trys: [],
                ops: []
            },
            n, i, s, a;
        return a = {
            next: u(0),
            throw: u(1),
            return: u(2)
        }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
            return this
        }), a;

        function u(c) {
            return function(d) {
                return l([c, d])
            }
        }

        function l(c) {
            if (n) throw new TypeError("Generator is already executing.");
            for (; t;) try {
                if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
                switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                    case 0:
                    case 1:
                        s = c;
                        break;
                    case 4:
                        return t.label++, {
                            value: c[1],
                            done: !1
                        };
                    case 5:
                        t.label++, i = c[1], c = [0];
                        continue;
                    case 7:
                        c = t.ops.pop(), t.trys.pop();
                        continue;
                    default:
                        if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                            t = 0;
                            continue
                        }
                        if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                            t.label = c[1];
                            break
                        }
                        if (c[0] === 6 && t.label < s[1]) {
                            t.label = s[1], s = c;
                            break
                        }
                        if (s && t.label < s[2]) {
                            t.label = s[2], t.ops.push(c);
                            break
                        }
                        s[2] && t.ops.pop(), t.trys.pop();
                        continue
                }
                c = e.call(r, t)
            } catch (d) {
                c = [6, d], i = 0
            } finally {
                n = s = 0
            }
            if (c[0] & 5) throw c[1];
            return {
                value: c[0] ? c[1] : void 0,
                done: !0
            }
        }
    },
    ZX = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    },
    bP = (function() {
        function r(e, t) {
            var n = this,
                i;
            this._attributes = e, this.asyncAttributesPending = t != null, this._syncAttributes = (i = this._attributes) !== null && i !== void 0 ? i : {}, this._asyncAttributesPromise = t == null ? void 0 : t.then(function(s) {
                return n._attributes = Object.assign({}, n._attributes, s), n.asyncAttributesPending = !1, s
            }, function(s) {
                return ot.debug("a resource's async attributes promise rejected: %s", s), n.asyncAttributesPending = !1, {}
            })
        }
        return o(r, "Resource"), r.empty = function() {
            return r.EMPTY
        }, r.default = function() {
            var e;
            return new r((e = {}, e[nj] = YX(), e[hw] = W_[hw], e[fw] = W_[fw], e[gw] = W_[gw], e))
        }, Object.defineProperty(r.prototype, "attributes", {
            get: o(function() {
                var e;
                return this.asyncAttributesPending && ot.error("Accessing resource attributes before async attributes settled"), (e = this._attributes) !== null && e !== void 0 ? e : {}
            }, "get"),
            enumerable: !1,
            configurable: !0
        }), r.prototype.waitForAsyncAttributes = function() {
            return XX(this, void 0, void 0, function() {
                return JX(this, function(e) {
                    switch (e.label) {
                        case 0:
                            return this.asyncAttributesPending ? [4, this._asyncAttributesPromise] : [3, 2];
                        case 1:
                            e.sent(), e.label = 2;
                        case 2:
                            return [2]
                    }
                })
            })
        }, r.prototype.merge = function(e) {
            var t = this,
                n;
            if (!e) return this;
            var i = ps(ps({}, this._syncAttributes), (n = e._syncAttributes) !== null && n !== void 0 ? n : e.attributes);
            if (!this._asyncAttributesPromise && !e._asyncAttributesPromise) return new r(i);
            var s = Promise.all([this._asyncAttributesPromise, e._asyncAttributesPromise]).then(function(a) {
                var u, l = ZX(a, 2),
                    c = l[0],
                    d = l[1];
                return ps(ps(ps(ps({}, t._syncAttributes), c), (u = e._syncAttributes) !== null && u !== void 0 ? u : e.attributes), d)
            });
            return new r(i, s)
        }, r.EMPTY = new r({}), r
    })(),
    xh = function(r) {
        var e = typeof Symbol == "function" && Symbol.iterator,
            t = e && r[e],
            n = 0;
        if (t) return t.call(r);
        if (r && typeof r.length == "number") return {
            next: o(function() {
                return r && n >= r.length && (r = void 0), {
                    value: r && r[n++],
                    done: !r
                }
            }, "next")
        };
        throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
    },
    QX = (function() {
        function r(e) {
            this._spanProcessors = e
        }
        return o(r, "MultiSpanProcessor"), r.prototype.forceFlush = function() {
            var e, t, n = [];
            try {
                for (var i = xh(this._spanProcessors), s = i.next(); !s.done; s = i.next()) {
                    var a = s.value;
                    n.push(a.forceFlush())
                }
            } catch (u) {
                e = {
                    error: u
                }
            } finally {
                try {
                    s && !s.done && (t = i.return) && t.call(i)
                } finally {
                    if (e) throw e.error
                }
            }
            return new Promise(function(u) {
                Promise.all(n).then(function() {
                    u()
                }).catch(function(l) {
                    dg(l || new Error("MultiSpanProcessor: forceFlush failed")), u()
                })
            })
        }, r.prototype.onStart = function(e, t) {
            var n, i;
            try {
                for (var s = xh(this._spanProcessors), a = s.next(); !a.done; a = s.next()) {
                    var u = a.value;
                    u.onStart(e, t)
                }
            } catch (l) {
                n = {
                    error: l
                }
            } finally {
                try {
                    a && !a.done && (i = s.return) && i.call(s)
                } finally {
                    if (n) throw n.error
                }
            }
        }, r.prototype.onEnd = function(e) {
            var t, n;
            try {
                for (var i = xh(this._spanProcessors), s = i.next(); !s.done; s = i.next()) {
                    var a = s.value;
                    a.onEnd(e)
                }
            } catch (u) {
                t = {
                    error: u
                }
            } finally {
                try {
                    s && !s.done && (n = i.return) && n.call(i)
                } finally {
                    if (t) throw t.error
                }
            }
        }, r.prototype.shutdown = function() {
            var e, t, n = [];
            try {
                for (var i = xh(this._spanProcessors), s = i.next(); !s.done; s = i.next()) {
                    var a = s.value;
                    n.push(a.shutdown())
                }
            } catch (u) {
                e = {
                    error: u
                }
            } finally {
                try {
                    s && !s.done && (t = i.return) && t.call(i)
                } finally {
                    if (e) throw e.error
                }
            }
            return new Promise(function(u, l) {
                Promise.all(n).then(function() {
                    u()
                }, l)
            })
        }, r
    })(),
    eJ = (function() {
        function r() {}
        return o(r, "NoopSpanProcessor"), r.prototype.onStart = function(e, t) {}, r.prototype.onEnd = function(e) {}, r.prototype.shutdown = function() {
            return Promise.resolve()
        }, r.prototype.forceFlush = function() {
            return Promise.resolve()
        }, r
    })(),
    lo;
(function(r) {
    r[r.resolved = 0] = "resolved", r[r.timeout = 1] = "timeout", r[r.error = 2] = "error", r[r.unresolved = 3] = "unresolved"
})(lo || (lo = {}));
var tJ = (function() {
        function r(e) {
            e === void 0 && (e = {});
            var t;
            this._registeredSpanProcessors = [], this._tracers = new Map;
            var n = Hj({}, cD(), VX(e));
            this.resource = (t = n.resource) !== null && t !== void 0 ? t : bP.empty(), this.resource = bP.default().merge(this.resource), this._config = Object.assign({}, n, {
                resource: this.resource
            });
            var i = this._buildExporterFromEnv();
            if (i !== void 0) {
                var s = new WX(i);
                this.activeSpanProcessor = s
            } else this.activeSpanProcessor = new eJ
        }
        return o(r, "BasicTracerProvider"), r.prototype.getTracer = function(e, t, n) {
            var i = e + "@" + (t || "") + ":" + ((n == null ? void 0 : n.schemaUrl) || "");
            return this._tracers.has(i) || this._tracers.set(i, new KX({
                name: e,
                version: t,
                schemaUrl: n == null ? void 0 : n.schemaUrl
            }, this._config, this)), this._tracers.get(i)
        }, r.prototype.addSpanProcessor = function(e) {
            this._registeredSpanProcessors.length === 0 && this.activeSpanProcessor.shutdown().catch(function(t) {
                return ot.error("Error while trying to shutdown current span processor", t)
            }), this._registeredSpanProcessors.push(e), this.activeSpanProcessor = new QX(this._registeredSpanProcessors)
        }, r.prototype.getActiveSpanProcessor = function() {
            return this.activeSpanProcessor
        }, r.prototype.register = function(e) {
            e === void 0 && (e = {}), Nr.setGlobalTracerProvider(this), e.propagator === void 0 && (e.propagator = this._buildPropagatorFromEnv()), e.contextManager && Hr.setGlobalContextManager(e.contextManager), e.propagator && wi.setGlobalPropagator(e.propagator)
        }, r.prototype.forceFlush = function() {
            var e = this._config.forceFlushTimeoutMillis,
                t = this._registeredSpanProcessors.map(function(n) {
                    return new Promise(function(i) {
                        var s, a = setTimeout(function() {
                            i(new Error("Span processor did not completed within timeout period of " + e + " ms")), s = lo.timeout
                        }, e);
                        n.forceFlush().then(function() {
                            clearTimeout(a), s !== lo.timeout && (s = lo.resolved, i(s))
                        }).catch(function(u) {
                            clearTimeout(a), s = lo.error, i(u)
                        })
                    })
                });
            return new Promise(function(n, i) {
                Promise.all(t).then(function(s) {
                    var a = s.filter(function(u) {
                        return u !== lo.resolved
                    });
                    a.length > 0 ? i(a) : n()
                }).catch(function(s) {
                    return i([s])
                })
            })
        }, r.prototype.shutdown = function() {
            return this.activeSpanProcessor.shutdown()
        }, r.prototype._getPropagator = function(e) {
            var t;
            return (t = this.constructor._registeredPropagators.get(e)) === null || t === void 0 ? void 0 : t()
        }, r.prototype._getSpanExporter = function(e) {
            var t;
            return (t = this.constructor._registeredExporters.get(e)) === null || t === void 0 ? void 0 : t()
        }, r.prototype._buildPropagatorFromEnv = function() {
            var e = this,
                t = Array.from(new Set(Ba().OTEL_PROPAGATORS)),
                n = t.map(function(s) {
                    var a = e._getPropagator(s);
                    return a || ot.warn('Propagator "' + s + '" requested through environment variable is unavailable.'), a
                }),
                i = n.reduce(function(s, a) {
                    return a && s.push(a), s
                }, []);
            if (i.length !== 0) return t.length === 1 ? i[0] : new fj({
                propagators: i
            })
        }, r.prototype._buildExporterFromEnv = function() {
            var e = Ba().OTEL_TRACES_EXPORTER;
            if (!(e === "none" || e === "")) {
                var t = this._getSpanExporter(e);
                return t || ot.error('Exporter "' + e + '" requested through environment variable is unavailable.'), t
            }
        }, r._registeredPropagators = new Map([
            ["tracecontext", function() {
                return new Oj
            }],
            ["baggage", function() {
                return new b4
            }]
        ]), r._registeredExporters = new Map, r
    })(),
    rJ = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    },
    nJ = function(r, e, t) {
        if (t || arguments.length === 2)
            for (var n = 0, i = e.length, s; n < i; n++)(s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
        return r.concat(s || Array.prototype.slice.call(e))
    },
    iJ = (function() {
        function r() {
            this._enabled = !1, this._currentContext = _i
        }
        return o(r, "StackContextManager"), r.prototype._bindFunction = function(e, t) {
            e === void 0 && (e = _i);
            var n = this,
                i = o(function() {
                    for (var s = this, a = [], u = 0; u < arguments.length; u++) a[u] = arguments[u];
                    return n.with(e, function() {
                        return t.apply(s, a)
                    })
                }, "contextWrapper");
            return Object.defineProperty(i, "length", {
                enumerable: !1,
                configurable: !0,
                writable: !1,
                value: t.length
            }), i
        }, r.prototype.active = function() {
            return this._currentContext
        }, r.prototype.bind = function(e, t) {
            return e === void 0 && (e = this.active()), typeof t == "function" ? this._bindFunction(e, t) : t
        }, r.prototype.disable = function() {
            return this._currentContext = _i, this._enabled = !1, this
        }, r.prototype.enable = function() {
            return this._enabled ? this : (this._enabled = !0, this._currentContext = _i, this)
        }, r.prototype.with = function(e, t, n) {
            for (var i = [], s = 3; s < arguments.length; s++) i[s - 3] = arguments[s];
            var a = this._currentContext;
            this._currentContext = e || _i;
            try {
                return t.call.apply(t, nJ([n], rJ(i), !1))
            } finally {
                this._currentContext = a
            }
        }, r
    })(),
    sJ = (function() {
        var r = o(function(e, t) {
            return r = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array && function(n, i) {
                n.__proto__ = i
            } || function(n, i) {
                for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s])
            }, r(e, t)
        }, "extendStatics");
        return function(e, t) {
            if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
            r(e, t);

            function n() {
                this.constructor = e
            }
            o(n, "__"), e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n)
        }
    })(),
    oJ = (function(r) {
        sJ(e, r);

        function e(t) {
            t === void 0 && (t = {});
            var n = r.call(this, t) || this;
            if (t.contextManager) throw "contextManager should be defined in register method not in constructor";
            if (t.propagator) throw "propagator should be defined in register method not in constructor";
            return n
        }
        return o(e, "WebTracerProvider"), e.prototype.register = function(t) {
            t === void 0 && (t = {}), t.contextManager === void 0 && (t.contextManager = new iJ), t.contextManager && t.contextManager.enable(), r.prototype.register.call(this, t)
        }, e
    })(tJ);

function dD(r) {
    let e = r.getSpanInformation(),
        t = r.getContext();
    return {
        traceId: t.traceId,
        spanId: t.spanId,
        parentSpanId: e.parentSpanId,
        name: e.name,
        startTimeUnixNano: e.startTime,
        endTimeUnixNano: e.endTime,
        attributes: t.attributes,
        kind: e.kind,
        status: e.status
    }
}
o(dD, "serializeSpan");
var Jw, Ng, ho, qh, Kh, fD, gE = class gE {
    constructor(e) {
        let {
            transportManager: t,
            promiseMap: n = new Map,
            tracer: i
        } = e;
        Jw.add(this), Ng.set(this, void 0), ho.set(this, void 0), qh.set(this, 0), Kh.set(this, void 0), ye(this, Ng, t, "f"), ye(this, ho, n, "f"), ye(this, Kh, i, "f")
    }
    shutdown() {
        return he(this, void 0, void 0, function*() {
            yield Promise.all(O(this, ho, "f").values())
        })
    }
    forceFlush() {
        return he(this, void 0, void 0, function*() {
            yield Promise.all(O(this, ho, "f").values())
        })
    }
    onStart() {}
    onEnd(e) {
        let t = O(this, Kh, "f").fromOTSpan(e);
        O(this, Jw, "m", fD).call(this, t)
    }
};
o(gE, "MainTraceExporter");
var Zw = gE;
Ng = new WeakMap, ho = new WeakMap, qh = new WeakMap, Kh = new WeakMap, Jw = new WeakSet, fD = o(function(e) {
    var t, n;
    let i = (ye(this, qh, (n = O(this, qh, "f"), t = n++, n), "f"), t),
        s = dD(e),
        a = o(() => he(this, void 0, void 0, function*() {
            yield O(this, Ng, "f").processSpan(s), O(this, ho, "f").delete(i)
        }), "work");
    O(this, ho, "f").set(i, a())
}, "_MainTraceExporter_writeSpan");

function aJ(r, e) {
    var t, n;
    if (e) {
        let i = (n = (t = e.getSpanInformation()) === null || t === void 0 ? void 0 : t.childrenNames) !== null && n !== void 0 ? n : [];
        i.push(r), e.setAttribute(yt.ChildrenNames, i)
    }
}
o(aJ, "addChildSpanNameToParent");
var On = {
        Tag: "outsystems.log.message.tag",
        Visibility: "outsystems.otel.access.visibility",
        AccessType: "outsystems.otel.access.type",
        ChildrenNames: yt.ChildrenNames,
        IsNonAggregable: yt.IsNonAggregable
    },
    uJ = [On.IsNonAggregable, On.ChildrenNames],
    Ht, Yh, Xh, Cl, pE = class pE {
        constructor(e) {
            let {
                visibility: t,
                attributes: n = {},
                span: i,
                activateSpan: s,
                explicitChildren: a = []
            } = e;
            Ht.set(this, void 0), Yh.set(this, void 0), Xh.set(this, void 0), Cl.set(this, void 0), ye(this, Ht, i, "f"), ye(this, Yh, s, "f"), ye(this, Cl, a, "f"), t !== void 0 && O(this, Ht, "f").setAttribute(On.Visibility, ep[t]), O(this, Ht, "f").setAttributes(n), this.ended = new Promise(u => {
                ye(this, Xh, u, "f")
            })
        }
        setAttribute(e, t) {
            O(this, Ht, "f").setAttribute(e, t)
        }
        setStatus(e, t) {
            O(this, Ht, "f").setStatus({
                code: e,
                message: t
            })
        }
        raiseError(e, t) {
            O(this, Ht, "f").recordException(e), this.setStatus(2, t)
        }
        getContext() {
            let e = O(this, Ht, "f").spanContext();
            return {
                spanId: e.spanId,
                traceId: e.traceId,
                attributes: O(this, Ht, "f").attributes,
                sampled: !!(e.traceFlags & 1)
            }
        }
        addEvent(e, t) {
            O(this, Ht, "f").addEvent(e, t)
        }
        end() {
            return he(this, void 0, void 0, function*() {
                var e;
                yield Promise.all(O(this, Cl, "f").map(t => t.ended)), O(this, Ht, "f").end(), (e = O(this, Xh, "f")) === null || e === void 0 || e.call(this)
            })
        }
        fail() {
            O(this, Ht, "f").setStatus({
                code: Fl.ERROR
            })
        }
        getSpanInformation() {
            return {
                name: O(this, Ht, "f").name,
                kind: O(this, Ht, "f").kind,
                status: O(this, Ht, "f").status.code,
                parentSpanId: O(this, Ht, "f").parentSpanId,
                startTime: Rn.toNanoSeconds(new Rn(O(this, Ht, "f").startTime)),
                endTime: Rn.toNanoSeconds(new Rn(O(this, Ht, "f").endTime)),
                childrenNames: O(this, Ht, "f").attributes[yt.ChildrenNames]
            }
        }
        activate() {
            return O(this, Yh, "f").call(this)
        }
        addExplicitChild(e) {
            O(this, Cl, "f").push(e)
        }
    };
o(pE, "Span");
var Qw = pE;
Ht = new WeakMap, Yh = new WeakMap, Xh = new WeakMap, Cl = new WeakMap;
var eT, hs, Ea, ba, uo, Jh, Sa, Zh, ka, Dg, hD, mE = class mE {
    constructor(e) {
        let {
            transports: t,
            baseAttributes: n = {},
            staticAttributes: i = [],
            databaseNameSuffix: s,
            transportManager: a = new $l({
                traceTransports: t,
                databaseNameSuffix: s
            }),
            tracerProvider: u = new oJ,
            contextManager: l = new hY,
            tracer: c = u.getTracer("@outsystems/logger-js", "3.4.2"),
            exporter: d,
            enabled: f = !0,
            getActiveSpan: h = o(() => Nr.getActiveSpan(), "getActiveSpan"),
            setSpan: g = o((m, w) => Nr.setSpan(m, w), "setSpan")
        } = e;
        eT.add(this), hs.set(this, void 0), Ea.set(this, void 0), ba.set(this, void 0), uo.set(this, void 0), Jh.set(this, void 0), Sa.set(this, void 0), Zh.set(this, void 0), ka.set(this, void 0), Dg.set(this, void 0), ye(this, hs, a, "f"), ye(this, uo, c, "f"), ye(this, ba, f, "f"), ye(this, Sa, h, "f"), ye(this, Ea, u, "f"), ye(this, Zh, g, "f"), ye(this, Jh, l, "f"), ye(this, ka, n, "f"), ye(this, Dg, i, "f");
        let p = d != null ? d : new Zw({
            transportManager: a,
            tracer: this
        });
        O(this, Ea, "f").register({
            contextManager: l
        }), O(this, Ea, "f").addSpanProcessor(p)
    }
    addTransport(e) {
        O(this, hs, "f").addTraceTransport(e)
    }
    removeTransport(e) {
        O(this, hs, "f").removeTraceTransport(e)
    }
    startSpan(e, t, n, i) {
        if (O(this, ba, "f")) {
            let s = n != null ? n : O(this, Sa, "f").call(this) ? this.fromOTSpan(O(this, Sa, "f").call(this)) : void 0;
            aJ(e, s);
            let a = n ? O(this, uo, "f").startSpan(e, {
                    attributes: {},
                    kind: i
                }, n.activate()) : O(this, uo, "f").startSpan(e, {
                    kind: i
                }),
                u = this.fromOTSpan(a, t);
            return n == null || n.addExplicitChild(u), u
        } else return
    }
    startActiveSpan(e, t, n, i, s) {
        if (O(this, ba, "f")) {
            let a = o(l => {
                let c = this.fromOTSpan(l, n);
                return i == null || i.addExplicitChild(c), t(c)
            }, "fn");
            return i ? O(this, uo, "f").startActiveSpan(e, {
                attributes: {},
                kind: s
            }, i.activate(), a) : O(this, uo, "f").startActiveSpan(e, {
                kind: s
            }, a)
        } else return t(void 0)
    }
    getActiveSpan() {
        let e = O(this, Sa, "f").call(this);
        return e ? this.fromOTSpan(e) : void 0
    }
    setStatus(e) {
        ye(this, ba, e, "f")
    }
    addBaseSpanAttributes(e) {
        ye(this, ka, Object.assign(Object.assign({}, O(this, ka, "f")), e), "f")
    }
    enableFetchInstrumentation() {
        (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Xw).setTracerProvider(O(this, Ea, "f"))
    }
    span(e) {
        return he(this, void 0, void 0, function*() {
            yield O(this, hs, "f").processSpan(e)
        })
    }
    flush() {
        return he(this, void 0, void 0, function*() {
            O(this, hs, "f").flushSpans()
        })
    }
    setSchedulerTimerInterval(e) {
        O(this, hs, "f").setSchedulerTimerInterval(e)
    }
    fromOTSpan(e, t) {
        let n = O(this, eT, "m", hD).call(this, e);
        return new Qw({
            span: e,
            attributes: Al(n),
            activateSpan: o(() => O(this, Zh, "f").call(this, O(this, Jh, "f").active(), e), "activateSpan"),
            visibility: t
        })
    }
};
o(mE, "Tracer");
var tT = mE;
hs = new WeakMap, Ea = new WeakMap, ba = new WeakMap, uo = new WeakMap, Jh = new WeakMap, Sa = new WeakMap, Zh = new WeakMap, ka = new WeakMap, Dg = new WeakMap, eT = new WeakSet, hD = o(function(e) {
    let t = Object.assign({}, O(this, ka, "f"));
    return e.parentSpanId === void 0 || Object.keys(t).forEach(i => {
        O(this, Dg, "f").includes(i) && delete t[i]
    }), t
}, "_Tracer_handleStaticAttributes");
var rT, Lg, gD, cJ = "Application",
    vE = class vE {
        constructor(e) {
            let {
                transportId: t,
                logTypeBaseline: n = Je.Debug,
                formatter: i,
                transportConsole: s = console,
                shouldWriteLogsOnConsoles: a = o(() => !1, "shouldWriteLogsOnConsoles")
            } = e;
            rT.add(this), Lg.set(this, void 0), this.formatConsoleLog = u => {
                var l, c, d, f;
                let h = {
                    errorCode: u.type === Je.Error ? (l = u.errorCode) !== null && l !== void 0 ? l : HN : void 0,
                    category: (c = u.category) !== null && c !== void 0 ? c : cJ,
                    message: (f = (d = u == null ? void 0 : u.error) === null || d === void 0 ? void 0 : d.message) !== null && f !== void 0 ? f : u.message,
                    timestamp: Rn.toISOString(u.timestamp)
                };
                return `${h.timestamp}:${h.errorCode?" "+h.errorCode:""} [${h.category}] ${h.message}`
            }, this.transportId = t, this.logTypeBaseline = n, this.formatter = i, this.transportConsole = s, ye(this, Lg, a, "f")
        }
        getTransportId() {
            return this.transportId
        }
        requiresConnectivity() {
            return !1
        }
        hasWriteBuffer() {
            return !1
        }
        getLogTypeBaseline() {
            return this.logTypeBaseline
        }
        setLogTypeBaseline(e) {
            this.logTypeBaseline = e
        }
        write(e) {
            return he(this, void 0, void 0, function*() {
                if (!O(this, rT, "m", gD).call(this, e)) return;
                let t = this.formatter ? this.formatter.format(e) : this.formatConsoleLog(e);
                switch (e.type) {
                    case Je.Debug:
                        this.transportConsole.debug(t);
                        break;
                    case Je.Info:
                        this.transportConsole.log(t);
                        break;
                    case Je.Warning:
                        this.transportConsole.warn(t);
                        break;
                    case Je.Error:
                        this.transportConsole.error(t, e.error);
                        break;
                    default:
                        this.transportConsole.log(t)
                }
            })
        }
        writeAll(e) {
            return he(this, void 0, void 0, function*() {
                for (let t of e) yield this.write(t)
            })
        }
    };
o(vE, "ConsoleTransport");
var nT = vE;
Lg = new WeakMap, rT = new WeakSet, gD = o(function(e) {
    return e.visibility === Pe.External || O(this, Lg, "f").call(this)
}, "_ConsoleTransport_canWriteOnConsole");

function pD(r) {
    let e = {};
    return r.category && (e[On.Tag] = r.category), e
}
o(pD, "mapLogFieldToAttributes");
var yE = class yE {
    format(e) {
        var t, n;
        let i = (t = e.visibility) !== null && t !== void 0 ? t : Pe.External,
            s = jN(e),
            a = pD(e),
            u = Object.assign(Object.assign(Object.assign({
                [On.Visibility]: ep[i]
            }, s), a), e.attributes),
            l = xT(u),
            c = Rn.toISOString(e.timestamp);
        return {
            message: (n = e.message) !== null && n !== void 0 ? n : "",
            attributes: l,
            instant: c
        }
    }
};
o(yE, "NativeLoggerFormatter");
var iT = yE,
    lJ = {
        [Je.Debug]: "logDebug",
        [Je.Info]: "logInfo",
        [Je.Warning]: "logWarning",
        [Je.Error]: "logError",
        [Je.Trace]: "logTrace"
    },
    _E = class _E {
        constructor(e) {
            let {
                transportId: t,
                logTypeBaseline: n,
                nativeLoggerV2: i,
                formatter: s = new iT
            } = e;
            this.transportId = t, this.logTypeBaseline = n, this.nativeLoggerV2 = i, this.formatter = s
        }
        getTransportId() {
            return this.transportId
        }
        requiresConnectivity() {
            return !1
        }
        hasWriteBuffer() {
            return !1
        }
        getLogTypeBaseline() {
            return this.logTypeBaseline
        }
        setLogTypeBaseline(e) {
            this.logTypeBaseline = e
        }
        write(e) {
            return he(this, void 0, void 0, function*() {
                let t = this.formatter.format(e),
                    n = lJ[e.type];
                return this.nativeLoggerV2[n](t)
            })
        }
        writeAll(e) {
            return he(this, void 0, void 0, function*() {
                for (let t of e) yield this.write(t)
            })
        }
    };
o(_E, "NativeLoggerTransport");
var sT = _E,
    Rl, SP = 2e3,
    dJ = {
        [Je.Trace]: 1,
        [Je.Debug]: 5,
        [Je.Info]: 9,
        [Je.Warning]: 13,
        [Je.Error]: 17
    },
    fJ = {
        [Je.Debug]: "Debug",
        [Je.Info]: "Information",
        [Je.Warning]: "Warning",
        [Je.Error]: "Error",
        [Je.Trace]: "Trace"
    },
    hJ = o(r => {
        let e = {
            body: {
                stringValue: ""
            }
        };
        if (r.message) {
            let t = r.message.length > SP ? `${r.message.substring(0,SP-3)}...` : r.message;
            e.body = {
                stringValue: t
            }
        }
        return e
    }, "getOptionalLogRecordFields"),
    wE = class wE {
        constructor() {
            let {
                resourceAttributes: e = {}
            } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            Rl.set(this, void 0), ye(this, Rl, e, "f")
        }
        setResourceAttributes(e) {
            ye(this, Rl, e != null ? e : {}, "f")
        }
        format(e) {
            return this.formatAll([e])
        }
        formatAll(e) {
            let t = Object.assign({
                    [On.AccessType]: 3
                }, O(this, Rl, "f")),
                n = Sg(t),
                i = e.map(s => pJ(s));
            return gJ(i, n)
        }
    };
o(wE, "OpenTelemetryLogFormatter");
var oT = wE;
Rl = new WeakMap;

function gJ(r, e) {
    return {
        resourceLogs: [{
            resource: {
                attributes: e
            },
            scopeLogs: [{
                scope: {
                    name: "@outsystems/logger-js",
                    version: "3.4.2"
                },
                logRecords: r
            }]
        }]
    }
}
o(gJ, "formatRequest$1");

function pJ(r) {
    var e;
    let t = (e = r.visibility) !== null && e !== void 0 ? e : Pe.External,
        n = jN(r),
        i = dY(r),
        s = pD(r),
        a = Object.assign(Object.assign(Object.assign({
            [On.Visibility]: ep[t]
        }, n), s), r.attributes),
        u = xT(a),
        l = Sg(u),
        c = dJ[r.type],
        d = fJ[r.type],
        f = Rn.toNanoSeconds(r.timestamp),
        h = hJ(r);
    return Object.assign(Object.assign(Object.assign({}, h), i), {
        timeUnixNano: f,
        severityNumber: c,
        severityText: d,
        attributes: l
    })
}
o(pJ, "formatLog");
var Qh, go, xg, aT, mJ = "/v2/logs",
    TE = class TE {
        constructor(e) {
            let {
                transportId: t,
                resourceAttributes: n,
                logTypeBaseline: i,
                logsEndpoint: s = mJ,
                logsCollectorBaseUrl: a,
                tagId: u,
                enableWriteBuffer: l = !0,
                httpClient: c = new mi({
                    baseUrl: a,
                    headers: u ? {
                        "api-key": u,
                        "tag-id": u
                    } : {}
                }),
                formatter: d = new oT({
                    resourceAttributes: n
                })
            } = e;
            Qh.add(this), go.set(this, void 0), xg.set(this, void 0), this.transportId = t, this.logTypeBaseline = i, this.logsEndpoint = s, this.enableWriteBuffer = l, this.httpClient = c, this.formatter = d, ye(this, go, u, "f"), ye(this, xg, a, "f")
        }
        getTransportId() {
            return this.transportId
        }
        requiresConnectivity() {
            return !0
        }
        hasWriteBuffer() {
            return this.enableWriteBuffer
        }
        getLogTypeBaseline() {
            return this.logTypeBaseline
        }
        setLogTypeBaseline(e) {
            this.logTypeBaseline = e
        }
        setTagId(e) {
            ye(this, go, e, "f")
        }
        setResourceAttributes(e) {
            var t, n;
            (n = (t = this.formatter).setResourceAttributes) === null || n === void 0 || n.call(t, e)
        }
        write(e) {
            return he(this, void 0, void 0, function*() {
                return O(this, Qh, "m", aT).call(this, this.formatter.format(e))
            })
        }
        writeAll(e) {
            return he(this, void 0, void 0, function*() {
                return O(this, Qh, "m", aT).call(this, this.formatter.formatAll(e))
            })
        }
    };
o(TE, "OpenTelemetryLoggerTransport");
var uT = TE;
go = new WeakMap, xg = new WeakMap, Qh = new WeakSet, aT = o(function(e) {
    return he(this, void 0, void 0, function*() {
        return this.httpClient.post({
            url: this.logsEndpoint,
            payload: e,
            contentType: ir.Json,
            headers: O(this, go, "f") ? {
                "api-key": O(this, go, "f"),
                "tag-id": O(this, go, "f")
            } : {},
            baseURL: O(this, xg, "f")
        })
    })
}, "_OpenTelemetryLoggerTransport_postLogs");
var cT, Ol, mD, EE = class EE {
    constructor() {
        let {
            resourceAttributes: e = {}
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        cT.add(this), Ol.set(this, void 0), ye(this, Ol, e, "f")
    }
    setResourceAttributes(e) {
        ye(this, Ol, e != null ? e : {}, "f")
    }
    format(e) {
        return this.formatAll([e])
    }
    formatAll(e) {
        let t = Object.assign({
                [On.AccessType]: 3
            }, O(this, Ol, "f")),
            n = Sg(t),
            i = e.map(s => {
                let a = Object.assign({
                        [On.Visibility]: ep[Pe.External]
                    }, O(this, cT, "m", mD).call(this, s.attributes)),
                    u = xT(a),
                    l = Sg(u);
                return Object.assign({
                    traceId: s.traceId,
                    spanId: s.spanId,
                    parentSpanId: s.parentSpanId,
                    name: s.name,
                    startTimeUnixNano: s.startTimeUnixNano,
                    endTimeUnixNano: s.endTimeUnixNano,
                    status: {
                        code: s.status !== 0 ? s.status : 1
                    },
                    attributes: l
                }, s.kind ? {
                    kind: s.kind
                } : {})
            });
        return vJ(i, n)
    }
};
o(EE, "OpenTelemetryTraceFormatter");
var lT = EE;
Ol = new WeakMap, cT = new WeakSet, mD = o(function(e) {
    return Object.entries(e).reduce((t, n) => {
        let [i, s] = n;
        return uJ.includes(i) || (t[i] = s), t
    }, {})
}, "_OpenTelemetryTraceFormatter_filterInternalAttributes");

function vJ(r, e) {
    return {
        resourceSpans: [{
            resource: {
                attributes: e
            },
            scopeSpans: [{
                scope: {
                    name: "@outsystems/logger-js",
                    version: "3.4.2"
                },
                spans: r
            }]
        }]
    }
}
o(vJ, "formatRequest");
var eg, Aa, po, Ug, dT, yJ = "/v2/traces",
    bE = class bE {
        constructor(e) {
            let {
                transportId: t,
                resourceAttributes: n,
                enabled: i = !0,
                tracesEndpoint: s = yJ,
                tracesCollectorBaseUrl: a,
                tagId: u,
                enableWriteBuffer: l = !0,
                httpClient: c = new mi({
                    baseUrl: a,
                    headers: u ? {
                        "api-key": u,
                        "tag-id": u
                    } : {}
                }),
                formatter: d = new lT({
                    resourceAttributes: n
                })
            } = e;
            eg.add(this), Aa.set(this, void 0), po.set(this, void 0), Ug.set(this, void 0), this.transportId = t, ye(this, Aa, i, "f"), this.tracesEndpoint = s, this.enableWriteBuffer = l, this.httpClient = c, this.formatter = d, ye(this, po, u, "f"), ye(this, Ug, a, "f")
        }
        getTransportId() {
            return this.transportId
        }
        isTracingEnabled() {
            return O(this, Aa, "f")
        }
        enableTracing() {
            ye(this, Aa, !0, "f")
        }
        disableTracing() {
            ye(this, Aa, !1, "f")
        }
        requiresConnectivity() {
            return !0
        }
        hasWriteBuffer() {
            return this.enableWriteBuffer
        }
        setTagId(e) {
            ye(this, po, e, "f")
        }
        setResourceAttributes(e) {
            var t, n;
            (n = (t = this.formatter).setResourceAttributes) === null || n === void 0 || n.call(t, e)
        }
        write(e) {
            return he(this, void 0, void 0, function*() {
                return O(this, eg, "m", dT).call(this, this.formatter.format(e))
            })
        }
        writeAll(e) {
            return he(this, void 0, void 0, function*() {
                return O(this, eg, "m", dT).call(this, this.formatter.formatAll(e))
            })
        }
    };
o(bE, "OpenTelemetryTracerTransport");
var fT = bE;
Aa = new WeakMap, po = new WeakMap, Ug = new WeakMap, eg = new WeakSet, dT = o(function(e) {
    return he(this, void 0, void 0, function*() {
        return this.httpClient.post({
            url: this.tracesEndpoint,
            payload: e,
            contentType: ir.Json,
            headers: O(this, po, "f") ? {
                "api-key": O(this, po, "f"),
                "tag-id": O(this, po, "f")
            } : {},
            baseURL: O(this, Ug, "f")
        })
    })
}, "_OpenTelemetryTracerTransport_postSpans");
var gs, tg, Ia, Pl, SE = class SE {
    constructor() {
        let {
            sw: e,
            container: t = navigator.serviceWorker
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var n;
        if (gs.set(this, void 0), tg.set(this, void 0), Ia.set(this, []), Pl.set(this, !1), !t) throw new Error("No service worker container available");
        ye(this, gs, (n = e != null ? e : t == null ? void 0 : t.controller) !== null && n !== void 0 ? n : void 0, "f"), ye(this, tg, t, "f"), this.waitForSW()
    }
    get pendingMessages() {
        return O(this, Ia, "f")
    }
    isServiceWorkerAvailable() {
        return !!O(this, gs, "f") && O(this, gs, "f").state === "activated"
    }
    send(e, t) {
        this.sendMessage({
            kind: e,
            data: t
        })
    }
    sendMessage(e, t) {
        var n;
        this.isServiceWorkerAvailable() ? (n = O(this, gs, "f")) === null || n === void 0 || n.postMessage(e, t) : (O(this, Ia, "f").push({
            message: e,
            options: t
        }), this.waitForSW())
    }
    waitForSW() {
        return he(this, void 0, void 0, function*() {
            if (this.isServiceWorkerAvailable() || O(this, Pl, "f")) return;
            ye(this, Pl, !0, "f");
            let {
                active: e
            } = yield O(this, tg, "f").ready;
            ye(this, gs, e != null ? e : void 0, "f"), ye(this, Pl, !1, "f"), this.flushMessages()
        })
    }
    flushMessages() {
        var e;
        if (this.isServiceWorkerAvailable()) {
            for (let {
                    message: t,
                    options: n
                } of O(this, Ia, "f"))(e = O(this, gs, "f")) === null || e === void 0 || e.postMessage(t, n);
            ye(this, Ia, [], "f")
        } else this.waitForSW()
    }
};
o(SE, "ServiceWorkerTransport");
var hT = SE;
gs = new WeakMap, tg = new WeakMap, Ia = new WeakMap, Pl = new WeakMap;
var Nl, rg, Ca, Mg, kg, Fg, $g, Bg, Ra, ng, AE = class AE {
    constructor(e) {
        let {
            transportId: t,
            tagId: n,
            collectorBaseUrl: i,
            databaseSuffix: s,
            swTransport: a = new hT,
            enabled: u = !0,
            attributes: l = {},
            aggregateSpans: c = !1
        } = e;
        Nl.add(this), rg.set(this, void 0), Ca.set(this, void 0), Mg.set(this, void 0), kg.set(this, void 0), Fg.set(this, void 0), $g.set(this, void 0), Bg.set(this, void 0), Ra.set(this, void 0), ye(this, rg, t, "f"), ye(this, Ca, a, "f"), ye(this, Ra, u, "f"), ye(this, Mg, l, "f"), ye(this, kg, n, "f"), ye(this, Fg, i, "f"), ye(this, $g, s, "f"), ye(this, Bg, c, "f")
    }
    getTransportId() {
        return O(this, rg, "f")
    }
    requiresConnectivity() {
        return !1
    }
    isTracingEnabled() {
        return O(this, Ra, "f")
    }
    enableTracing() {
        ye(this, Ra, !0, "f")
    }
    disableTracing() {
        ye(this, Ra, !1, "f")
    }
    hasWriteBuffer() {
        return !1
    }
    write(e) {
        return O(this, Ca, "f").send("Span", {
            span: e,
            meta: O(this, Nl, "m", ng).call(this)
        }), Promise.resolve()
    }
    writeAll(e) {
        for (let t of e) O(this, Ca, "f").send("Span", {
            span: t,
            meta: O(this, Nl, "m", ng).call(this)
        });
        return Promise.resolve()
    }
    flush() {
        return O(this, Ca, "f").send("Flush", {
            kind: "Spans",
            meta: O(this, Nl, "m", ng).call(this)
        }), Promise.resolve()
    }
};
o(AE, "ServiceWorkerTracerTransport");
var gT = AE;
rg = new WeakMap, Ca = new WeakMap, Mg = new WeakMap, kg = new WeakMap, Fg = new WeakMap, $g = new WeakMap, Bg = new WeakMap, Ra = new WeakMap, Nl = new WeakSet, ng = o(function() {
    return {
        databaseSuffix: O(this, $g, "f"),
        resourceAttributes: O(this, Mg, "f"),
        collectorBaseUrl: O(this, Fg, "f"),
        apiKey: O(this, kg, "f"),
        aggregateSpans: O(this, Bg, "f")
    }
}, "_ServiceWorkerTracerTransport_getMetadata");
var Oa, Br, Pa, Na, ig, sg, og, ag, ug, Dl, IE = class IE {
    constructor(e) {
        let {
            databaseNameSuffix: t,
            logTransports: n,
            traceTransports: i,
            baseLogAttributes: s = {},
            baseSpanAttributes: a = {},
            staticSpanAttributes: u = [],
            isOnline: l,
            aggregateSpans: c,
            transportManager: d = new $l({
                databaseNameSuffix: t,
                logTransports: n,
                traceTransports: i,
                isOnline: l,
                aggregateSpans: c
            }),
            tracerInstance: f,
            loggerInstance: h
        } = e;
        Oa.add(this), Br.set(this, void 0), Pa.set(this, void 0), Na.set(this, void 0), ig.set(this, void 0), sg.set(this, void 0), og.set(this, void 0), ag.set(this, void 0), ug.set(this, void 0), ye(this, Br, d, "f"), ye(this, Pa, f, "f"), ye(this, Na, h, "f"), ye(this, ig, () => Hn.isEnabled(di.WriteLogsOnConsoles), "f"), ye(this, sg, s, "f"), ye(this, og, a, "f"), ye(this, ag, u, "f"), ye(this, ug, t, "f")
    }
    init() {
        return he(this, void 0, void 0, function*() {
            yield this.getLogger(), this.getTracer()
        })
    }
    getLogger() {
        return he(this, void 0, void 0, function*() {
            return O(this, Na, "f") || ye(this, Na, yield $w.build({
                transportManager: O(this, Br, "f"),
                baseAttributes: O(this, sg, "f")
            }), "f"), O(this, Na, "f")
        })
    }
    getTracer() {
        return O(this, Pa, "f") || ye(this, Pa, new tT({
            transportManager: O(this, Br, "f"),
            baseAttributes: O(this, og, "f"),
            staticAttributes: O(this, ag, "f")
        }), "f"), O(this, Pa, "f")
    }
    useNativeLoggerTransport(e) {
        return he(this, arguments, void 0, function(t) {
            var n = this;
            let {
                plugin: i,
                logTypeBaseline: s
            } = t;
            return (function*() {
                (yield n.getLogger()).addTransport(new sT({
                    transportId: "native-logger-transport",
                    nativeLoggerV2: i,
                    logTypeBaseline: s
                }))
            })()
        })
    }
    useOpenTelemetryLoggerTransport(e) {
        return he(this, arguments, void 0, function(t) {
            var n = this;
            let {
                resourceAttributes: i,
                logTypeBaseline: s,
                collectorBaseUrl: a,
                tagId: u,
                httpClient: l
            } = t;
            return (function*() {
                (yield n.getLogger()).addTransport(new uT({
                    transportId: "otel-logger-transport",
                    resourceAttributes: i,
                    logTypeBaseline: s,
                    logsCollectorBaseUrl: a,
                    tagId: u,
                    httpClient: l
                }))
            })()
        })
    }
    useConsoleLoggerTransport(e) {
        return he(this, void 0, void 0, function*() {
            (yield this.getLogger()).addTransport(new nT({
                transportId: "console-transport",
                logTypeBaseline: e,
                shouldWriteLogsOnConsoles: O(this, ig, "f")
            }))
        })
    }
    useServiceWorkerTracerTransport(e) {
        let {
            resourceAttributes: t,
            enabled: n = !0,
            collectorBaseUrl: i,
            tagId: s,
            swTransport: a,
            aggregateSpans: u = !1
        } = e, l = this.getTracer(), c = new gT({
            transportId: "sw-tracer-transport",
            attributes: t,
            enabled: n,
            tagId: s,
            collectorBaseUrl: i,
            databaseSuffix: O(this, ug, "f"),
            swTransport: a,
            aggregateSpans: u
        });
        l.addTransport(c)
    }
    useOpenTelemetryTracerTransport(e) {
        let {
            resourceAttributes: t,
            enabled: n = !0,
            collectorBaseUrl: i,
            tagId: s,
            httpClient: a
        } = e, u = this.getTracer(), l = new fT({
            transportId: "otel-tracer-transport",
            resourceAttributes: t,
            enabled: n,
            tagId: s,
            tracesCollectorBaseUrl: i,
            httpClient: a
        });
        u.addTransport(l)
    }
    useConsoleTracerTransport() {
        return he(this, void 0, void 0, function*() {
            throw new Error("Not implemented")
        })
    }
    useFetchInstrumentation() {
        this.getTracer().enableFetchInstrumentation()
    }
    setLogLevel(e) {
        O(this, Br, "f").setAllLogTypeBaselines(e)
    }
    setTracerStatus(e) {
        this.getTracer().setStatus(e)
    }
    setTagId(e) {
        O(this, Br, "f").setTagId(e)
    }
    setAggregateSpansStatus(e) {
        O(this, Br, "f").setAggregateSpansStatus(e)
    }
    setResourceAttributes(e) {
        O(this, Br, "f").setResourceAttributes(e)
    }
    setSchedulerTimerInterval(e) {
        O(this, Br, "f").setSchedulerTimerInterval(e)
    }
    flushInstrumentationData() {
        return he(this, void 0, void 0, function*() {
            yield Promise.all([O(this, Br, "f").flushLogs(), O(this, Br, "f").flushSpans()])
        })
    }
    logError(e) {
        return he(this, arguments, void 0, function(t) {
            var n = this;
            let {
                category: i,
                message: s,
                error: a,
                errorCode: u,
                visibility: l,
                failSpan: c = !0,
                attributes: d
            } = t;
            return (function*() {
                if (c) {
                    let g = n.getTracer().getActiveSpan();
                    g == null || g.fail()
                }(yield n.getLogger()).error({
                    category: i,
                    message: s,
                    error: a,
                    errorCode: u,
                    visibility: l,
                    span: O(n, Oa, "m", Dl).call(n),
                    attributes: d
                })
            })()
        })
    }
    logWarning(e) {
        return he(this, arguments, void 0, function(t) {
            var n = this;
            let {
                category: i,
                message: s,
                visibility: a,
                attributes: u
            } = t;
            return (function*() {
                (yield n.getLogger()).warning({
                    category: i,
                    message: s,
                    visibility: a,
                    span: O(n, Oa, "m", Dl).call(n),
                    attributes: u
                })
            })()
        })
    }
    logInfo(e) {
        return he(this, arguments, void 0, function(t) {
            var n = this;
            let {
                category: i,
                message: s,
                visibility: a,
                attributes: u
            } = t;
            return (function*() {
                (yield n.getLogger()).info({
                    category: i,
                    message: s,
                    visibility: a,
                    span: O(n, Oa, "m", Dl).call(n),
                    attributes: u
                })
            })()
        })
    }
    logDebug(e) {
        return he(this, arguments, void 0, function(t) {
            var n = this;
            let {
                category: i,
                message: s,
                visibility: a,
                attributes: u
            } = t;
            return (function*() {
                (yield n.getLogger()).debug({
                    category: i,
                    message: s,
                    visibility: a,
                    span: O(n, Oa, "m", Dl).call(n),
                    attributes: u
                })
            })()
        })
    }
    log(e) {
        return he(this, void 0, void 0, function*() {
            yield(yield this.getLogger()).log(e)
        })
    }
    span(e) {
        return he(this, void 0, void 0, function*() {
            yield this.getTracer().span(e)
        })
    }
    flushLogs() {
        return he(this, void 0, void 0, function*() {
            yield O(this, Br, "f").flushLogs()
        })
    }
    flushSpans() {
        return he(this, void 0, void 0, function*() {
            yield O(this, Br, "f").flushSpans()
        })
    }
    startSpan(e, t, n, i) {
        return this.getTracer().startSpan(e, t, n, i)
    }
    startActiveSpan(e, t, n, i, s) {
        return this.getTracer().startActiveSpan(e, t, n, i, s)
    }
    getActiveSpan() {
        return this.getTracer().getActiveSpan()
    }
};
o(IE, "InstrumentationFactory");
var Vg = IE;
Br = new WeakMap, Pa = new WeakMap, Na = new WeakMap, ig = new WeakMap, sg = new WeakMap, og = new WeakMap, ag = new WeakMap, ug = new WeakMap, Oa = new WeakSet, Dl = o(function() {
    let t = this.getTracer().getActiveSpan();
    return t ? dD(t) : void 0
}, "_InstrumentationFactory_getActiveSpanInfo");
var Hg;
(function(r) {
    r[r.Internal = 0] = "Internal", r[r.Client = 2] = "Client"
})(Hg || (Hg = {}));
var $E = o(function(r, e) {
    return $E = Object.setPrototypeOf || {
        __proto__: []
    }
    instanceof Array && function(t, n) {
        t.__proto__ = n
    } || function(t, n) {
        for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
    }, $E(r, e)
}, "extendStatics");

function zp(r, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    $E(r, e);

    function t() {
        this.constructor = r
    }
    o(t, "__"), r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t)
}
o(zp, "__extends$1");
var Kt = o(function() {
    return Kt = Object.assign || o(function(e) {
        for (var t, n = 1, i = arguments.length; n < i; n++) {
            t = arguments[n];
            for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s])
        }
        return e
    }, "__assign"), Kt.apply(this, arguments)
}, "__assign$8");

function cL(r, e) {
    var t = {};
    for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]);
    if (r != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++) e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]);
    return t
}
o(cL, "__rest");

function lL(r, e, t, n) {
    var i = arguments.length,
        s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n,
        a;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, n);
    else
        for (var u = r.length - 1; u >= 0; u--)(a = r[u]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, t, s) : a(e, t)) || s);
    return i > 3 && s && Object.defineProperty(e, t, s), s
}
o(lL, "__decorate");

function dL(r, e) {
    return function(t, n) {
        e(t, n, r)
    }
}
o(dL, "__param");

function fL(r, e, t, n, i, s) {
    function a(T) {
        if (T !== void 0 && typeof T != "function") throw new TypeError("Function expected");
        return T
    }
    o(a, "accept");
    for (var u = n.kind, l = u === "getter" ? "get" : u === "setter" ? "set" : "value", c = !e && r ? n.static ? r : r.prototype : null, d = e || (c ? Object.getOwnPropertyDescriptor(c, n.name) : {}), f, h = !1, g = t.length - 1; g >= 0; g--) {
        var p = {};
        for (var m in n) p[m] = m === "access" ? {} : n[m];
        for (var m in n.access) p.access[m] = n.access[m];
        p.addInitializer = function(T) {
            if (h) throw new TypeError("Cannot add initializers after decoration has completed");
            s.push(a(T || null))
        };
        var w = (0, t[g])(u === "accessor" ? {
            get: d.get,
            set: d.set
        } : d[l], p);
        if (u === "accessor") {
            if (w === void 0) continue;
            if (w === null || typeof w != "object") throw new TypeError("Object expected");
            (f = a(w.get)) && (d.get = f), (f = a(w.set)) && (d.set = f), (f = a(w.init)) && i.unshift(f)
        } else(f = a(w)) && (u === "field" ? i.unshift(f) : d[l] = f)
    }
    c && Object.defineProperty(c, n.name, d), h = !0
}
o(fL, "__esDecorate");

function hL(r, e, t) {
    for (var n = arguments.length > 2, i = 0; i < e.length; i++) t = n ? e[i].call(r, t) : e[i].call(r);
    return n ? t : void 0
}
o(hL, "__runInitializers");

function gL(r) {
    return typeof r == "symbol" ? r : "".concat(r)
}
o(gL, "__propKey");

function pL(r, e, t) {
    return typeof e == "symbol" && (e = e.description ? "[".concat(e.description, "]") : ""), Object.defineProperty(r, "name", {
        configurable: !0,
        value: t ? "".concat(t, " ", e) : e
    })
}
o(pL, "__setFunctionName");

function mL(r, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(r, e)
}
o(mL, "__metadata");

function be(r, e, t, n) {
    function i(s) {
        return s instanceof t ? s : new t(function(a) {
            a(s)
        })
    }
    return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
        function u(d) {
            try {
                c(n.next(d))
            } catch (f) {
                a(f)
            }
        }
        o(u, "fulfilled");

        function l(d) {
            try {
                c(n.throw(d))
            } catch (f) {
                a(f)
            }
        }
        o(l, "rejected");

        function c(d) {
            d.done ? s(d.value) : i(d.value).then(u, l)
        }
        o(c, "step"), c((n = n.apply(r, e || [])).next())
    })
}
o(be, "__awaiter$d");

function Ze(r, e) {
    var t = {
            label: 0,
            sent: o(function() {
                if (s[0] & 1) throw s[1];
                return s[1]
            }, "sent"),
            trys: [],
            ops: []
        },
        n, i, s, a = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
    return a.next = u(0), a.throw = u(1), a.return = u(2), typeof Symbol == "function" && (a[Symbol.iterator] = function() {
        return this
    }), a;

    function u(c) {
        return function(d) {
            return l([c, d])
        }
    }

    function l(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; a && (a = 0, c[0] && (t = 0)), t;) try {
            if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
            switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                case 0:
                case 1:
                    s = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, i = c[1], c = [0];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue
                    }
                    if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                        t.label = c[1];
                        break
                    }
                    if (c[0] === 6 && t.label < s[1]) {
                        t.label = s[1], s = c;
                        break
                    }
                    if (s && t.label < s[2]) {
                        t.label = s[2], t.ops.push(c);
                        break
                    }
                    s[2] && t.ops.pop(), t.trys.pop();
                    continue
            }
            c = e.call(r, t)
        } catch (d) {
            c = [6, d], i = 0
        } finally {
            n = s = 0
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        }
    }
}
o(Ze, "__generator$d");
var qp = Object.create ? function(r, e, t, n) {
    n === void 0 && (n = t);
    var i = Object.getOwnPropertyDescriptor(e, t);
    (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = {
        enumerable: !0,
        get: o(function() {
            return e[t]
        }, "get")
    }), Object.defineProperty(r, n, i)
} : function(r, e, t, n) {
    n === void 0 && (n = t), r[n] = e[t]
};

function vL(r, e) {
    for (var t in r) t !== "default" && !Object.prototype.hasOwnProperty.call(e, t) && qp(e, r, t)
}
o(vL, "__exportStar");

function Ap(r) {
    var e = typeof Symbol == "function" && Symbol.iterator,
        t = e && r[e],
        n = 0;
    if (t) return t.call(r);
    if (r && typeof r.length == "number") return {
        next: o(function() {
            return r && n >= r.length && (r = void 0), {
                value: r && r[n++],
                done: !r
            }
        }, "next")
    };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
o(Ap, "__values$2");

function dn(r, e) {
    var t = typeof Symbol == "function" && r[Symbol.iterator];
    if (!t) return r;
    var n = t.call(r),
        i, s = [],
        a;
    try {
        for (;
            (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
    } catch (u) {
        a = {
            error: u
        }
    } finally {
        try {
            i && !i.done && (t = n.return) && t.call(n)
        } finally {
            if (a) throw a.error
        }
    }
    return s
}
o(dn, "__read$6");

function yL() {
    for (var r = [], e = 0; e < arguments.length; e++) r = r.concat(dn(arguments[e]));
    return r
}
o(yL, "__spread");

function _L() {
    for (var r = 0, e = 0, t = arguments.length; e < t; e++) r += arguments[e].length;
    for (var n = Array(r), i = 0, e = 0; e < t; e++)
        for (var s = arguments[e], a = 0, u = s.length; a < u; a++, i++) n[i] = s[a];
    return n
}
o(_L, "__spreadArrays");

function wL(r, e, t) {
    if (t || arguments.length === 2)
        for (var n = 0, i = e.length, s; n < i; n++)(s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
    return r.concat(s || Array.prototype.slice.call(e))
}
o(wL, "__spreadArray$3");

function fu(r) {
    return this instanceof fu ? (this.v = r, this) : new fu(r)
}
o(fu, "__await");

function TL(r, e, t) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var n = t.apply(r, e || []),
        i, s = [];
    return i = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), u("next"), u("throw"), u("return", a), i[Symbol.asyncIterator] = function() {
        return this
    }, i;

    function a(g) {
        return function(p) {
            return Promise.resolve(p).then(g, f)
        }
    }

    function u(g, p) {
        n[g] && (i[g] = function(m) {
            return new Promise(function(w, T) {
                s.push([g, m, w, T]) > 1 || l(g, m)
            })
        }, p && (i[g] = p(i[g])))
    }

    function l(g, p) {
        try {
            c(n[g](p))
        } catch (m) {
            h(s[0][3], m)
        }
    }

    function c(g) {
        g.value instanceof fu ? Promise.resolve(g.value.v).then(d, f) : h(s[0][2], g)
    }

    function d(g) {
        l("next", g)
    }

    function f(g) {
        l("throw", g)
    }

    function h(g, p) {
        g(p), s.shift(), s.length && l(s[0][0], s[0][1])
    }
}
o(TL, "__asyncGenerator");

function EL(r) {
    var e, t;
    return e = {}, n("next"), n("throw", function(i) {
        throw i
    }), n("return"), e[Symbol.iterator] = function() {
        return this
    }, e;

    function n(i, s) {
        e[i] = r[i] ? function(a) {
            return (t = !t) ? {
                value: fu(r[i](a)),
                done: !1
            } : s ? s(a) : a
        } : s
    }
}
o(EL, "__asyncDelegator");

function bL(r) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = r[Symbol.asyncIterator],
        t;
    return e ? e.call(r) : (r = typeof Ap == "function" ? Ap(r) : r[Symbol.iterator](), t = {}, n("next"), n("throw"), n("return"), t[Symbol.asyncIterator] = function() {
        return this
    }, t);

    function n(s) {
        t[s] = r[s] && function(a) {
            return new Promise(function(u, l) {
                a = r[s](a), i(u, l, a.done, a.value)
            })
        }
    }

    function i(s, a, u, l) {
        Promise.resolve(l).then(function(c) {
            s({
                value: c,
                done: u
            })
        }, a)
    }
}
o(bL, "__asyncValues");

function SL(r, e) {
    return Object.defineProperty ? Object.defineProperty(r, "raw", {
        value: e
    }) : r.raw = e, r
}
o(SL, "__makeTemplateObject");
var _J = Object.create ? function(r, e) {
        Object.defineProperty(r, "default", {
            enumerable: !0,
            value: e
        })
    } : function(r, e) {
        r.default = e
    },
    BE = o(function(r) {
        return BE = Object.getOwnPropertyNames || function(e) {
            var t = [];
            for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[t.length] = n);
            return t
        }, BE(r)
    }, "ownKeys");

function AL(r) {
    if (r && r.__esModule) return r;
    var e = {};
    if (r != null)
        for (var t = BE(r), n = 0; n < t.length; n++) t[n] !== "default" && qp(e, r, t[n]);
    return _J(e, r), e
}
o(AL, "__importStar");

function IL(r) {
    return r && r.__esModule ? r : {
        default: r
    }
}
o(IL, "__importDefault");

function H(r, e, t, n) {
    if (t === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? r !== e || !n : !e.has(r)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return t === "m" ? n : t === "a" ? n.call(r) : n ? n.value : e.get(r)
}
o(H, "__classPrivateFieldGet");

function Ae(r, e, t, n, i) {
    if (n === "m") throw new TypeError("Private method is not writable");
    if (n === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? r !== e || !i : !e.has(r)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return n === "a" ? i.call(r, t) : i ? i.value = t : e.set(r, t), t
}
o(Ae, "__classPrivateFieldSet");

function CL(r, e) {
    if (e === null || typeof e != "object" && typeof e != "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof r == "function" ? e === r : r.has(e)
}
o(CL, "__classPrivateFieldIn");

function RL(r, e, t) {
    if (e != null) {
        if (typeof e != "object" && typeof e != "function") throw new TypeError("Object expected.");
        var n, i;
        if (t) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            n = e[Symbol.asyncDispose]
        }
        if (n === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            n = e[Symbol.dispose], t && (i = n)
        }
        if (typeof n != "function") throw new TypeError("Object not disposable.");
        i && (n = o(function() {
            try {
                i.call(this)
            } catch (s) {
                return Promise.reject(s)
            }
        }, "dispose")), r.stack.push({
            value: e,
            dispose: n,
            async: t
        })
    } else t && r.stack.push({
        async: !0
    });
    return e
}
o(RL, "__addDisposableResource");
var wJ = typeof SuppressedError == "function" ? SuppressedError : function(r, e, t) {
    var n = new Error(t);
    return n.name = "SuppressedError", n.error = r, n.suppressed = e, n
};

function OL(r) {
    function e(s) {
        r.error = r.hasError ? new wJ(s, r.error, "An error was suppressed during disposal.") : s, r.hasError = !0
    }
    o(e, "fail");
    var t, n = 0;

    function i() {
        for (; t = r.stack.pop();) try {
            if (!t.async && n === 1) return n = 0, r.stack.push(t), Promise.resolve().then(i);
            if (t.dispose) {
                var s = t.dispose.call(t.value);
                if (t.async) return n |= 2, Promise.resolve(s).then(i, function(a) {
                    return e(a), i()
                })
            } else n |= 1
        } catch (a) {
            e(a)
        }
        if (n === 1) return r.hasError ? Promise.reject(r.error) : Promise.resolve();
        if (r.hasError) throw r.error
    }
    return o(i, "next"), i()
}
o(OL, "__disposeResources");

function PL(r, e) {
    return typeof r == "string" && /^\.\.?\//.test(r) ? r.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(t, n, i, s, a) {
        return n ? e ? ".jsx" : ".js" : i && (!s || !a) ? t : i + s + "." + a.toLowerCase() + "js"
    }) : r
}
o(PL, "__rewriteRelativeImportExtension");
var TJ = {
        __extends: zp,
        __assign: Kt,
        __rest: cL,
        __decorate: lL,
        __param: dL,
        __esDecorate: fL,
        __runInitializers: hL,
        __propKey: gL,
        __setFunctionName: pL,
        __metadata: mL,
        __awaiter: be,
        __generator: Ze,
        __createBinding: qp,
        __exportStar: vL,
        __values: Ap,
        __read: dn,
        __spread: yL,
        __spreadArrays: _L,
        __spreadArray: wL,
        __await: fu,
        __asyncGenerator: TL,
        __asyncDelegator: EL,
        __asyncValues: bL,
        __makeTemplateObject: SL,
        __importStar: AL,
        __importDefault: IL,
        __classPrivateFieldGet: H,
        __classPrivateFieldSet: Ae,
        __classPrivateFieldIn: CL,
        __addDisposableResource: RL,
        __disposeResources: OL,
        __rewriteRelativeImportExtension: PL
    },
    EJ = Object.freeze({
        __proto__: null,
        __addDisposableResource: RL,
        get __assign() {
            return Kt
        },
        __asyncDelegator: EL,
        __asyncGenerator: TL,
        __asyncValues: bL,
        __await: fu,
        __awaiter: be,
        __classPrivateFieldGet: H,
        __classPrivateFieldIn: CL,
        __classPrivateFieldSet: Ae,
        __createBinding: qp,
        __decorate: lL,
        __disposeResources: OL,
        __esDecorate: fL,
        __exportStar: vL,
        __extends: zp,
        __generator: Ze,
        __importDefault: IL,
        __importStar: AL,
        __makeTemplateObject: SL,
        __metadata: mL,
        __param: dL,
        __propKey: gL,
        __read: dn,
        __rest: cL,
        __rewriteRelativeImportExtension: PL,
        __runInitializers: hL,
        __setFunctionName: pL,
        __spread: yL,
        __spreadArray: wL,
        __spreadArrays: _L,
        __values: Ap,
        default: TJ
    }),
    Ip;
(function(r) {
    r.Cognito = "COGNITO", r.Google = "Google", r.Facebook = "Facebook", r.Amazon = "LoginWithAmazon", r.Apple = "SignInWithApple"
})(Ip || (Ip = {}));

function CE(r) {
    var e = ["provider"];
    return r && !!e.find(function(t) {
        return r.hasOwnProperty(t)
    })
}
o(CE, "isFederatedSignInOptions");

function bJ(r) {
    var e = ["customProvider"];
    return r && !!e.find(function(t) {
        return r.hasOwnProperty(t)
    })
}
o(bJ, "isFederatedSignInOptionsCustom");

function SJ(r) {
    var e = ["customState"];
    return r && !!e.find(function(t) {
        return r.hasOwnProperty(t)
    })
}
o(SJ, "hasCustomState");

function Ao(r) {
    return r.redirectSignIn !== void 0
}
o(Ao, "isCognitoHostedOpts");
var at;
(function(r) {
    r.NoConfig = "noConfig", r.MissingAuthConfig = "missingAuthConfig", r.EmptyUsername = "emptyUsername", r.InvalidUsername = "invalidUsername", r.EmptyPassword = "emptyPassword", r.EmptyCode = "emptyCode", r.SignUpError = "signUpError", r.NoMFA = "noMFA", r.InvalidMFA = "invalidMFA", r.EmptyChallengeResponse = "emptyChallengeResponse", r.NoUserSession = "noUserSession", r.Default = "default", r.DeviceConfig = "deviceConfig", r.NetworkError = "networkError", r.AutoSignInError = "autoSignInError"
})(at || (at = {}));

function AJ(r) {
    return !!r.username
}
o(AJ, "isUsernamePasswordOpts");
var vD;
(function(r) {
    r.API_KEY = "API_KEY", r.AWS_IAM = "AWS_IAM", r.OPENID_CONNECT = "OPENID_CONNECT", r.AMAZON_COGNITO_USER_POOLS = "AMAZON_COGNITO_USER_POOLS", r.AWS_LAMBDA = "AWS_LAMBDA"
})(vD || (vD = {}));
var IJ = "Logging",
    CJ = function(r) {
        var e = typeof Symbol == "function" && Symbol.iterator,
            t = e && r[e],
            n = 0;
        if (t) return t.call(r);
        if (r && typeof r.length == "number") return {
            next: o(function() {
                return r && n >= r.length && (r = void 0), {
                    value: r && r[n++],
                    done: !r
                }
            }, "next")
        };
        throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
    },
    Ka = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    },
    Ya = function(r, e, t) {
        if (t || arguments.length === 2)
            for (var n = 0, i = e.length, s; n < i; n++)(s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
        return r.concat(s || Array.prototype.slice.call(e))
    },
    yD = {
        VERBOSE: 1,
        DEBUG: 2,
        INFO: 3,
        WARN: 4,
        ERROR: 5
    },
    Pn;
(function(r) {
    r.DEBUG = "DEBUG", r.ERROR = "ERROR", r.INFO = "INFO", r.WARN = "WARN", r.VERBOSE = "VERBOSE"
})(Pn || (Pn = {}));
var Ln = (function() {
        function r(e, t) {
            t === void 0 && (t = Pn.WARN), this.name = e, this.level = t, this._pluggables = []
        }
        return o(r, "ConsoleLogger"), r.prototype._padding = function(e) {
            return e < 10 ? "0" + e : "" + e
        }, r.prototype._ts = function() {
            var e = new Date;
            return [this._padding(e.getMinutes()), this._padding(e.getSeconds())].join(":") + "." + e.getMilliseconds()
        }, r.prototype.configure = function(e) {
            return e ? (this._config = e, this._config) : this._config
        }, r.prototype._log = function(e) {
            for (var t, n, i = [], s = 1; s < arguments.length; s++) i[s - 1] = arguments[s];
            var a = this.level;
            r.LOG_LEVEL && (a = r.LOG_LEVEL), typeof window != "undefined" && window.LOG_LEVEL && (a = window.LOG_LEVEL);
            var u = yD[a],
                l = yD[e];
            if (l >= u) {
                var c = console.log.bind(console);
                e === Pn.ERROR && console.error && (c = console.error.bind(console)), e === Pn.WARN && console.warn && (c = console.warn.bind(console));
                var d = "[".concat(e, "] ").concat(this._ts(), " ").concat(this.name),
                    f = "";
                if (i.length === 1 && typeof i[0] == "string") f = "".concat(d, " - ").concat(i[0]), c(f);
                else if (i.length === 1) f = "".concat(d, " ").concat(i[0]), c(d, i[0]);
                else if (typeof i[0] == "string") {
                    var h = i.slice(1);
                    h.length === 1 && (h = h[0]), f = "".concat(d, " - ").concat(i[0], " ").concat(h), c("".concat(d, " - ").concat(i[0]), h)
                } else f = "".concat(d, " ").concat(i), c(d, i);
                try {
                    for (var g = CJ(this._pluggables), p = g.next(); !p.done; p = g.next()) {
                        var m = p.value,
                            w = {
                                message: f,
                                timestamp: Date.now()
                            };
                        m.pushLogs([w])
                    }
                } catch (T) {
                    t = {
                        error: T
                    }
                } finally {
                    try {
                        p && !p.done && (n = g.return) && n.call(g)
                    } finally {
                        if (t) throw t.error
                    }
                }
            }
        }, r.prototype.log = function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            this._log.apply(this, Ya([Pn.INFO], Ka(e), !1))
        }, r.prototype.info = function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            this._log.apply(this, Ya([Pn.INFO], Ka(e), !1))
        }, r.prototype.warn = function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            this._log.apply(this, Ya([Pn.WARN], Ka(e), !1))
        }, r.prototype.error = function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            this._log.apply(this, Ya([Pn.ERROR], Ka(e), !1))
        }, r.prototype.debug = function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            this._log.apply(this, Ya([Pn.DEBUG], Ka(e), !1))
        }, r.prototype.verbose = function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            this._log.apply(this, Ya([Pn.VERBOSE], Ka(e), !1))
        }, r.prototype.addPluggable = function(e) {
            e && e.getCategoryName() === IJ && (this._pluggables.push(e), e.configure(this._config))
        }, r.prototype.listPluggables = function() {
            return this._pluggables
        }, r.LOG_LEVEL = null, r
    })(),
    RJ = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    },
    RE = new Ln("Amplify"),
    OJ = (function() {
        function r() {
            this._components = [], this._config = {}, this._modules = {}, this.Auth = null, this.Analytics = null, this.API = null, this.Credentials = null, this.Storage = null, this.I18n = null, this.Cache = null, this.PubSub = null, this.Interactions = null, this.Pushnotification = null, this.UI = null, this.XR = null, this.Predictions = null, this.DataStore = null, this.Geo = null, this.Notifications = null, this.Logger = Ln, this.ServiceWorker = null
        }
        return o(r, "AmplifyClass"), r.prototype.register = function(e) {
            RE.debug("component registered in amplify", e), this._components.push(e), typeof e.getModuleName == "function" ? (this._modules[e.getModuleName()] = e, this[e.getModuleName()] = e) : RE.debug("no getModuleName method for component", e), e.configure(this._config)
        }, r.prototype.configure = function(e) {
            var t = this;
            return e ? (this._config = Object.assign(this._config, e), RE.debug("amplify config", this._config), Object.entries(this._modules).forEach(function(n) {
                var i = RJ(n, 2);
                i[0];
                var s = i[1];
                Object.keys(s).forEach(function(a) {
                    t._modules[a] && (s[a] = t._modules[a])
                })
            }), this._components.map(function(n) {
                n.configure(t._config)
            }), this._config) : this._config
        }, r.prototype.addPluggable = function(e) {
            e && e.getCategory && typeof e.getCategory == "function" && this._components.map(function(t) {
                t.addPluggable && typeof t.addPluggable == "function" && t.addPluggable(e)
            })
        }, r
    })(),
    wd = new OJ,
    Ut;
(function(r) {
    r.WebUnknown = "0", r.React = "1", r.NextJs = "2", r.Angular = "3", r.VueJs = "4", r.Nuxt = "5", r.Svelte = "6", r.ServerSideUnknown = "100", r.ReactSSR = "101", r.NextJsSSR = "102", r.AngularSSR = "103", r.VueJsSSR = "104", r.NuxtSSR = "105", r.SvelteSSR = "106", r.ReactNative = "201", r.Expo = "202"
})(Ut || (Ut = {}));
var VE;
(function(r) {
    r.API = "api", r.Auth = "auth", r.Analytics = "analytics", r.DataStore = "datastore", r.Geo = "geo", r.InAppMessaging = "inappmessaging", r.Interactions = "interactions", r.Predictions = "predictions", r.PubSub = "pubsub", r.PushNotification = "pushnotification", r.Storage = "storage"
})(VE || (VE = {}));
var _D;
(function(r) {
    r.Record = "1", r.UpdateEndpoint = "2"
})(_D || (_D = {}));
var wD;
(function(r) {
    r.GraphQl = "1", r.Get = "2", r.Post = "3", r.Put = "4", r.Patch = "5", r.Del = "6", r.Head = "7"
})(wD || (wD = {}));
var HE;
(function(r) {
    r.FederatedSignIn = "30"
})(HE || (HE = {}));
var TD;
(function(r) {
    r.Subscribe = "1", r.GraphQl = "2"
})(TD || (TD = {}));
var ED;
(function(r) {
    r.None = "0"
})(ED || (ED = {}));
var bD;
(function(r) {
    r.None = "0"
})(bD || (bD = {}));
var SD;
(function(r) {
    r.None = "0"
})(SD || (SD = {}));
var AD;
(function(r) {
    r.Convert = "1", r.Identify = "2", r.Interpret = "3"
})(AD || (AD = {}));
var ID;
(function(r) {
    r.Subscribe = "1"
})(ID || (ID = {}));
var CD;
(function(r) {
    r.None = "0"
})(CD || (CD = {}));
var RD;
(function(r) {
    r.Put = "1", r.Get = "2", r.List = "3", r.Copy = "4", r.Remove = "5", r.GetProperties = "6"
})(RD || (RD = {}));
var NL = "5.3.26",
    Kp = o(function() {
        return typeof global != "undefined"
    }, "globalExists"),
    hu = o(function() {
        return typeof window != "undefined"
    }, "windowExists"),
    DL = o(function() {
        return typeof document != "undefined"
    }, "documentExists"),
    wb = o(function() {
        return typeof process != "undefined"
    }, "processExists"),
    md = o(function(r, e) {
        return !!Object.keys(r).find(function(t) {
            return t.startsWith(e)
        })
    }, "keyPrefixMatch");

function PJ() {
    var r = o(function(n) {
            return n.startsWith("_react") || n.startsWith("__react")
        }, "elementKeyPrefixedWithReact"),
        e = o(function(n) {
            return Object.keys(n).find(r)
        }, "elementIsReactEnabled"),
        t = o(function() {
            return Array.from(document.querySelectorAll("[id]"))
        }, "allElementsWithId");
    return DL() && t().some(e)
}
o(PJ, "reactWebDetect");

function NJ() {
    return wb() && typeof process.env != "undefined" && !!Object.keys(process.env).find(function(r) {
        return r.includes("react")
    })
}
o(NJ, "reactSSRDetect");

function DJ() {
    return hu() && md(window, "__VUE")
}
o(DJ, "vueWebDetect");

function LJ() {
    return Kp() && md(global, "__VUE")
}
o(LJ, "vueSSRDetect");

function xJ() {
    return hu() && md(window, "__SVELTE")
}
o(xJ, "svelteWebDetect");

function UJ() {
    return wb() && typeof process.env != "undefined" && !!Object.keys(process.env).find(function(r) {
        return r.includes("svelte")
    })
}
o(UJ, "svelteSSRDetect");

function MJ() {
    return hu() && window.next && typeof window.next == "object"
}
o(MJ, "nextWebDetect");

function kJ() {
    return Kp() && (md(global, "__next") || md(global, "__NEXT"))
}
o(kJ, "nextSSRDetect");

function FJ() {
    return hu() && (window.__NUXT__ !== void 0 || window.$nuxt !== void 0)
}
o(FJ, "nuxtWebDetect");

function $J() {
    return Kp() && typeof global.__NUXT_PATHS__ != "undefined"
}
o($J, "nuxtSSRDetect");

function BJ() {
    var r = !!(DL() && document.querySelector("[ng-version]")),
        e = !!(hu() && typeof window.ng != "undefined");
    return r || e
}
o(BJ, "angularWebDetect");

function VJ() {
    var r;
    return wb() && typeof process.env == "object" && ((r = process.env.npm_lifecycle_script) === null || r === void 0 ? void 0 : r.startsWith("ng ")) || !1
}
o(VJ, "angularSSRDetect");

function HJ() {
    return typeof navigator != "undefined" && typeof navigator.product != "undefined" && navigator.product === "ReactNative"
}
o(HJ, "reactNativeDetect");

function jJ() {
    return Kp() && typeof global.expo != "undefined"
}
o(jJ, "expoDetect");

function WJ() {
    return hu()
}
o(WJ, "webDetect");
var GJ = [{
    platform: Ut.Expo,
    detectionMethod: jJ
}, {
    platform: Ut.ReactNative,
    detectionMethod: HJ
}, {
    platform: Ut.NextJs,
    detectionMethod: MJ
}, {
    platform: Ut.Nuxt,
    detectionMethod: FJ
}, {
    platform: Ut.Angular,
    detectionMethod: BJ
}, {
    platform: Ut.React,
    detectionMethod: PJ
}, {
    platform: Ut.VueJs,
    detectionMethod: DJ
}, {
    platform: Ut.Svelte,
    detectionMethod: xJ
}, {
    platform: Ut.WebUnknown,
    detectionMethod: WJ
}, {
    platform: Ut.NextJsSSR,
    detectionMethod: kJ
}, {
    platform: Ut.NuxtSSR,
    detectionMethod: $J
}, {
    platform: Ut.ReactSSR,
    detectionMethod: NJ
}, {
    platform: Ut.VueJsSSR,
    detectionMethod: LJ
}, {
    platform: Ut.AngularSSR,
    detectionMethod: VJ
}, {
    platform: Ut.SvelteSSR,
    detectionMethod: UJ
}];

function zJ() {
    var r;
    return ((r = GJ.find(function(e) {
        return e.detectionMethod()
    })) === null || r === void 0 ? void 0 : r.platform) || Ut.ServerSideUnknown
}
o(zJ, "detect");
var rd, lp = [],
    Cp = !1,
    qJ = 10,
    KJ = 10,
    YJ = 1e3,
    Tb = o(function() {
        if (!rd) {
            if (rd = zJ(), Cp)
                for (; lp.length;) lp.pop()();
            else lp.forEach(function(r) {
                return r()
            });
            OD(Ut.ServerSideUnknown, qJ), OD(Ut.WebUnknown, KJ)
        }
        return rd
    }, "detectFramework"),
    LL = o(function(r) {
        Cp || lp.push(r)
    }, "observeFrameworkChanges");

function XJ() {
    rd = void 0
}
o(XJ, "clearCache");

function OD(r, e) {
    rd === r && !Cp && setTimeout(function() {
        XJ(), Cp = !0, setTimeout(Tb, YJ)
    }, e)
}
o(OD, "resetTimeout");
var JJ = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    },
    xL = "aws-amplify",
    ZJ = (function() {
        function r() {
            this.userAgent = "".concat(xL, "/").concat(NL)
        }
        return o(r, "PlatformBuilder"), Object.defineProperty(r.prototype, "framework", {
            get: o(function() {
                return Tb()
            }, "get"),
            enumerable: !1,
            configurable: !0
        }), Object.defineProperty(r.prototype, "isReactNative", {
            get: o(function() {
                return this.framework === Ut.ReactNative || this.framework === Ut.Expo
            }, "get"),
            enumerable: !1,
            configurable: !0
        }), r.prototype.observeFrameworkChanges = function(e) {
            LL(e)
        }, r
    })(),
    OE = new ZJ,
    QJ = o(function(r) {
        var e = r === void 0 ? {} : r,
            t = e.category,
            n = e.action;
        e.framework;
        var i = [
            [xL, NL]
        ];
        return t && i.push([t, n]), i.push(["framework", Tb()]), i
    }, "getAmplifyUserAgentObject"),
    Eb = o(function(r) {
        var e = QJ(r),
            t = e.map(function(n) {
                var i = JJ(n, 2),
                    s = i[0],
                    a = i[1];
                return "".concat(s, "/").concat(a)
            }).join(" ");
        return t
    }, "getAmplifyUserAgent$1"),
    nd = function() {
        return nd = Object.assign || function(r) {
            for (var e, t = 1, n = arguments.length; t < n; t++) {
                e = arguments[t];
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (r[i] = e[i])
            }
            return r
        }, nd.apply(this, arguments)
    },
    PE = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    },
    PD = function(r, e, t) {
        if (t || arguments.length === 2)
            for (var n = 0, i = e.length, s; n < i; n++)(s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
        return r.concat(s || Array.prototype.slice.call(e))
    },
    Ci = new Ln("Hub"),
    eZ = typeof Symbol != "undefined" && typeof Symbol.for == "function" ? Symbol.for("amplify_default") : "@@amplify_default";

function tZ(r) {
    return r.onHubCapsule !== void 0
}
o(tZ, "isLegacyCallback");
var rZ = (function() {
        function r(e) {
            this.listeners = [], this.patterns = [], this.protectedChannels = ["core", "auth", "api", "analytics", "interactions", "pubsub", "storage", "ui", "xr"], this.name = e
        }
        return o(r, "HubClass"), r.prototype._remove = function(e, t) {
            if (e instanceof RegExp) {
                var n = this.patterns.find(function(s) {
                    var a = s.pattern;
                    return a.source === e.source
                });
                if (!n) {
                    Ci.warn("No listeners for ".concat(e));
                    return
                }
                this.patterns = PD([], PE(this.patterns.filter(function(s) {
                    return s !== n
                })), !1)
            } else {
                var i = this.listeners[e];
                if (!i) {
                    Ci.warn("No listeners for ".concat(e));
                    return
                }
                this.listeners[e] = PD([], PE(i.filter(function(s) {
                    var a = s.callback;
                    return a !== t
                })), !1)
            }
        }, r.prototype.remove = function(e, t) {
            this._remove(e, t)
        }, r.prototype.dispatch = function(e, t, n, i) {
            if (n === void 0 && (n = ""), this.protectedChannels.indexOf(e) > -1) {
                var s = i === eZ;
                s || Ci.warn("WARNING: ".concat(e, " is protected and dispatching on it can have unintended consequences"))
            }
            var a = {
                channel: e,
                payload: nd({}, t),
                source: n,
                patternInfo: []
            };
            try {
                this._toListeners(a)
            } catch (u) {
                Ci.error(u)
            }
        }, r.prototype.listen = function(e, t, n) {
            var i = this;
            n === void 0 && (n = "noname");
            var s;
            if (tZ(t)) Ci.warn("WARNING onHubCapsule is Deprecated. Please pass in a callback."), s = t.onHubCapsule.bind(t);
            else {
                if (typeof t != "function") throw new Error("No callback supplied to Hub");
                s = t
            }
            if (e instanceof RegExp) this.patterns.push({
                pattern: e,
                callback: s
            });
            else {
                var a = this.listeners[e];
                a || (a = [], this.listeners[e] = a), a.push({
                    name: n,
                    callback: s
                })
            }
            return function() {
                i._remove(e, s)
            }
        }, r.prototype._toListeners = function(e) {
            var t = e.channel,
                n = e.payload,
                i = this.listeners[t];
            if (i && i.forEach(function(a) {
                    Ci.debug("Dispatching to ".concat(t, " with "), n);
                    try {
                        a.callback(e)
                    } catch (u) {
                        Ci.error(u)
                    }
                }), this.patterns.length > 0) {
                if (!n.message) {
                    Ci.warn("Cannot perform pattern matching without a message key");
                    return
                }
                var s = n.message;
                this.patterns.forEach(function(a) {
                    var u = s.match(a.pattern);
                    if (u) {
                        var l = PE(u),
                            c = l.slice(1),
                            d = nd(nd({}, e), {
                                patternInfo: c
                            });
                        try {
                            a.callback(d)
                        } catch (f) {
                            Ci.error(f)
                        }
                    }
                })
            }
        }, r
    })(),
    Oi = new rZ("__default__"),
    nZ = o(function(r) {
        if (r.isResolved) return r;
        var e = !0,
            t = !1,
            n = !1,
            i = r.then(function(s) {
                return n = !0, e = !1, s
            }, function(s) {
                throw t = !0, e = !1, s
            });
        return i.isFullfilled = function() {
            return n
        }, i.isPending = function() {
            return e
        }, i.isRejected = function() {
            return t
        }, i
    }, "makeQuerablePromise"),
    ki = o(function() {
        var r = typeof window != "undefined" && typeof window.document != "undefined",
            e = typeof process != "undefined" && process.versions != null && process.versions.node != null;
        return {
            isBrowser: r,
            isNode: e
        }
    }, "browserOrNode"),
    iZ = (function() {
        var r = o(function(e, t) {
            return r = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array && function(n, i) {
                n.__proto__ = i
            } || function(n, i) {
                for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s])
            }, r(e, t)
        }, "extendStatics");
        return function(e, t) {
            if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
            r(e, t);

            function n() {
                this.constructor = e
            }
            o(n, "__"), e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n)
        }
    })(),
    ND = function(r, e, t, n) {
        function i(s) {
            return s instanceof t ? s : new t(function(a) {
                a(s)
            })
        }
        return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
            function u(d) {
                try {
                    c(n.next(d))
                } catch (f) {
                    a(f)
                }
            }
            o(u, "fulfilled");

            function l(d) {
                try {
                    c(n.throw(d))
                } catch (f) {
                    a(f)
                }
            }
            o(l, "rejected");

            function c(d) {
                d.done ? s(d.value) : i(d.value).then(u, l)
            }
            o(c, "step"), c((n = n.apply(r, e || [])).next())
        })
    },
    NE = function(r, e) {
        var t = {
                label: 0,
                sent: o(function() {
                    if (s[0] & 1) throw s[1];
                    return s[1]
                }, "sent"),
                trys: [],
                ops: []
            },
            n, i, s, a;
        return a = {
            next: u(0),
            throw: u(1),
            return: u(2)
        }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
            return this
        }), a;

        function u(c) {
            return function(d) {
                return l([c, d])
            }
        }

        function l(c) {
            if (n) throw new TypeError("Generator is already executing.");
            for (; a && (a = 0, c[0] && (t = 0)), t;) try {
                if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
                switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                    case 0:
                    case 1:
                        s = c;
                        break;
                    case 4:
                        return t.label++, {
                            value: c[1],
                            done: !1
                        };
                    case 5:
                        t.label++, i = c[1], c = [0];
                        continue;
                    case 7:
                        c = t.ops.pop(), t.trys.pop();
                        continue;
                    default:
                        if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                            t = 0;
                            continue
                        }
                        if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                            t.label = c[1];
                            break
                        }
                        if (c[0] === 6 && t.label < s[1]) {
                            t.label = s[1], s = c;
                            break
                        }
                        if (s && t.label < s[2]) {
                            t.label = s[2], t.ops.push(c);
                            break
                        }
                        s[2] && t.ops.pop(), t.trys.pop();
                        continue
                }
                c = e.call(r, t)
            } catch (d) {
                c = [6, d], i = 0
            } finally {
                n = s = 0
            }
            if (c[0] & 5) throw c[1];
            return {
                value: c[0] ? c[1] : void 0,
                done: !0
            }
        }
    },
    sZ = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    },
    oZ = function(r, e, t) {
        if (t || arguments.length === 2)
            for (var n = 0, i = e.length, s; n < i; n++)(s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
        return r.concat(s || Array.prototype.slice.call(e))
    },
    np = new Ln("Util"),
    Io = (function(r) {
        iZ(e, r);

        function e(t) {
            var n = r.call(this, t) || this;
            return n.nonRetryable = !0, n
        }
        return o(e, "NonRetryableError"), e
    })(Error),
    aZ = o(function(r) {
        var e = "nonRetryable";
        return r && r[e]
    }, "isNonRetryableError$1");

function uZ(r, e, t, n) {
    return ND(this, void 0, void 0, function() {
        var i = this;
        return NE(this, function(s) {
            if (typeof r != "function") throw Error("functionToRetry must be a function");
            return [2, new Promise(function(a, u) {
                return ND(i, void 0, void 0, function() {
                    var l, c, d, f, h, g;
                    return NE(this, function(p) {
                        switch (p.label) {
                            case 0:
                                l = 0, c = !1, d = o(function() {}, "wakeUp"), h = o(function() {
                                    var m, w, T, E;
                                    return NE(this, function(b) {
                                        switch (b.label) {
                                            case 0:
                                                l++, np.debug("".concat(r.name, " attempt #").concat(l, " with this vars: ").concat(JSON.stringify(e))), b.label = 1;
                                            case 1:
                                                return b.trys.push([1, 3, , 7]), m = {}, w = a, [4, r.apply(void 0, oZ([], sZ(e), !1))];
                                            case 2:
                                                return [2, (m.value = w.apply(void 0, [b.sent()]), m)];
                                            case 3:
                                                return T = b.sent(), f = T, np.debug("error on ".concat(r.name), T), aZ(T) ? (np.debug("".concat(r.name, " non retryable error"), T), [2, {
                                                    value: u(T)
                                                }]) : (E = t(l, e, T), np.debug("".concat(r.name, " retrying in ").concat(E, " ms")), E === !1 || c ? [2, {
                                                    value: u(T)
                                                }] : [3, 4]);
                                            case 4:
                                                return [4, new Promise(function(R) {
                                                    d = R, setTimeout(d, E)
                                                })];
                                            case 5:
                                                b.sent(), b.label = 6;
                                            case 6:
                                                return [3, 7];
                                            case 7:
                                                return [2]
                                        }
                                    })
                                }, "_loop_1"), p.label = 1;
                            case 1:
                                return c ? [3, 3] : [5, h()];
                            case 2:
                                return g = p.sent(), typeof g == "object" ? [2, g.value] : [3, 1];
                            case 3:
                                return u(f), [2]
                        }
                    })
                })
            })]
        })
    })
}
o(uZ, "retry$1");
var cZ = 300 * 1e3;

function UL(r) {
    r === void 0 && (r = cZ);
    var e = 100,
        t = 100;
    return function(n) {
        var i = Math.pow(2, n) * e + t * Math.random();
        return i > r ? !1 : i
    }
}
o(UL, "jitteredBackoff$2");
var lZ = o(function(r, e, t, n) {
        return uZ(r, e, UL(t))
    }, "jitteredExponentialRetry$1"),
    Ui = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};

function dZ(r) {
    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r
}
o(dZ, "getDefaultExportFromCjs");

function bb(r) {
    if (r.__esModule) return r;
    var e = r.default;
    if (typeof e == "function") {
        var t = o(function n() {
            return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        }, "a");
        t.prototype = e.prototype
    } else t = {};
    return Object.defineProperty(t, "__esModule", {
        value: !0
    }), Object.keys(r).forEach(function(n) {
        var i = Object.getOwnPropertyDescriptor(r, n);
        Object.defineProperty(t, n, i.get ? i : {
            enumerable: !0,
            get: o(function() {
                return r[n]
            }, "get")
        })
    }), t
}
o(bb, "getAugmentedNamespace");

function fZ(r) {
    return r.split("").map(function(e) {
        return e.charCodeAt(0).toString(16).padStart(2, "0")
    }).join("")
}
o(fZ, "urlSafeEncode");

function hZ(r) {
    return r.match(/.{2}/g).map(function(e) {
        return String.fromCharCode(parseInt(e, 16))
    }).join("")
}
o(hZ, "urlSafeDecode");
var Co = {},
    ML = bb(EJ),
    Yp = {},
    Qr = {};
Object.defineProperty(Qr, "__esModule", {
    value: !0
});
Qr.MAX_HASHABLE_LENGTH = Qr.INIT = Qr.KEY = Qr.DIGEST_LENGTH = Qr.BLOCK_SIZE = void 0;
Qr.BLOCK_SIZE = 64;
Qr.DIGEST_LENGTH = 32;
Qr.KEY = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
Qr.INIT = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];
Qr.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
var Xp = {};
Object.defineProperty(Xp, "__esModule", {
    value: !0
});
Xp.RawSha256 = void 0;
var cn = Qr,
    gZ = (function() {
        function r() {
            this.state = Int32Array.from(cn.INIT), this.temp = new Int32Array(64), this.buffer = new Uint8Array(64), this.bufferLength = 0, this.bytesHashed = 0, this.finished = !1
        }
        return o(r, "RawSha256"), r.prototype.update = function(e) {
            if (this.finished) throw new Error("Attempted to update an already finished hash.");
            var t = 0,
                n = e.byteLength;
            if (this.bytesHashed += n, this.bytesHashed * 8 > cn.MAX_HASHABLE_LENGTH) throw new Error("Cannot hash more than 2^53 - 1 bits");
            for (; n > 0;) this.buffer[this.bufferLength++] = e[t++], n--, this.bufferLength === cn.BLOCK_SIZE && (this.hashBuffer(), this.bufferLength = 0)
        }, r.prototype.digest = function() {
            if (!this.finished) {
                var e = this.bytesHashed * 8,
                    t = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength),
                    n = this.bufferLength;
                if (t.setUint8(this.bufferLength++, 128), n % cn.BLOCK_SIZE >= cn.BLOCK_SIZE - 8) {
                    for (var i = this.bufferLength; i < cn.BLOCK_SIZE; i++) t.setUint8(i, 0);
                    this.hashBuffer(), this.bufferLength = 0
                }
                for (var i = this.bufferLength; i < cn.BLOCK_SIZE - 8; i++) t.setUint8(i, 0);
                t.setUint32(cn.BLOCK_SIZE - 8, Math.floor(e / 4294967296), !0), t.setUint32(cn.BLOCK_SIZE - 4, e), this.hashBuffer(), this.finished = !0
            }
            for (var s = new Uint8Array(cn.DIGEST_LENGTH), i = 0; i < 8; i++) s[i * 4] = this.state[i] >>> 24 & 255, s[i * 4 + 1] = this.state[i] >>> 16 & 255, s[i * 4 + 2] = this.state[i] >>> 8 & 255, s[i * 4 + 3] = this.state[i] >>> 0 & 255;
            return s
        }, r.prototype.hashBuffer = function() {
            for (var e = this, t = e.buffer, n = e.state, i = n[0], s = n[1], a = n[2], u = n[3], l = n[4], c = n[5], d = n[6], f = n[7], h = 0; h < cn.BLOCK_SIZE; h++) {
                if (h < 16) this.temp[h] = (t[h * 4] & 255) << 24 | (t[h * 4 + 1] & 255) << 16 | (t[h * 4 + 2] & 255) << 8 | t[h * 4 + 3] & 255;
                else {
                    var g = this.temp[h - 2],
                        p = (g >>> 17 | g << 15) ^ (g >>> 19 | g << 13) ^ g >>> 10;
                    g = this.temp[h - 15];
                    var m = (g >>> 7 | g << 25) ^ (g >>> 18 | g << 14) ^ g >>> 3;
                    this.temp[h] = (p + this.temp[h - 7] | 0) + (m + this.temp[h - 16] | 0)
                }
                var w = (((l >>> 6 | l << 26) ^ (l >>> 11 | l << 21) ^ (l >>> 25 | l << 7)) + (l & c ^ ~l & d) | 0) + (f + (cn.KEY[h] + this.temp[h] | 0) | 0) | 0,
                    T = ((i >>> 2 | i << 30) ^ (i >>> 13 | i << 19) ^ (i >>> 22 | i << 10)) + (i & s ^ i & a ^ s & a) | 0;
                f = d, d = c, c = l, l = u + w | 0, u = a, a = s, s = i, i = w + T | 0
            }
            n[0] += i, n[1] += s, n[2] += a, n[3] += u, n[4] += l, n[5] += c, n[6] += d, n[7] += f
        }, r
    })();
Xp.RawSha256 = gZ;
var kL = {},
    Jp = {},
    pZ = o(r => {
        let e = [];
        for (let t = 0, n = r.length; t < n; t++) {
            let i = r.charCodeAt(t);
            if (i < 128) e.push(i);
            else if (i < 2048) e.push(i >> 6 | 192, i & 63 | 128);
            else if (t + 1 < r.length && (i & 64512) === 55296 && (r.charCodeAt(t + 1) & 64512) === 56320) {
                let s = 65536 + ((i & 1023) << 10) + (r.charCodeAt(++t) & 1023);
                e.push(s >> 18 | 240, s >> 12 & 63 | 128, s >> 6 & 63 | 128, s & 63 | 128)
            } else e.push(i >> 12 | 224, i >> 6 & 63 | 128, i & 63 | 128)
        }
        return Uint8Array.from(e)
    }, "fromUtf8$3"),
    mZ = o(r => {
        let e = "";
        for (let t = 0, n = r.length; t < n; t++) {
            let i = r[t];
            if (i < 128) e += String.fromCharCode(i);
            else if (192 <= i && i < 224) {
                let s = r[++t];
                e += String.fromCharCode((i & 31) << 6 | s & 63)
            } else if (240 <= i && i < 365) {
                let a = "%" + [i, r[++t], r[++t], r[++t]].map(u => u.toString(16)).join("%");
                e += decodeURIComponent(a)
            } else e += String.fromCharCode((i & 15) << 12 | (r[++t] & 63) << 6 | r[++t] & 63)
        }
        return e
    }, "toUtf8$2");

function vZ(r) {
    return new TextEncoder().encode(r)
}
o(vZ, "fromUtf8$2");

function yZ(r) {
    return new TextDecoder("utf-8").decode(r)
}
o(yZ, "toUtf8$1");
var _Z = o(r => typeof TextEncoder == "function" ? vZ(r) : pZ(r), "fromUtf8$1"),
    wZ = o(r => typeof TextDecoder == "function" ? yZ(r) : mZ(r), "toUtf8"),
    TZ = Object.freeze({
        __proto__: null,
        fromUtf8: _Z,
        toUtf8: wZ
    }),
    EZ = bb(TZ);
Object.defineProperty(Jp, "__esModule", {
    value: !0
});
Jp.convertToBuffer = void 0;
var bZ = EZ,
    SZ = typeof Buffer != "undefined" && Buffer.from ? function(r) {
        return Buffer.from(r, "utf8")
    } : bZ.fromUtf8;

function AZ(r) {
    return r instanceof Uint8Array ? r : typeof r == "string" ? SZ(r) : ArrayBuffer.isView(r) ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(r)
}
o(AZ, "convertToBuffer");
Jp.convertToBuffer = AZ;
var Zp = {};
Object.defineProperty(Zp, "__esModule", {
    value: !0
});
Zp.isEmptyData = void 0;

function IZ(r) {
    return typeof r == "string" ? r.length === 0 : r.byteLength === 0
}
o(IZ, "isEmptyData");
Zp.isEmptyData = IZ;
var Qp = {};
Object.defineProperty(Qp, "__esModule", {
    value: !0
});
Qp.numToUint8 = void 0;

function CZ(r) {
    return new Uint8Array([(r & 4278190080) >> 24, (r & 16711680) >> 16, (r & 65280) >> 8, r & 255])
}
o(CZ, "numToUint8");
Qp.numToUint8 = CZ;
var em = {};
Object.defineProperty(em, "__esModule", {
    value: !0
});
em.uint32ArrayFrom = void 0;

function RZ(r) {
    if (!Array.from) {
        for (var e = new Uint32Array(r.length), t = 0; t < r.length;) e[t] = r[t];
        return e
    }
    return Uint32Array.from(r)
}
o(RZ, "uint32ArrayFrom");
em.uint32ArrayFrom = RZ;
(function(r) {
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), r.uint32ArrayFrom = r.numToUint8 = r.isEmptyData = r.convertToBuffer = void 0;
    var e = Jp;
    Object.defineProperty(r, "convertToBuffer", {
        enumerable: !0,
        get: o(function() {
            return e.convertToBuffer
        }, "get")
    });
    var t = Zp;
    Object.defineProperty(r, "isEmptyData", {
        enumerable: !0,
        get: o(function() {
            return t.isEmptyData
        }, "get")
    });
    var n = Qp;
    Object.defineProperty(r, "numToUint8", {
        enumerable: !0,
        get: o(function() {
            return n.numToUint8
        }, "get")
    });
    var i = em;
    Object.defineProperty(r, "uint32ArrayFrom", {
        enumerable: !0,
        get: o(function() {
            return i.uint32ArrayFrom
        }, "get")
    })
})(kL);
Object.defineProperty(Yp, "__esModule", {
    value: !0
});
Yp.Sha256 = void 0;
var DD = ML,
    Rp = Qr,
    jE = Xp,
    WE = kL,
    OZ = (function() {
        function r(e) {
            if (this.hash = new jE.RawSha256, e) {
                this.outer = new jE.RawSha256;
                var t = PZ(e),
                    n = new Uint8Array(Rp.BLOCK_SIZE);
                n.set(t);
                for (var i = 0; i < Rp.BLOCK_SIZE; i++) t[i] ^= 54, n[i] ^= 92;
                this.hash.update(t), this.outer.update(n);
                for (var i = 0; i < t.byteLength; i++) t[i] = 0
            }
        }
        return o(r, "Sha256"), r.prototype.update = function(e) {
            if (!((0, WE.isEmptyData)(e) || this.error)) try {
                this.hash.update((0, WE.convertToBuffer)(e))
            } catch (t) {
                this.error = t
            }
        }, r.prototype.digestSync = function() {
            if (this.error) throw this.error;
            return this.outer ? (this.outer.finished || this.outer.update(this.hash.digest()), this.outer.digest()) : this.hash.digest()
        }, r.prototype.digest = function() {
            return (0, DD.__awaiter)(this, void 0, void 0, function() {
                return (0, DD.__generator)(this, function(e) {
                    return [2, this.digestSync()]
                })
            })
        }, r
    })();
Yp.Sha256 = OZ;

function PZ(r) {
    var e = (0, WE.convertToBuffer)(r);
    if (e.byteLength > Rp.BLOCK_SIZE) {
        var t = new jE.RawSha256;
        t.update(e), e = t.digest()
    }
    var n = new Uint8Array(Rp.BLOCK_SIZE);
    return n.set(e), n
}
o(PZ, "bufferFromSecret");
(function(r) {
    Object.defineProperty(r, "__esModule", {
        value: !0
    });
    var e = ML;
    (0, e.__exportStar)(Yp, r)
})(Co);
var Op = function() {
        return Op = Object.assign || function(r) {
            for (var e, t = 1, n = arguments.length; t < n; t++) {
                e = arguments[t];
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (r[i] = e[i])
            }
            return r
        }, Op.apply(this, arguments)
    },
    NZ = new Ln("Parser"),
    FL = o(function(r) {
        var e = {};
        if (r.aws_mobile_analytics_app_id) {
            var t = {
                AWSPinpoint: {
                    appId: r.aws_mobile_analytics_app_id,
                    region: r.aws_mobile_analytics_app_region
                }
            };
            e.Analytics = t
        }(r.aws_cognito_identity_pool_id || r.aws_user_pools_id) && (e.Auth = {
            userPoolId: r.aws_user_pools_id,
            userPoolWebClientId: r.aws_user_pools_web_client_id,
            region: r.aws_cognito_region,
            identityPoolId: r.aws_cognito_identity_pool_id,
            identityPoolRegion: r.aws_cognito_region,
            mandatorySignIn: r.aws_mandatory_sign_in === "enable",
            signUpVerificationMethod: r.aws_cognito_sign_up_verification_method || "code"
        });
        var n;
        return r.aws_user_files_s3_bucket ? n = {
            AWSS3: {
                bucket: r.aws_user_files_s3_bucket,
                region: r.aws_user_files_s3_bucket_region,
                dangerouslyConnectToHttpEndpointForTesting: r.aws_user_files_s3_dangerously_connect_to_http_endpoint_for_testing
            }
        } : n = r ? r.Storage || r : {}, r.Logging && (e.Logging = Op(Op({}, r.Logging), {
            region: r.aws_project_region
        })), r.geo && (e.Geo = Object.assign({}, r.geo), r.geo.amazon_location_service && (e.Geo = {
            AmazonLocationService: r.geo.amazon_location_service
        })), e.Analytics = Object.assign({}, e.Analytics, r.Analytics), e.Auth = Object.assign({}, e.Auth, r.Auth), e.Storage = Object.assign({}, n), e.Logging = Object.assign({}, e.Logging, r.Logging), NZ.debug("parse config", r, "to amplifyconfig", e), e
    }, "parseAWSExports"),
    DZ = function(r, e, t, n) {
        function i(s) {
            return s instanceof t ? s : new t(function(a) {
                a(s)
            })
        }
        return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
            function u(d) {
                try {
                    c(n.next(d))
                } catch (f) {
                    a(f)
                }
            }
            o(u, "fulfilled");

            function l(d) {
                try {
                    c(n.throw(d))
                } catch (f) {
                    a(f)
                }
            }
            o(l, "rejected");

            function c(d) {
                d.done ? s(d.value) : i(d.value).then(u, l)
            }
            o(c, "step"), c((n = n.apply(r, e || [])).next())
        })
    },
    LZ = function(r, e) {
        var t = {
                label: 0,
                sent: o(function() {
                    if (s[0] & 1) throw s[1];
                    return s[1]
                }, "sent"),
                trys: [],
                ops: []
            },
            n, i, s, a;
        return a = {
            next: u(0),
            throw: u(1),
            return: u(2)
        }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
            return this
        }), a;

        function u(c) {
            return function(d) {
                return l([c, d])
            }
        }

        function l(c) {
            if (n) throw new TypeError("Generator is already executing.");
            for (; a && (a = 0, c[0] && (t = 0)), t;) try {
                if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
                switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                    case 0:
                    case 1:
                        s = c;
                        break;
                    case 4:
                        return t.label++, {
                            value: c[1],
                            done: !1
                        };
                    case 5:
                        t.label++, i = c[1], c = [0];
                        continue;
                    case 7:
                        c = t.ops.pop(), t.trys.pop();
                        continue;
                    default:
                        if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                            t = 0;
                            continue
                        }
                        if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                            t.label = c[1];
                            break
                        }
                        if (c[0] === 6 && t.label < s[1]) {
                            t.label = s[1], s = c;
                            break
                        }
                        if (s && t.label < s[2]) {
                            t.label = s[2], t.ops.push(c);
                            break
                        }
                        s[2] && t.ops.pop(), t.trys.pop();
                        continue
                }
                c = e.call(r, t)
            } catch (d) {
                c = [6, d], i = 0
            } finally {
                n = s = 0
            }
            if (c[0] & 5) throw c[1];
            return {
                value: c[0] ? c[1] : void 0,
                done: !0
            }
        }
    },
    Ts = new Ln("CognitoCredentials"),
    xZ = new Promise(function(r, e) {
        if (!ki().isBrowser) return Ts.debug("not in the browser, directly resolved"), r();
        var t = window.gapi && window.gapi.auth2 ? window.gapi.auth2 : null;
        if (t) return Ts.debug("google api already loaded"), r();
        setTimeout(function() {
            return r()
        }, 2e3)
    }),
    UZ = (function() {
        function r() {
            this.initialized = !1, this.refreshGoogleToken = this.refreshGoogleToken.bind(this), this._refreshGoogleTokenImpl = this._refreshGoogleTokenImpl.bind(this)
        }
        return o(r, "GoogleOAuth"), r.prototype.refreshGoogleToken = function() {
            return DZ(this, void 0, void 0, function() {
                return LZ(this, function(e) {
                    switch (e.label) {
                        case 0:
                            return this.initialized ? [3, 2] : (Ts.debug("need to wait for the Google SDK loaded"), [4, xZ]);
                        case 1:
                            e.sent(), this.initialized = !0, Ts.debug("finish waiting"), e.label = 2;
                        case 2:
                            return [2, this._refreshGoogleTokenImpl()]
                    }
                })
            })
        }, r.prototype._refreshGoogleTokenImpl = function() {
            var e = null;
            return ki().isBrowser && (e = window.gapi && window.gapi.auth2 ? window.gapi.auth2 : null), e ? new Promise(function(t, n) {
                e.getAuthInstance().then(function(i) {
                    i || (Ts.debug("google Auth undefined"), n(new Io("google Auth undefined")));
                    var s = i.currentUser.get();
                    s.isSignedIn() ? (Ts.debug("refreshing the google access token"), s.reloadAuthResponse().then(function(a) {
                        var u = a.id_token,
                            l = a.expires_at;
                        t({
                            token: u,
                            expires_at: l
                        })
                    }).catch(function(a) {
                        a && a.error === "network_error" ? n("Network error reloading google auth response") : n(new Io("Failed to reload google auth response"))
                    })) : n(new Io("User is not signed in with Google"))
                }).catch(function(i) {
                    Ts.debug("Failed to refresh google token", i), n(new Io("Failed to refresh google token"))
                })
            }) : (Ts.debug("no gapi auth2 available"), Promise.reject("no gapi auth2 available"))
        }, r
    })(),
    MZ = function(r, e, t, n) {
        function i(s) {
            return s instanceof t ? s : new t(function(a) {
                a(s)
            })
        }
        return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
            function u(d) {
                try {
                    c(n.next(d))
                } catch (f) {
                    a(f)
                }
            }
            o(u, "fulfilled");

            function l(d) {
                try {
                    c(n.throw(d))
                } catch (f) {
                    a(f)
                }
            }
            o(l, "rejected");

            function c(d) {
                d.done ? s(d.value) : i(d.value).then(u, l)
            }
            o(c, "step"), c((n = n.apply(r, e || [])).next())
        })
    },
    kZ = function(r, e) {
        var t = {
                label: 0,
                sent: o(function() {
                    if (s[0] & 1) throw s[1];
                    return s[1]
                }, "sent"),
                trys: [],
                ops: []
            },
            n, i, s, a;
        return a = {
            next: u(0),
            throw: u(1),
            return: u(2)
        }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
            return this
        }), a;

        function u(c) {
            return function(d) {
                return l([c, d])
            }
        }

        function l(c) {
            if (n) throw new TypeError("Generator is already executing.");
            for (; a && (a = 0, c[0] && (t = 0)), t;) try {
                if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
                switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                    case 0:
                    case 1:
                        s = c;
                        break;
                    case 4:
                        return t.label++, {
                            value: c[1],
                            done: !1
                        };
                    case 5:
                        t.label++, i = c[1], c = [0];
                        continue;
                    case 7:
                        c = t.ops.pop(), t.trys.pop();
                        continue;
                    default:
                        if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                            t = 0;
                            continue
                        }
                        if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                            t.label = c[1];
                            break
                        }
                        if (c[0] === 6 && t.label < s[1]) {
                            t.label = s[1], s = c;
                            break
                        }
                        if (s && t.label < s[2]) {
                            t.label = s[2], t.ops.push(c);
                            break
                        }
                        s[2] && t.ops.pop(), t.trys.pop();
                        continue
                }
                c = e.call(r, t)
            } catch (d) {
                c = [6, d], i = 0
            } finally {
                n = s = 0
            }
            if (c[0] & 5) throw c[1];
            return {
                value: c[0] ? c[1] : void 0,
                done: !0
            }
        }
    },
    Eo = new Ln("CognitoCredentials"),
    FZ = new Promise(function(r, e) {
        if (!ki().isBrowser) return Eo.debug("not in the browser, directly resolved"), r();
        var t = window.FB;
        if (t) return Eo.debug("FB SDK already loaded"), r();
        setTimeout(function() {
            return r()
        }, 2e3)
    }),
    $Z = (function() {
        function r() {
            this.initialized = !1, this.refreshFacebookToken = this.refreshFacebookToken.bind(this), this._refreshFacebookTokenImpl = this._refreshFacebookTokenImpl.bind(this)
        }
        return o(r, "FacebookOAuth"), r.prototype.refreshFacebookToken = function() {
            return MZ(this, void 0, void 0, function() {
                return kZ(this, function(e) {
                    switch (e.label) {
                        case 0:
                            return this.initialized ? [3, 2] : (Eo.debug("need to wait for the Facebook SDK loaded"), [4, FZ]);
                        case 1:
                            e.sent(), this.initialized = !0, Eo.debug("finish waiting"), e.label = 2;
                        case 2:
                            return [2, this._refreshFacebookTokenImpl()]
                    }
                })
            })
        }, r.prototype._refreshFacebookTokenImpl = function() {
            var e = null;
            if (ki().isBrowser && (e = window.FB), !e) {
                var t = "no fb sdk available";
                return Eo.debug(t), Promise.reject(new Io(t))
            }
            return new Promise(function(n, i) {
                e.getLoginStatus(function(s) {
                    if (!s || !s.authResponse) {
                        var a = "no response from facebook when refreshing the jwt token";
                        Eo.debug(a), i(new Io(a))
                    } else {
                        var u = s.authResponse,
                            l = u.accessToken,
                            c = u.expiresIn,
                            d = new Date,
                            f = c * 1e3 + d.getTime();
                        if (!l) {
                            var a = "the jwtToken is undefined";
                            Eo.debug(a), i(new Io(a))
                        }
                        n({
                            token: l,
                            expires_at: f
                        })
                    }
                }, {
                    scope: "public_profile,email"
                })
            })
        }, r
    })(),
    BZ = new UZ,
    VZ = new $Z,
    _o = {},
    HZ = (function() {
        function r() {}
        return o(r, "MemoryStorage"), r.setItem = function(e, t) {
            return _o[e] = t, _o[e]
        }, r.getItem = function(e) {
            return Object.prototype.hasOwnProperty.call(_o, e) ? _o[e] : void 0
        }, r.removeItem = function(e) {
            return delete _o[e]
        }, r.clear = function() {
            return _o = {}, _o
        }, r
    })(),
    $L = (function() {
        function r() {
            try {
                this.storageWindow = window.localStorage, this.storageWindow.setItem("aws.amplify.test-ls", 1), this.storageWindow.removeItem("aws.amplify.test-ls")
            } catch (e) {
                this.storageWindow = HZ
            }
        }
        return o(r, "StorageHelper"), r.prototype.getStorage = function() {
            return this.storageWindow
        }, r
    })(),
    BL = {
        id: "aws",
        outputs: {
            dnsSuffix: "amazonaws.com"
        },
        regionRegex: "^(us|eu|ap|sa|ca|me|af)\\-\\w+\\-\\d+$",
        regions: ["aws-global"]
    },
    jZ = {
        partitions: [BL, {
            id: "aws-cn",
            outputs: {
                dnsSuffix: "amazonaws.com.cn"
            },
            regionRegex: "^cn\\-\\w+\\-\\d+$",
            regions: ["aws-cn-global"]
        }]
    },
    WZ = function(r) {
        var e = typeof Symbol == "function" && Symbol.iterator,
            t = e && r[e],
            n = 0;
        if (t) return t.call(r);
        if (r && typeof r.length == "number") return {
            next: o(function() {
                return r && n >= r.length && (r = void 0), {
                    value: r && r[n++],
                    done: !r
                }
            }, "next")
        };
        throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
    },
    GZ = o(function(r) {
        var e, t, n = jZ.partitions;
        try {
            for (var i = WZ(n), s = i.next(); !s.done; s = i.next()) {
                var a = s.value,
                    u = a.regions,
                    l = a.outputs,
                    c = a.regionRegex,
                    d = new RegExp(c);
                if (u.includes(r) || d.test(r)) return l.dnsSuffix
            }
        } catch (f) {
            e = {
                error: f
            }
        } finally {
            try {
                s && !s.done && (t = i.return) && t.call(i)
            } finally {
                if (e) throw e.error
            }
        }
        return BL.outputs.dnsSuffix
    }, "getDnsSuffix");

function zZ(r, e) {
    return e = e || {}, new Promise(function(t, n) {
        var i = new XMLHttpRequest,
            s = [],
            a = [],
            u = {},
            l = o(function() {
                return {
                    ok: (i.status / 100 | 0) == 2,
                    statusText: i.statusText,
                    status: i.status,
                    url: i.responseURL,
                    text: o(function() {
                        return Promise.resolve(i.responseText)
                    }, "text"),
                    json: o(function() {
                        return Promise.resolve(i.responseText).then(JSON.parse)
                    }, "json"),
                    blob: o(function() {
                        return Promise.resolve(new Blob([i.response]))
                    }, "blob"),
                    clone: l,
                    headers: {
                        keys: o(function() {
                            return s
                        }, "keys"),
                        entries: o(function() {
                            return a
                        }, "entries"),
                        get: o(function(d) {
                            return u[d.toLowerCase()]
                        }, "get"),
                        has: o(function(d) {
                            return d.toLowerCase() in u
                        }, "has")
                    }
                }
            }, "a");
        for (var c in i.open(e.method || "get", r, !0), i.onload = function() {
                i.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(d, f, h) {
                    s.push(f = f.toLowerCase()), a.push([f, h]), u[f] = u[f] ? u[f] + "," + h : h
                }), t(l())
            }, i.onerror = n, i.withCredentials = e.credentials == "include", e.headers) i.setRequestHeader(c, e.headers[c]);
        i.send(e.body || null)
    })
}
o(zZ, "unfetch_module");
var qZ = Object.freeze({
        __proto__: null,
        default: zZ
    }),
    LD = bb(qZ);
self.fetch || (self.fetch = LD.default || LD);
var DE = o(function(r) {
        var e;
        return function() {
            return e || (e = r()), e
        }
    }, "withMemoization"),
    Pp = function() {
        return Pp = Object.assign || function(r) {
            for (var e, t = 1, n = arguments.length; t < n; t++) {
                e = arguments[t];
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (r[i] = e[i])
            }
            return r
        }, Pp.apply(this, arguments)
    },
    KZ = function(r, e, t, n) {
        function i(s) {
            return s instanceof t ? s : new t(function(a) {
                a(s)
            })
        }
        return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
            function u(d) {
                try {
                    c(n.next(d))
                } catch (f) {
                    a(f)
                }
            }
            o(u, "fulfilled");

            function l(d) {
                try {
                    c(n.throw(d))
                } catch (f) {
                    a(f)
                }
            }
            o(l, "rejected");

            function c(d) {
                d.done ? s(d.value) : i(d.value).then(u, l)
            }
            o(c, "step"), c((n = n.apply(r, e || [])).next())
        })
    },
    YZ = function(r, e) {
        var t = {
                label: 0,
                sent: o(function() {
                    if (s[0] & 1) throw s[1];
                    return s[1]
                }, "sent"),
                trys: [],
                ops: []
            },
            n, i, s, a;
        return a = {
            next: u(0),
            throw: u(1),
            return: u(2)
        }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
            return this
        }), a;

        function u(c) {
            return function(d) {
                return l([c, d])
            }
        }

        function l(c) {
            if (n) throw new TypeError("Generator is already executing.");
            for (; a && (a = 0, c[0] && (t = 0)), t;) try {
                if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
                switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                    case 0:
                    case 1:
                        s = c;
                        break;
                    case 4:
                        return t.label++, {
                            value: c[1],
                            done: !1
                        };
                    case 5:
                        t.label++, i = c[1], c = [0];
                        continue;
                    case 7:
                        c = t.ops.pop(), t.trys.pop();
                        continue;
                    default:
                        if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                            t = 0;
                            continue
                        }
                        if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                            t.label = c[1];
                            break
                        }
                        if (c[0] === 6 && t.label < s[1]) {
                            t.label = s[1], s = c;
                            break
                        }
                        if (s && t.label < s[2]) {
                            t.label = s[2], t.ops.push(c);
                            break
                        }
                        s[2] && t.ops.pop(), t.trys.pop();
                        continue
                }
                c = e.call(r, t)
            } catch (d) {
                c = [6, d], i = 0
            } finally {
                n = s = 0
            }
            if (c[0] & 5) throw c[1];
            return {
                value: c[0] ? c[1] : void 0,
                done: !0
            }
        }
    },
    XZ = o(function(r) {
        return !["HEAD", "GET", "DELETE"].includes(r.toUpperCase())
    }, "shouldSendBody"),
    JZ = o(function(r, e) {
        var t = r.url,
            n = r.method,
            i = r.headers,
            s = r.body,
            a = e.abortSignal;
        return KZ(void 0, void 0, void 0, function() {
            var u, l, c, d, f, h, g;
            return YZ(this, function(p) {
                switch (p.label) {
                    case 0:
                        return p.trys.push([0, 2, , 3]), [4, fetch(t, {
                            method: n,
                            headers: i,
                            body: XZ(n) ? s : void 0,
                            signal: a
                        })];
                    case 1:
                        return u = p.sent(), [3, 3];
                    case 2:
                        throw l = p.sent(), l instanceof TypeError ? new Error("Network error") : l;
                    case 3:
                        return c = {}, (h = u.headers) === null || h === void 0 || h.forEach(function(m, w) {
                            c[w.toLowerCase()] = m
                        }), d = {
                            statusCode: u.status,
                            headers: c,
                            body: null
                        }, f = Object.assign((g = u.body) !== null && g !== void 0 ? g : {}, {
                            text: DE(function() {
                                return u.text()
                            }),
                            blob: DE(function() {
                                return u.blob()
                            }),
                            json: DE(function() {
                                return u.json()
                            })
                        }), [2, Pp(Pp({}, d), {
                            body: f
                        })]
                }
            })
        })
    }, "fetchTransferHandler"),
    Np = function() {
        return Np = Object.assign || function(r) {
            for (var e, t = 1, n = arguments.length; t < n; t++) {
                e = arguments[t];
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (r[i] = e[i])
            }
            return r
        }, Np.apply(this, arguments)
    },
    ZZ = function(r, e, t, n) {
        function i(s) {
            return s instanceof t ? s : new t(function(a) {
                a(s)
            })
        }
        return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
            function u(d) {
                try {
                    c(n.next(d))
                } catch (f) {
                    a(f)
                }
            }
            o(u, "fulfilled");

            function l(d) {
                try {
                    c(n.throw(d))
                } catch (f) {
                    a(f)
                }
            }
            o(l, "rejected");

            function c(d) {
                d.done ? s(d.value) : i(d.value).then(u, l)
            }
            o(c, "step"), c((n = n.apply(r, e || [])).next())
        })
    },
    QZ = function(r, e) {
        var t = {
                label: 0,
                sent: o(function() {
                    if (s[0] & 1) throw s[1];
                    return s[1]
                }, "sent"),
                trys: [],
                ops: []
            },
            n, i, s, a;
        return a = {
            next: u(0),
            throw: u(1),
            return: u(2)
        }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
            return this
        }), a;

        function u(c) {
            return function(d) {
                return l([c, d])
            }
        }

        function l(c) {
            if (n) throw new TypeError("Generator is already executing.");
            for (; a && (a = 0, c[0] && (t = 0)), t;) try {
                if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
                switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                    case 0:
                    case 1:
                        s = c;
                        break;
                    case 4:
                        return t.label++, {
                            value: c[1],
                            done: !1
                        };
                    case 5:
                        t.label++, i = c[1], c = [0];
                        continue;
                    case 7:
                        c = t.ops.pop(), t.trys.pop();
                        continue;
                    default:
                        if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                            t = 0;
                            continue
                        }
                        if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                            t.label = c[1];
                            break
                        }
                        if (c[0] === 6 && t.label < s[1]) {
                            t.label = s[1], s = c;
                            break
                        }
                        if (s && t.label < s[2]) {
                            t.label = s[2], t.ops.push(c);
                            break
                        }
                        s[2] && t.ops.pop(), t.trys.pop();
                        continue
                }
                c = e.call(r, t)
            } catch (d) {
                c = [6, d], i = 0
            } finally {
                n = s = 0
            }
            if (c[0] & 5) throw c[1];
            return {
                value: c[0] ? c[1] : void 0,
                done: !0
            }
        }
    },
    eQ = 3,
    tQ = o(function(r) {
        var e = r.maxAttempts,
            t = e === void 0 ? eQ : e,
            n = r.retryDecider,
            i = r.computeDelay,
            s = r.abortSignal;
        if (t < 1) throw new Error("maxAttempts must be greater than 0");
        return function(a, u) {
            return o(function(c) {
                var d;
                return ZZ(this, void 0, void 0, function() {
                    var f, h, g, p, m, w;
                    return QZ(this, function(T) {
                        switch (T.label) {
                            case 0:
                                h = (d = u.attemptsCount) !== null && d !== void 0 ? d : 0, p = o(function() {
                                    if (g) return xD(g, h), g;
                                    throw xD(f, h), f
                                }, "handleTerminalErrorOrResponse"), T.label = 1;
                            case 1:
                                if (!(!(s != null && s.aborted) && h < t)) return [3, 11];
                                T.label = 2;
                            case 2:
                                return T.trys.push([2, 4, , 5]), [4, a(c)];
                            case 3:
                                return g = T.sent(), f = void 0, [3, 5];
                            case 4:
                                return m = T.sent(), f = m, g = void 0, [3, 5];
                            case 5:
                                return h = u.attemptsCount > h ? u.attemptsCount : h + 1, u.attemptsCount = h, [4, n(g, f)];
                            case 6:
                                return T.sent() ? !(s != null && s.aborted) && h < t ? (w = i(h), [4, rQ(w, s)]) : [3, 8] : [3, 9];
                            case 7:
                                T.sent(), T.label = 8;
                            case 8:
                                return [3, 1];
                            case 9:
                                return [2, p()];
                            case 10:
                                return [3, 1];
                            case 11:
                                if (s != null && s.aborted) throw new Error("Request aborted.");
                                return [2, p()]
                        }
                    })
                })
            }, "retryMiddleware")
        }
    }, "retryMiddleware"),
    rQ = o(function(r, e) {
        if (e != null && e.aborted) return Promise.resolve();
        var t, n, i = new Promise(function(s) {
            n = s, t = setTimeout(s, r)
        });
        return e == null || e.addEventListener("abort", o(function s(a) {
            clearTimeout(t), e == null || e.removeEventListener("abort", s), n()
        }, "cancelSleep")), i
    }, "cancellableSleep"),
    xD = o(function(r, e) {
        var t;
        Object.prototype.toString.call(r) === "[object Object]" && (r.$metadata = Np(Np({}, (t = r.$metadata) !== null && t !== void 0 ? t : {}), {
            attempts: e
        }))
    }, "addOrIncrementMetadataAttempts"),
    UD = 300 * 1e3,
    nQ = o(function(r) {
        var e = UL(UD),
            t = e(r);
        return t === !1 ? UD : t
    }, "jitteredBackoff$1"),
    iQ = ["AuthFailure", "InvalidSignatureException", "RequestExpired", "RequestInTheFuture", "RequestTimeTooSkewed", "SignatureDoesNotMatch", "BadRequestException"],
    sQ = o(function(r) {
        return iQ.includes(r)
    }, "isClockSkewError"),
    oQ = function(r, e, t, n) {
        function i(s) {
            return s instanceof t ? s : new t(function(a) {
                a(s)
            })
        }
        return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
            function u(d) {
                try {
                    c(n.next(d))
                } catch (f) {
                    a(f)
                }
            }
            o(u, "fulfilled");

            function l(d) {
                try {
                    c(n.throw(d))
                } catch (f) {
                    a(f)
                }
            }
            o(l, "rejected");

            function c(d) {
                d.done ? s(d.value) : i(d.value).then(u, l)
            }
            o(c, "step"), c((n = n.apply(r, e || [])).next())
        })
    },
    aQ = function(r, e) {
        var t = {
                label: 0,
                sent: o(function() {
                    if (s[0] & 1) throw s[1];
                    return s[1]
                }, "sent"),
                trys: [],
                ops: []
            },
            n, i, s, a;
        return a = {
            next: u(0),
            throw: u(1),
            return: u(2)
        }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
            return this
        }), a;

        function u(c) {
            return function(d) {
                return l([c, d])
            }
        }

        function l(c) {
            if (n) throw new TypeError("Generator is already executing.");
            for (; a && (a = 0, c[0] && (t = 0)), t;) try {
                if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
                switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                    case 0:
                    case 1:
                        s = c;
                        break;
                    case 4:
                        return t.label++, {
                            value: c[1],
                            done: !1
                        };
                    case 5:
                        t.label++, i = c[1], c = [0];
                        continue;
                    case 7:
                        c = t.ops.pop(), t.trys.pop();
                        continue;
                    default:
                        if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                            t = 0;
                            continue
                        }
                        if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                            t.label = c[1];
                            break
                        }
                        if (c[0] === 6 && t.label < s[1]) {
                            t.label = s[1], s = c;
                            break
                        }
                        if (s && t.label < s[2]) {
                            t.label = s[2], t.ops.push(c);
                            break
                        }
                        s[2] && t.ops.pop(), t.trys.pop();
                        continue
                }
                c = e.call(r, t)
            } catch (d) {
                c = [6, d], i = 0
            } finally {
                n = s = 0
            }
            if (c[0] & 5) throw c[1];
            return {
                value: c[0] ? c[1] : void 0,
                done: !0
            }
        }
    },
    uQ = o(function(r) {
        return function(e, t) {
            return oQ(void 0, void 0, void 0, function() {
                var n, i, s, a;
                return aQ(this, function(u) {
                    switch (u.label) {
                        case 0:
                            return t == null ? [3, 1] : (i = t, [3, 3]);
                        case 1:
                            return [4, r(e)];
                        case 2:
                            i = u.sent(), u.label = 3;
                        case 3:
                            return n = ((a = i) !== null && a !== void 0 ? a : {}).name, s = e == null ? void 0 : e.statusCode, [2, fQ(t) || dQ(s, n) || sQ(n) || hQ(s, n)]
                    }
                })
            })
        }
    }, "getRetryDecider"),
    cQ = ["BandwidthLimitExceeded", "EC2ThrottledException", "LimitExceededException", "PriorRequestNotComplete", "ProvisionedThroughputExceededException", "RequestLimitExceeded", "RequestThrottled", "RequestThrottledException", "SlowDown", "ThrottledException", "Throttling", "ThrottlingException", "TooManyRequestsException"],
    lQ = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"],
    dQ = o(function(r, e) {
        return r === 429 || cQ.includes(e)
    }, "isThrottlingError"),
    fQ = o(function(r) {
        return (r == null ? void 0 : r.name) === "Network error"
    }, "isConnectionError"),
    hQ = o(function(r, e) {
        return [500, 502, 503, 504].includes(r) || lQ.includes(e)
    }, "isServerSideError"),
    gQ = function(r, e, t, n) {
        function i(s) {
            return s instanceof t ? s : new t(function(a) {
                a(s)
            })
        }
        return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
            function u(d) {
                try {
                    c(n.next(d))
                } catch (f) {
                    a(f)
                }
            }
            o(u, "fulfilled");

            function l(d) {
                try {
                    c(n.throw(d))
                } catch (f) {
                    a(f)
                }
            }
            o(l, "rejected");

            function c(d) {
                d.done ? s(d.value) : i(d.value).then(u, l)
            }
            o(c, "step"), c((n = n.apply(r, e || [])).next())
        })
    },
    pQ = function(r, e) {
        var t = {
                label: 0,
                sent: o(function() {
                    if (s[0] & 1) throw s[1];
                    return s[1]
                }, "sent"),
                trys: [],
                ops: []
            },
            n, i, s, a;
        return a = {
            next: u(0),
            throw: u(1),
            return: u(2)
        }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
            return this
        }), a;

        function u(c) {
            return function(d) {
                return l([c, d])
            }
        }

        function l(c) {
            if (n) throw new TypeError("Generator is already executing.");
            for (; a && (a = 0, c[0] && (t = 0)), t;) try {
                if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
                switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                    case 0:
                    case 1:
                        s = c;
                        break;
                    case 4:
                        return t.label++, {
                            value: c[1],
                            done: !1
                        };
                    case 5:
                        t.label++, i = c[1], c = [0];
                        continue;
                    case 7:
                        c = t.ops.pop(), t.trys.pop();
                        continue;
                    default:
                        if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                            t = 0;
                            continue
                        }
                        if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                            t.label = c[1];
                            break
                        }
                        if (c[0] === 6 && t.label < s[1]) {
                            t.label = s[1], s = c;
                            break
                        }
                        if (s && t.label < s[2]) {
                            t.label = s[2], t.ops.push(c);
                            break
                        }
                        s[2] && t.ops.pop(), t.trys.pop();
                        continue
                }
                c = e.call(r, t)
            } catch (d) {
                c = [6, d], i = 0
            } finally {
                n = s = 0
            }
            if (c[0] & 5) throw c[1];
            return {
                value: c[0] ? c[1] : void 0,
                done: !0
            }
        }
    },
    mQ = o(function(r) {
        var e = r.userAgentHeader,
            t = e === void 0 ? "x-amz-user-agent" : e,
            n = r.userAgentValue,
            i = n === void 0 ? "" : n;
        return function(s) {
            return o(function(u) {
                return gQ(this, void 0, void 0, function() {
                    var l, c, d;
                    return pQ(this, function(f) {
                        switch (f.label) {
                            case 0:
                                return i.trim().length !== 0 ? [3, 2] : [4, s(u)];
                            case 1:
                                return l = f.sent(), [2, l];
                            case 2:
                                return c = t.toLowerCase(), u.headers[c] = u.headers[c] ? "".concat(u.headers[c], " ").concat(i) : i, [4, s(u)];
                            case 3:
                                return d = f.sent(), [2, d]
                        }
                    })
                })
            }, "userAgentMiddleware")
        }
    }, "userAgentMiddleware"),
    VL = o(function(r, e) {
        return function(t, n) {
            for (var i = {}, s = o(function(c) {
                    return r(c, n)
                }, "composedHandler"), a = e.length - 1; a >= 0; a--) {
                var u = e[a],
                    l = u(n);
                s = l(s, i)
            }
            return s(t)
        }
    }, "composeTransferHandler"),
    vQ = VL(JZ, [mQ, tQ]),
    Dp = function() {
        return Dp = Object.assign || function(r) {
            for (var e, t = 1, n = arguments.length; t < n; t++) {
                e = arguments[t];
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (r[i] = e[i])
            }
            return r
        }, Dp.apply(this, arguments)
    },
    tm = o(function(r) {
        var e, t, n = r.headers,
            i = r.statusCode;
        return Dp(Dp({}, yQ(r) ? r.$metadata : {}), {
            httpStatusCode: i,
            requestId: (t = (e = n["x-amzn-requestid"]) !== null && e !== void 0 ? e : n["x-amzn-request-id"]) !== null && t !== void 0 ? t : n["x-amz-request-id"],
            extendedRequestId: n["x-amz-id-2"],
            cfId: n["x-amz-cf-id"]
        })
    }, "parseMetadata"),
    yQ = o(function(r) {
        return typeof(r == null ? void 0 : r.$metadata) == "object"
    }, "isMetadataBearer"),
    HL = function(r, e, t, n) {
        function i(s) {
            return s instanceof t ? s : new t(function(a) {
                a(s)
            })
        }
        return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
            function u(d) {
                try {
                    c(n.next(d))
                } catch (f) {
                    a(f)
                }
            }
            o(u, "fulfilled");

            function l(d) {
                try {
                    c(n.throw(d))
                } catch (f) {
                    a(f)
                }
            }
            o(l, "rejected");

            function c(d) {
                d.done ? s(d.value) : i(d.value).then(u, l)
            }
            o(c, "step"), c((n = n.apply(r, e || [])).next())
        })
    },
    jL = function(r, e) {
        var t = {
                label: 0,
                sent: o(function() {
                    if (s[0] & 1) throw s[1];
                    return s[1]
                }, "sent"),
                trys: [],
                ops: []
            },
            n, i, s, a;
        return a = {
            next: u(0),
            throw: u(1),
            return: u(2)
        }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
            return this
        }), a;

        function u(c) {
            return function(d) {
                return l([c, d])
            }
        }

        function l(c) {
            if (n) throw new TypeError("Generator is already executing.");
            for (; a && (a = 0, c[0] && (t = 0)), t;) try {
                if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
                switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                    case 0:
                    case 1:
                        s = c;
                        break;
                    case 4:
                        return t.label++, {
                            value: c[1],
                            done: !1
                        };
                    case 5:
                        t.label++, i = c[1], c = [0];
                        continue;
                    case 7:
                        c = t.ops.pop(), t.trys.pop();
                        continue;
                    default:
                        if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                            t = 0;
                            continue
                        }
                        if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                            t.label = c[1];
                            break
                        }
                        if (c[0] === 6 && t.label < s[1]) {
                            t.label = s[1], s = c;
                            break
                        }
                        if (s && t.label < s[2]) {
                            t.label = s[2], t.ops.push(c);
                            break
                        }
                        s[2] && t.ops.pop(), t.trys.pop();
                        continue
                }
                c = e.call(r, t)
            } catch (d) {
                c = [6, d], i = 0
            } finally {
                n = s = 0
            }
            if (c[0] & 5) throw c[1];
            return {
                value: c[0] ? c[1] : void 0,
                done: !0
            }
        }
    },
    _Q = function(r, e) {
        var t = typeof Symbol == "function" && r[Symbol.iterator];
        if (!t) return r;
        var n = t.call(r),
            i, s = [],
            a;
        try {
            for (;
                (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
        } catch (u) {
            a = {
                error: u
            }
        } finally {
            try {
                i && !i.done && (t = n.return) && t.call(n)
            } finally {
                if (a) throw a.error
            }
        }
        return s
    },
    Sb = o(function(r) {
        return HL(void 0, void 0, void 0, function() {
            var e, t, n, i, s, a, u, l, c, d;
            return jL(this, function(f) {
                switch (f.label) {
                    case 0:
                        return !r || r.statusCode < 300 ? [2] : [4, Ab(r)];
                    case 1:
                        return e = f.sent(), t = o(function(h) {
                            var g = _Q(h.toString().split(/[\,\:]+/), 1),
                                p = g[0];
                            return p.includes("#") ? p.split("#")[1] : p
                        }, "sanitizeErrorCode"), n = t((l = (u = (a = r.headers["x-amzn-errortype"]) !== null && a !== void 0 ? a : e.code) !== null && u !== void 0 ? u : e.__type) !== null && l !== void 0 ? l : "UnknownError"), i = (d = (c = e.message) !== null && c !== void 0 ? c : e.Message) !== null && d !== void 0 ? d : "Unknown error", s = new Error(i), [2, Object.assign(s, {
                            name: n,
                            $metadata: tm(r)
                        })]
                }
            })
        })
    }, "parseJsonError"),
    Ab = o(function(r) {
        return HL(void 0, void 0, void 0, function() {
            var e;
            return jL(this, function(t) {
                switch (t.label) {
                    case 0:
                        if (!r.body) throw new Error("Missing response payload");
                        return [4, r.body.json()];
                    case 1:
                        return e = t.sent(), [2, Object.assign(e, {
                            $metadata: tm(r)
                        })]
                }
            })
        })
    }, "parseJsonBody"),
    wQ = function(r, e, t, n) {
        function i(s) {
            return s instanceof t ? s : new t(function(a) {
                a(s)
            })
        }
        return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
            function u(d) {
                try {
                    c(n.next(d))
                } catch (f) {
                    a(f)
                }
            }
            o(u, "fulfilled");

            function l(d) {
                try {
                    c(n.throw(d))
                } catch (f) {
                    a(f)
                }
            }
            o(l, "rejected");

            function c(d) {
                d.done ? s(d.value) : i(d.value).then(u, l)
            }
            o(c, "step"), c((n = n.apply(r, e || [])).next())
        })
    },
    TQ = function(r, e) {
        var t = {
                label: 0,
                sent: o(function() {
                    if (s[0] & 1) throw s[1];
                    return s[1]
                }, "sent"),
                trys: [],
                ops: []
            },
            n, i, s, a;
        return a = {
            next: u(0),
            throw: u(1),
            return: u(2)
        }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
            return this
        }), a;

        function u(c) {
            return function(d) {
                return l([c, d])
            }
        }

        function l(c) {
            if (n) throw new TypeError("Generator is already executing.");
            for (; a && (a = 0, c[0] && (t = 0)), t;) try {
                if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
                switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                    case 0:
                    case 1:
                        s = c;
                        break;
                    case 4:
                        return t.label++, {
                            value: c[1],
                            done: !1
                        };
                    case 5:
                        t.label++, i = c[1], c = [0];
                        continue;
                    case 7:
                        c = t.ops.pop(), t.trys.pop();
                        continue;
                    default:
                        if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                            t = 0;
                            continue
                        }
                        if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                            t.label = c[1];
                            break
                        }
                        if (c[0] === 6 && t.label < s[1]) {
                            t.label = s[1], s = c;
                            break
                        }
                        if (s && t.label < s[2]) {
                            t.label = s[2], t.ops.push(c);
                            break
                        }
                        s[2] && t.ops.pop(), t.trys.pop();
                        continue
                }
                c = e.call(r, t)
            } catch (d) {
                c = [6, d], i = 0
            } finally {
                n = s = 0
            }
            if (c[0] & 5) throw c[1];
            return {
                value: c[0] ? c[1] : void 0,
                done: !0
            }
        }
    },
    EQ = "cognito-identity",
    bQ = o(function(r) {
        var e = r.region;
        return {
            url: new URL("https://cognito-identity.".concat(e, ".").concat(GZ(e)))
        }
    }, "endpointResolver"),
    SQ = o(function() {
        return function(r, e) {
            return o(function(n) {
                return wQ(this, void 0, void 0, function() {
                    return TQ(this, function(i) {
                        return n.headers["cache-control"] = "no-store", [2, r(n)]
                    })
                })
            }, "disableCacheMiddleware")
        }
    }, "disableCacheMiddleware"),
    WL = VL(vQ, [SQ]),
    Ib = {
        service: EQ,
        endpointResolver: bQ,
        retryDecider: uQ(Sb),
        computeDelay: nQ,
        userAgentValue: Eb()
    };
LL(function() {
    Ib.userAgentValue = Eb()
});
var GL = o(function(r) {
        return {
            "content-type": "application/x-amz-json-1.1",
            "x-amz-target": "AWSCognitoIdentityService.".concat(r)
        }
    }, "getSharedHeaders"),
    zL = o(function(r, e, t) {
        var n = r.url;
        return {
            headers: e,
            url: n,
            body: t,
            method: "POST"
        }
    }, "buildHttpRpcRequest"),
    id = function() {
        return id = Object.assign || function(r) {
            for (var e, t = 1, n = arguments.length; t < n; t++) {
                e = arguments[t];
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (r[i] = e[i])
            }
            return r
        }, id.apply(this, arguments)
    },
    AQ = function(r, e, t, n) {
        function i(s) {
            return s instanceof t ? s : new t(function(a) {
                a(s)
            })
        }
        return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
            function u(d) {
                try {
                    c(n.next(d))
                } catch (f) {
                    a(f)
                }
            }
            o(u, "fulfilled");

            function l(d) {
                try {
                    c(n.throw(d))
                } catch (f) {
                    a(f)
                }
            }
            o(l, "rejected");

            function c(d) {
                d.done ? s(d.value) : i(d.value).then(u, l)
            }
            o(c, "step"), c((n = n.apply(r, e || [])).next())
        })
    },
    IQ = function(r, e) {
        var t = {
                label: 0,
                sent: o(function() {
                    if (s[0] & 1) throw s[1];
                    return s[1]
                }, "sent"),
                trys: [],
                ops: []
            },
            n, i, s, a;
        return a = {
            next: u(0),
            throw: u(1),
            return: u(2)
        }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
            return this
        }), a;

        function u(c) {
            return function(d) {
                return l([c, d])
            }
        }

        function l(c) {
            if (n) throw new TypeError("Generator is already executing.");
            for (; a && (a = 0, c[0] && (t = 0)), t;) try {
                if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
                switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                    case 0:
                    case 1:
                        s = c;
                        break;
                    case 4:
                        return t.label++, {
                            value: c[1],
                            done: !1
                        };
                    case 5:
                        t.label++, i = c[1], c = [0];
                        continue;
                    case 7:
                        c = t.ops.pop(), t.trys.pop();
                        continue;
                    default:
                        if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                            t = 0;
                            continue
                        }
                        if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                            t.label = c[1];
                            break
                        }
                        if (c[0] === 6 && t.label < s[1]) {
                            t.label = s[1], s = c;
                            break
                        }
                        if (s && t.label < s[2]) {
                            t.label = s[2], t.ops.push(c);
                            break
                        }
                        s[2] && t.ops.pop(), t.trys.pop();
                        continue
                }
                c = e.call(r, t)
            } catch (d) {
                c = [6, d], i = 0
            } finally {
                n = s = 0
            }
            if (c[0] & 5) throw c[1];
            return {
                value: c[0] ? c[1] : void 0,
                done: !0
            }
        }
    },
    qL = o(function(r, e, t, n) {
        return function(i, s) {
            return AQ(void 0, void 0, void 0, function() {
                var a, u, l, c;
                return IQ(this, function(d) {
                    switch (d.label) {
                        case 0:
                            return a = id(id({}, n), i), [4, a.endpointResolver(a, s)];
                        case 1:
                            return u = d.sent(), [4, e(s, u)];
                        case 2:
                            return l = d.sent(), [4, r(l, id({}, a))];
                        case 3:
                            return c = d.sent(), [4, t(c)];
                        case 4:
                            return [2, d.sent()]
                    }
                })
            })
        }
    }, "composeServiceApi"),
    CQ = function(r, e, t, n) {
        function i(s) {
            return s instanceof t ? s : new t(function(a) {
                a(s)
            })
        }
        return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
            function u(d) {
                try {
                    c(n.next(d))
                } catch (f) {
                    a(f)
                }
            }
            o(u, "fulfilled");

            function l(d) {
                try {
                    c(n.throw(d))
                } catch (f) {
                    a(f)
                }
            }
            o(l, "rejected");

            function c(d) {
                d.done ? s(d.value) : i(d.value).then(u, l)
            }
            o(c, "step"), c((n = n.apply(r, e || [])).next())
        })
    },
    RQ = function(r, e) {
        var t = {
                label: 0,
                sent: o(function() {
                    if (s[0] & 1) throw s[1];
                    return s[1]
                }, "sent"),
                trys: [],
                ops: []
            },
            n, i, s, a;
        return a = {
            next: u(0),
            throw: u(1),
            return: u(2)
        }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
            return this
        }), a;

        function u(c) {
            return function(d) {
                return l([c, d])
            }
        }

        function l(c) {
            if (n) throw new TypeError("Generator is already executing.");
            for (; a && (a = 0, c[0] && (t = 0)), t;) try {
                if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
                switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                    case 0:
                    case 1:
                        s = c;
                        break;
                    case 4:
                        return t.label++, {
                            value: c[1],
                            done: !1
                        };
                    case 5:
                        t.label++, i = c[1], c = [0];
                        continue;
                    case 7:
                        c = t.ops.pop(), t.trys.pop();
                        continue;
                    default:
                        if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                            t = 0;
                            continue
                        }
                        if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                            t.label = c[1];
                            break
                        }
                        if (c[0] === 6 && t.label < s[1]) {
                            t.label = s[1], s = c;
                            break
                        }
                        if (s && t.label < s[2]) {
                            t.label = s[2], t.ops.push(c);
                            break
                        }
                        s[2] && t.ops.pop(), t.trys.pop();
                        continue
                }
                c = e.call(r, t)
            } catch (d) {
                c = [6, d], i = 0
            } finally {
                n = s = 0
            }
            if (c[0] & 5) throw c[1];
            return {
                value: c[0] ? c[1] : void 0,
                done: !0
            }
        }
    },
    OQ = o(function(r, e) {
        var t = GL("GetId"),
            n = JSON.stringify(r);
        return zL(e, t, n)
    }, "getIdSerializer"),
    PQ = o(function(r) {
        return CQ(void 0, void 0, void 0, function() {
            var e, t;
            return RQ(this, function(n) {
                switch (n.label) {
                    case 0:
                        return r.statusCode >= 300 ? [4, Sb(r)] : [3, 2];
                    case 1:
                        throw e = n.sent(), e;
                    case 2:
                        return [4, Ab(r)];
                    case 3:
                        return t = n.sent(), [2, {
                            IdentityId: t.IdentityId,
                            $metadata: tm(r)
                        }]
                }
            })
        })
    }, "getIdDeserializer"),
    ip = qL(WL, OQ, PQ, Ib),
    NQ = function(r, e, t, n) {
        function i(s) {
            return s instanceof t ? s : new t(function(a) {
                a(s)
            })
        }
        return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
            function u(d) {
                try {
                    c(n.next(d))
                } catch (f) {
                    a(f)
                }
            }
            o(u, "fulfilled");

            function l(d) {
                try {
                    c(n.throw(d))
                } catch (f) {
                    a(f)
                }
            }
            o(l, "rejected");

            function c(d) {
                d.done ? s(d.value) : i(d.value).then(u, l)
            }
            o(c, "step"), c((n = n.apply(r, e || [])).next())
        })
    },
    DQ = function(r, e) {
        var t = {
                label: 0,
                sent: o(function() {
                    if (s[0] & 1) throw s[1];
                    return s[1]
                }, "sent"),
                trys: [],
                ops: []
            },
            n, i, s, a;
        return a = {
            next: u(0),
            throw: u(1),
            return: u(2)
        }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
            return this
        }), a;

        function u(c) {
            return function(d) {
                return l([c, d])
            }
        }

        function l(c) {
            if (n) throw new TypeError("Generator is already executing.");
            for (; a && (a = 0, c[0] && (t = 0)), t;) try {
                if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
                switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                    case 0:
                    case 1:
                        s = c;
                        break;
                    case 4:
                        return t.label++, {
                            value: c[1],
                            done: !1
                        };
                    case 5:
                        t.label++, i = c[1], c = [0];
                        continue;
                    case 7:
                        c = t.ops.pop(), t.trys.pop();
                        continue;
                    default:
                        if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                            t = 0;
                            continue
                        }
                        if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                            t.label = c[1];
                            break
                        }
                        if (c[0] === 6 && t.label < s[1]) {
                            t.label = s[1], s = c;
                            break
                        }
                        if (s && t.label < s[2]) {
                            t.label = s[2], t.ops.push(c);
                            break
                        }
                        s[2] && t.ops.pop(), t.trys.pop();
                        continue
                }
                c = e.call(r, t)
            } catch (d) {
                c = [6, d], i = 0
            } finally {
                n = s = 0
            }
            if (c[0] & 5) throw c[1];
            return {
                value: c[0] ? c[1] : void 0,
                done: !0
            }
        }
    },
    LQ = o(function(r, e) {
        var t = GL("GetCredentialsForIdentity"),
            n = JSON.stringify(r);
        return zL(e, t, n)
    }, "getCredentialsForIdentitySerializer"),
    xQ = o(function(r) {
        return NQ(void 0, void 0, void 0, function() {
            var e, t;
            return DQ(this, function(n) {
                switch (n.label) {
                    case 0:
                        return r.statusCode >= 300 ? [4, Sb(r)] : [3, 2];
                    case 1:
                        throw e = n.sent(), e;
                    case 2:
                        return [4, Ab(r)];
                    case 3:
                        return t = n.sent(), [2, {
                            IdentityId: t.IdentityId,
                            Credentials: UQ(t.Credentials),
                            $metadata: tm(r)
                        }]
                }
            })
        })
    }, "getCredentialsForIdentityDeserializer"),
    UQ = o(function(r) {
        return r === void 0 && (r = {}), {
            AccessKeyId: r.AccessKeyId,
            SecretKey: r.SecretKey,
            SessionToken: r.SessionToken,
            Expiration: new Date(r.Expiration * 1e3)
        }
    }, "deserializeCredentials"),
    sp = qL(WL, LQ, xQ, Ib),
    Lp = function() {
        return Lp = Object.assign || function(r) {
            for (var e, t = 1, n = arguments.length; t < n; t++) {
                e = arguments[t];
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (r[i] = e[i])
            }
            return r
        }, Lp.apply(this, arguments)
    },
    wr = function(r, e, t, n) {
        function i(s) {
            return s instanceof t ? s : new t(function(a) {
                a(s)
            })
        }
        return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
            function u(d) {
                try {
                    c(n.next(d))
                } catch (f) {
                    a(f)
                }
            }
            o(u, "fulfilled");

            function l(d) {
                try {
                    c(n.throw(d))
                } catch (f) {
                    a(f)
                }
            }
            o(l, "rejected");

            function c(d) {
                d.done ? s(d.value) : i(d.value).then(u, l)
            }
            o(c, "step"), c((n = n.apply(r, e || [])).next())
        })
    },
    Tr = function(r, e) {
        var t = {
                label: 0,
                sent: o(function() {
                    if (s[0] & 1) throw s[1];
                    return s[1]
                }, "sent"),
                trys: [],
                ops: []
            },
            n, i, s, a;
        return a = {
            next: u(0),
            throw: u(1),
            return: u(2)
        }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
            return this
        }), a;

        function u(c) {
            return function(d) {
                return l([c, d])
            }
        }

        function l(c) {
            if (n) throw new TypeError("Generator is already executing.");
            for (; a && (a = 0, c[0] && (t = 0)), t;) try {
                if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
                switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                    case 0:
                    case 1:
                        s = c;
                        break;
                    case 4:
                        return t.label++, {
                            value: c[1],
                            done: !1
                        };
                    case 5:
                        t.label++, i = c[1], c = [0];
                        continue;
                    case 7:
                        c = t.ops.pop(), t.trys.pop();
                        continue;
                    default:
                        if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                            t = 0;
                            continue
                        }
                        if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                            t.label = c[1];
                            break
                        }
                        if (c[0] === 6 && t.label < s[1]) {
                            t.label = s[1], s = c;
                            break
                        }
                        if (s && t.label < s[2]) {
                            t.label = s[2], t.ops.push(c);
                            break
                        }
                        s[2] && t.ops.pop(), t.trys.pop();
                        continue
                }
                c = e.call(r, t)
            } catch (d) {
                c = [6, d], i = 0
            } finally {
                n = s = 0
            }
            if (c[0] & 5) throw c[1];
            return {
                value: c[0] ? c[1] : void 0,
                done: !0
            }
        }
    },
    je = new Ln("Credentials"),
    MQ = 3e3 * 1e3,
    kQ = "CognitoIdentityId-",
    FQ = typeof Symbol != "undefined" && typeof Symbol.for == "function" ? Symbol.for("amplify_default") : "@@amplify_default",
    $Q = o(function(r, e, t) {
        Oi.dispatch("core", {
            event: r,
            data: e,
            message: t
        }, "Credentials", FQ)
    }, "dispatchCredentialsEvent"),
    BQ = (function() {
        function r(e) {
            this._gettingCredPromise = null, this._refreshHandlers = {}, this.Auth = void 0, this.configure(e), this._refreshHandlers.google = BZ.refreshGoogleToken, this._refreshHandlers.facebook = VZ.refreshFacebookToken
        }
        return o(r, "CredentialsClass"), r.prototype.getModuleName = function() {
            return "Credentials"
        }, r.prototype.getCredSource = function() {
            return this._credentials_source
        }, r.prototype.configure = function(e) {
            if (!e) return this._config || {};
            this._config = Object.assign({}, this._config, e);
            var t = this._config.refreshHandlers;
            return t && (this._refreshHandlers = Lp(Lp({}, this._refreshHandlers), t)), this._storage = this._config.storage, this._storage || (this._storage = new $L().getStorage()), this._storageSync = Promise.resolve(), typeof this._storage.sync == "function" && (this._storageSync = this._storage.sync()), $Q("credentials_configured", null, "Credentials has been configured successfully"), this._config
        }, r.prototype.get = function() {
            return je.debug("getting credentials"), this._pickupCredentials()
        }, r.prototype._getCognitoIdentityIdStorageKey = function(e) {
            return "".concat(kQ).concat(e)
        }, r.prototype._pickupCredentials = function() {
            return je.debug("picking up credentials"), !this._gettingCredPromise || !this._gettingCredPromise.isPending() ? (je.debug("getting new cred promise"), this._gettingCredPromise = nZ(this._keepAlive())) : je.debug("getting old cred promise"), this._gettingCredPromise
        }, r.prototype._keepAlive = function() {
            return wr(this, void 0, void 0, function() {
                var e, t, n, i, s, a, u, l;
                return Tr(this, function(c) {
                    switch (c.label) {
                        case 0:
                            if (je.debug("checking if credentials exists and not expired"), e = this._credentials, e && !this._isExpired(e) && !this._isPastTTL()) return je.debug("credentials not changed and not expired, directly return"), [2, Promise.resolve(e)];
                            if (je.debug("need to get a new credential or refresh the existing one"), t = this.Auth, n = t === void 0 ? wd.Auth : t, !n || typeof n.currentUserCredentials != "function") return [2, this._setCredentialsForGuest()];
                            if (!(!this._isExpired(e) && this._isPastTTL())) return [3, 6];
                            je.debug("ttl has passed but token is not yet expired"), c.label = 1;
                        case 1:
                            return c.trys.push([1, 5, , 6]), [4, n.currentUserPoolUser()];
                        case 2:
                            return i = c.sent(), [4, n.currentSession()];
                        case 3:
                            return s = c.sent(), a = s.refreshToken, u = new Promise(function(d, f) {
                                i.refreshSession(a, function(h, g) {
                                    return h ? f(h) : d(g)
                                })
                            }), [4, u];
                        case 4:
                            return c.sent(), [3, 6];
                        case 5:
                            return l = c.sent(), je.debug("Error attempting to refreshing the session", l), [3, 6];
                        case 6:
                            return [2, n.currentUserCredentials()]
                    }
                })
            })
        }, r.prototype.refreshFederatedToken = function(e) {
            je.debug("Getting federated credentials");
            var t = e.provider,
                n = e.user,
                i = e.token,
                s = e.identity_id,
                a = e.expires_at;
            a = new Date(a).getFullYear() === 1970 ? a * 1e3 : a;
            var u = this;
            return je.debug("checking if federated jwt token expired"), a > new Date().getTime() ? (je.debug("token not expired"), this._setCredentialsFromFederation({
                provider: t,
                token: i,
                user: n,
                identity_id: s,
                expires_at: a
            })) : u._refreshHandlers[t] && typeof u._refreshHandlers[t] == "function" ? (je.debug("getting refreshed jwt token from federation provider"), this._providerRefreshWithRetry({
                refreshHandler: u._refreshHandlers[t],
                provider: t,
                user: n
            })) : (je.debug("no refresh handler for provider:", t), this.clear(), Promise.reject("no refresh handler for provider"))
        }, r.prototype._providerRefreshWithRetry = function(e) {
            var t = this,
                n = e.refreshHandler,
                i = e.provider,
                s = e.user,
                a = 10 * 1e3;
            return lZ(n, [], a).then(function(u) {
                return je.debug("refresh federated token sucessfully", u), t._setCredentialsFromFederation({
                    provider: i,
                    token: u.token,
                    user: s,
                    identity_id: u.identity_id,
                    expires_at: u.expires_at
                })
            }).catch(function(u) {
                var l = typeof u == "string" && u.toLowerCase().lastIndexOf("network error", u.length) === 0;
                return l || t.clear(), je.debug("refresh federated token failed", u), Promise.reject("refreshing federation token failed: " + u)
            })
        }, r.prototype._isExpired = function(e) {
            if (!e) return je.debug("no credentials for expiration check"), !0;
            je.debug("are these credentials expired?", e);
            var t = Date.now(),
                n = e.expiration;
            return n.getTime() <= t
        }, r.prototype._isPastTTL = function() {
            return this._nextCredentialsRefresh <= Date.now()
        }, r.prototype._setCredentialsForGuest = function() {
            var e;
            return wr(this, void 0, void 0, function() {
                var t, n, i, s, a, u, l, c, d, f, h = this;
                return Tr(this, function(g) {
                    switch (g.label) {
                        case 0:
                            return je.debug("setting credentials for guest"), !((e = this._config) === null || e === void 0) && e.identityPoolId || (this._config = Object.assign({}, this._config, FL(this._config || {}).Auth)), t = this._config, n = t.identityPoolId, i = t.region, s = t.mandatorySignIn, a = t.identityPoolRegion, s ? [2, Promise.reject("cannot get guest credentials when mandatory signin enabled")] : n ? !a && !i ? (je.debug("region is not configured for getting the credentials"), [2, Promise.reject("region is not configured for getting the credentials")]) : (l = this, [4, this._getGuestIdentityId()]) : (je.debug("No Cognito Identity pool provided for unauthenticated access"), [2, Promise.reject("No Cognito Identity pool provided for unauthenticated access")]);
                        case 1:
                            return u = l._identityId = g.sent(), c = {
                                region: a != null ? a : i
                            }, d = o(function() {
                                return wr(h, void 0, void 0, function() {
                                    var p, m;
                                    return Tr(this, function(w) {
                                        switch (w.label) {
                                            case 0:
                                                return u ? [3, 2] : [4, ip(c, {
                                                    IdentityPoolId: n
                                                })];
                                            case 1:
                                                p = w.sent().IdentityId, this._identityId = p, w.label = 2;
                                            case 2:
                                                return [4, sp(c, {
                                                    IdentityId: this._identityId
                                                })];
                                            case 3:
                                                return m = w.sent().Credentials, [2, {
                                                    identityId: this._identityId,
                                                    accessKeyId: m.AccessKeyId,
                                                    secretAccessKey: m.SecretKey,
                                                    sessionToken: m.SessionToken,
                                                    expiration: m.Expiration
                                                }]
                                        }
                                    })
                                })
                            }, "guestCredentialsProvider"), f = d().catch(function(p) {
                                return wr(h, void 0, void 0, function() {
                                    return Tr(this, function(m) {
                                        throw p
                                    })
                                })
                            }), [2, this._loadCredentials(f, "guest", !1, null).then(function(p) {
                                return p
                            }).catch(function(p) {
                                return wr(h, void 0, void 0, function() {
                                    var m, w = this;
                                    return Tr(this, function(T) {
                                        switch (T.label) {
                                            case 0:
                                                return p.name === "ResourceNotFoundException" && p.message === "Identity '".concat(u, "' not found.") ? (je.debug("Failed to load guest credentials"), [4, this._removeGuestIdentityId()]) : [3, 2];
                                            case 1:
                                                return T.sent(), m = o(function() {
                                                    return wr(w, void 0, void 0, function() {
                                                        var E, b;
                                                        return Tr(this, function(R) {
                                                            switch (R.label) {
                                                                case 0:
                                                                    return [4, ip(c, {
                                                                        IdentityPoolId: n
                                                                    })];
                                                                case 1:
                                                                    return E = R.sent().IdentityId, this._identityId = E, [4, sp(c, {
                                                                        IdentityId: E
                                                                    })];
                                                                case 2:
                                                                    return b = R.sent().Credentials, [2, {
                                                                        identityId: E,
                                                                        accessKeyId: b.AccessKeyId,
                                                                        secretAccessKey: b.SecretKey,
                                                                        sessionToken: b.SessionToken,
                                                                        expiration: b.Expiration
                                                                    }]
                                                            }
                                                        })
                                                    })
                                                }, "guestCredentialsProvider_1"), f = m().catch(function(E) {
                                                    return wr(w, void 0, void 0, function() {
                                                        return Tr(this, function(b) {
                                                            throw E
                                                        })
                                                    })
                                                }), [2, this._loadCredentials(f, "guest", !1, null)];
                                            case 2:
                                                return [2, p]
                                        }
                                    })
                                })
                            })]
                    }
                })
            })
        }, r.prototype._setCredentialsFromFederation = function(e) {
            var t = this,
                n = e.provider,
                i = e.token,
                s = e.identity_id,
                a = {
                    google: "accounts.google.com",
                    facebook: "graph.facebook.com",
                    amazon: "www.amazon.com",
                    developer: "cognito-identity.amazonaws.com"
                },
                u = a[n] || n;
            if (!u) return Promise.reject("You must specify a federated provider");
            var l = {};
            l[u] = i;
            var c = this._config,
                d = c.identityPoolId,
                f = c.region,
                h = c.identityPoolRegion;
            if (!d) return je.debug("No Cognito Federated Identity pool provided"), Promise.reject("No Cognito Federated Identity pool provided");
            if (!h && !f) return je.debug("region is not configured for getting the credentials"), Promise.reject("region is not configured for getting the credentials");
            var g = {
                    region: h != null ? h : f
                },
                p = o(function() {
                    return wr(t, void 0, void 0, function() {
                        var w, T;
                        return Tr(this, function(E) {
                            switch (E.label) {
                                case 0:
                                    return s ? [3, 2] : [4, ip(g, {
                                        IdentityPoolId: d,
                                        Logins: l
                                    })];
                                case 1:
                                    w = E.sent().IdentityId, s = w, E.label = 2;
                                case 2:
                                    return [4, sp(g, {
                                        IdentityId: s,
                                        Logins: l
                                    })];
                                case 3:
                                    return T = E.sent().Credentials, [2, {
                                        identityId: s,
                                        accessKeyId: T.AccessKeyId,
                                        secretAccessKey: T.SecretKey,
                                        sessionToken: T.SessionToken,
                                        expiration: T.Expiration
                                    }]
                            }
                        })
                    })
                }, "authenticatedCredentialsProvider"),
                m = p().catch(function(w) {
                    return wr(t, void 0, void 0, function() {
                        return Tr(this, function(T) {
                            throw w
                        })
                    })
                });
            return this._loadCredentials(m, "federated", !0, e)
        }, r.prototype._setCredentialsFromSession = function(e) {
            var t = this;
            je.debug("set credentials from session");
            var n = e.getIdToken().getJwtToken(),
                i = this._config,
                s = i.region,
                a = i.userPoolId,
                u = i.identityPoolId,
                l = i.identityPoolRegion;
            if (!u) return je.debug("No Cognito Federated Identity pool provided"), Promise.reject("No Cognito Federated Identity pool provided");
            if (!l && !s) return je.debug("region is not configured for getting the credentials"), Promise.reject("region is not configured for getting the credentials");
            var c = "cognito-idp." + s + ".amazonaws.com/" + a,
                d = {};
            d[c] = n;
            var f = {
                    region: l != null ? l : s
                },
                h = o(function() {
                    return wr(t, void 0, void 0, function() {
                        var p, m, w, T, E, b, R, L, V, z;
                        return Tr(this, function(j) {
                            switch (j.label) {
                                case 0:
                                    return [4, this._getGuestIdentityId()];
                                case 1:
                                    return p = j.sent(), p ? [3, 3] : [4, ip(f, {
                                        IdentityPoolId: u,
                                        Logins: d
                                    })];
                                case 2:
                                    w = j.sent().IdentityId, m = w, j.label = 3;
                                case 3:
                                    return [4, sp(f, {
                                        IdentityId: p || m,
                                        Logins: d
                                    })];
                                case 4:
                                    return T = j.sent(), E = T.Credentials, b = E.AccessKeyId, R = E.Expiration, L = E.SecretKey, V = E.SessionToken, z = T.IdentityId, this._identityId = z, p ? (je.debug("The guest identity ".concat(p, " has been successfully linked to the logins")), p === z && je.debug("The guest identity ".concat(p, " has become the primary identity")), [4, this._removeGuestIdentityId()]) : [3, 6];
                                case 5:
                                    j.sent(), j.label = 6;
                                case 6:
                                    return [2, {
                                        accessKeyId: b,
                                        secretAccessKey: L,
                                        sessionToken: V,
                                        expiration: R,
                                        identityId: z
                                    }]
                            }
                        })
                    })
                }, "credentialsProvider"),
                g = h().catch(function(p) {
                    return wr(t, void 0, void 0, function() {
                        return Tr(this, function(m) {
                            throw p
                        })
                    })
                });
            return this._loadCredentials(g, "userPool", !0, null)
        }, r.prototype._loadCredentials = function(e, t, n, i) {
            var s = this,
                a = this;
            return new Promise(function(u, l) {
                e.then(function(c) {
                    return wr(s, void 0, void 0, function() {
                        var d, f, h, g, p;
                        return Tr(this, function(m) {
                            switch (m.label) {
                                case 0:
                                    if (je.debug("Load credentials successfully", c), this._identityId && !c.identityId && (c.identityId = this._identityId), a._credentials = c, a._credentials.authenticated = n, a._credentials_source = t, a._nextCredentialsRefresh = new Date().getTime() + MQ, t === "federated") {
                                        d = Object.assign({
                                            id: this._credentials.identityId
                                        }, i.user), f = i.provider, h = i.token, g = i.expires_at, p = i.identity_id;
                                        try {
                                            this._storage.setItem("aws-amplify-federatedInfo", JSON.stringify({
                                                provider: f,
                                                token: h,
                                                user: d,
                                                expires_at: g,
                                                identity_id: p
                                            }))
                                        } catch (w) {
                                            je.debug("Failed to put federated info into auth storage", w)
                                        }
                                    }
                                    return t !== "guest" ? [3, 2] : [4, this._setGuestIdentityId(c.identityId)];
                                case 1:
                                    m.sent(), m.label = 2;
                                case 2:
                                    return u(a._credentials), [2]
                            }
                        })
                    })
                }).catch(function(c) {
                    if (c) {
                        je.debug("Failed to load credentials", e), je.debug("Error loading credentials", c), l(c);
                        return
                    }
                })
            })
        }, r.prototype.set = function(e, t) {
            return t === "session" ? this._setCredentialsFromSession(e) : t === "federation" ? this._setCredentialsFromFederation(e) : t === "guest" ? this._setCredentialsForGuest() : (je.debug("no source specified for setting credentials"), Promise.reject("invalid source"))
        }, r.prototype.clear = function() {
            return wr(this, void 0, void 0, function() {
                return Tr(this, function(e) {
                    return this._credentials = null, this._credentials_source = null, je.debug("removing aws-amplify-federatedInfo from storage"), this._storage.removeItem("aws-amplify-federatedInfo"), [2]
                })
            })
        }, r.prototype._getGuestIdentityId = function() {
            return wr(this, void 0, void 0, function() {
                var e, t;
                return Tr(this, function(n) {
                    switch (n.label) {
                        case 0:
                            e = this._config.identityPoolId, n.label = 1;
                        case 1:
                            return n.trys.push([1, 3, , 4]), [4, this._storageSync];
                        case 2:
                            return n.sent(), [2, this._storage.getItem(this._getCognitoIdentityIdStorageKey(e))];
                        case 3:
                            return t = n.sent(), je.debug("Failed to get the cached guest identityId", t), [3, 4];
                        case 4:
                            return [2]
                    }
                })
            })
        }, r.prototype._setGuestIdentityId = function(e) {
            return wr(this, void 0, void 0, function() {
                var t, n;
                return Tr(this, function(i) {
                    switch (i.label) {
                        case 0:
                            t = this._config.identityPoolId, i.label = 1;
                        case 1:
                            return i.trys.push([1, 3, , 4]), [4, this._storageSync];
                        case 2:
                            return i.sent(), this._storage.setItem(this._getCognitoIdentityIdStorageKey(t), e), [3, 4];
                        case 3:
                            return n = i.sent(), je.debug("Failed to cache guest identityId", n), [3, 4];
                        case 4:
                            return [2]
                    }
                })
            })
        }, r.prototype._removeGuestIdentityId = function() {
            return wr(this, void 0, void 0, function() {
                var e;
                return Tr(this, function(t) {
                    return e = this._config.identityPoolId, je.debug("removing ".concat(this._getCognitoIdentityIdStorageKey(e), " from storage")), this._storage.removeItem(this._getCognitoIdentityIdStorageKey(e)), [2]
                })
            })
        }, r.prototype.shear = function(e) {
            return {
                accessKeyId: e.accessKeyId,
                sessionToken: e.sessionToken,
                secretAccessKey: e.secretAccessKey,
                identityId: e.identityId,
                authenticated: e.authenticated
            }
        }, r
    })(),
    KL = new BQ(null);
wd.register(KL);
var op = {};
var MD;

function VQ() {
    if (MD) return op;
    MD = 1, op.parse = a, op.serialize = c;
    var r = Object.prototype.toString,
        e = Object.prototype.hasOwnProperty,
        t = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/,
        n = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/,
        i = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,
        s = /^[\u0020-\u003A\u003D-\u007E]*$/;

    function a(g, p) {
        if (typeof g != "string") throw new TypeError("argument str must be a string");
        var m = {},
            w = g.length;
        if (w < 2) return m;
        var T = p && p.decode || d,
            E = 0,
            b = 0,
            R = 0;
        do {
            if (b = g.indexOf("=", E), b === -1) break;
            if (R = g.indexOf(";", E), R === -1) R = w;
            else if (b > R) {
                E = g.lastIndexOf(";", b - 1) + 1;
                continue
            }
            var L = u(g, E, b),
                V = l(g, b, L),
                z = g.slice(L, V);
            if (!e.call(m, z)) {
                var j = u(g, b + 1, R),
                    Y = l(g, R, j);
                g.charCodeAt(j) === 34 && g.charCodeAt(Y - 1) === 34 && (j++, Y--);
                var q = g.slice(j, Y);
                m[z] = h(q, T)
            }
            E = R + 1
        } while (E < w);
        return m
    }
    o(a, "parse");

    function u(g, p, m) {
        do {
            var w = g.charCodeAt(p);
            if (w !== 32 && w !== 9) return p
        } while (++p < m);
        return m
    }
    o(u, "startIndex");

    function l(g, p, m) {
        for (; p > m;) {
            var w = g.charCodeAt(--p);
            if (w !== 32 && w !== 9) return p + 1
        }
        return m
    }
    o(l, "endIndex");

    function c(g, p, m) {
        var w = m && m.encode || encodeURIComponent;
        if (typeof w != "function") throw new TypeError("option encode is invalid");
        if (!t.test(g)) throw new TypeError("argument name is invalid");
        var T = w(p);
        if (!n.test(T)) throw new TypeError("argument val is invalid");
        var E = g + "=" + T;
        if (!m) return E;
        if (m.maxAge != null) {
            var b = Math.floor(m.maxAge);
            if (!isFinite(b)) throw new TypeError("option maxAge is invalid");
            E += "; Max-Age=" + b
        }
        if (m.domain) {
            if (!i.test(m.domain)) throw new TypeError("option domain is invalid");
            E += "; Domain=" + m.domain
        }
        if (m.path) {
            if (!s.test(m.path)) throw new TypeError("option path is invalid");
            E += "; Path=" + m.path
        }
        if (m.expires) {
            var R = m.expires;
            if (!f(R) || isNaN(R.valueOf())) throw new TypeError("option expires is invalid");
            E += "; Expires=" + R.toUTCString()
        }
        if (m.httpOnly && (E += "; HttpOnly"), m.secure && (E += "; Secure"), m.partitioned && (E += "; Partitioned"), m.priority) {
            var L = typeof m.priority == "string" ? m.priority.toLowerCase() : m.priority;
            switch (L) {
                case "low":
                    E += "; Priority=Low";
                    break;
                case "medium":
                    E += "; Priority=Medium";
                    break;
                case "high":
                    E += "; Priority=High";
                    break;
                default:
                    throw new TypeError("option priority is invalid")
            }
        }
        if (m.sameSite) {
            var V = typeof m.sameSite == "string" ? m.sameSite.toLowerCase() : m.sameSite;
            switch (V) {
                case !0:
                    E += "; SameSite=Strict";
                    break;
                case "lax":
                    E += "; SameSite=Lax";
                    break;
                case "strict":
                    E += "; SameSite=Strict";
                    break;
                case "none":
                    E += "; SameSite=None";
                    break;
                default:
                    throw new TypeError("option sameSite is invalid")
            }
        }
        return E
    }
    o(c, "serialize");

    function d(g) {
        return g.indexOf("%") !== -1 ? decodeURIComponent(g) : g
    }
    o(d, "decode");

    function f(g) {
        return r.call(g) === "[object Date]"
    }
    o(f, "isDate");

    function h(g, p) {
        try {
            return p(g)
        } catch (m) {
            return g
        }
    }
    return o(h, "tryDecode"), op
}
o(VQ, "requireCookie");
var dp = VQ();

function HQ() {
    let r = typeof global == "undefined" ? void 0 : global.TEST_HAS_DOCUMENT_COOKIE;
    return typeof r == "boolean" ? r : typeof document == "object" && typeof document.cookie == "string"
}
o(HQ, "hasDocumentCookie");

function jQ(r) {
    return typeof r == "string" ? dp.parse(r) : typeof r == "object" && r !== null ? r : {}
}
o(jQ, "parseCookies");

function LE(r) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        t = WQ(r);
    if (!e.doNotParse) try {
        return JSON.parse(t)
    } catch (n) {}
    return r
}
o(LE, "readCookie");

function WQ(r) {
    return r && r[0] === "j" && r[1] === ":" ? r.substr(2) : r
}
o(WQ, "cleanupCookieValue");
var Db = class Db {
    constructor(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.changeListeners = [], this.HAS_DOCUMENT_COOKIE = !1, this.update = () => {
            if (!this.HAS_DOCUMENT_COOKIE) return;
            let i = this.cookies;
            this.cookies = dp.parse(document.cookie), this._checkChanges(i)
        };
        let n = typeof document == "undefined" ? "" : document.cookie;
        this.cookies = jQ(e || n), this.defaultSetOptions = t, this.HAS_DOCUMENT_COOKIE = HQ()
    }
    _emitChange(e) {
        for (let t = 0; t < this.changeListeners.length; ++t) this.changeListeners[t](e)
    }
    _checkChanges(e) {
        new Set(Object.keys(e).concat(Object.keys(this.cookies))).forEach(n => {
            e[n] !== this.cookies[n] && this._emitChange({
                name: n,
                value: LE(this.cookies[n])
            })
        })
    }
    _startPolling() {
        this.pollingInterval = setInterval(this.update, 300)
    }
    _stopPolling() {
        this.pollingInterval && clearInterval(this.pollingInterval)
    }
    get(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return t.doNotUpdate || this.update(), LE(this.cookies[e], t)
    }
    getAll() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        e.doNotUpdate || this.update();
        let t = {};
        for (let n in this.cookies) t[n] = LE(this.cookies[n], e);
        return t
    }
    set(e, t, n) {
        n ? n = Object.assign(Object.assign({}, this.defaultSetOptions), n) : n = this.defaultSetOptions;
        let i = typeof t == "string" ? t : JSON.stringify(t);
        this.cookies = Object.assign(Object.assign({}, this.cookies), {
            [e]: i
        }), this.HAS_DOCUMENT_COOKIE && (document.cookie = dp.serialize(e, i, n)), this._emitChange({
            name: e,
            value: t,
            options: n
        })
    }
    remove(e, t) {
        let n = t = Object.assign(Object.assign(Object.assign({}, this.defaultSetOptions), t), {
            expires: new Date(1970, 1, 1, 0, 0, 1),
            maxAge: 0
        });
        this.cookies = Object.assign({}, this.cookies), delete this.cookies[e], this.HAS_DOCUMENT_COOKIE && (document.cookie = dp.serialize(e, "", n)), this._emitChange({
            name: e,
            value: void 0,
            options: t
        })
    }
    addChangeListener(e) {
        this.changeListeners.push(e), this.HAS_DOCUMENT_COOKIE && this.changeListeners.length === 1 && (typeof window == "object" && "cookieStore" in window ? window.cookieStore.addEventListener("change", this.update) : this._startPolling())
    }
    removeChangeListener(e) {
        let t = this.changeListeners.indexOf(e);
        t >= 0 && this.changeListeners.splice(t, 1), this.HAS_DOCUMENT_COOKIE && this.changeListeners.length === 0 && (typeof window == "object" && "cookieStore" in window ? window.cookieStore.removeEventListener("change", this.update) : this._stopPolling())
    }
};
o(Db, "Cookies");
var sd = Db,
    xp = function() {
        return xp = Object.assign || function(r) {
            for (var e, t = 1, n = arguments.length; t < n; t++) {
                e = arguments[t];
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (r[i] = e[i])
            }
            return r
        }, xp.apply(this, arguments)
    },
    kD = ki().isBrowser,
    GQ = 365 * 24 * 60 * 60 * 1e3,
    zQ = (function() {
        function r(e) {
            e === void 0 && (e = {}), this.cookies = new sd, this.store = kD ? window.localStorage : Object.create(null), this.cookies = e.req ? new sd(decodeURIComponent(e.req.headers.cookie)) : new sd, Object.assign(this.store, this.cookies.getAll())
        }
        return o(r, "UniversalStorage"), Object.defineProperty(r.prototype, "length", {
            get: o(function() {
                return Object.entries(this.store).length
            }, "get"),
            enumerable: !1,
            configurable: !0
        }), r.prototype.clear = function() {
            var e = this;
            Array.from(new Array(this.length)).map(function(t, n) {
                return e.key(n)
            }).forEach(function(t) {
                return e.removeItem(t)
            })
        }, r.prototype.getItem = function(e) {
            return this.getLocalItem(e)
        }, r.prototype.getLocalItem = function(e) {
            return Object.prototype.hasOwnProperty.call(this.store, e) ? this.store[e] : null
        }, r.prototype.getUniversalItem = function(e) {
            return this.cookies.get(e)
        }, r.prototype.key = function(e) {
            return Object.keys(this.store)[e]
        }, r.prototype.removeItem = function(e) {
            this.removeLocalItem(e), this.removeUniversalItem(e)
        }, r.prototype.removeLocalItem = function(e) {
            delete this.store[e]
        }, r.prototype.removeUniversalItem = function(e) {
            this.cookies.remove(e, {
                path: "/"
            })
        }, r.prototype.setItem = function(e, t) {
            this.setLocalItem(e, t);
            var n = e.split(".").pop(),
                i = ["LastAuthUser", "accessToken", "refreshToken", "idToken"];
            i.includes(n != null ? n : "") && this.setUniversalItem(e, t, {
                expires: new Date(Date.now() + GQ)
            })
        }, r.prototype.setLocalItem = function(e, t) {
            this.store[e] = t
        }, r.prototype.setUniversalItem = function(e, t, n) {
            n === void 0 && (n = {}), this.cookies.set(e, t, xp(xp({}, n), {
                path: "/",
                sameSite: !0,
                secure: !(kD && window.location.hostname === "localhost")
            }))
        }, r
    })(),
    qQ = "x-amz-user-agent";
var FD = (function() {
        function r(t) {
            var n = t || {},
                i = n.ValidationData,
                s = n.Username,
                a = n.Password,
                u = n.AuthParameters,
                l = n.ClientMetadata;
            this.validationData = i || {}, this.authParameters = u || {}, this.clientMetadata = l || {}, this.username = s, this.password = a
        }
        o(r, "AuthenticationDetails");
        var e = r.prototype;
        return e.getUsername = o(function() {
            return this.username
        }, "getUsername"), e.getPassword = o(function() {
            return this.password
        }, "getPassword"), e.getValidationData = o(function() {
            return this.validationData
        }, "getValidationData"), e.getAuthParameters = o(function() {
            return this.authParameters
        }, "getAuthParameters"), e.getClientMetadata = o(function() {
            return this.clientMetadata
        }, "getClientMetadata"), r
    })(),
    wt = {},
    rm = {};
rm.byteLength = YQ;
rm.toByteArray = JQ;
rm.fromByteArray = eee;
var Zn = [],
    ln = [],
    KQ = typeof Uint8Array != "undefined" ? Uint8Array : Array,
    xE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (wo = 0, $D = xE.length; wo < $D; ++wo) Zn[wo] = xE[wo], ln[xE.charCodeAt(wo)] = wo;
var wo, $D;
ln[45] = 62;
ln[95] = 63;

function YL(r) {
    var e = r.length;
    if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var t = r.indexOf("=");
    t === -1 && (t = e);
    var n = t === e ? 0 : 4 - t % 4;
    return [t, n]
}
o(YL, "getLens");

function YQ(r) {
    var e = YL(r),
        t = e[0],
        n = e[1];
    return (t + n) * 3 / 4 - n
}
o(YQ, "byteLength");

function XQ(r, e, t) {
    return (e + t) * 3 / 4 - t
}
o(XQ, "_byteLength");

function JQ(r) {
    var e, t = YL(r),
        n = t[0],
        i = t[1],
        s = new KQ(XQ(r, n, i)),
        a = 0,
        u = i > 0 ? n - 4 : n,
        l;
    for (l = 0; l < u; l += 4) e = ln[r.charCodeAt(l)] << 18 | ln[r.charCodeAt(l + 1)] << 12 | ln[r.charCodeAt(l + 2)] << 6 | ln[r.charCodeAt(l + 3)], s[a++] = e >> 16 & 255, s[a++] = e >> 8 & 255, s[a++] = e & 255;
    return i === 2 && (e = ln[r.charCodeAt(l)] << 2 | ln[r.charCodeAt(l + 1)] >> 4, s[a++] = e & 255), i === 1 && (e = ln[r.charCodeAt(l)] << 10 | ln[r.charCodeAt(l + 1)] << 4 | ln[r.charCodeAt(l + 2)] >> 2, s[a++] = e >> 8 & 255, s[a++] = e & 255), s
}
o(JQ, "toByteArray");

function ZQ(r) {
    return Zn[r >> 18 & 63] + Zn[r >> 12 & 63] + Zn[r >> 6 & 63] + Zn[r & 63]
}
o(ZQ, "tripletToBase64");

function QQ(r, e, t) {
    for (var n, i = [], s = e; s < t; s += 3) n = (r[s] << 16 & 16711680) + (r[s + 1] << 8 & 65280) + (r[s + 2] & 255), i.push(ZQ(n));
    return i.join("")
}
o(QQ, "encodeChunk");

function eee(r) {
    for (var e, t = r.length, n = t % 3, i = [], s = 16383, a = 0, u = t - n; a < u; a += s) i.push(QQ(r, a, a + s > u ? u : a + s));
    return n === 1 ? (e = r[t - 1], i.push(Zn[e >> 2] + Zn[e << 4 & 63] + "==")) : n === 2 && (e = (r[t - 2] << 8) + r[t - 1], i.push(Zn[e >> 10] + Zn[e >> 4 & 63] + Zn[e << 2 & 63] + "=")), i.join("")
}
o(eee, "fromByteArray");
var Cb = {};
Cb.read = function(r, e, t, n, i) {
    var s, a, u = i * 8 - n - 1,
        l = (1 << u) - 1,
        c = l >> 1,
        d = -7,
        f = t ? i - 1 : 0,
        h = t ? -1 : 1,
        g = r[e + f];
    for (f += h, s = g & (1 << -d) - 1, g >>= -d, d += u; d > 0; s = s * 256 + r[e + f], f += h, d -= 8);
    for (a = s & (1 << -d) - 1, s >>= -d, d += n; d > 0; a = a * 256 + r[e + f], f += h, d -= 8);
    if (s === 0) s = 1 - c;
    else {
        if (s === l) return a ? NaN : (g ? -1 : 1) * (1 / 0);
        a = a + Math.pow(2, n), s = s - c
    }
    return (g ? -1 : 1) * a * Math.pow(2, s - n)
};
Cb.write = function(r, e, t, n, i, s) {
    var a, u, l, c = s * 8 - i - 1,
        d = (1 << c) - 1,
        f = d >> 1,
        h = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
        g = n ? 0 : s - 1,
        p = n ? 1 : -1,
        m = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (u = isNaN(e) ? 1 : 0, a = d) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), a + f >= 1 ? e += h / l : e += h * Math.pow(2, 1 - f), e * l >= 2 && (a++, l /= 2), a + f >= d ? (u = 0, a = d) : a + f >= 1 ? (u = (e * l - 1) * Math.pow(2, i), a = a + f) : (u = e * Math.pow(2, f - 1) * Math.pow(2, i), a = 0)); i >= 8; r[t + g] = u & 255, g += p, u /= 256, i -= 8);
    for (a = a << i | u, c += i; c > 0; r[t + g] = a & 255, g += p, a /= 256, c -= 8);
    r[t + g - p] |= m * 128
};
var tee = {}.toString,
    ree = Array.isArray || function(r) {
        return tee.call(r) == "[object Array]"
    };
(function(r) {
    var e = rm,
        t = Cb,
        n = ree;
    r.Buffer = u, r.SlowBuffer = T, r.INSPECT_MAX_BYTES = 50, u.TYPED_ARRAY_SUPPORT = Ui.TYPED_ARRAY_SUPPORT !== void 0 ? Ui.TYPED_ARRAY_SUPPORT : i(), r.kMaxLength = s();

    function i() {
        try {
            var A = new Uint8Array(1);
            return A.__proto__ = {
                __proto__: Uint8Array.prototype,
                foo: o(function() {
                    return 42
                }, "foo")
            }, A.foo() === 42 && typeof A.subarray == "function" && A.subarray(1, 1).byteLength === 0
        } catch (v) {
            return !1
        }
    }
    o(i, "typedArraySupport");

    function s() {
        return u.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
    }
    o(s, "kMaxLength");

    function a(A, v) {
        if (s() < v) throw new RangeError("Invalid typed array length");
        return u.TYPED_ARRAY_SUPPORT ? (A = new Uint8Array(v), A.__proto__ = u.prototype) : (A === null && (A = new u(v)), A.length = v), A
    }
    o(a, "createBuffer");

    function u(A, v, y) {
        if (!u.TYPED_ARRAY_SUPPORT && !(this instanceof u)) return new u(A, v, y);
        if (typeof A == "number") {
            if (typeof v == "string") throw new Error("If encoding is specified then the first argument must be a string");
            return f(this, A)
        }
        return l(this, A, v, y)
    }
    o(u, "Buffer"), u.poolSize = 8192, u._augment = function(A) {
        return A.__proto__ = u.prototype, A
    };

    function l(A, v, y, C) {
        if (typeof v == "number") throw new TypeError('"value" argument must not be a number');
        return typeof ArrayBuffer != "undefined" && v instanceof ArrayBuffer ? p(A, v, y, C) : typeof v == "string" ? h(A, v, y) : m(A, v)
    }
    o(l, "from"), u.from = function(A, v, y) {
        return l(null, A, v, y)
    }, u.TYPED_ARRAY_SUPPORT && (u.prototype.__proto__ = Uint8Array.prototype, u.__proto__ = Uint8Array, typeof Symbol != "undefined" && Symbol.species && u[Symbol.species] === u && Object.defineProperty(u, Symbol.species, {
        value: null,
        configurable: !0
    }));

    function c(A) {
        if (typeof A != "number") throw new TypeError('"size" argument must be a number');
        if (A < 0) throw new RangeError('"size" argument must not be negative')
    }
    o(c, "assertSize");

    function d(A, v, y, C) {
        return c(v), v <= 0 ? a(A, v) : y !== void 0 ? typeof C == "string" ? a(A, v).fill(y, C) : a(A, v).fill(y) : a(A, v)
    }
    o(d, "alloc"), u.alloc = function(A, v, y) {
        return d(null, A, v, y)
    };

    function f(A, v) {
        if (c(v), A = a(A, v < 0 ? 0 : w(v) | 0), !u.TYPED_ARRAY_SUPPORT)
            for (var y = 0; y < v; ++y) A[y] = 0;
        return A
    }
    o(f, "allocUnsafe"), u.allocUnsafe = function(A) {
        return f(null, A)
    }, u.allocUnsafeSlow = function(A) {
        return f(null, A)
    };

    function h(A, v, y) {
        if ((typeof y != "string" || y === "") && (y = "utf8"), !u.isEncoding(y)) throw new TypeError('"encoding" must be a valid string encoding');
        var C = E(v, y) | 0;
        A = a(A, C);
        var B = A.write(v, y);
        return B !== C && (A = A.slice(0, B)), A
    }
    o(h, "fromString");

    function g(A, v) {
        var y = v.length < 0 ? 0 : w(v.length) | 0;
        A = a(A, y);
        for (var C = 0; C < y; C += 1) A[C] = v[C] & 255;
        return A
    }
    o(g, "fromArrayLike");

    function p(A, v, y, C) {
        if (v.byteLength, y < 0 || v.byteLength < y) throw new RangeError("'offset' is out of bounds");
        if (v.byteLength < y + (C || 0)) throw new RangeError("'length' is out of bounds");
        return y === void 0 && C === void 0 ? v = new Uint8Array(v) : C === void 0 ? v = new Uint8Array(v, y) : v = new Uint8Array(v, y, C), u.TYPED_ARRAY_SUPPORT ? (A = v, A.__proto__ = u.prototype) : A = g(A, v), A
    }
    o(p, "fromArrayBuffer");

    function m(A, v) {
        if (u.isBuffer(v)) {
            var y = w(v.length) | 0;
            return A = a(A, y), A.length === 0 || v.copy(A, 0, 0, y), A
        }
        if (v) {
            if (typeof ArrayBuffer != "undefined" && v.buffer instanceof ArrayBuffer || "length" in v) return typeof v.length != "number" || Me(v.length) ? a(A, 0) : g(A, v);
            if (v.type === "Buffer" && n(v.data)) return g(A, v.data)
        }
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
    }
    o(m, "fromObject");

    function w(A) {
        if (A >= s()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s().toString(16) + " bytes");
        return A | 0
    }
    o(w, "checked");

    function T(A) {
        return +A != A && (A = 0), u.alloc(+A)
    }
    o(T, "SlowBuffer"), u.isBuffer = o(function(v) {
        return !!(v != null && v._isBuffer)
    }, "isBuffer"), u.compare = o(function(v, y) {
        if (!u.isBuffer(v) || !u.isBuffer(y)) throw new TypeError("Arguments must be Buffers");
        if (v === y) return 0;
        for (var C = v.length, B = y.length, se = 0, ce = Math.min(C, B); se < ce; ++se)
            if (v[se] !== y[se]) {
                C = v[se], B = y[se];
                break
            } return C < B ? -1 : B < C ? 1 : 0
    }, "compare"), u.isEncoding = o(function(v) {
        switch (String(v).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
        }
    }, "isEncoding"), u.concat = o(function(v, y) {
        if (!n(v)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (v.length === 0) return u.alloc(0);
        var C;
        if (y === void 0)
            for (y = 0, C = 0; C < v.length; ++C) y += v[C].length;
        var B = u.allocUnsafe(y),
            se = 0;
        for (C = 0; C < v.length; ++C) {
            var ce = v[C];
            if (!u.isBuffer(ce)) throw new TypeError('"list" argument must be an Array of Buffers');
            ce.copy(B, se), se += ce.length
        }
        return B
    }, "concat");

    function E(A, v) {
        if (u.isBuffer(A)) return A.length;
        if (typeof ArrayBuffer != "undefined" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(A) || A instanceof ArrayBuffer)) return A.byteLength;
        typeof A != "string" && (A = "" + A);
        var y = A.length;
        if (y === 0) return 0;
        for (var C = !1;;) switch (v) {
            case "ascii":
            case "latin1":
            case "binary":
                return y;
            case "utf8":
            case "utf-8":
            case void 0:
                return W(A).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return y * 2;
            case "hex":
                return y >>> 1;
            case "base64":
                return we(A).length;
            default:
                if (C) return W(A).length;
                v = ("" + v).toLowerCase(), C = !0
        }
    }
    o(E, "byteLength"), u.byteLength = E;

    function b(A, v, y) {
        var C = !1;
        if ((v === void 0 || v < 0) && (v = 0), v > this.length || ((y === void 0 || y > this.length) && (y = this.length), y <= 0) || (y >>>= 0, v >>>= 0, y <= v)) return "";
        for (A || (A = "utf8");;) switch (A) {
            case "hex":
                return Xe(this, v, y);
            case "utf8":
            case "utf-8":
                return S(this, v, y);
            case "ascii":
                return Oe(this, v, y);
            case "latin1":
            case "binary":
                return Ye(this, v, y);
            case "base64":
                return oe(this, v, y);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return de(this, v, y);
            default:
                if (C) throw new TypeError("Unknown encoding: " + A);
                A = (A + "").toLowerCase(), C = !0
        }
    }
    o(b, "slowToString"), u.prototype._isBuffer = !0;

    function R(A, v, y) {
        var C = A[v];
        A[v] = A[y], A[y] = C
    }
    o(R, "swap"), u.prototype.swap16 = o(function() {
        var v = this.length;
        if (v % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var y = 0; y < v; y += 2) R(this, y, y + 1);
        return this
    }, "swap16"), u.prototype.swap32 = o(function() {
        var v = this.length;
        if (v % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var y = 0; y < v; y += 4) R(this, y, y + 3), R(this, y + 1, y + 2);
        return this
    }, "swap32"), u.prototype.swap64 = o(function() {
        var v = this.length;
        if (v % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var y = 0; y < v; y += 8) R(this, y, y + 7), R(this, y + 1, y + 6), R(this, y + 2, y + 5), R(this, y + 3, y + 4);
        return this
    }, "swap64"), u.prototype.toString = o(function() {
        var v = this.length | 0;
        return v === 0 ? "" : arguments.length === 0 ? S(this, 0, v) : b.apply(this, arguments)
    }, "toString"), u.prototype.equals = o(function(v) {
        if (!u.isBuffer(v)) throw new TypeError("Argument must be a Buffer");
        return this === v ? !0 : u.compare(this, v) === 0
    }, "equals"), u.prototype.inspect = o(function() {
        var v = "",
            y = r.INSPECT_MAX_BYTES;
        return this.length > 0 && (v = this.toString("hex", 0, y).match(/.{2}/g).join(" "), this.length > y && (v += " ... ")), "<Buffer " + v + ">"
    }, "inspect"), u.prototype.compare = o(function(v, y, C, B, se) {
        if (!u.isBuffer(v)) throw new TypeError("Argument must be a Buffer");
        if (y === void 0 && (y = 0), C === void 0 && (C = v ? v.length : 0), B === void 0 && (B = 0), se === void 0 && (se = this.length), y < 0 || C > v.length || B < 0 || se > this.length) throw new RangeError("out of range index");
        if (B >= se && y >= C) return 0;
        if (B >= se) return -1;
        if (y >= C) return 1;
        if (y >>>= 0, C >>>= 0, B >>>= 0, se >>>= 0, this === v) return 0;
        for (var ce = se - B, Ge = C - y, it = Math.min(ce, Ge), st = this.slice(B, se), _t = v.slice(y, C), mt = 0; mt < it; ++mt)
            if (st[mt] !== _t[mt]) {
                ce = st[mt], Ge = _t[mt];
                break
            } return ce < Ge ? -1 : Ge < ce ? 1 : 0
    }, "compare");

    function L(A, v, y, C, B) {
        if (A.length === 0) return -1;
        if (typeof y == "string" ? (C = y, y = 0) : y > 2147483647 ? y = 2147483647 : y < -2147483648 && (y = -2147483648), y = +y, isNaN(y) && (y = B ? 0 : A.length - 1), y < 0 && (y = A.length + y), y >= A.length) {
            if (B) return -1;
            y = A.length - 1
        } else if (y < 0)
            if (B) y = 0;
            else return -1;
        if (typeof v == "string" && (v = u.from(v, C)), u.isBuffer(v)) return v.length === 0 ? -1 : V(A, v, y, C, B);
        if (typeof v == "number") return v = v & 255, u.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? B ? Uint8Array.prototype.indexOf.call(A, v, y) : Uint8Array.prototype.lastIndexOf.call(A, v, y) : V(A, [v], y, C, B);
        throw new TypeError("val must be string, number or Buffer")
    }
    o(L, "bidirectionalIndexOf");

    function V(A, v, y, C, B) {
        var se = 1,
            ce = A.length,
            Ge = v.length;
        if (C !== void 0 && (C = String(C).toLowerCase(), C === "ucs2" || C === "ucs-2" || C === "utf16le" || C === "utf-16le")) {
            if (A.length < 2 || v.length < 2) return -1;
            se = 2, ce /= 2, Ge /= 2, y /= 2
        }

        function it(Zi, Qi) {
            return se === 1 ? Zi[Qi] : Zi.readUInt16BE(Qi * se)
        }
        o(it, "read");
        var st;
        if (B) {
            var _t = -1;
            for (st = y; st < ce; st++)
                if (it(A, st) === it(v, _t === -1 ? 0 : st - _t)) {
                    if (_t === -1 && (_t = st), st - _t + 1 === Ge) return _t * se
                } else _t !== -1 && (st -= st - _t), _t = -1
        } else
            for (y + Ge > ce && (y = ce - Ge), st = y; st >= 0; st--) {
                for (var mt = !0, $t = 0; $t < Ge; $t++)
                    if (it(A, st + $t) !== it(v, $t)) {
                        mt = !1;
                        break
                    } if (mt) return st
            }
        return -1
    }
    o(V, "arrayIndexOf"), u.prototype.includes = o(function(v, y, C) {
        return this.indexOf(v, y, C) !== -1
    }, "includes"), u.prototype.indexOf = o(function(v, y, C) {
        return L(this, v, y, C, !0)
    }, "indexOf"), u.prototype.lastIndexOf = o(function(v, y, C) {
        return L(this, v, y, C, !1)
    }, "lastIndexOf");

    function z(A, v, y, C) {
        y = Number(y) || 0;
        var B = A.length - y;
        C ? (C = Number(C), C > B && (C = B)) : C = B;
        var se = v.length;
        if (se % 2 !== 0) throw new TypeError("Invalid hex string");
        C > se / 2 && (C = se / 2);
        for (var ce = 0; ce < C; ++ce) {
            var Ge = parseInt(v.substr(ce * 2, 2), 16);
            if (isNaN(Ge)) return ce;
            A[y + ce] = Ge
        }
        return ce
    }
    o(z, "hexWrite");

    function j(A, v, y, C) {
        return Ie(W(v, A.length - y), A, y, C)
    }
    o(j, "utf8Write");

    function Y(A, v, y, C) {
        return Ie(te(v), A, y, C)
    }
    o(Y, "asciiWrite");

    function q(A, v, y, C) {
        return Y(A, v, y, C)
    }
    o(q, "latin1Write");

    function P(A, v, y, C) {
        return Ie(we(v), A, y, C)
    }
    o(P, "base64Write");

    function Z(A, v, y, C) {
        return Ie(_e(v, A.length - y), A, y, C)
    }
    o(Z, "ucs2Write"), u.prototype.write = o(function(v, y, C, B) {
        if (y === void 0) B = "utf8", C = this.length, y = 0;
        else if (C === void 0 && typeof y == "string") B = y, C = this.length, y = 0;
        else if (isFinite(y)) y = y | 0, isFinite(C) ? (C = C | 0, B === void 0 && (B = "utf8")) : (B = C, C = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        var se = this.length - y;
        if ((C === void 0 || C > se) && (C = se), v.length > 0 && (C < 0 || y < 0) || y > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        B || (B = "utf8");
        for (var ce = !1;;) switch (B) {
            case "hex":
                return z(this, v, y, C);
            case "utf8":
            case "utf-8":
                return j(this, v, y, C);
            case "ascii":
                return Y(this, v, y, C);
            case "latin1":
            case "binary":
                return q(this, v, y, C);
            case "base64":
                return P(this, v, y, C);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Z(this, v, y, C);
            default:
                if (ce) throw new TypeError("Unknown encoding: " + B);
                B = ("" + B).toLowerCase(), ce = !0
        }
    }, "write"), u.prototype.toJSON = o(function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }, "toJSON");

    function oe(A, v, y) {
        return v === 0 && y === A.length ? e.fromByteArray(A) : e.fromByteArray(A.slice(v, y))
    }
    o(oe, "base64Slice");

    function S(A, v, y) {
        y = Math.min(A.length, y);
        for (var C = [], B = v; B < y;) {
            var se = A[B],
                ce = null,
                Ge = se > 239 ? 4 : se > 223 ? 3 : se > 191 ? 2 : 1;
            if (B + Ge <= y) {
                var it, st, _t, mt;
                switch (Ge) {
                    case 1:
                        se < 128 && (ce = se);
                        break;
                    case 2:
                        it = A[B + 1], (it & 192) === 128 && (mt = (se & 31) << 6 | it & 63, mt > 127 && (ce = mt));
                        break;
                    case 3:
                        it = A[B + 1], st = A[B + 2], (it & 192) === 128 && (st & 192) === 128 && (mt = (se & 15) << 12 | (it & 63) << 6 | st & 63, mt > 2047 && (mt < 55296 || mt > 57343) && (ce = mt));
                        break;
                    case 4:
                        it = A[B + 1], st = A[B + 2], _t = A[B + 3], (it & 192) === 128 && (st & 192) === 128 && (_t & 192) === 128 && (mt = (se & 15) << 18 | (it & 63) << 12 | (st & 63) << 6 | _t & 63, mt > 65535 && mt < 1114112 && (ce = mt))
                }
            }
            ce === null ? (ce = 65533, Ge = 1) : ce > 65535 && (ce -= 65536, C.push(ce >>> 10 & 1023 | 55296), ce = 56320 | ce & 1023), C.push(ce), B += Ge
        }
        return M(C)
    }
    o(S, "utf8Slice");
    var K = 4096;

    function M(A) {
        var v = A.length;
        if (v <= K) return String.fromCharCode.apply(String, A);
        for (var y = "", C = 0; C < v;) y += String.fromCharCode.apply(String, A.slice(C, C += K));
        return y
    }
    o(M, "decodeCodePointsArray");

    function Oe(A, v, y) {
        var C = "";
        y = Math.min(A.length, y);
        for (var B = v; B < y; ++B) C += String.fromCharCode(A[B] & 127);
        return C
    }
    o(Oe, "asciiSlice");

    function Ye(A, v, y) {
        var C = "";
        y = Math.min(A.length, y);
        for (var B = v; B < y; ++B) C += String.fromCharCode(A[B]);
        return C
    }
    o(Ye, "latin1Slice");

    function Xe(A, v, y) {
        var C = A.length;
        (!v || v < 0) && (v = 0), (!y || y < 0 || y > C) && (y = C);
        for (var B = "", se = v; se < y; ++se) B += X(A[se]);
        return B
    }
    o(Xe, "hexSlice");

    function de(A, v, y) {
        for (var C = A.slice(v, y), B = "", se = 0; se < C.length; se += 2) B += String.fromCharCode(C[se] + C[se + 1] * 256);
        return B
    }
    o(de, "utf16leSlice"), u.prototype.slice = o(function(v, y) {
        var C = this.length;
        v = ~~v, y = y === void 0 ? C : ~~y, v < 0 ? (v += C, v < 0 && (v = 0)) : v > C && (v = C), y < 0 ? (y += C, y < 0 && (y = 0)) : y > C && (y = C), y < v && (y = v);
        var B;
        if (u.TYPED_ARRAY_SUPPORT) B = this.subarray(v, y), B.__proto__ = u.prototype;
        else {
            var se = y - v;
            B = new u(se, void 0);
            for (var ce = 0; ce < se; ++ce) B[ce] = this[ce + v]
        }
        return B
    }, "slice");

    function N(A, v, y) {
        if (A % 1 !== 0 || A < 0) throw new RangeError("offset is not uint");
        if (A + v > y) throw new RangeError("Trying to access beyond buffer length")
    }
    o(N, "checkOffset"), u.prototype.readUIntLE = o(function(v, y, C) {
        v = v | 0, y = y | 0, C || N(v, y, this.length);
        for (var B = this[v], se = 1, ce = 0; ++ce < y && (se *= 256);) B += this[v + ce] * se;
        return B
    }, "readUIntLE"), u.prototype.readUIntBE = o(function(v, y, C) {
        v = v | 0, y = y | 0, C || N(v, y, this.length);
        for (var B = this[v + --y], se = 1; y > 0 && (se *= 256);) B += this[v + --y] * se;
        return B
    }, "readUIntBE"), u.prototype.readUInt8 = o(function(v, y) {
        return y || N(v, 1, this.length), this[v]
    }, "readUInt8"), u.prototype.readUInt16LE = o(function(v, y) {
        return y || N(v, 2, this.length), this[v] | this[v + 1] << 8
    }, "readUInt16LE"), u.prototype.readUInt16BE = o(function(v, y) {
        return y || N(v, 2, this.length), this[v] << 8 | this[v + 1]
    }, "readUInt16BE"), u.prototype.readUInt32LE = o(function(v, y) {
        return y || N(v, 4, this.length), (this[v] | this[v + 1] << 8 | this[v + 2] << 16) + this[v + 3] * 16777216
    }, "readUInt32LE"), u.prototype.readUInt32BE = o(function(v, y) {
        return y || N(v, 4, this.length), this[v] * 16777216 + (this[v + 1] << 16 | this[v + 2] << 8 | this[v + 3])
    }, "readUInt32BE"), u.prototype.readIntLE = o(function(v, y, C) {
        v = v | 0, y = y | 0, C || N(v, y, this.length);
        for (var B = this[v], se = 1, ce = 0; ++ce < y && (se *= 256);) B += this[v + ce] * se;
        return se *= 128, B >= se && (B -= Math.pow(2, 8 * y)), B
    }, "readIntLE"), u.prototype.readIntBE = o(function(v, y, C) {
        v = v | 0, y = y | 0, C || N(v, y, this.length);
        for (var B = y, se = 1, ce = this[v + --B]; B > 0 && (se *= 256);) ce += this[v + --B] * se;
        return se *= 128, ce >= se && (ce -= Math.pow(2, 8 * y)), ce
    }, "readIntBE"), u.prototype.readInt8 = o(function(v, y) {
        return y || N(v, 1, this.length), this[v] & 128 ? (255 - this[v] + 1) * -1 : this[v]
    }, "readInt8"), u.prototype.readInt16LE = o(function(v, y) {
        y || N(v, 2, this.length);
        var C = this[v] | this[v + 1] << 8;
        return C & 32768 ? C | 4294901760 : C
    }, "readInt16LE"), u.prototype.readInt16BE = o(function(v, y) {
        y || N(v, 2, this.length);
        var C = this[v + 1] | this[v] << 8;
        return C & 32768 ? C | 4294901760 : C
    }, "readInt16BE"), u.prototype.readInt32LE = o(function(v, y) {
        return y || N(v, 4, this.length), this[v] | this[v + 1] << 8 | this[v + 2] << 16 | this[v + 3] << 24
    }, "readInt32LE"), u.prototype.readInt32BE = o(function(v, y) {
        return y || N(v, 4, this.length), this[v] << 24 | this[v + 1] << 16 | this[v + 2] << 8 | this[v + 3]
    }, "readInt32BE"), u.prototype.readFloatLE = o(function(v, y) {
        return y || N(v, 4, this.length), t.read(this, v, !0, 23, 4)
    }, "readFloatLE"), u.prototype.readFloatBE = o(function(v, y) {
        return y || N(v, 4, this.length), t.read(this, v, !1, 23, 4)
    }, "readFloatBE"), u.prototype.readDoubleLE = o(function(v, y) {
        return y || N(v, 8, this.length), t.read(this, v, !0, 52, 8)
    }, "readDoubleLE"), u.prototype.readDoubleBE = o(function(v, y) {
        return y || N(v, 8, this.length), t.read(this, v, !1, 52, 8)
    }, "readDoubleBE");

    function x(A, v, y, C, B, se) {
        if (!u.isBuffer(A)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (v > B || v < se) throw new RangeError('"value" argument is out of bounds');
        if (y + C > A.length) throw new RangeError("Index out of range")
    }
    o(x, "checkInt"), u.prototype.writeUIntLE = o(function(v, y, C, B) {
        if (v = +v, y = y | 0, C = C | 0, !B) {
            var se = Math.pow(2, 8 * C) - 1;
            x(this, v, y, C, se, 0)
        }
        var ce = 1,
            Ge = 0;
        for (this[y] = v & 255; ++Ge < C && (ce *= 256);) this[y + Ge] = v / ce & 255;
        return y + C
    }, "writeUIntLE"), u.prototype.writeUIntBE = o(function(v, y, C, B) {
        if (v = +v, y = y | 0, C = C | 0, !B) {
            var se = Math.pow(2, 8 * C) - 1;
            x(this, v, y, C, se, 0)
        }
        var ce = C - 1,
            Ge = 1;
        for (this[y + ce] = v & 255; --ce >= 0 && (Ge *= 256);) this[y + ce] = v / Ge & 255;
        return y + C
    }, "writeUIntBE"), u.prototype.writeUInt8 = o(function(v, y, C) {
        return v = +v, y = y | 0, C || x(this, v, y, 1, 255, 0), u.TYPED_ARRAY_SUPPORT || (v = Math.floor(v)), this[y] = v & 255, y + 1
    }, "writeUInt8");

    function U(A, v, y, C) {
        v < 0 && (v = 65535 + v + 1);
        for (var B = 0, se = Math.min(A.length - y, 2); B < se; ++B) A[y + B] = (v & 255 << 8 * (C ? B : 1 - B)) >>> (C ? B : 1 - B) * 8
    }
    o(U, "objectWriteUInt16"), u.prototype.writeUInt16LE = o(function(v, y, C) {
        return v = +v, y = y | 0, C || x(this, v, y, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[y] = v & 255, this[y + 1] = v >>> 8) : U(this, v, y, !0), y + 2
    }, "writeUInt16LE"), u.prototype.writeUInt16BE = o(function(v, y, C) {
        return v = +v, y = y | 0, C || x(this, v, y, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[y] = v >>> 8, this[y + 1] = v & 255) : U(this, v, y, !1), y + 2
    }, "writeUInt16BE");

    function ve(A, v, y, C) {
        v < 0 && (v = 4294967295 + v + 1);
        for (var B = 0, se = Math.min(A.length - y, 4); B < se; ++B) A[y + B] = v >>> (C ? B : 3 - B) * 8 & 255
    }
    o(ve, "objectWriteUInt32"), u.prototype.writeUInt32LE = o(function(v, y, C) {
        return v = +v, y = y | 0, C || x(this, v, y, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[y + 3] = v >>> 24, this[y + 2] = v >>> 16, this[y + 1] = v >>> 8, this[y] = v & 255) : ve(this, v, y, !0), y + 4
    }, "writeUInt32LE"), u.prototype.writeUInt32BE = o(function(v, y, C) {
        return v = +v, y = y | 0, C || x(this, v, y, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[y] = v >>> 24, this[y + 1] = v >>> 16, this[y + 2] = v >>> 8, this[y + 3] = v & 255) : ve(this, v, y, !1), y + 4
    }, "writeUInt32BE"), u.prototype.writeIntLE = o(function(v, y, C, B) {
        if (v = +v, y = y | 0, !B) {
            var se = Math.pow(2, 8 * C - 1);
            x(this, v, y, C, se - 1, -se)
        }
        var ce = 0,
            Ge = 1,
            it = 0;
        for (this[y] = v & 255; ++ce < C && (Ge *= 256);) v < 0 && it === 0 && this[y + ce - 1] !== 0 && (it = 1), this[y + ce] = (v / Ge >> 0) - it & 255;
        return y + C
    }, "writeIntLE"), u.prototype.writeIntBE = o(function(v, y, C, B) {
        if (v = +v, y = y | 0, !B) {
            var se = Math.pow(2, 8 * C - 1);
            x(this, v, y, C, se - 1, -se)
        }
        var ce = C - 1,
            Ge = 1,
            it = 0;
        for (this[y + ce] = v & 255; --ce >= 0 && (Ge *= 256);) v < 0 && it === 0 && this[y + ce + 1] !== 0 && (it = 1), this[y + ce] = (v / Ge >> 0) - it & 255;
        return y + C
    }, "writeIntBE"), u.prototype.writeInt8 = o(function(v, y, C) {
        return v = +v, y = y | 0, C || x(this, v, y, 1, 127, -128), u.TYPED_ARRAY_SUPPORT || (v = Math.floor(v)), v < 0 && (v = 255 + v + 1), this[y] = v & 255, y + 1
    }, "writeInt8"), u.prototype.writeInt16LE = o(function(v, y, C) {
        return v = +v, y = y | 0, C || x(this, v, y, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[y] = v & 255, this[y + 1] = v >>> 8) : U(this, v, y, !0), y + 2
    }, "writeInt16LE"), u.prototype.writeInt16BE = o(function(v, y, C) {
        return v = +v, y = y | 0, C || x(this, v, y, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[y] = v >>> 8, this[y + 1] = v & 255) : U(this, v, y, !1), y + 2
    }, "writeInt16BE"), u.prototype.writeInt32LE = o(function(v, y, C) {
        return v = +v, y = y | 0, C || x(this, v, y, 4, 2147483647, -2147483648), u.TYPED_ARRAY_SUPPORT ? (this[y] = v & 255, this[y + 1] = v >>> 8, this[y + 2] = v >>> 16, this[y + 3] = v >>> 24) : ve(this, v, y, !0), y + 4
    }, "writeInt32LE"), u.prototype.writeInt32BE = o(function(v, y, C) {
        return v = +v, y = y | 0, C || x(this, v, y, 4, 2147483647, -2147483648), v < 0 && (v = 4294967295 + v + 1), u.TYPED_ARRAY_SUPPORT ? (this[y] = v >>> 24, this[y + 1] = v >>> 16, this[y + 2] = v >>> 8, this[y + 3] = v & 255) : ve(this, v, y, !1), y + 4
    }, "writeInt32BE");

    function Te(A, v, y, C, B, se) {
        if (y + C > A.length) throw new RangeError("Index out of range");
        if (y < 0) throw new RangeError("Index out of range")
    }
    o(Te, "checkIEEE754");

    function Fe(A, v, y, C, B) {
        return B || Te(A, v, y, 4), t.write(A, v, y, C, 23, 4), y + 4
    }
    o(Fe, "writeFloat"), u.prototype.writeFloatLE = o(function(v, y, C) {
        return Fe(this, v, y, !0, C)
    }, "writeFloatLE"), u.prototype.writeFloatBE = o(function(v, y, C) {
        return Fe(this, v, y, !1, C)
    }, "writeFloatBE");

    function rt(A, v, y, C, B) {
        return B || Te(A, v, y, 8), t.write(A, v, y, C, 52, 8), y + 8
    }
    o(rt, "writeDouble"), u.prototype.writeDoubleLE = o(function(v, y, C) {
        return rt(this, v, y, !0, C)
    }, "writeDoubleLE"), u.prototype.writeDoubleBE = o(function(v, y, C) {
        return rt(this, v, y, !1, C)
    }, "writeDoubleBE"), u.prototype.copy = o(function(v, y, C, B) {
        if (C || (C = 0), !B && B !== 0 && (B = this.length), y >= v.length && (y = v.length), y || (y = 0), B > 0 && B < C && (B = C), B === C || v.length === 0 || this.length === 0) return 0;
        if (y < 0) throw new RangeError("targetStart out of bounds");
        if (C < 0 || C >= this.length) throw new RangeError("sourceStart out of bounds");
        if (B < 0) throw new RangeError("sourceEnd out of bounds");
        B > this.length && (B = this.length), v.length - y < B - C && (B = v.length - y + C);
        var se = B - C,
            ce;
        if (this === v && C < y && y < B)
            for (ce = se - 1; ce >= 0; --ce) v[ce + y] = this[ce + C];
        else if (se < 1e3 || !u.TYPED_ARRAY_SUPPORT)
            for (ce = 0; ce < se; ++ce) v[ce + y] = this[ce + C];
        else Uint8Array.prototype.set.call(v, this.subarray(C, C + se), y);
        return se
    }, "copy"), u.prototype.fill = o(function(v, y, C, B) {
        if (typeof v == "string") {
            if (typeof y == "string" ? (B = y, y = 0, C = this.length) : typeof C == "string" && (B = C, C = this.length), v.length === 1) {
                var se = v.charCodeAt(0);
                se < 256 && (v = se)
            }
            if (B !== void 0 && typeof B != "string") throw new TypeError("encoding must be a string");
            if (typeof B == "string" && !u.isEncoding(B)) throw new TypeError("Unknown encoding: " + B)
        } else typeof v == "number" && (v = v & 255);
        if (y < 0 || this.length < y || this.length < C) throw new RangeError("Out of range index");
        if (C <= y) return this;
        y = y >>> 0, C = C === void 0 ? this.length : C >>> 0, v || (v = 0);
        var ce;
        if (typeof v == "number")
            for (ce = y; ce < C; ++ce) this[ce] = v;
        else {
            var Ge = u.isBuffer(v) ? v : W(new u(v, B).toString()),
                it = Ge.length;
            for (ce = 0; ce < C - y; ++ce) this[ce + y] = Ge[ce % it]
        }
        return this
    }, "fill");
    var xe = /[^+\/0-9A-Za-z-_]/g;

    function fe(A) {
        if (A = $(A).replace(xe, ""), A.length < 2) return "";
        for (; A.length % 4 !== 0;) A = A + "=";
        return A
    }
    o(fe, "base64clean");

    function $(A) {
        return A.trim ? A.trim() : A.replace(/^\s+|\s+$/g, "")
    }
    o($, "stringtrim");

    function X(A) {
        return A < 16 ? "0" + A.toString(16) : A.toString(16)
    }
    o(X, "toHex");

    function W(A, v) {
        v = v || 1 / 0;
        for (var y, C = A.length, B = null, se = [], ce = 0; ce < C; ++ce) {
            if (y = A.charCodeAt(ce), y > 55295 && y < 57344) {
                if (!B) {
                    if (y > 56319) {
                        (v -= 3) > -1 && se.push(239, 191, 189);
                        continue
                    } else if (ce + 1 === C) {
                        (v -= 3) > -1 && se.push(239, 191, 189);
                        continue
                    }
                    B = y;
                    continue
                }
                if (y < 56320) {
                    (v -= 3) > -1 && se.push(239, 191, 189), B = y;
                    continue
                }
                y = (B - 55296 << 10 | y - 56320) + 65536
            } else B && (v -= 3) > -1 && se.push(239, 191, 189);
            if (B = null, y < 128) {
                if ((v -= 1) < 0) break;
                se.push(y)
            } else if (y < 2048) {
                if ((v -= 2) < 0) break;
                se.push(y >> 6 | 192, y & 63 | 128)
            } else if (y < 65536) {
                if ((v -= 3) < 0) break;
                se.push(y >> 12 | 224, y >> 6 & 63 | 128, y & 63 | 128)
            } else if (y < 1114112) {
                if ((v -= 4) < 0) break;
                se.push(y >> 18 | 240, y >> 12 & 63 | 128, y >> 6 & 63 | 128, y & 63 | 128)
            } else throw new Error("Invalid code point")
        }
        return se
    }
    o(W, "utf8ToBytes");

    function te(A) {
        for (var v = [], y = 0; y < A.length; ++y) v.push(A.charCodeAt(y) & 255);
        return v
    }
    o(te, "asciiToBytes");

    function _e(A, v) {
        for (var y, C, B, se = [], ce = 0; ce < A.length && !((v -= 2) < 0); ++ce) y = A.charCodeAt(ce), C = y >> 8, B = y % 256, se.push(B), se.push(C);
        return se
    }
    o(_e, "utf16leToBytes");

    function we(A) {
        return e.toByteArray(fe(A))
    }
    o(we, "base64ToBytes");

    function Ie(A, v, y, C) {
        for (var B = 0; B < C && !(B + y >= v.length || B >= A.length); ++B) v[B + y] = A[B];
        return B
    }
    o(Ie, "blitBuffer");

    function Me(A) {
        return A !== A
    }
    o(Me, "isnan")
})(wt);
var hn;
typeof window != "undefined" && window.crypto && (hn = window.crypto);
!hn && typeof window != "undefined" && window.msCrypto && (hn = window.msCrypto);
!hn && typeof global != "undefined" && global.crypto && (hn = global.crypto);
if (!hn && typeof is == "function") try {
    hn = is("crypto")
} catch (r) {}

function nee() {
    if (hn) {
        if (typeof hn.getRandomValues == "function") try {
            return hn.getRandomValues(new Uint32Array(1))[0]
        } catch (r) {}
        if (typeof hn.randomBytes == "function") try {
            return hn.randomBytes(4).readInt32LE()
        } catch (r) {}
    }
    throw new Error("Native crypto module could not be used to get secure random number.")
}
o(nee, "cryptoSecureRandomInt");

function iee(r) {
    for (var e = r.words, t = r.sigBytes, n = [], i = 0; i < t; i++) {
        var s = e[i >>> 2] >>> 24 - i % 4 * 8 & 255;
        n.push((s >>> 4).toString(16)), n.push((s & 15).toString(16))
    }
    return n.join("")
}
o(iee, "hexStringify");
var see = (function() {
    function r(t, n) {
        t = this.words = t || [], n != null ? this.sigBytes = n : this.sigBytes = t.length * 4
    }
    o(r, "WordArray");
    var e = r.prototype;
    return e.random = o(function(n) {
        for (var i = [], s = 0; s < n; s += 4) i.push(nee());
        return new r(i, n)
    }, "random"), e.toString = o(function() {
        return iee(this)
    }, "toString"), r
})();

function Se(r, e) {
    r != null && this.fromString(r, e)
}
o(Se, "BigInteger");

function Dr() {
    return new Se(null)
}
o(Dr, "nbi");
var Ss, oee = 0xdeadbeefcafe,
    BD = (oee & 16777215) == 15715070;

function aee(r, e, t, n, i, s) {
    for (; --s >= 0;) {
        var a = e * this[r++] + t[n] + i;
        i = Math.floor(a / 67108864), t[n++] = a & 67108863
    }
    return i
}
o(aee, "am1");

function uee(r, e, t, n, i, s) {
    for (var a = e & 32767, u = e >> 15; --s >= 0;) {
        var l = this[r] & 32767,
            c = this[r++] >> 15,
            d = u * l + c * a;
        l = a * l + ((d & 32767) << 15) + t[n] + (i & 1073741823), i = (l >>> 30) + (d >>> 15) + u * c + (i >>> 30), t[n++] = l & 1073741823
    }
    return i
}
o(uee, "am2");

function cee(r, e, t, n, i, s) {
    for (var a = e & 16383, u = e >> 14; --s >= 0;) {
        var l = this[r] & 16383,
            c = this[r++] >> 14,
            d = u * l + c * a;
        l = a * l + ((d & 16383) << 14) + t[n] + i, i = (l >> 28) + (d >> 14) + u * c, t[n++] = l & 268435455
    }
    return i
}
o(cee, "am3");
var VD = typeof navigator != "undefined";
VD && BD && navigator.appName == "Microsoft Internet Explorer" ? (Se.prototype.am = uee, Ss = 30) : VD && BD && navigator.appName != "Netscape" ? (Se.prototype.am = aee, Ss = 26) : (Se.prototype.am = cee, Ss = 28);
Se.prototype.DB = Ss;
Se.prototype.DM = (1 << Ss) - 1;
Se.prototype.DV = 1 << Ss;
var Rb = 52;
Se.prototype.FV = Math.pow(2, Rb);
Se.prototype.F1 = Rb - Ss;
Se.prototype.F2 = 2 * Ss - Rb;
var lee = "0123456789abcdefghijklmnopqrstuvwxyz",
    nm = new Array,
    gu, pn;
gu = 48;
for (pn = 0; pn <= 9; ++pn) nm[gu++] = pn;
gu = 97;
for (pn = 10; pn < 36; ++pn) nm[gu++] = pn;
gu = 65;
for (pn = 10; pn < 36; ++pn) nm[gu++] = pn;

function HD(r) {
    return lee.charAt(r)
}
o(HD, "int2char");

function dee(r, e) {
    var t = nm[r.charCodeAt(e)];
    return t == null ? -1 : t
}
o(dee, "intAt");

function fee(r) {
    for (var e = this.t - 1; e >= 0; --e) r[e] = this[e];
    r.t = this.t, r.s = this.s
}
o(fee, "bnpCopyTo");

function hee(r) {
    this.t = 1, this.s = r < 0 ? -1 : 0, r > 0 ? this[0] = r : r < -1 ? this[0] = r + this.DV : this.t = 0
}
o(hee, "bnpFromInt");

function Ob(r) {
    var e = Dr();
    return e.fromInt(r), e
}
o(Ob, "nbv");

function gee(r, e) {
    var t;
    if (e == 16) t = 4;
    else if (e == 8) t = 3;
    else if (e == 2) t = 1;
    else if (e == 32) t = 5;
    else if (e == 4) t = 2;
    else throw new Error("Only radix 2, 4, 8, 16, 32 are supported");
    this.t = 0, this.s = 0;
    for (var n = r.length, i = !1, s = 0; --n >= 0;) {
        var a = dee(r, n);
        if (a < 0) {
            r.charAt(n) == "-" && (i = !0);
            continue
        }
        i = !1, s == 0 ? this[this.t++] = a : s + t > this.DB ? (this[this.t - 1] |= (a & (1 << this.DB - s) - 1) << s, this[this.t++] = a >> this.DB - s) : this[this.t - 1] |= a << s, s += t, s >= this.DB && (s -= this.DB)
    }
    this.clamp(), i && Se.ZERO.subTo(this, this)
}
o(gee, "bnpFromString");

function pee() {
    for (var r = this.s & this.DM; this.t > 0 && this[this.t - 1] == r;) --this.t
}
o(pee, "bnpClamp");

function mee(r) {
    if (this.s < 0) return "-" + this.negate().toString(r);
    var e;
    if (r == 16) e = 4;
    else if (r == 8) e = 3;
    else if (r == 2) e = 1;
    else if (r == 32) e = 5;
    else if (r == 4) e = 2;
    else throw new Error("Only radix 2, 4, 8, 16, 32 are supported");
    var t = (1 << e) - 1,
        n, i = !1,
        s = "",
        a = this.t,
        u = this.DB - a * this.DB % e;
    if (a-- > 0)
        for (u < this.DB && (n = this[a] >> u) > 0 && (i = !0, s = HD(n)); a >= 0;) u < e ? (n = (this[a] & (1 << u) - 1) << e - u, n |= this[--a] >> (u += this.DB - e)) : (n = this[a] >> (u -= e) & t, u <= 0 && (u += this.DB, --a)), n > 0 && (i = !0), i && (s += HD(n));
    return i ? s : "0"
}
o(mee, "bnToString");

function vee() {
    var r = Dr();
    return Se.ZERO.subTo(this, r), r
}
o(vee, "bnNegate");

function yee() {
    return this.s < 0 ? this.negate() : this
}
o(yee, "bnAbs");

function _ee(r) {
    var e = this.s - r.s;
    if (e != 0) return e;
    var t = this.t;
    if (e = t - r.t, e != 0) return this.s < 0 ? -e : e;
    for (; --t >= 0;)
        if ((e = this[t] - r[t]) != 0) return e;
    return 0
}
o(_ee, "bnCompareTo");

function Pb(r) {
    var e = 1,
        t;
    return (t = r >>> 16) != 0 && (r = t, e += 16), (t = r >> 8) != 0 && (r = t, e += 8), (t = r >> 4) != 0 && (r = t, e += 4), (t = r >> 2) != 0 && (r = t, e += 2), (t = r >> 1) != 0 && (r = t, e += 1), e
}
o(Pb, "nbits");

function wee() {
    return this.t <= 0 ? 0 : this.DB * (this.t - 1) + Pb(this[this.t - 1] ^ this.s & this.DM)
}
o(wee, "bnBitLength");

function Tee(r, e) {
    var t;
    for (t = this.t - 1; t >= 0; --t) e[t + r] = this[t];
    for (t = r - 1; t >= 0; --t) e[t] = 0;
    e.t = this.t + r, e.s = this.s
}
o(Tee, "bnpDLShiftTo");

function Eee(r, e) {
    for (var t = r; t < this.t; ++t) e[t - r] = this[t];
    e.t = Math.max(this.t - r, 0), e.s = this.s
}
o(Eee, "bnpDRShiftTo");

function bee(r, e) {
    var t = r % this.DB,
        n = this.DB - t,
        i = (1 << n) - 1,
        s = Math.floor(r / this.DB),
        a = this.s << t & this.DM,
        u;
    for (u = this.t - 1; u >= 0; --u) e[u + s + 1] = this[u] >> n | a, a = (this[u] & i) << t;
    for (u = s - 1; u >= 0; --u) e[u] = 0;
    e[s] = a, e.t = this.t + s + 1, e.s = this.s, e.clamp()
}
o(bee, "bnpLShiftTo");

function See(r, e) {
    e.s = this.s;
    var t = Math.floor(r / this.DB);
    if (t >= this.t) {
        e.t = 0;
        return
    }
    var n = r % this.DB,
        i = this.DB - n,
        s = (1 << n) - 1;
    e[0] = this[t] >> n;
    for (var a = t + 1; a < this.t; ++a) e[a - t - 1] |= (this[a] & s) << i, e[a - t] = this[a] >> n;
    n > 0 && (e[this.t - t - 1] |= (this.s & s) << i), e.t = this.t - t, e.clamp()
}
o(See, "bnpRShiftTo");

function Aee(r, e) {
    for (var t = 0, n = 0, i = Math.min(r.t, this.t); t < i;) n += this[t] - r[t], e[t++] = n & this.DM, n >>= this.DB;
    if (r.t < this.t) {
        for (n -= r.s; t < this.t;) n += this[t], e[t++] = n & this.DM, n >>= this.DB;
        n += this.s
    } else {
        for (n += this.s; t < r.t;) n -= r[t], e[t++] = n & this.DM, n >>= this.DB;
        n -= r.s
    }
    e.s = n < 0 ? -1 : 0, n < -1 ? e[t++] = this.DV + n : n > 0 && (e[t++] = n), e.t = t, e.clamp()
}
o(Aee, "bnpSubTo");

function Iee(r, e) {
    var t = this.abs(),
        n = r.abs(),
        i = t.t;
    for (e.t = i + n.t; --i >= 0;) e[i] = 0;
    for (i = 0; i < n.t; ++i) e[i + t.t] = t.am(0, n[i], e, i, 0, t.t);
    e.s = 0, e.clamp(), this.s != r.s && Se.ZERO.subTo(e, e)
}
o(Iee, "bnpMultiplyTo");

function Cee(r) {
    for (var e = this.abs(), t = r.t = 2 * e.t; --t >= 0;) r[t] = 0;
    for (t = 0; t < e.t - 1; ++t) {
        var n = e.am(t, e[t], r, 2 * t, 0, 1);
        (r[t + e.t] += e.am(t + 1, 2 * e[t], r, 2 * t + 1, n, e.t - t - 1)) >= e.DV && (r[t + e.t] -= e.DV, r[t + e.t + 1] = 1)
    }
    r.t > 0 && (r[r.t - 1] += e.am(t, e[t], r, 2 * t, 0, 1)), r.s = 0, r.clamp()
}
o(Cee, "bnpSquareTo");

function Ree(r, e, t) {
    var n = r.abs();
    if (!(n.t <= 0)) {
        var i = this.abs();
        if (i.t < n.t) {
            e != null && e.fromInt(0), t != null && this.copyTo(t);
            return
        }
        t == null && (t = Dr());
        var s = Dr(),
            a = this.s,
            u = r.s,
            l = this.DB - Pb(n[n.t - 1]);
        l > 0 ? (n.lShiftTo(l, s), i.lShiftTo(l, t)) : (n.copyTo(s), i.copyTo(t));
        var c = s.t,
            d = s[c - 1];
        if (d != 0) {
            var f = d * (1 << this.F1) + (c > 1 ? s[c - 2] >> this.F2 : 0),
                h = this.FV / f,
                g = (1 << this.F1) / f,
                p = 1 << this.F2,
                m = t.t,
                w = m - c,
                T = e == null ? Dr() : e;
            for (s.dlShiftTo(w, T), t.compareTo(T) >= 0 && (t[t.t++] = 1, t.subTo(T, t)), Se.ONE.dlShiftTo(c, T), T.subTo(s, s); s.t < c;) s[s.t++] = 0;
            for (; --w >= 0;) {
                var E = t[--m] == d ? this.DM : Math.floor(t[m] * h + (t[m - 1] + p) * g);
                if ((t[m] += s.am(0, E, t, w, 0, c)) < E)
                    for (s.dlShiftTo(w, T), t.subTo(T, t); t[m] < --E;) t.subTo(T, t)
            }
            e != null && (t.drShiftTo(c, e), a != u && Se.ZERO.subTo(e, e)), t.t = c, t.clamp(), l > 0 && t.rShiftTo(l, t), a < 0 && Se.ZERO.subTo(t, t)
        }
    }
}
o(Ree, "bnpDivRemTo");

function Oee(r) {
    var e = Dr();
    return this.abs().divRemTo(r, null, e), this.s < 0 && e.compareTo(Se.ZERO) > 0 && r.subTo(e, e), e
}
o(Oee, "bnMod");

function Pee() {
    if (this.t < 1) return 0;
    var r = this[0];
    if ((r & 1) == 0) return 0;
    var e = r & 3;
    return e = e * (2 - (r & 15) * e) & 15, e = e * (2 - (r & 255) * e) & 255, e = e * (2 - ((r & 65535) * e & 65535)) & 65535, e = e * (2 - r * e % this.DV) % this.DV, e > 0 ? this.DV - e : -e
}
o(Pee, "bnpInvDigit");

function Nee(r) {
    return this.compareTo(r) == 0
}
o(Nee, "bnEquals");

function Dee(r, e) {
    for (var t = 0, n = 0, i = Math.min(r.t, this.t); t < i;) n += this[t] + r[t], e[t++] = n & this.DM, n >>= this.DB;
    if (r.t < this.t) {
        for (n += r.s; t < this.t;) n += this[t], e[t++] = n & this.DM, n >>= this.DB;
        n += this.s
    } else {
        for (n += this.s; t < r.t;) n += r[t], e[t++] = n & this.DM, n >>= this.DB;
        n += r.s
    }
    e.s = n < 0 ? -1 : 0, n > 0 ? e[t++] = n : n < -1 && (e[t++] = this.DV + n), e.t = t, e.clamp()
}
o(Dee, "bnpAddTo");

function Lee(r) {
    var e = Dr();
    return this.addTo(r, e), e
}
o(Lee, "bnAdd");

function xee(r) {
    var e = Dr();
    return this.subTo(r, e), e
}
o(xee, "bnSubtract");

function Uee(r) {
    var e = Dr();
    return this.multiplyTo(r, e), e
}
o(Uee, "bnMultiply");

function Mee(r) {
    var e = Dr();
    return this.divRemTo(r, e, null), e
}
o(Mee, "bnDivide");

function pu(r) {
    this.m = r, this.mp = r.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << r.DB - 15) - 1, this.mt2 = 2 * r.t
}
o(pu, "Montgomery");

function kee(r) {
    var e = Dr();
    return r.abs().dlShiftTo(this.m.t, e), e.divRemTo(this.m, null, e), r.s < 0 && e.compareTo(Se.ZERO) > 0 && this.m.subTo(e, e), e
}
o(kee, "montConvert");

function Fee(r) {
    var e = Dr();
    return r.copyTo(e), this.reduce(e), e
}
o(Fee, "montRevert");

function $ee(r) {
    for (; r.t <= this.mt2;) r[r.t++] = 0;
    for (var e = 0; e < this.m.t; ++e) {
        var t = r[e] & 32767,
            n = t * this.mpl + ((t * this.mph + (r[e] >> 15) * this.mpl & this.um) << 15) & r.DM;
        for (t = e + this.m.t, r[t] += this.m.am(0, n, r, e, 0, this.m.t); r[t] >= r.DV;) r[t] -= r.DV, r[++t]++
    }
    r.clamp(), r.drShiftTo(this.m.t, r), r.compareTo(this.m) >= 0 && r.subTo(this.m, r)
}
o($ee, "montReduce");

function Bee(r, e) {
    r.squareTo(e), this.reduce(e)
}
o(Bee, "montSqrTo");

function Vee(r, e, t) {
    r.multiplyTo(e, t), this.reduce(t)
}
o(Vee, "montMulTo");
pu.prototype.convert = kee;
pu.prototype.revert = Fee;
pu.prototype.reduce = $ee;
pu.prototype.mulTo = Vee;
pu.prototype.sqrTo = Bee;

function Hee(r, e, t) {
    var n = r.bitLength(),
        i, s = Ob(1),
        a = new pu(e);
    if (n <= 0) return s;
    n < 18 ? i = 1 : n < 48 ? i = 3 : n < 144 ? i = 4 : n < 768 ? i = 5 : i = 6;
    var u = new Array,
        l = 3,
        c = i - 1,
        d = (1 << i) - 1;
    if (u[1] = a.convert(this), i > 1) {
        var f = Dr();
        for (a.sqrTo(u[1], f); l <= d;) u[l] = Dr(), a.mulTo(f, u[l - 2], u[l]), l += 2
    }
    var h = r.t - 1,
        g, p = !0,
        m = Dr(),
        w;
    for (n = Pb(r[h]) - 1; h >= 0;) {
        for (n >= c ? g = r[h] >> n - c & d : (g = (r[h] & (1 << n + 1) - 1) << c - n, h > 0 && (g |= r[h - 1] >> this.DB + n - c)), l = i;
            (g & 1) == 0;) g >>= 1, --l;
        if ((n -= l) < 0 && (n += this.DB, --h), p) u[g].copyTo(s), p = !1;
        else {
            for (; l > 1;) a.sqrTo(s, m), a.sqrTo(m, s), l -= 2;
            l > 0 ? a.sqrTo(s, m) : (w = s, s = m, m = w), a.mulTo(m, u[g], s)
        }
        for (; h >= 0 && (r[h] & 1 << n) == 0;) a.sqrTo(s, m), w = s, s = m, m = w, --n < 0 && (n = this.DB - 1, --h)
    }
    var T = a.revert(s);
    return t(null, T), T
}
o(Hee, "bnModPow");
Se.prototype.copyTo = fee;
Se.prototype.fromInt = hee;
Se.prototype.fromString = gee;
Se.prototype.clamp = pee;
Se.prototype.dlShiftTo = Tee;
Se.prototype.drShiftTo = Eee;
Se.prototype.lShiftTo = bee;
Se.prototype.rShiftTo = See;
Se.prototype.subTo = Aee;
Se.prototype.multiplyTo = Iee;
Se.prototype.squareTo = Cee;
Se.prototype.divRemTo = Ree;
Se.prototype.invDigit = Pee;
Se.prototype.addTo = Dee;
Se.prototype.toString = mee;
Se.prototype.negate = vee;
Se.prototype.abs = yee;
Se.prototype.compareTo = _ee;
Se.prototype.bitLength = wee;
Se.prototype.mod = Oee;
Se.prototype.equals = Nee;
Se.prototype.add = Lee;
Se.prototype.subtract = xee;
Se.prototype.multiply = Uee;
Se.prototype.divide = Mee;
Se.prototype.modPow = Hee;
Se.ZERO = Ob(0);
Se.ONE = Ob(1);

function UE(r) {
    return wt.Buffer.from(new see().random(r).toString(), "hex")
}
o(UE, "randomBytes");
var jee = /^[89a-f]/i,
    Wee = "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF",
    Gee = "userAttributes.",
    Xa = (function() {
        function r(t) {
            this.N = new Se(Wee, 16), this.g = new Se("2", 16), this.k = new Se(this.hexHash("" + this.padHex(this.N) + this.padHex(this.g)), 16), this.smallAValue = this.generateRandomSmallA(), this.getLargeAValue(function() {}), this.infoBits = wt.Buffer.from("Caldera Derived Key", "utf8"), this.poolName = t
        }
        o(r, "AuthenticationHelper");
        var e = r.prototype;
        return e.getSmallAValue = o(function() {
            return this.smallAValue
        }, "getSmallAValue"), e.getLargeAValue = o(function(n) {
            var i = this;
            this.largeAValue ? n(null, this.largeAValue) : this.calculateA(this.smallAValue, function(s, a) {
                s && n(s, null), i.largeAValue = a, n(null, i.largeAValue)
            })
        }, "getLargeAValue"), e.generateRandomSmallA = o(function() {
            var n = UE(128).toString("hex"),
                i = new Se(n, 16);
            return i
        }, "generateRandomSmallA"), e.generateRandomString = o(function() {
            return UE(40).toString("base64")
        }, "generateRandomString"), e.getRandomPassword = o(function() {
            return this.randomPassword
        }, "getRandomPassword"), e.getSaltDevices = o(function() {
            return this.SaltToHashDevices
        }, "getSaltDevices"), e.getVerifierDevices = o(function() {
            return this.verifierDevices
        }, "getVerifierDevices"), e.generateHashDevice = o(function(n, i, s) {
            var a = this;
            this.randomPassword = this.generateRandomString();
            var u = "" + n + i + ":" + this.randomPassword,
                l = this.hash(u),
                c = UE(16).toString("hex");
            this.SaltToHashDevices = this.padHex(new Se(c, 16)), this.g.modPow(new Se(this.hexHash(this.SaltToHashDevices + l), 16), this.N, function(d, f) {
                d && s(d, null), a.verifierDevices = a.padHex(f), s(null, null)
            })
        }, "generateHashDevice"), e.calculateA = o(function(n, i) {
            var s = this;
            this.g.modPow(n, this.N, function(a, u) {
                a && i(a, null), u.mod(s.N).equals(Se.ZERO) && i(new Error("Illegal paramater. A mod N cannot be 0."), null), i(null, u)
            })
        }, "calculateA"), e.calculateU = o(function(n, i) {
            this.UHexHash = this.hexHash(this.padHex(n) + this.padHex(i));
            var s = new Se(this.UHexHash, 16);
            return s
        }, "calculateU"), e.hash = o(function(n) {
            var i = new Co.Sha256;
            i.update(n);
            var s = i.digestSync(),
                a = wt.Buffer.from(s).toString("hex");
            return new Array(64 - a.length).join("0") + a
        }, "hash"), e.hexHash = o(function(n) {
            return this.hash(wt.Buffer.from(n, "hex"))
        }, "hexHash"), e.computehkdf = o(function(n, i) {
            var s = wt.Buffer.concat([this.infoBits, wt.Buffer.from("", "utf8")]),
                a = new Co.Sha256(i);
            a.update(n);
            var u = a.digestSync(),
                l = new Co.Sha256(u);
            l.update(s);
            var c = l.digestSync(),
                d = c,
                f = d.slice(0, 16);
            return f
        }, "computehkdf"), e.getPasswordAuthenticationKey = o(function(n, i, s, a, u) {
            var l = this;
            if (s.mod(this.N).equals(Se.ZERO)) throw new Error("B cannot be zero.");
            if (this.UValue = this.calculateU(this.largeAValue, s), this.UValue.equals(Se.ZERO)) throw new Error("U cannot be zero.");
            var c = "" + this.poolName + n + ":" + i,
                d = this.hash(c),
                f = new Se(this.hexHash(this.padHex(a) + d), 16);
            this.calculateS(f, s, function(h, g) {
                h && u(h, null);
                var p = l.computehkdf(wt.Buffer.from(l.padHex(g), "hex"), wt.Buffer.from(l.padHex(l.UValue), "hex"));
                u(null, p)
            })
        }, "getPasswordAuthenticationKey"), e.calculateS = o(function(n, i, s) {
            var a = this;
            this.g.modPow(n, this.N, function(u, l) {
                u && s(u, null);
                var c = i.subtract(a.k.multiply(l));
                c.modPow(a.smallAValue.add(a.UValue.multiply(n)), a.N, function(d, f) {
                    d && s(d, null), s(null, f.mod(a.N))
                })
            })
        }, "calculateS"), e.getNewPasswordRequiredChallengeUserAttributePrefix = o(function() {
            return Gee
        }, "getNewPasswordRequiredChallengeUserAttributePrefix"), e.padHex = o(function(n) {
            if (!(n instanceof Se)) throw new Error("Not a BigInteger");
            var i = n.compareTo(Se.ZERO) < 0,
                s = n.abs().toString(16);
            if (s = s.length % 2 !== 0 ? "0" + s : s, s = jee.test(s) ? "00" + s : s, i) {
                var a = s.split("").map(function(l) {
                        var c = ~parseInt(l, 16) & 15;
                        return "0123456789ABCDEF".charAt(c)
                    }).join(""),
                    u = new Se(a, 16).add(Se.ONE);
                s = u.toString(16), s.toUpperCase().startsWith("FF8") && (s = s.substring(2))
            }
            return s
        }, "padHex"), r
    })();
var XL = (function() {
    function r(t) {
        this.jwtToken = t || "", this.payload = this.decodePayload()
    }
    o(r, "CognitoJwtToken");
    var e = r.prototype;
    return e.getJwtToken = o(function() {
        return this.jwtToken
    }, "getJwtToken"), e.getExpiration = o(function() {
        return this.payload.exp
    }, "getExpiration"), e.getIssuedAt = o(function() {
        return this.payload.iat
    }, "getIssuedAt"), e.decodePayload = o(function() {
        var n = this.jwtToken.split(".")[1];
        try {
            return JSON.parse(wt.Buffer.from(n, "base64").toString("utf8"))
        } catch (i) {
            return {}
        }
    }, "decodePayload"), r
})();

function zee(r, e) {
    r.prototype = Object.create(e.prototype), r.prototype.constructor = r, GE(r, e)
}
o(zee, "_inheritsLoose$2");

function GE(r, e) {
    return GE = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, n) {
        return t.__proto__ = n, t
    }, GE(r, e)
}
o(GE, "_setPrototypeOf$2");
var zE = (function(r) {
    function e(t) {
        var n = t === void 0 ? {} : t,
            i = n.AccessToken;
        return r.call(this, i || "") || this
    }
    return o(e, "CognitoAccessToken"), zee(e, r), e
})(XL);

function qee(r, e) {
    r.prototype = Object.create(e.prototype), r.prototype.constructor = r, qE(r, e)
}
o(qee, "_inheritsLoose$1");

function qE(r, e) {
    return qE = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, n) {
        return t.__proto__ = n, t
    }, qE(r, e)
}
o(qE, "_setPrototypeOf$1");
var KE = (function(r) {
    function e(t) {
        var n = t === void 0 ? {} : t,
            i = n.IdToken;
        return r.call(this, i || "") || this
    }
    return o(e, "CognitoIdToken"), qee(e, r), e
})(XL);
var YE = (function() {
        function r(t) {
            var n = t === void 0 ? {} : t,
                i = n.RefreshToken;
            this.token = i || ""
        }
        o(r, "CognitoRefreshToken");
        var e = r.prototype;
        return e.getToken = o(function() {
            return this.token
        }, "getToken"), r
    })(),
    Kee = "5.0.4";
var Yee = "aws-amplify/" + Kee,
    JL = {
        userAgent: Yee,
        isReactNative: typeof navigator != "undefined" && navigator.product === "ReactNative"
    },
    Xee = o(function() {
        return JL.userAgent
    }, "getUserAgent");
var XE = (function() {
    function r(t) {
        var n = t === void 0 ? {} : t,
            i = n.IdToken,
            s = n.RefreshToken,
            a = n.AccessToken,
            u = n.ClockDrift;
        if (a == null || i == null) throw new Error("Id token and Access Token must be present.");
        this.idToken = i, this.refreshToken = s, this.accessToken = a, this.clockDrift = u === void 0 ? this.calculateClockDrift() : u
    }
    o(r, "CognitoUserSession");
    var e = r.prototype;
    return e.getIdToken = o(function() {
        return this.idToken
    }, "getIdToken"), e.getRefreshToken = o(function() {
        return this.refreshToken
    }, "getRefreshToken"), e.getAccessToken = o(function() {
        return this.accessToken
    }, "getAccessToken"), e.getClockDrift = o(function() {
        return this.clockDrift
    }, "getClockDrift"), e.calculateClockDrift = o(function() {
        var n = Math.floor(new Date / 1e3),
            i = Math.min(this.accessToken.getIssuedAt(), this.idToken.getIssuedAt());
        return n - i
    }, "calculateClockDrift"), e.isValid = o(function() {
        var n = Math.floor(new Date / 1e3),
            i = n - this.clockDrift;
        return i < this.accessToken.getExpiration() && i < this.idToken.getExpiration()
    }, "isValid"), r
})();
var Jee = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    Zee = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    jD = (function() {
        function r() {}
        o(r, "DateHelper");
        var e = r.prototype;
        return e.getNowString = o(function() {
            var n = new Date,
                i = Zee[n.getUTCDay()],
                s = Jee[n.getUTCMonth()],
                a = n.getUTCDate(),
                u = n.getUTCHours();
            u < 10 && (u = "0" + u);
            var l = n.getUTCMinutes();
            l < 10 && (l = "0" + l);
            var c = n.getUTCSeconds();
            c < 10 && (c = "0" + c);
            var d = n.getUTCFullYear(),
                f = i + " " + s + " " + a + " " + u + ":" + l + ":" + c + " UTC " + d;
            return f
        }, "getNowString"), r
    })();
var Za = (function() {
    function r(t) {
        var n = t === void 0 ? {} : t,
            i = n.Name,
            s = n.Value;
        this.Name = i || "", this.Value = s || ""
    }
    o(r, "CognitoUserAttribute");
    var e = r.prototype;
    return e.getValue = o(function() {
        return this.Value
    }, "getValue"), e.setValue = o(function(n) {
        return this.Value = n, this
    }, "setValue"), e.getName = o(function() {
        return this.Name
    }, "getName"), e.setName = o(function(n) {
        return this.Name = n, this
    }, "setName"), e.toString = o(function() {
        return JSON.stringify(this)
    }, "toString"), e.toJSON = o(function() {
        return {
            Name: this.Name,
            Value: this.Value
        }
    }, "toJSON"), r
})();
var To = {},
    Qee = (function() {
        function r() {}
        return o(r, "MemoryStorage"), r.setItem = o(function(t, n) {
            return To[t] = n, To[t]
        }, "setItem"), r.getItem = o(function(t) {
            return Object.prototype.hasOwnProperty.call(To, t) ? To[t] : void 0
        }, "getItem"), r.removeItem = o(function(t) {
            return delete To[t]
        }, "removeItem"), r.clear = o(function() {
            return To = {}, To
        }, "clear"), r
    })(),
    ZL = (function() {
        function r() {
            try {
                this.storageWindow = window.localStorage, this.storageWindow.setItem("aws.cognito.test-ls", 1), this.storageWindow.removeItem("aws.cognito.test-ls")
            } catch (t) {
                this.storageWindow = Qee
            }
        }
        o(r, "StorageHelper");
        var e = r.prototype;
        return e.getStorage = o(function() {
            return this.storageWindow
        }, "getStorage"), r
    })();
var ete = typeof navigator != "undefined",
    WD = ete ? JL.isReactNative ? "react-native" : navigator.userAgent : "nodejs",
    JE = (function() {
        function r(t) {
            if (t == null || t.Username == null || t.Pool == null) throw new Error("Username and Pool information are required.");
            this.username = t.Username || "", this.pool = t.Pool, this.Session = null, this.client = t.Pool.client, this.signInUserSession = null, this.authenticationFlowType = "USER_SRP_AUTH", this.storage = t.Storage || new ZL().getStorage(), this.keyPrefix = "CognitoIdentityServiceProvider." + this.pool.getClientId(), this.userDataKey = this.keyPrefix + "." + this.username + ".userData"
        }
        o(r, "CognitoUser");
        var e = r.prototype;
        return e.setSignInUserSession = o(function(n) {
            this.clearCachedUserData(), this.signInUserSession = n, this.cacheTokens()
        }, "setSignInUserSession"), e.getSignInUserSession = o(function() {
            return this.signInUserSession
        }, "getSignInUserSession"), e.getUsername = o(function() {
            return this.username
        }, "getUsername"), e.getAuthenticationFlowType = o(function() {
            return this.authenticationFlowType
        }, "getAuthenticationFlowType"), e.setAuthenticationFlowType = o(function(n) {
            this.authenticationFlowType = n
        }, "setAuthenticationFlowType"), e.initiateAuth = o(function(n, i) {
            var s = this,
                a = n.getAuthParameters();
            a.USERNAME = this.username;
            var u = Object.keys(n.getValidationData()).length !== 0 ? n.getValidationData() : n.getClientMetadata(),
                l = {
                    AuthFlow: "CUSTOM_AUTH",
                    ClientId: this.pool.getClientId(),
                    AuthParameters: a,
                    ClientMetadata: u
                };
            this.getUserContextData() && (l.UserContextData = this.getUserContextData()), this.client.request("InitiateAuth", l, function(c, d) {
                if (c) return i.onFailure(c);
                var f = d.ChallengeName,
                    h = d.ChallengeParameters;
                return f === "CUSTOM_CHALLENGE" ? (s.Session = d.Session, i.customChallenge(h)) : (s.signInUserSession = s.getCognitoUserSession(d.AuthenticationResult), s.cacheTokens(), i.onSuccess(s.signInUserSession))
            })
        }, "initiateAuth"), e.authenticateUser = o(function(n, i) {
            return this.authenticationFlowType === "USER_PASSWORD_AUTH" ? this.authenticateUserPlainUsernamePassword(n, i) : this.authenticationFlowType === "USER_SRP_AUTH" || this.authenticationFlowType === "CUSTOM_AUTH" ? this.authenticateUserDefaultAuth(n, i) : i.onFailure(new Error("Authentication flow type is invalid."))
        }, "authenticateUser"), e.authenticateUserDefaultAuth = o(function(n, i) {
            var s = this,
                a = new Xa(this.pool.getUserPoolName()),
                u = new jD,
                l, c, d = {};
            this.deviceKey != null && (d.DEVICE_KEY = this.deviceKey), d.USERNAME = this.username, a.getLargeAValue(function(f, h) {
                f && i.onFailure(f), d.SRP_A = h.toString(16), s.authenticationFlowType === "CUSTOM_AUTH" && (d.CHALLENGE_NAME = "SRP_A");
                var g = Object.keys(n.getValidationData()).length !== 0 ? n.getValidationData() : n.getClientMetadata(),
                    p = {
                        AuthFlow: s.authenticationFlowType,
                        ClientId: s.pool.getClientId(),
                        AuthParameters: d,
                        ClientMetadata: g
                    };
                s.getUserContextData(s.username) && (p.UserContextData = s.getUserContextData(s.username)), s.client.request("InitiateAuth", p, function(m, w) {
                    if (m) return i.onFailure(m);
                    var T = w.ChallengeParameters;
                    s.username = T.USER_ID_FOR_SRP, s.userDataKey = s.keyPrefix + "." + s.username + ".userData", l = new Se(T.SRP_B, 16), c = new Se(T.SALT, 16), s.getCachedDeviceKeyAndPassword(), a.getPasswordAuthenticationKey(s.username, n.getPassword(), l, c, function(E, b) {
                        E && i.onFailure(E);
                        var R = u.getNowString(),
                            L = wt.Buffer.concat([wt.Buffer.from(s.pool.getUserPoolName(), "utf8"), wt.Buffer.from(s.username, "utf8"), wt.Buffer.from(T.SECRET_BLOCK, "base64"), wt.Buffer.from(R, "utf8")]),
                            V = new Co.Sha256(b);
                        V.update(L);
                        var z = V.digestSync(),
                            j = wt.Buffer.from(z).toString("base64"),
                            Y = {};
                        Y.USERNAME = s.username, Y.PASSWORD_CLAIM_SECRET_BLOCK = T.SECRET_BLOCK, Y.TIMESTAMP = R, Y.PASSWORD_CLAIM_SIGNATURE = j, s.deviceKey != null && (Y.DEVICE_KEY = s.deviceKey);
                        var q = o(function(oe, S) {
                                return s.client.request("RespondToAuthChallenge", oe, function(K, M) {
                                    return K && K.code === "ResourceNotFoundException" && K.message.toLowerCase().indexOf("device") !== -1 ? (Y.DEVICE_KEY = null, s.deviceKey = null, s.randomPassword = null, s.deviceGroupKey = null, s.clearCachedDeviceKeyAndPassword(), q(oe, S)) : S(K, M)
                                })
                            }, "respondToAuthChallenge"),
                            P = {
                                ChallengeName: "PASSWORD_VERIFIER",
                                ClientId: s.pool.getClientId(),
                                ChallengeResponses: Y,
                                Session: w.Session,
                                ClientMetadata: g
                            };
                        s.getUserContextData() && (P.UserContextData = s.getUserContextData()), q(P, function(Z, oe) {
                            return Z ? i.onFailure(Z) : s.authenticateUserInternal(oe, a, i)
                        })
                    })
                })
            })
        }, "authenticateUserDefaultAuth"), e.authenticateUserPlainUsernamePassword = o(function(n, i) {
            var s = this,
                a = {};
            if (a.USERNAME = this.username, a.PASSWORD = n.getPassword(), !a.PASSWORD) {
                i.onFailure(new Error("PASSWORD parameter is required"));
                return
            }
            var u = new Xa(this.pool.getUserPoolName());
            this.getCachedDeviceKeyAndPassword(), this.deviceKey != null && (a.DEVICE_KEY = this.deviceKey);
            var l = Object.keys(n.getValidationData()).length !== 0 ? n.getValidationData() : n.getClientMetadata(),
                c = {
                    AuthFlow: "USER_PASSWORD_AUTH",
                    ClientId: this.pool.getClientId(),
                    AuthParameters: a,
                    ClientMetadata: l
                };
            this.getUserContextData(this.username) && (c.UserContextData = this.getUserContextData(this.username)), this.client.request("InitiateAuth", c, function(d, f) {
                return d ? i.onFailure(d) : s.authenticateUserInternal(f, u, i)
            })
        }, "authenticateUserPlainUsernamePassword"), e.authenticateUserInternal = o(function(n, i, s) {
            var a = this,
                u = n.ChallengeName,
                l = n.ChallengeParameters;
            if (u === "SMS_MFA") return this.Session = n.Session, s.mfaRequired(u, l);
            if (u === "SELECT_MFA_TYPE") return this.Session = n.Session, s.selectMFAType(u, l);
            if (u === "MFA_SETUP") return this.Session = n.Session, s.mfaSetup(u, l);
            if (u === "SOFTWARE_TOKEN_MFA") return this.Session = n.Session, s.totpRequired(u, l);
            if (u === "CUSTOM_CHALLENGE") return this.Session = n.Session, s.customChallenge(l);
            if (u === "NEW_PASSWORD_REQUIRED") {
                this.Session = n.Session;
                var c = null,
                    d = null,
                    f = [],
                    h = i.getNewPasswordRequiredChallengeUserAttributePrefix();
                if (l && (c = JSON.parse(n.ChallengeParameters.userAttributes), d = JSON.parse(n.ChallengeParameters.requiredAttributes)), d)
                    for (var g = 0; g < d.length; g++) f[g] = d[g].substr(h.length);
                return s.newPasswordRequired(c, f)
            }
            if (u === "DEVICE_SRP_AUTH") {
                this.Session = n.Session, this.getDeviceResponse(s);
                return
            }
            this.signInUserSession = this.getCognitoUserSession(n.AuthenticationResult), this.challengeName = u, this.cacheTokens();
            var p = n.AuthenticationResult.NewDeviceMetadata;
            if (p == null) return s.onSuccess(this.signInUserSession);
            i.generateHashDevice(n.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, n.AuthenticationResult.NewDeviceMetadata.DeviceKey, function(m) {
                if (m) return s.onFailure(m);
                var w = {
                    Salt: wt.Buffer.from(i.getSaltDevices(), "hex").toString("base64"),
                    PasswordVerifier: wt.Buffer.from(i.getVerifierDevices(), "hex").toString("base64")
                };
                a.verifierDevices = w.PasswordVerifier, a.deviceGroupKey = p.DeviceGroupKey, a.randomPassword = i.getRandomPassword(), a.client.request("ConfirmDevice", {
                    DeviceKey: p.DeviceKey,
                    AccessToken: a.signInUserSession.getAccessToken().getJwtToken(),
                    DeviceSecretVerifierConfig: w,
                    DeviceName: WD
                }, function(T, E) {
                    return T ? s.onFailure(T) : (a.deviceKey = n.AuthenticationResult.NewDeviceMetadata.DeviceKey, a.cacheDeviceKeyAndPassword(), E.UserConfirmationNecessary === !0 ? s.onSuccess(a.signInUserSession, E.UserConfirmationNecessary) : s.onSuccess(a.signInUserSession))
                })
            })
        }, "authenticateUserInternal"), e.completeNewPasswordChallenge = o(function(n, i, s, a) {
            var u = this;
            if (!n) return s.onFailure(new Error("New password is required."));
            var l = new Xa(this.pool.getUserPoolName()),
                c = l.getNewPasswordRequiredChallengeUserAttributePrefix(),
                d = {};
            i && Object.keys(i).forEach(function(h) {
                d[c + h] = i[h]
            }), d.NEW_PASSWORD = n, d.USERNAME = this.username;
            var f = {
                ChallengeName: "NEW_PASSWORD_REQUIRED",
                ClientId: this.pool.getClientId(),
                ChallengeResponses: d,
                Session: this.Session,
                ClientMetadata: a
            };
            this.getUserContextData() && (f.UserContextData = this.getUserContextData()), this.client.request("RespondToAuthChallenge", f, function(h, g) {
                return h ? s.onFailure(h) : u.authenticateUserInternal(g, l, s)
            })
        }, "completeNewPasswordChallenge"), e.getDeviceResponse = o(function(n, i) {
            var s = this,
                a = new Xa(this.deviceGroupKey),
                u = new jD,
                l = {};
            l.USERNAME = this.username, l.DEVICE_KEY = this.deviceKey, a.getLargeAValue(function(c, d) {
                c && n.onFailure(c), l.SRP_A = d.toString(16);
                var f = {
                    ChallengeName: "DEVICE_SRP_AUTH",
                    ClientId: s.pool.getClientId(),
                    ChallengeResponses: l,
                    ClientMetadata: i,
                    Session: s.Session
                };
                s.getUserContextData() && (f.UserContextData = s.getUserContextData()), s.client.request("RespondToAuthChallenge", f, function(h, g) {
                    if (h) return n.onFailure(h);
                    var p = g.ChallengeParameters,
                        m = new Se(p.SRP_B, 16),
                        w = new Se(p.SALT, 16);
                    a.getPasswordAuthenticationKey(s.deviceKey, s.randomPassword, m, w, function(T, E) {
                        if (T) return n.onFailure(T);
                        var b = u.getNowString(),
                            R = wt.Buffer.concat([wt.Buffer.from(s.deviceGroupKey, "utf8"), wt.Buffer.from(s.deviceKey, "utf8"), wt.Buffer.from(p.SECRET_BLOCK, "base64"), wt.Buffer.from(b, "utf8")]),
                            L = new Co.Sha256(E);
                        L.update(R);
                        var V = L.digestSync(),
                            z = wt.Buffer.from(V).toString("base64"),
                            j = {};
                        j.USERNAME = s.username, j.PASSWORD_CLAIM_SECRET_BLOCK = p.SECRET_BLOCK, j.TIMESTAMP = b, j.PASSWORD_CLAIM_SIGNATURE = z, j.DEVICE_KEY = s.deviceKey;
                        var Y = {
                            ChallengeName: "DEVICE_PASSWORD_VERIFIER",
                            ClientId: s.pool.getClientId(),
                            ChallengeResponses: j,
                            Session: g.Session
                        };
                        s.getUserContextData() && (Y.UserContextData = s.getUserContextData()), s.client.request("RespondToAuthChallenge", Y, function(q, P) {
                            return q ? n.onFailure(q) : (s.signInUserSession = s.getCognitoUserSession(P.AuthenticationResult), s.cacheTokens(), n.onSuccess(s.signInUserSession))
                        })
                    })
                })
            })
        }, "getDeviceResponse"), e.confirmRegistration = o(function(n, i, s, a) {
            var u = {
                ClientId: this.pool.getClientId(),
                ConfirmationCode: n,
                Username: this.username,
                ForceAliasCreation: i,
                ClientMetadata: a
            };
            this.getUserContextData() && (u.UserContextData = this.getUserContextData()), this.client.request("ConfirmSignUp", u, function(l) {
                return l ? s(l, null) : s(null, "SUCCESS")
            })
        }, "confirmRegistration"), e.sendCustomChallengeAnswer = o(function(n, i, s) {
            var a = this,
                u = {};
            u.USERNAME = this.username, u.ANSWER = n;
            var l = new Xa(this.pool.getUserPoolName());
            this.getCachedDeviceKeyAndPassword(), this.deviceKey != null && (u.DEVICE_KEY = this.deviceKey);
            var c = {
                ChallengeName: "CUSTOM_CHALLENGE",
                ChallengeResponses: u,
                ClientId: this.pool.getClientId(),
                Session: this.Session,
                ClientMetadata: s
            };
            this.getUserContextData() && (c.UserContextData = this.getUserContextData()), this.client.request("RespondToAuthChallenge", c, function(d, f) {
                return d ? i.onFailure(d) : a.authenticateUserInternal(f, l, i)
            })
        }, "sendCustomChallengeAnswer"), e.sendMFACode = o(function(n, i, s, a) {
            var u = this,
                l = {};
            l.USERNAME = this.username, l.SMS_MFA_CODE = n;
            var c = s || "SMS_MFA";
            c === "SOFTWARE_TOKEN_MFA" && (l.SOFTWARE_TOKEN_MFA_CODE = n), this.deviceKey != null && (l.DEVICE_KEY = this.deviceKey);
            var d = {
                ChallengeName: c,
                ChallengeResponses: l,
                ClientId: this.pool.getClientId(),
                Session: this.Session,
                ClientMetadata: a
            };
            this.getUserContextData() && (d.UserContextData = this.getUserContextData()), this.client.request("RespondToAuthChallenge", d, function(f, h) {
                if (f) return i.onFailure(f);
                var g = h.ChallengeName;
                if (g === "DEVICE_SRP_AUTH") {
                    u.getDeviceResponse(i);
                    return
                }
                if (u.signInUserSession = u.getCognitoUserSession(h.AuthenticationResult), u.cacheTokens(), h.AuthenticationResult.NewDeviceMetadata == null) return i.onSuccess(u.signInUserSession);
                var p = new Xa(u.pool.getUserPoolName());
                p.generateHashDevice(h.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, h.AuthenticationResult.NewDeviceMetadata.DeviceKey, function(m) {
                    if (m) return i.onFailure(m);
                    var w = {
                        Salt: wt.Buffer.from(p.getSaltDevices(), "hex").toString("base64"),
                        PasswordVerifier: wt.Buffer.from(p.getVerifierDevices(), "hex").toString("base64")
                    };
                    u.verifierDevices = w.PasswordVerifier, u.deviceGroupKey = h.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, u.randomPassword = p.getRandomPassword(), u.client.request("ConfirmDevice", {
                        DeviceKey: h.AuthenticationResult.NewDeviceMetadata.DeviceKey,
                        AccessToken: u.signInUserSession.getAccessToken().getJwtToken(),
                        DeviceSecretVerifierConfig: w,
                        DeviceName: WD
                    }, function(T, E) {
                        return T ? i.onFailure(T) : (u.deviceKey = h.AuthenticationResult.NewDeviceMetadata.DeviceKey, u.cacheDeviceKeyAndPassword(), E.UserConfirmationNecessary === !0 ? i.onSuccess(u.signInUserSession, E.UserConfirmationNecessary) : i.onSuccess(u.signInUserSession))
                    })
                })
            })
        }, "sendMFACode"), e.changePassword = o(function(n, i, s, a) {
            if (!(this.signInUserSession != null && this.signInUserSession.isValid())) return s(new Error("User is not authenticated"), null);
            this.client.request("ChangePassword", {
                PreviousPassword: n,
                ProposedPassword: i,
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
                ClientMetadata: a
            }, function(u) {
                return u ? s(u, null) : s(null, "SUCCESS")
            })
        }, "changePassword"), e.enableMFA = o(function(n) {
            if (this.signInUserSession == null || !this.signInUserSession.isValid()) return n(new Error("User is not authenticated"), null);
            var i = [],
                s = {
                    DeliveryMedium: "SMS",
                    AttributeName: "phone_number"
                };
            i.push(s), this.client.request("SetUserSettings", {
                MFAOptions: i,
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
            }, function(a) {
                return a ? n(a, null) : n(null, "SUCCESS")
            })
        }, "enableMFA"), e.setUserMfaPreference = o(function(n, i, s) {
            if (this.signInUserSession == null || !this.signInUserSession.isValid()) return s(new Error("User is not authenticated"), null);
            this.client.request("SetUserMFAPreference", {
                SMSMfaSettings: n,
                SoftwareTokenMfaSettings: i,
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
            }, function(a) {
                return a ? s(a, null) : s(null, "SUCCESS")
            })
        }, "setUserMfaPreference"), e.disableMFA = o(function(n) {
            if (this.signInUserSession == null || !this.signInUserSession.isValid()) return n(new Error("User is not authenticated"), null);
            var i = [];
            this.client.request("SetUserSettings", {
                MFAOptions: i,
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
            }, function(s) {
                return s ? n(s, null) : n(null, "SUCCESS")
            })
        }, "disableMFA"), e.deleteUser = o(function(n, i) {
            var s = this;
            if (this.signInUserSession == null || !this.signInUserSession.isValid()) return n(new Error("User is not authenticated"), null);
            this.client.request("DeleteUser", {
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
                ClientMetadata: i
            }, function(a) {
                return a ? n(a, null) : (s.clearCachedUser(), n(null, "SUCCESS"))
            })
        }, "deleteUser"), e.updateAttributes = o(function(n, i, s) {
            var a = this;
            if (this.signInUserSession == null || !this.signInUserSession.isValid()) return i(new Error("User is not authenticated"), null);
            this.client.request("UpdateUserAttributes", {
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
                UserAttributes: n,
                ClientMetadata: s
            }, function(u, l) {
                return u ? i(u, null) : a.getUserData(function() {
                    return i(null, "SUCCESS", l)
                }, {
                    bypassCache: !0
                })
            })
        }, "updateAttributes"), e.getUserAttributes = o(function(n) {
            if (!(this.signInUserSession != null && this.signInUserSession.isValid())) return n(new Error("User is not authenticated"), null);
            this.client.request("GetUser", {
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
            }, function(i, s) {
                if (i) return n(i, null);
                for (var a = [], u = 0; u < s.UserAttributes.length; u++) {
                    var l = {
                            Name: s.UserAttributes[u].Name,
                            Value: s.UserAttributes[u].Value
                        },
                        c = new Za(l);
                    a.push(c)
                }
                return n(null, a)
            })
        }, "getUserAttributes"), e.getMFAOptions = o(function(n) {
            if (!(this.signInUserSession != null && this.signInUserSession.isValid())) return n(new Error("User is not authenticated"), null);
            this.client.request("GetUser", {
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
            }, function(i, s) {
                return i ? n(i, null) : n(null, s.MFAOptions)
            })
        }, "getMFAOptions"), e.createGetUserRequest = o(function() {
            return this.client.promisifyRequest("GetUser", {
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
            })
        }, "createGetUserRequest"), e.refreshSessionIfPossible = o(function(n) {
            var i = this;
            return n === void 0 && (n = {}), new Promise(function(s) {
                var a = i.signInUserSession.getRefreshToken();
                a && a.getToken() ? i.refreshSession(a, s, n.clientMetadata) : s()
            })
        }, "refreshSessionIfPossible"), e.getUserData = o(function(n, i) {
            var s = this;
            if (!(this.signInUserSession != null && this.signInUserSession.isValid())) return this.clearCachedUserData(), n(new Error("User is not authenticated"), null);
            var a = this.getUserDataFromCache();
            if (!a) {
                this.fetchUserData().then(function(u) {
                    n(null, u)
                }).catch(n);
                return
            }
            if (this.isFetchUserDataAndTokenRequired(i)) {
                this.fetchUserData().then(function(u) {
                    return s.refreshSessionIfPossible(i).then(function() {
                        return u
                    })
                }).then(function(u) {
                    return n(null, u)
                }).catch(n);
                return
            }
            try {
                n(null, JSON.parse(a));
                return
            } catch (u) {
                this.clearCachedUserData(), n(u, null);
                return
            }
        }, "getUserData"), e.getUserDataFromCache = o(function() {
            var n = this.storage.getItem(this.userDataKey);
            return n
        }, "getUserDataFromCache"), e.isFetchUserDataAndTokenRequired = o(function(n) {
            var i = n || {},
                s = i.bypassCache,
                a = s === void 0 ? !1 : s;
            return a
        }, "isFetchUserDataAndTokenRequired"), e.fetchUserData = o(function() {
            var n = this;
            return this.createGetUserRequest().then(function(i) {
                return n.cacheUserData(i), i
            })
        }, "fetchUserData"), e.deleteAttributes = o(function(n, i) {
            var s = this;
            if (!(this.signInUserSession != null && this.signInUserSession.isValid())) return i(new Error("User is not authenticated"), null);
            this.client.request("DeleteUserAttributes", {
                UserAttributeNames: n,
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
            }, function(a) {
                return a ? i(a, null) : s.getUserData(function() {
                    return i(null, "SUCCESS")
                }, {
                    bypassCache: !0
                })
            })
        }, "deleteAttributes"), e.resendConfirmationCode = o(function(n, i) {
            var s = {
                ClientId: this.pool.getClientId(),
                Username: this.username,
                ClientMetadata: i
            };
            this.client.request("ResendConfirmationCode", s, function(a, u) {
                return a ? n(a, null) : n(null, u)
            })
        }, "resendConfirmationCode"), e.getSession = o(function(n, i) {
            if (i === void 0 && (i = {}), this.username == null) return n(new Error("Username is null. Cannot retrieve a new session"), null);
            if (this.signInUserSession != null && this.signInUserSession.isValid()) return n(null, this.signInUserSession);
            var s = "CognitoIdentityServiceProvider." + this.pool.getClientId() + "." + this.username,
                a = s + ".idToken",
                u = s + ".accessToken",
                l = s + ".refreshToken",
                c = s + ".clockDrift";
            if (this.storage.getItem(a)) {
                var d = new KE({
                        IdToken: this.storage.getItem(a)
                    }),
                    f = new zE({
                        AccessToken: this.storage.getItem(u)
                    }),
                    h = new YE({
                        RefreshToken: this.storage.getItem(l)
                    }),
                    g = parseInt(this.storage.getItem(c), 0) || 0,
                    p = {
                        IdToken: d,
                        AccessToken: f,
                        RefreshToken: h,
                        ClockDrift: g
                    },
                    m = new XE(p);
                if (m.isValid()) return this.signInUserSession = m, n(null, this.signInUserSession);
                if (!h.getToken()) return n(new Error("Cannot retrieve a new session. Please authenticate."), null);
                this.refreshSession(h, n, i.clientMetadata)
            } else n(new Error("Local storage is missing an ID Token, Please authenticate"), null)
        }, "getSession"), e.refreshSession = o(function(n, i, s) {
            var a = this,
                u = this.pool.wrapRefreshSessionCallback ? this.pool.wrapRefreshSessionCallback(i) : i,
                l = {};
            l.REFRESH_TOKEN = n.getToken();
            var c = "CognitoIdentityServiceProvider." + this.pool.getClientId(),
                d = c + ".LastAuthUser";
            if (this.storage.getItem(d)) {
                this.username = this.storage.getItem(d);
                var f = c + "." + this.username + ".deviceKey";
                this.deviceKey = this.storage.getItem(f), l.DEVICE_KEY = this.deviceKey
            }
            var h = {
                ClientId: this.pool.getClientId(),
                AuthFlow: "REFRESH_TOKEN_AUTH",
                AuthParameters: l,
                ClientMetadata: s
            };
            this.getUserContextData() && (h.UserContextData = this.getUserContextData()), this.client.requestWithRetry("InitiateAuth", h, function(g, p) {
                if (g) return g.code === "NotAuthorizedException" && a.clearCachedUser(), u(g, null);
                if (p) {
                    var m = p.AuthenticationResult;
                    return Object.prototype.hasOwnProperty.call(m, "RefreshToken") || (m.RefreshToken = n.getToken()), a.signInUserSession = a.getCognitoUserSession(m), a.cacheTokens(), u(null, a.signInUserSession)
                }
            })
        }, "refreshSession"), e.cacheTokens = o(function() {
            var n = "CognitoIdentityServiceProvider." + this.pool.getClientId(),
                i = n + "." + this.username + ".idToken",
                s = n + "." + this.username + ".accessToken",
                a = n + "." + this.username + ".refreshToken",
                u = n + "." + this.username + ".clockDrift",
                l = n + ".LastAuthUser";
            this.storage.setItem(i, this.signInUserSession.getIdToken().getJwtToken()), this.storage.setItem(s, this.signInUserSession.getAccessToken().getJwtToken()), this.storage.setItem(a, this.signInUserSession.getRefreshToken().getToken()), this.storage.setItem(u, "" + this.signInUserSession.getClockDrift()), this.storage.setItem(l, this.username)
        }, "cacheTokens"), e.cacheUserData = o(function(n) {
            this.storage.setItem(this.userDataKey, JSON.stringify(n))
        }, "cacheUserData"), e.clearCachedUserData = o(function() {
            this.storage.removeItem(this.userDataKey)
        }, "clearCachedUserData"), e.clearCachedUser = o(function() {
            this.clearCachedTokens(), this.clearCachedUserData()
        }, "clearCachedUser"), e.cacheDeviceKeyAndPassword = o(function() {
            var n = "CognitoIdentityServiceProvider." + this.pool.getClientId() + "." + this.username,
                i = n + ".deviceKey",
                s = n + ".randomPasswordKey",
                a = n + ".deviceGroupKey";
            this.storage.setItem(i, this.deviceKey), this.storage.setItem(s, this.randomPassword), this.storage.setItem(a, this.deviceGroupKey)
        }, "cacheDeviceKeyAndPassword"), e.getCachedDeviceKeyAndPassword = o(function() {
            var n = "CognitoIdentityServiceProvider." + this.pool.getClientId() + "." + this.username,
                i = n + ".deviceKey",
                s = n + ".randomPasswordKey",
                a = n + ".deviceGroupKey";
            this.storage.getItem(i) && (this.deviceKey = this.storage.getItem(i), this.randomPassword = this.storage.getItem(s), this.deviceGroupKey = this.storage.getItem(a))
        }, "getCachedDeviceKeyAndPassword"), e.clearCachedDeviceKeyAndPassword = o(function() {
            var n = "CognitoIdentityServiceProvider." + this.pool.getClientId() + "." + this.username,
                i = n + ".deviceKey",
                s = n + ".randomPasswordKey",
                a = n + ".deviceGroupKey";
            this.storage.removeItem(i), this.storage.removeItem(s), this.storage.removeItem(a)
        }, "clearCachedDeviceKeyAndPassword"), e.clearCachedTokens = o(function() {
            var n = "CognitoIdentityServiceProvider." + this.pool.getClientId(),
                i = n + "." + this.username + ".idToken",
                s = n + "." + this.username + ".accessToken",
                a = n + "." + this.username + ".refreshToken",
                u = n + ".LastAuthUser",
                l = n + "." + this.username + ".clockDrift";
            this.storage.removeItem(i), this.storage.removeItem(s), this.storage.removeItem(a), this.storage.removeItem(u), this.storage.removeItem(l)
        }, "clearCachedTokens"), e.getCognitoUserSession = o(function(n) {
            var i = new KE(n),
                s = new zE(n),
                a = new YE(n),
                u = {
                    IdToken: i,
                    AccessToken: s,
                    RefreshToken: a
                };
            return new XE(u)
        }, "getCognitoUserSession"), e.forgotPassword = o(function(n, i) {
            var s = {
                ClientId: this.pool.getClientId(),
                Username: this.username,
                ClientMetadata: i
            };
            this.getUserContextData() && (s.UserContextData = this.getUserContextData()), this.client.request("ForgotPassword", s, function(a, u) {
                return a ? n.onFailure(a) : typeof n.inputVerificationCode == "function" ? n.inputVerificationCode(u) : n.onSuccess(u)
            })
        }, "forgotPassword"), e.confirmPassword = o(function(n, i, s, a) {
            var u = {
                ClientId: this.pool.getClientId(),
                Username: this.username,
                ConfirmationCode: n,
                Password: i,
                ClientMetadata: a
            };
            this.getUserContextData() && (u.UserContextData = this.getUserContextData()), this.client.request("ConfirmForgotPassword", u, function(l) {
                return l ? s.onFailure(l) : s.onSuccess("SUCCESS")
            })
        }, "confirmPassword"), e.getAttributeVerificationCode = o(function(n, i, s) {
            if (this.signInUserSession == null || !this.signInUserSession.isValid()) return i.onFailure(new Error("User is not authenticated"));
            this.client.request("GetUserAttributeVerificationCode", {
                AttributeName: n,
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
                ClientMetadata: s
            }, function(a, u) {
                return a ? i.onFailure(a) : typeof i.inputVerificationCode == "function" ? i.inputVerificationCode(u) : i.onSuccess("SUCCESS")
            })
        }, "getAttributeVerificationCode"), e.verifyAttribute = o(function(n, i, s) {
            if (this.signInUserSession == null || !this.signInUserSession.isValid()) return s.onFailure(new Error("User is not authenticated"));
            this.client.request("VerifyUserAttribute", {
                AttributeName: n,
                Code: i,
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
            }, function(a) {
                return a ? s.onFailure(a) : s.onSuccess("SUCCESS")
            })
        }, "verifyAttribute"), e.getDevice = o(function(n) {
            if (this.signInUserSession == null || !this.signInUserSession.isValid()) return n.onFailure(new Error("User is not authenticated"));
            this.client.request("GetDevice", {
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
                DeviceKey: this.deviceKey
            }, function(i, s) {
                return i ? n.onFailure(i) : n.onSuccess(s)
            })
        }, "getDevice"), e.forgetSpecificDevice = o(function(n, i) {
            if (this.signInUserSession == null || !this.signInUserSession.isValid()) return i.onFailure(new Error("User is not authenticated"));
            this.client.request("ForgetDevice", {
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
                DeviceKey: n
            }, function(s) {
                return s ? i.onFailure(s) : i.onSuccess("SUCCESS")
            })
        }, "forgetSpecificDevice"), e.forgetDevice = o(function(n) {
            var i = this;
            this.forgetSpecificDevice(this.deviceKey, {
                onFailure: n.onFailure,
                onSuccess: o(function(a) {
                    return i.deviceKey = null, i.deviceGroupKey = null, i.randomPassword = null, i.clearCachedDeviceKeyAndPassword(), n.onSuccess(a)
                }, "onSuccess")
            })
        }, "forgetDevice"), e.setDeviceStatusRemembered = o(function(n) {
            if (this.signInUserSession == null || !this.signInUserSession.isValid()) return n.onFailure(new Error("User is not authenticated"));
            this.client.request("UpdateDeviceStatus", {
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
                DeviceKey: this.deviceKey,
                DeviceRememberedStatus: "remembered"
            }, function(i) {
                return i ? n.onFailure(i) : n.onSuccess("SUCCESS")
            })
        }, "setDeviceStatusRemembered"), e.setDeviceStatusNotRemembered = o(function(n) {
            if (this.signInUserSession == null || !this.signInUserSession.isValid()) return n.onFailure(new Error("User is not authenticated"));
            this.client.request("UpdateDeviceStatus", {
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
                DeviceKey: this.deviceKey,
                DeviceRememberedStatus: "not_remembered"
            }, function(i) {
                return i ? n.onFailure(i) : n.onSuccess("SUCCESS")
            })
        }, "setDeviceStatusNotRemembered"), e.listDevices = o(function(n, i, s) {
            if (this.signInUserSession == null || !this.signInUserSession.isValid()) return s.onFailure(new Error("User is not authenticated"));
            var a = {
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
                Limit: n
            };
            i && (a.PaginationToken = i), this.client.request("ListDevices", a, function(u, l) {
                return u ? s.onFailure(u) : s.onSuccess(l)
            })
        }, "listDevices"), e.globalSignOut = o(function(n) {
            var i = this;
            if (this.signInUserSession == null || !this.signInUserSession.isValid()) return n.onFailure(new Error("User is not authenticated"));
            this.client.request("GlobalSignOut", {
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
            }, function(s) {
                return s ? n.onFailure(s) : (i.clearCachedUser(), n.onSuccess("SUCCESS"))
            })
        }, "globalSignOut"), e.signOut = o(function(n) {
            var i = this;
            if (!n || typeof n != "function") {
                this.cleanClientData();
                return
            }
            this.getSession(function(s, a) {
                if (s) return n(s);
                i.revokeTokens(function(u) {
                    i.cleanClientData(), n(u)
                })
            })
        }, "signOut"), e.revokeTokens = o(function(n) {
            if (n === void 0 && (n = o(function() {}, "revokeTokenCallback")), typeof n != "function") throw new Error("Invalid revokeTokenCallback. It should be a function.");
            if (!this.signInUserSession) {
                var i = new Error("User is not authenticated");
                return n(i)
            }
            if (!this.signInUserSession.getAccessToken()) {
                var s = new Error("No Access token available");
                return n(s)
            }
            var a = this.signInUserSession.getRefreshToken().getToken(),
                u = this.signInUserSession.getAccessToken();
            if (this.isSessionRevocable(u) && a) return this.revokeToken({
                token: a,
                callback: n
            });
            n()
        }, "revokeTokens"), e.isSessionRevocable = o(function(n) {
            if (n && typeof n.decodePayload == "function") try {
                var i = n.decodePayload(),
                    s = i.origin_jti;
                return !!s
            } catch (a) {}
            return !1
        }, "isSessionRevocable"), e.cleanClientData = o(function() {
            this.signInUserSession = null, this.clearCachedUser()
        }, "cleanClientData"), e.revokeToken = o(function(n) {
            var i = n.token,
                s = n.callback;
            this.client.requestWithRetry("RevokeToken", {
                Token: i,
                ClientId: this.pool.getClientId()
            }, function(a) {
                if (a) return s(a);
                s()
            })
        }, "revokeToken"), e.sendMFASelectionAnswer = o(function(n, i) {
            var s = this,
                a = {};
            a.USERNAME = this.username, a.ANSWER = n;
            var u = {
                ChallengeName: "SELECT_MFA_TYPE",
                ChallengeResponses: a,
                ClientId: this.pool.getClientId(),
                Session: this.Session
            };
            this.getUserContextData() && (u.UserContextData = this.getUserContextData()), this.client.request("RespondToAuthChallenge", u, function(l, c) {
                if (l) return i.onFailure(l);
                if (s.Session = c.Session, n === "SMS_MFA") return i.mfaRequired(c.ChallengeName, c.ChallengeParameters);
                if (n === "SOFTWARE_TOKEN_MFA") return i.totpRequired(c.ChallengeName, c.ChallengeParameters)
            })
        }, "sendMFASelectionAnswer"), e.getUserContextData = o(function() {
            var n = this.pool;
            return n.getUserContextData(this.username)
        }, "getUserContextData"), e.associateSoftwareToken = o(function(n) {
            var i = this;
            this.signInUserSession != null && this.signInUserSession.isValid() ? this.client.request("AssociateSoftwareToken", {
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
            }, function(s, a) {
                return s ? n.onFailure(s) : n.associateSecretCode(a.SecretCode)
            }) : this.client.request("AssociateSoftwareToken", {
                Session: this.Session
            }, function(s, a) {
                return s ? n.onFailure(s) : (i.Session = a.Session, n.associateSecretCode(a.SecretCode))
            })
        }, "associateSoftwareToken"), e.verifySoftwareToken = o(function(n, i, s) {
            var a = this;
            this.signInUserSession != null && this.signInUserSession.isValid() ? this.client.request("VerifySoftwareToken", {
                AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
                UserCode: n,
                FriendlyDeviceName: i
            }, function(u, l) {
                return u ? s.onFailure(u) : s.onSuccess(l)
            }) : this.client.request("VerifySoftwareToken", {
                Session: this.Session,
                UserCode: n,
                FriendlyDeviceName: i
            }, function(u, l) {
                if (u) return s.onFailure(u);
                a.Session = l.Session;
                var c = {};
                c.USERNAME = a.username;
                var d = {
                    ChallengeName: "MFA_SETUP",
                    ClientId: a.pool.getClientId(),
                    ChallengeResponses: c,
                    Session: a.Session
                };
                a.getUserContextData() && (d.UserContextData = a.getUserContextData()), a.client.request("RespondToAuthChallenge", d, function(f, h) {
                    return f ? s.onFailure(f) : (a.signInUserSession = a.getCognitoUserSession(h.AuthenticationResult), a.cacheTokens(), s.onSuccess(a.signInUserSession))
                })
            })
        }, "verifySoftwareToken"), r
    })(),
    tte = "auth";

function bs() {}
o(bs, "UserAgent");
bs.prototype.userAgent = Xee();
var rte = o(function() {
        bs.category = tte
    }, "addAuthCategoryToCognitoUserAgent"),
    GD = o(function(e) {
        bs.framework = e
    }, "addFrameworkToCognitoUserAgent"),
    nte = o(function(e) {
        var t = bs.category ? " " + bs.category : "",
            n = bs.framework ? " framework/" + bs.framework : "",
            i = "" + bs.prototype.userAgent + t + n;
        return i
    }, "getAmplifyUserAgent");

function ite(r, e) {
    r.prototype = Object.create(e.prototype), r.prototype.constructor = r, vd(r, e)
}
o(ite, "_inheritsLoose");

function ZE(r) {
    var e = typeof Map == "function" ? new Map : void 0;
    return ZE = o(function(n) {
        if (n === null || !ote(n)) return n;
        if (typeof n != "function") throw new TypeError("Super expression must either be null or a function");
        if (e !== void 0) {
            if (e.has(n)) return e.get(n);
            e.set(n, i)
        }

        function i() {
            return ste(n, arguments, QE(this).constructor)
        }
        return o(i, "Wrapper"), i.prototype = Object.create(n.prototype, {
            constructor: {
                value: i,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), vd(i, n)
    }, "_wrapNativeSuper"), ZE(r)
}
o(ZE, "_wrapNativeSuper");

function ste(r, e, t) {
    if (QL()) return Reflect.construct.apply(null, arguments);
    var n = [null];
    n.push.apply(n, e);
    var i = new(r.bind.apply(r, n));
    return t && vd(i, t.prototype), i
}
o(ste, "_construct");

function QL() {
    try {
        var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch (e) {}
    return (QL = o(function() {
        return !!r
    }, "_isNativeReflectConstruct"))()
}
o(QL, "_isNativeReflectConstruct");

function ote(r) {
    try {
        return Function.toString.call(r).indexOf("[native code]") !== -1
    } catch (e) {
        return typeof r == "function"
    }
}
o(ote, "_isNativeFunction");

function vd(r, e) {
    return vd = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, n) {
        return t.__proto__ = n, t
    }, vd(r, e)
}
o(vd, "_setPrototypeOf");

function QE(r) {
    return QE = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
        return e.__proto__ || Object.getPrototypeOf(e)
    }, QE(r)
}
o(QE, "_getPrototypeOf");
var ate = (function(r) {
        function e(t, n, i, s) {
            var a;
            return a = r.call(this, t) || this, a.code = n, a.name = i, a.statusCode = s, a
        }
        return o(e, "CognitoError"), ite(e, r), e
    })(ZE(Error)),
    ute = (function() {
        function r(t, n, i) {
            this.endpoint = n || "https://cognito-idp." + t + ".amazonaws.com/";
            var s = i || {},
                a = s.credentials;
            this.fetchOptions = a ? {
                credentials: a
            } : {}
        }
        o(r, "Client");
        var e = r.prototype;
        return e.promisifyRequest = o(function(n, i) {
            var s = this;
            return new Promise(function(a, u) {
                s.request(n, i, function(l, c) {
                    l ? u(new ate(l.message, l.code, l.name, l.statusCode)) : a(c)
                })
            })
        }, "promisifyRequest"), e.requestWithRetry = o(function(n, i, s) {
            var a = this,
                u = 5 * 1e3;
            dte(function(l) {
                return new Promise(function(c, d) {
                    a.request(n, l, function(f, h) {
                        f ? d(f) : c(h)
                    })
                })
            }, [i], u).then(function(l) {
                return s(null, l)
            }).catch(function(l) {
                return s(l)
            })
        }, "requestWithRetry"), e.request = o(function(n, i, s) {
            var a = {
                    "Content-Type": "application/x-amz-json-1.1",
                    "X-Amz-Target": "AWSCognitoIdentityProviderService." + n,
                    "X-Amz-User-Agent": nte(),
                    "Cache-Control": "no-store"
                },
                u = Object.assign({}, this.fetchOptions, {
                    headers: a,
                    method: "POST",
                    mode: "cors",
                    body: JSON.stringify(i)
                }),
                l;
            fetch(this.endpoint, u).then(function(c) {
                return l = c, c
            }, function(c) {
                throw c instanceof TypeError ? new Error("Network error") : c
            }).then(function(c) {
                return c.json().catch(function() {
                    return {}
                })
            }).then(function(c) {
                if (l.ok) return s(null, c);
                var d = (c.__type || c.code).split("#").pop(),
                    f = new Error(c.message || c.Message || null);
                return f.name = d, f.code = d, s(f)
            }).catch(function(c) {
                if (l && l.headers && l.headers.get("x-amzn-errortype")) try {
                    var d = l.headers.get("x-amzn-errortype").split(":")[0],
                        f = new Error(l.status ? l.status.toString() : null);
                    return f.code = d, f.name = d, f.statusCode = l.status, s(f)
                } catch (h) {
                    return s(c)
                } else c instanceof Error && c.message === "Network error" && (c.code = "NetworkError");
                return s(c)
            })
        }, "request"), r
    })(),
    ap = {
        debug: o(function() {}, "debug")
    },
    cte = o(function(e) {
        var t = "nonRetryable";
        return e && e[t]
    }, "isNonRetryableError");

function ex(r, e, t, n) {
    if (n === void 0 && (n = 1), typeof r != "function") throw Error("functionToRetry must be a function");
    return ap.debug(r.name + " attempt #" + n + " with args: " + JSON.stringify(e)), r.apply(void 0, e).catch(function(i) {
        if (ap.debug("error on " + r.name, i), cte(i)) throw ap.debug(r.name + " non retryable error", i), i;
        var s = t(n, e, i);
        if (ap.debug(r.name + " retrying in " + s + " ms"), s !== !1) return new Promise(function(a) {
            return setTimeout(a, s)
        }).then(function() {
            return ex(r, e, t, n + 1)
        });
        throw i
    })
}
o(ex, "retry");

function lte(r) {
    var e = 100,
        t = 100;
    return function(n) {
        var i = Math.pow(2, n) * e + t * Math.random();
        return i > r ? !1 : i
    }
}
o(lte, "jitteredBackoff");

function dte(r, e, t) {
    return ex(r, e, lte(t))
}
o(dte, "jitteredExponentialRetry");
var fte = 55,
    hte = (function() {
        function r(t, n) {
            var i = t || {},
                s = i.UserPoolId,
                a = i.ClientId,
                u = i.endpoint,
                l = i.fetchOptions,
                c = i.AdvancedSecurityDataCollectionFlag;
            if (!s || !a) throw new Error("Both UserPoolId and ClientId are required.");
            if (s.length > fte || !/^[\w-]+_[0-9a-zA-Z]+$/.test(s)) throw new Error("Invalid UserPoolId format.");
            var d = s.split("_")[0];
            this.userPoolId = s, this.clientId = a, this.client = new ute(d, u, l), this.advancedSecurityDataCollectionFlag = c !== !1, this.storage = t.Storage || new ZL().getStorage(), n && (this.wrapRefreshSessionCallback = n)
        }
        o(r, "CognitoUserPool");
        var e = r.prototype;
        return e.getUserPoolId = o(function() {
            return this.userPoolId
        }, "getUserPoolId"), e.getUserPoolName = o(function() {
            return this.getUserPoolId().split("_")[1]
        }, "getUserPoolName"), e.getClientId = o(function() {
            return this.clientId
        }, "getClientId"), e.signUp = o(function(n, i, s, a, u, l) {
            var c = this,
                d = {
                    ClientId: this.clientId,
                    Username: n,
                    Password: i,
                    UserAttributes: s,
                    ValidationData: a,
                    ClientMetadata: l
                };
            this.getUserContextData(n) && (d.UserContextData = this.getUserContextData(n)), this.client.request("SignUp", d, function(f, h) {
                if (f) return u(f, null);
                var g = {
                        Username: n,
                        Pool: c,
                        Storage: c.storage
                    },
                    p = {
                        user: new JE(g),
                        userConfirmed: h.UserConfirmed,
                        userSub: h.UserSub,
                        codeDeliveryDetails: h.CodeDeliveryDetails
                    };
                return u(null, p)
            })
        }, "signUp"), e.getCurrentUser = o(function() {
            var n = "CognitoIdentityServiceProvider." + this.clientId + ".LastAuthUser",
                i = this.storage.getItem(n);
            if (i) {
                var s = {
                    Username: i,
                    Pool: this,
                    Storage: this.storage
                };
                return new JE(s)
            }
            return null
        }, "getCurrentUser"), e.getUserContextData = o(function(n) {
            if (typeof AmazonCognitoAdvancedSecurityData != "undefined") {
                var i = AmazonCognitoAdvancedSecurityData;
                if (this.advancedSecurityDataCollectionFlag) {
                    var s = i.getData(n, this.userPoolId, this.clientId);
                    if (s) {
                        var a = {
                            EncodedData: s
                        };
                        return a
                    }
                }
                return {}
            }
        }, "getUserContextData"), r
    })(),
    tx = {
        exports: {}
    };
(function(r, e) {
    (function(t) {
        var n;
        if (r.exports = t(), n = !0, !n) {
            var i = window.Cookies,
                s = window.Cookies = t();
            s.noConflict = function() {
                return window.Cookies = i, s
            }
        }
    })(function() {
        function t() {
            for (var s = 0, a = {}; s < arguments.length; s++) {
                var u = arguments[s];
                for (var l in u) a[l] = u[l]
            }
            return a
        }
        o(t, "extend");

        function n(s) {
            return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent)
        }
        o(n, "decode");

        function i(s) {
            function a() {}
            o(a, "api");

            function u(c, d, f) {
                if (typeof document != "undefined") {
                    f = t({
                        path: "/"
                    }, a.defaults, f), typeof f.expires == "number" && (f.expires = new Date(new Date * 1 + f.expires * 864e5)), f.expires = f.expires ? f.expires.toUTCString() : "";
                    try {
                        var h = JSON.stringify(d);
                        /^[\{\[]/.test(h) && (d = h)
                    } catch (m) {}
                    d = s.write ? s.write(d, c) : encodeURIComponent(String(d)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent), c = encodeURIComponent(String(c)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
                    var g = "";
                    for (var p in f) f[p] && (g += "; " + p, f[p] !== !0 && (g += "=" + f[p].split(";")[0]));
                    return document.cookie = c + "=" + d + g
                }
            }
            o(u, "set");

            function l(c, d) {
                if (typeof document != "undefined") {
                    for (var f = {}, h = document.cookie ? document.cookie.split("; ") : [], g = 0; g < h.length; g++) {
                        var p = h[g].split("="),
                            m = p.slice(1).join("=");
                        !d && m.charAt(0) === '"' && (m = m.slice(1, -1));
                        try {
                            var w = n(p[0]);
                            if (m = (s.read || s)(m, w) || n(m), d) try {
                                m = JSON.parse(m)
                            } catch (T) {}
                            if (f[w] = m, c === w) break
                        } catch (T) {}
                    }
                    return c ? f[c] : f
                }
            }
            return o(l, "get"), a.set = u, a.get = function(c) {
                return l(c, !1)
            }, a.getJSON = function(c) {
                return l(c, !0)
            }, a.remove = function(c, d) {
                u(c, "", t(d, {
                    expires: -1
                }))
            }, a.defaults = {}, a.withConverter = i, a
        }
        return o(i, "init"), i(function() {})
    })
})(tx);
var Yl = tx.exports,
    gte = (function() {
        function r(t) {
            if (t === void 0 && (t = {}), t.domain && (this.domain = t.domain), t.path ? this.path = t.path : this.path = "/", Object.prototype.hasOwnProperty.call(t, "expires") ? this.expires = t.expires : this.expires = 365, Object.prototype.hasOwnProperty.call(t, "secure") ? this.secure = t.secure : this.secure = !0, Object.prototype.hasOwnProperty.call(t, "sameSite")) {
                if (!["strict", "lax", "none"].includes(t.sameSite)) throw new Error('The sameSite value of cookieStorage must be "lax", "strict" or "none".');
                if (t.sameSite === "none" && !this.secure) throw new Error("sameSite = None requires the Secure attribute in latest browser versions.");
                this.sameSite = t.sameSite
            } else this.sameSite = null
        }
        o(r, "CookieStorage");
        var e = r.prototype;
        return e.setItem = o(function(n, i) {
            var s = {
                path: this.path,
                expires: this.expires,
                domain: this.domain,
                secure: this.secure
            };
            return this.sameSite && (s.sameSite = this.sameSite), Yl.set(n, i, s), Yl.get(n)
        }, "setItem"), e.getItem = o(function(n) {
            return Yl.get(n)
        }, "getItem"), e.removeItem = o(function(n) {
            var i = {
                path: this.path,
                expires: this.expires,
                domain: this.domain,
                secure: this.secure
            };
            return this.sameSite && (i.sameSite = this.sameSite), Yl.remove(n, i)
        }, "removeItem"), e.clear = o(function() {
            for (var n = Yl.get(), i = Object.keys(n).length, s = 0; s < i; ++s) this.removeItem(Object.keys(n)[s]);
            return {}
        }, "clear"), r
    })(),
    Up = {
        exports: {}
    };
Up.exports;
(function(r, e) {
    (function(t) {
        var n = e && !e.nodeType && e,
            i = r && !r.nodeType && r,
            s = typeof Ui == "object" && Ui;
        (s.global === s || s.window === s || s.self === s) && (t = s);
        var a, u = 2147483647,
            l = 36,
            c = 1,
            d = 26,
            f = 38,
            h = 700,
            g = 72,
            p = 128,
            m = "-",
            w = /^xn--/,
            T = /[^\x20-\x7E]/,
            E = /[\x2E\u3002\uFF0E\uFF61]/g,
            b = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
            },
            R = l - c,
            L = Math.floor,
            V = String.fromCharCode,
            z;

        function j(de) {
            throw RangeError(b[de])
        }
        o(j, "error");

        function Y(de, N) {
            for (var x = de.length, U = []; x--;) U[x] = N(de[x]);
            return U
        }
        o(Y, "map");

        function q(de, N) {
            var x = de.split("@"),
                U = "";
            x.length > 1 && (U = x[0] + "@", de = x[1]), de = de.replace(E, ".");
            var ve = de.split("."),
                Te = Y(ve, N).join(".");
            return U + Te
        }
        o(q, "mapDomain");

        function P(de) {
            for (var N = [], x = 0, U = de.length, ve, Te; x < U;) ve = de.charCodeAt(x++), ve >= 55296 && ve <= 56319 && x < U ? (Te = de.charCodeAt(x++), (Te & 64512) == 56320 ? N.push(((ve & 1023) << 10) + (Te & 1023) + 65536) : (N.push(ve), x--)) : N.push(ve);
            return N
        }
        o(P, "ucs2decode");

        function Z(de) {
            return Y(de, function(N) {
                var x = "";
                return N > 65535 && (N -= 65536, x += V(N >>> 10 & 1023 | 55296), N = 56320 | N & 1023), x += V(N), x
            }).join("")
        }
        o(Z, "ucs2encode");

        function oe(de) {
            return de - 48 < 10 ? de - 22 : de - 65 < 26 ? de - 65 : de - 97 < 26 ? de - 97 : l
        }
        o(oe, "basicToDigit");

        function S(de, N) {
            return de + 22 + 75 * (de < 26) - ((N != 0) << 5)
        }
        o(S, "digitToBasic");

        function K(de, N, x) {
            var U = 0;
            for (de = x ? L(de / h) : de >> 1, de += L(de / N); de > R * d >> 1; U += l) de = L(de / R);
            return L(U + (R + 1) * de / (de + f))
        }
        o(K, "adapt");

        function M(de) {
            var N = [],
                x = de.length,
                U, ve = 0,
                Te = p,
                Fe = g,
                rt, xe, fe, $, X, W, te, _e, we;
            for (rt = de.lastIndexOf(m), rt < 0 && (rt = 0), xe = 0; xe < rt; ++xe) de.charCodeAt(xe) >= 128 && j("not-basic"), N.push(de.charCodeAt(xe));
            for (fe = rt > 0 ? rt + 1 : 0; fe < x;) {
                for ($ = ve, X = 1, W = l; fe >= x && j("invalid-input"), te = oe(de.charCodeAt(fe++)), (te >= l || te > L((u - ve) / X)) && j("overflow"), ve += te * X, _e = W <= Fe ? c : W >= Fe + d ? d : W - Fe, !(te < _e); W += l) we = l - _e, X > L(u / we) && j("overflow"), X *= we;
                U = N.length + 1, Fe = K(ve - $, U, $ == 0), L(ve / U) > u - Te && j("overflow"), Te += L(ve / U), ve %= U, N.splice(ve++, 0, Te)
            }
            return Z(N)
        }
        o(M, "decode");

        function Oe(de) {
            var N, x, U, ve, Te, Fe, rt, xe, fe, $, X, W = [],
                te, _e, we, Ie;
            for (de = P(de), te = de.length, N = p, x = 0, Te = g, Fe = 0; Fe < te; ++Fe) X = de[Fe], X < 128 && W.push(V(X));
            for (U = ve = W.length, ve && W.push(m); U < te;) {
                for (rt = u, Fe = 0; Fe < te; ++Fe) X = de[Fe], X >= N && X < rt && (rt = X);
                for (_e = U + 1, rt - N > L((u - x) / _e) && j("overflow"), x += (rt - N) * _e, N = rt, Fe = 0; Fe < te; ++Fe)
                    if (X = de[Fe], X < N && ++x > u && j("overflow"), X == N) {
                        for (xe = x, fe = l; $ = fe <= Te ? c : fe >= Te + d ? d : fe - Te, !(xe < $); fe += l) Ie = xe - $, we = l - $, W.push(V(S($ + Ie % we, 0))), xe = L(Ie / we);
                        W.push(V(S(xe, 0))), Te = K(x, _e, U == ve), x = 0, ++U
                    }++ x, ++N
            }
            return W.join("")
        }
        o(Oe, "encode");

        function Ye(de) {
            return q(de, function(N) {
                return w.test(N) ? M(N.slice(4).toLowerCase()) : N
            })
        }
        o(Ye, "toUnicode");

        function Xe(de) {
            return q(de, function(N) {
                return T.test(N) ? "xn--" + Oe(N) : N
            })
        }
        if (o(Xe, "toASCII"), a = {
                version: "1.3.2",
                ucs2: {
                    decode: P,
                    encode: Z
                },
                decode: M,
                encode: Oe,
                toASCII: Xe,
                toUnicode: Ye
            }, n && i)
            if (r.exports == n) i.exports = a;
            else
                for (z in a) a.hasOwnProperty(z) && (n[z] = a[z]);
        else t.punycode = a
    })(Ui)
})(Up, Up.exports);
var pte = Up.exports,
    mte = {
        isString: o(function(r) {
            return typeof r == "string"
        }, "isString"),
        isObject: o(function(r) {
            return typeof r == "object" && r !== null
        }, "isObject"),
        isNull: o(function(r) {
            return r === null
        }, "isNull"),
        isNullOrUndefined: o(function(r) {
            return r == null
        }, "isNullOrUndefined")
    },
    yd = {};

function vte(r, e) {
    return Object.prototype.hasOwnProperty.call(r, e)
}
o(vte, "hasOwnProperty");
var yte = o(function(r, e, t, n) {
        e = e || "&", t = t || "=";
        var i = {};
        if (typeof r != "string" || r.length === 0) return i;
        var s = /\+/g;
        r = r.split(e);
        var a = 1e3;
        n && typeof n.maxKeys == "number" && (a = n.maxKeys);
        var u = r.length;
        a > 0 && u > a && (u = a);
        for (var l = 0; l < u; ++l) {
            var c = r[l].replace(s, "%20"),
                d = c.indexOf(t),
                f, h, g, p;
            d >= 0 ? (f = c.substr(0, d), h = c.substr(d + 1)) : (f = c, h = ""), g = decodeURIComponent(f), p = decodeURIComponent(h), vte(i, g) ? Array.isArray(i[g]) ? i[g].push(p) : i[g] = [i[g], p] : i[g] = p
        }
        return i
    }, "decode"),
    Xl = o(function(r) {
        switch (typeof r) {
            case "string":
                return r;
            case "boolean":
                return r ? "true" : "false";
            case "number":
                return isFinite(r) ? r : "";
            default:
                return ""
        }
    }, "stringifyPrimitive"),
    _te = o(function(r, e, t, n) {
        return e = e || "&", t = t || "=", r === null && (r = void 0), typeof r == "object" ? Object.keys(r).map(function(i) {
            var s = encodeURIComponent(Xl(i)) + t;
            return Array.isArray(r[i]) ? r[i].map(function(a) {
                return s + encodeURIComponent(Xl(a))
            }).join(e) : s + encodeURIComponent(Xl(r[i]))
        }).join(e) : n ? encodeURIComponent(Xl(n)) + t + encodeURIComponent(Xl(r)) : ""
    }, "encode");
yd.decode = yd.parse = yte;
yd.encode = yd.stringify = _te;
var wte = pte,
    Pi = mte,
    Es = rx;

function Mi() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
}
o(Mi, "Url");
var Tte = /^([a-z0-9.+-]+:)/i,
    Ete = /:[0-9]*$/,
    bte = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    Ste = ["<", ">", '"', "`", " ", "\r", `
`, "	"],
    Ate = ["{", "}", "|", "\\", "^", "`"].concat(Ste),
    eb = ["'"].concat(Ate),
    zD = ["%", "/", "?", ";", "#"].concat(eb),
    qD = ["/", "?", "#"],
    Ite = 255,
    KD = /^[+a-z0-9A-Z_-]{0,63}$/,
    Cte = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    Rte = {
        javascript: !0,
        "javascript:": !0
    },
    tb = {
        javascript: !0,
        "javascript:": !0
    },
    lu = {
        http: !0,
        https: !0,
        ftp: !0,
        gopher: !0,
        file: !0,
        "http:": !0,
        "https:": !0,
        "ftp:": !0,
        "gopher:": !0,
        "file:": !0
    },
    rb = yd;

function rx(r, e, t) {
    if (r && Pi.isObject(r) && r instanceof Mi) return r;
    var n = new Mi;
    return n.parse(r, e, t), n
}
o(rx, "urlParse");
Mi.prototype.parse = function(r, e, t) {
    if (!Pi.isString(r)) throw new TypeError("Parameter 'url' must be a string, not " + typeof r);
    var n = r.indexOf("?"),
        i = n !== -1 && n < r.indexOf("#") ? "?" : "#",
        s = r.split(i),
        a = /\\/g;
    s[0] = s[0].replace(a, "/"), r = s.join(i);
    var u = r;
    if (u = u.trim(), !t && r.split("#").length === 1) {
        var l = bte.exec(u);
        if (l) return this.path = u, this.href = u, this.pathname = l[1], l[2] ? (this.search = l[2], e ? this.query = rb.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : e && (this.search = "", this.query = {}), this
    }
    var c = Tte.exec(u);
    if (c) {
        c = c[0];
        var d = c.toLowerCase();
        this.protocol = d, u = u.substr(c.length)
    }
    if (t || c || u.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var f = u.substr(0, 2) === "//";
        f && !(c && tb[c]) && (u = u.substr(2), this.slashes = !0)
    }
    if (!tb[c] && (f || c && !lu[c])) {
        for (var h = -1, g = 0; g < qD.length; g++) {
            var p = u.indexOf(qD[g]);
            p !== -1 && (h === -1 || p < h) && (h = p)
        }
        var m, w;
        h === -1 ? w = u.lastIndexOf("@") : w = u.lastIndexOf("@", h), w !== -1 && (m = u.slice(0, w), u = u.slice(w + 1), this.auth = decodeURIComponent(m)), h = -1;
        for (var g = 0; g < zD.length; g++) {
            var p = u.indexOf(zD[g]);
            p !== -1 && (h === -1 || p < h) && (h = p)
        }
        h === -1 && (h = u.length), this.host = u.slice(0, h), u = u.slice(h), this.parseHost(), this.hostname = this.hostname || "";
        var T = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!T)
            for (var E = this.hostname.split(/\./), g = 0, b = E.length; g < b; g++) {
                var R = E[g];
                if (R && !R.match(KD)) {
                    for (var L = "", V = 0, z = R.length; V < z; V++) R.charCodeAt(V) > 127 ? L += "x" : L += R[V];
                    if (!L.match(KD)) {
                        var j = E.slice(0, g),
                            Y = E.slice(g + 1),
                            q = R.match(Cte);
                        q && (j.push(q[1]), Y.unshift(q[2])), Y.length && (u = "/" + Y.join(".") + u), this.hostname = j.join(".");
                        break
                    }
                }
            }
        this.hostname.length > Ite ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), T || (this.hostname = wte.toASCII(this.hostname));
        var P = this.port ? ":" + this.port : "",
            Z = this.hostname || "";
        this.host = Z + P, this.href += this.host, T && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), u[0] !== "/" && (u = "/" + u))
    }
    if (!Rte[d])
        for (var g = 0, b = eb.length; g < b; g++) {
            var oe = eb[g];
            if (u.indexOf(oe) !== -1) {
                var S = encodeURIComponent(oe);
                S === oe && (S = escape(oe)), u = u.split(oe).join(S)
            }
        }
    var K = u.indexOf("#");
    K !== -1 && (this.hash = u.substr(K), u = u.slice(0, K));
    var M = u.indexOf("?");
    if (M !== -1 ? (this.search = u.substr(M), this.query = u.substr(M + 1), e && (this.query = rb.parse(this.query)), u = u.slice(0, M)) : e && (this.search = "", this.query = {}), u && (this.pathname = u), lu[d] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var P = this.pathname || "",
            Oe = this.search || "";
        this.path = P + Oe
    }
    return this.href = this.format(), this
};
Mi.prototype.format = function() {
    var r = this.auth || "";
    r && (r = encodeURIComponent(r), r = r.replace(/%3A/i, ":"), r += "@");
    var e = this.protocol || "",
        t = this.pathname || "",
        n = this.hash || "",
        i = !1,
        s = "";
    this.host ? i = r + this.host : this.hostname && (i = r + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (i += ":" + this.port)), this.query && Pi.isObject(this.query) && Object.keys(this.query).length && (s = rb.stringify(this.query));
    var a = this.search || s && "?" + s || "";
    return e && e.substr(-1) !== ":" && (e += ":"), this.slashes || (!e || lu[e]) && i !== !1 ? (i = "//" + (i || ""), t && t.charAt(0) !== "/" && (t = "/" + t)) : i || (i = ""), n && n.charAt(0) !== "#" && (n = "#" + n), a && a.charAt(0) !== "?" && (a = "?" + a), t = t.replace(/[?#]/g, function(u) {
        return encodeURIComponent(u)
    }), a = a.replace("#", "%23"), e + i + t + a + n
};
Mi.prototype.resolve = function(r) {
    return this.resolveObject(rx(r, !1, !0)).format()
};
Mi.prototype.resolveObject = function(r) {
    if (Pi.isString(r)) {
        var e = new Mi;
        e.parse(r, !1, !0), r = e
    }
    for (var t = new Mi, n = Object.keys(this), i = 0; i < n.length; i++) {
        var s = n[i];
        t[s] = this[s]
    }
    if (t.hash = r.hash, r.href === "") return t.href = t.format(), t;
    if (r.slashes && !r.protocol) {
        for (var a = Object.keys(r), u = 0; u < a.length; u++) {
            var l = a[u];
            l !== "protocol" && (t[l] = r[l])
        }
        return lu[t.protocol] && t.hostname && !t.pathname && (t.path = t.pathname = "/"), t.href = t.format(), t
    }
    if (r.protocol && r.protocol !== t.protocol) {
        if (!lu[r.protocol]) {
            for (var c = Object.keys(r), d = 0; d < c.length; d++) {
                var f = c[d];
                t[f] = r[f]
            }
            return t.href = t.format(), t
        }
        if (t.protocol = r.protocol, !r.host && !tb[r.protocol]) {
            for (var b = (r.pathname || "").split("/"); b.length && !(r.host = b.shift()););
            r.host || (r.host = ""), r.hostname || (r.hostname = ""), b[0] !== "" && b.unshift(""), b.length < 2 && b.unshift(""), t.pathname = b.join("/")
        } else t.pathname = r.pathname;
        if (t.search = r.search, t.query = r.query, t.host = r.host || "", t.auth = r.auth, t.hostname = r.hostname || r.host, t.port = r.port, t.pathname || t.search) {
            var h = t.pathname || "",
                g = t.search || "";
            t.path = h + g
        }
        return t.slashes = t.slashes || r.slashes, t.href = t.format(), t
    }
    var p = t.pathname && t.pathname.charAt(0) === "/",
        m = r.host || r.pathname && r.pathname.charAt(0) === "/",
        w = m || p || t.host && r.pathname,
        T = w,
        E = t.pathname && t.pathname.split("/") || [],
        b = r.pathname && r.pathname.split("/") || [],
        R = t.protocol && !lu[t.protocol];
    if (R && (t.hostname = "", t.port = null, t.host && (E[0] === "" ? E[0] = t.host : E.unshift(t.host)), t.host = "", r.protocol && (r.hostname = null, r.port = null, r.host && (b[0] === "" ? b[0] = r.host : b.unshift(r.host)), r.host = null), w = w && (b[0] === "" || E[0] === "")), m) t.host = r.host || r.host === "" ? r.host : t.host, t.hostname = r.hostname || r.hostname === "" ? r.hostname : t.hostname, t.search = r.search, t.query = r.query, E = b;
    else if (b.length) E || (E = []), E.pop(), E = E.concat(b), t.search = r.search, t.query = r.query;
    else if (!Pi.isNullOrUndefined(r.search)) {
        if (R) {
            t.hostname = t.host = E.shift();
            var L = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : !1;
            L && (t.auth = L.shift(), t.host = t.hostname = L.shift())
        }
        return t.search = r.search, t.query = r.query, (!Pi.isNull(t.pathname) || !Pi.isNull(t.search)) && (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.href = t.format(), t
    }
    if (!E.length) return t.pathname = null, t.search ? t.path = "/" + t.search : t.path = null, t.href = t.format(), t;
    for (var V = E.slice(-1)[0], z = (t.host || r.host || E.length > 1) && (V === "." || V === "..") || V === "", j = 0, Y = E.length; Y >= 0; Y--) V = E[Y], V === "." ? E.splice(Y, 1) : V === ".." ? (E.splice(Y, 1), j++) : j && (E.splice(Y, 1), j--);
    if (!w && !T)
        for (; j--; j) E.unshift("..");
    w && E[0] !== "" && (!E[0] || E[0].charAt(0) !== "/") && E.unshift(""), z && E.join("/").substr(-1) !== "/" && E.push("");
    var q = E[0] === "" || E[0] && E[0].charAt(0) === "/";
    if (R) {
        t.hostname = t.host = q ? "" : E.length ? E.shift() : "";
        var L = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : !1;
        L && (t.auth = L.shift(), t.host = t.hostname = L.shift())
    }
    return w = w || t.host && E.length, w && !q && E.unshift(""), E.length ? t.pathname = E.join("/") : (t.pathname = null, t.path = null), (!Pi.isNull(t.pathname) || !Pi.isNull(t.search)) && (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.auth = r.auth || t.auth, t.slashes = t.slashes || r.slashes, t.href = t.format(), t
};
Mi.prototype.parseHost = function() {
    var r = this.host,
        e = Ete.exec(r);
    e && (e = e[0], e !== ":" && (this.port = e.substr(1)), r = r.substr(0, r.length - e.length)), r && (this.hostname = r)
};
var Ote = "_self",
    Pte = o(function(r) {
        var e = window.open(r, Ote);
        return e ? Promise.resolve(e) : Promise.reject()
    }, "launchUri"),
    Nte = o(function(r) {
        window.sessionStorage.setItem("oauth_state", r)
    }, "setState"),
    Dte = o(function() {
        var r = window.sessionStorage.getItem("oauth_state");
        return window.sessionStorage.removeItem("oauth_state"), r
    }, "getState"),
    Lte = o(function(r) {
        window.sessionStorage.setItem("ouath_pkce_key", r)
    }, "setPKCE"),
    xte = o(function() {
        var r = window.sessionStorage.getItem("ouath_pkce_key");
        return window.sessionStorage.removeItem("ouath_pkce_key"), r
    }, "getPKCE"),
    Ute = typeof Symbol != "undefined" && typeof Symbol.for == "function" ? Symbol.for("amplify_default") : "@@amplify_default",
    ME = o(function(r, e, t) {
        Oi.dispatch("auth", {
            event: r,
            data: e,
            message: t
        }, "Auth", Ute)
    }, "dispatchAuthEvent$1"),
    Ja = new Ln("OAuth"),
    Mte = (function() {
        function r(e) {
            var t = e.config,
                n = e.cognitoClientId,
                i = e.scopes,
                s = i === void 0 ? [] : i;
            if (this._urlOpener = t.urlOpener || Pte, this._config = t, this._cognitoClientId = n, !this.isValidScopes(s)) throw Error("scopes must be a String Array");
            this._scopes = s
        }
        return o(r, "OAuth"), r.prototype.isValidScopes = function(e) {
            return Array.isArray(e) && e.every(function(t) {
                return typeof t == "string"
            })
        }, r.prototype.oauthSignIn = function(e, t, n, i, s, a) {
            e === void 0 && (e = "code"), s === void 0 && (s = Ip.Cognito);
            var u = this._generateState(32),
                l = a ? u + "-" + fZ(a) : u;
            Nte(l);
            var c = this._generateRandom(128);
            Lte(c);
            var d = this._generateChallenge(c),
                f = "S256",
                h = this._scopes.join(" "),
                g = Object.entries(Kt(Kt({
                    redirect_uri: n,
                    response_type: e,
                    client_id: i,
                    identity_provider: s,
                    scope: h,
                    state: l
                }, e === "code" ? {
                    code_challenge: d
                } : {}), e === "code" ? {
                    code_challenge_method: f
                } : {})).map(function(m) {
                    var w = dn(m, 2),
                        T = w[0],
                        E = w[1];
                    return encodeURIComponent(T) + "=" + encodeURIComponent(E)
                }).join("&"),
                p = "https://" + t + "/oauth2/authorize?" + g;
            Ja.debug("Redirecting to " + p), this._urlOpener(p, n)
        }, r.prototype._handleCodeFlow = function(e) {
            return be(this, void 0, void 0, function() {
                var t, n, i, s, a, u, l, c, d, f, h, g, p, m, w, T;
                return Ze(this, function(E) {
                    switch (E.label) {
                        case 0:
                            return t = (Es(e).query || "").split("&").map(function(b) {
                                return b.split("=")
                            }).reduce(function(b, R) {
                                var L, V = dn(R, 2),
                                    z = V[0],
                                    j = V[1];
                                return Kt(Kt({}, b), (L = {}, L[z] = j, L))
                            }, {
                                code: void 0
                            }).code, n = Es(e).pathname || "/", i = Es(this._config.redirectSignIn).pathname || "/", !t || n !== i ? [2] : (s = "https://" + this._config.domain + "/oauth2/token", ME("codeFlow", {}, "Retrieving tokens from " + s), a = Ao(this._config) ? this._cognitoClientId : this._config.clientID, u = Ao(this._config) ? this._config.redirectSignIn : this._config.redirectUri, l = xte(), c = Kt({
                                grant_type: "authorization_code",
                                code: t,
                                client_id: a,
                                redirect_uri: u
                            }, l ? {
                                code_verifier: l
                            } : {}), Ja.debug("Calling token endpoint: " + s + " with", c), d = Object.entries(c).map(function(b) {
                                var R = dn(b, 2),
                                    L = R[0],
                                    V = R[1];
                                return encodeURIComponent(L) + "=" + encodeURIComponent(V)
                            }).join("&"), f = {
                                category: VE.Auth,
                                action: HE.FederatedSignIn
                            }, [4, fetch(s, {
                                method: "POST",
                                headers: (T = {
                                    "Content-Type": "application/x-www-form-urlencoded"
                                }, T[qQ] = Eb(f), T),
                                body: d
                            })]);
                        case 1:
                            return [4, E.sent().json()];
                        case 2:
                            if (h = E.sent(), g = h.access_token, p = h.refresh_token, m = h.id_token, w = h.error, w) throw new Error(w);
                            return [2, {
                                accessToken: g,
                                refreshToken: p,
                                idToken: m
                            }]
                    }
                })
            })
        }, r.prototype._handleImplicitFlow = function(e) {
            return be(this, void 0, void 0, function() {
                var t, n, i;
                return Ze(this, function(s) {
                    return t = (Es(e).hash || "#").substr(1).split("&").map(function(a) {
                        return a.split("=")
                    }).reduce(function(a, u) {
                        var l, c = dn(u, 2),
                            d = c[0],
                            f = c[1];
                        return Kt(Kt({}, a), (l = {}, l[d] = f, l))
                    }, {
                        id_token: void 0,
                        access_token: void 0
                    }), n = t.id_token, i = t.access_token, ME("implicitFlow", {}, "Got tokens from " + e), Ja.debug("Retrieving implicit tokens from " + e + " with"), [2, {
                        accessToken: i,
                        idToken: n,
                        refreshToken: null
                    }]
                })
            })
        }, r.prototype.handleAuthResponse = function(e) {
            return be(this, void 0, void 0, function() {
                var t, n, i, s, a, u, l;
                return Ze(this, function(c) {
                    switch (c.label) {
                        case 0:
                            if (c.trys.push([0, 5, , 6]), t = e ? Kt(Kt({}, (Es(e).hash || "#").substr(1).split("&").map(function(d) {
                                    return d.split("=")
                                }).reduce(function(d, f) {
                                    var h = dn(f, 2),
                                        g = h[0],
                                        p = h[1];
                                    return d[g] = p, d
                                }, {})), (Es(e).query || "").split("&").map(function(d) {
                                    return d.split("=")
                                }).reduce(function(d, f) {
                                    var h = dn(f, 2),
                                        g = h[0],
                                        p = h[1];
                                    return d[g] = p, d
                                }, {})) : {}, n = t.error, i = t.error_description, n) throw new Error(i);
                            return s = this._validateState(t), Ja.debug("Starting " + this._config.responseType + " flow with " + e), this._config.responseType !== "code" ? [3, 2] : (a = [{}], [4, this._handleCodeFlow(e)]);
                        case 1:
                            return [2, Kt.apply(void 0, [Kt.apply(void 0, a.concat([c.sent()])), {
                                state: s
                            }])];
                        case 2:
                            return u = [{}], [4, this._handleImplicitFlow(e)];
                        case 3:
                            return [2, Kt.apply(void 0, [Kt.apply(void 0, u.concat([c.sent()])), {
                                state: s
                            }])];
                        case 4:
                            return [3, 6];
                        case 5:
                            throw l = c.sent(), Ja.debug("Error handling auth response.", l), l;
                        case 6:
                            return [2]
                    }
                })
            })
        }, r.prototype._validateState = function(e) {
            if (e) {
                var t = Dte(),
                    n = e.state;
                if (t && t !== n) throw new Error("Invalid state in OAuth flow");
                return n
            }
        }, r.prototype.signOut = function() {
            return be(this, void 0, void 0, function() {
                var e, t, n;
                return Ze(this, function(i) {
                    return e = "https://" + this._config.domain + "/logout?", t = Ao(this._config) ? this._cognitoClientId : this._config.oauth.clientID, n = Ao(this._config) ? this._config.redirectSignOut : this._config.returnTo, e += Object.entries({
                        client_id: t,
                        logout_uri: encodeURIComponent(n)
                    }).map(function(s) {
                        var a = dn(s, 2),
                            u = a[0],
                            l = a[1];
                        return u + "=" + l
                    }).join("&"), ME("oAuthSignOut", {
                        oAuth: "signOut"
                    }, "Signing out from " + e), Ja.debug("Signing out from " + e), [2, this._urlOpener(e, n)]
                })
            })
        }, r.prototype._generateState = function(e) {
            for (var t = "", n = e, i = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; n > 0; --n) t += i[Math.round(Math.random() * (i.length - 1))];
            return t
        }, r.prototype._generateChallenge = function(e) {
            var t = new Co.Sha256;
            t.update(e);
            var n = t.digestSync(),
                i = wt.Buffer.from(n).toString("base64"),
                s = this._base64URL(i);
            return s
        }, r.prototype._base64URL = function(e) {
            return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_")
        }, r.prototype._generateRandom = function(e) {
            var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",
                n = new Uint8Array(e);
            if (typeof window != "undefined" && window.crypto) window.crypto.getRandomValues(n);
            else
                for (var i = 0; i < e; i += 1) n[i] = Math.random() * t.length | 0;
            return this._bufferToString(n)
        }, r.prototype._bufferToString = function(e) {
            for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", n = [], i = 0; i < e.byteLength; i += 1) {
                var s = e[i] % t.length;
                n.push(t[s])
            }
            return n.join("")
        }, r
    })(),
    kte = o(function(r) {
        if (ki().isBrowser && window.location) {
            var e = window.location.href;
            r({
                url: e
            })
        } else if (!ki().isNode) throw new Error("Not supported")
    }, "urlListener"),
    gr;
(function(r) {
    r.DEFAULT_MSG = "Authentication Error", r.EMPTY_EMAIL = "Email cannot be empty", r.EMPTY_PHONE = "Phone number cannot be empty", r.EMPTY_USERNAME = "Username cannot be empty", r.INVALID_USERNAME = "The username should either be a string or one of the sign in types", r.EMPTY_PASSWORD = "Password cannot be empty", r.EMPTY_CODE = "Confirmation code cannot be empty", r.SIGN_UP_ERROR = "Error creating account", r.NO_MFA = "No valid MFA method provided", r.INVALID_MFA = "Invalid MFA type", r.EMPTY_CHALLENGE = "Challenge response cannot be empty", r.NO_USER_SESSION = "Failed to get the session because the user is empty", r.NETWORK_ERROR = "Network Error", r.DEVICE_CONFIG = "Device tracking has not been configured in this User Pool", r.AUTOSIGNIN_ERROR = "Please use your credentials to sign in"
})(gr || (gr = {}));
var Fte = new Ln("AuthError"),
    ws = (function(r) {
        zp(e, r);

        function e(t) {
            var n = this,
                i = Bte[t],
                s = i.message,
                a = i.log;
            return n = r.call(this, s) || this, n.constructor = e, Object.setPrototypeOf(n, e.prototype), n.name = "AuthError", n.log = a || s, Fte.error(n.log), n
        }
        return o(e, "AuthError"), e
    })(Error),
    $te = (function(r) {
        zp(e, r);

        function e(t) {
            var n = r.call(this, t) || this;
            return n.constructor = e, Object.setPrototypeOf(n, e.prototype), n.name = "NoUserPoolError", n
        }
        return o(e, "NoUserPoolError"), e
    })(ws),
    Bte = {
        noConfig: {
            message: gr.DEFAULT_MSG,
            log: `
            Error: Amplify has not been configured correctly.
            This error is typically caused by one of the following scenarios:

            1. Make sure you're passing the awsconfig object to Amplify.configure() in your app's entry point
                See https://aws-amplify.github.io/docs/js/authentication#configure-your-app for more information
            
            2. There might be multiple conflicting versions of amplify packages in your node_modules.
				Refer to our docs site for help upgrading Amplify packages (https://docs.amplify.aws/lib/troubleshooting/upgrading/q/platform/js)
        `
        },
        missingAuthConfig: {
            message: gr.DEFAULT_MSG,
            log: `
            Error: Amplify has not been configured correctly. 
            The configuration object is missing required auth properties.
            This error is typically caused by one of the following scenarios:

            1. Did you run \`amplify push\` after adding auth via \`amplify add auth\`?
                See https://aws-amplify.github.io/docs/js/authentication#amplify-project-setup for more information

            2. This could also be caused by multiple conflicting versions of amplify packages, see (https://docs.amplify.aws/lib/troubleshooting/upgrading/q/platform/js) for help upgrading Amplify packages.
        `
        },
        emptyUsername: {
            message: gr.EMPTY_USERNAME
        },
        invalidUsername: {
            message: gr.INVALID_USERNAME
        },
        emptyPassword: {
            message: gr.EMPTY_PASSWORD
        },
        emptyCode: {
            message: gr.EMPTY_CODE
        },
        signUpError: {
            message: gr.SIGN_UP_ERROR,
            log: "The first parameter should either be non-null string or object"
        },
        noMFA: {
            message: gr.NO_MFA
        },
        invalidMFA: {
            message: gr.INVALID_MFA
        },
        emptyChallengeResponse: {
            message: gr.EMPTY_CHALLENGE
        },
        noUserSession: {
            message: gr.NO_USER_SESSION
        },
        deviceConfig: {
            message: gr.DEVICE_CONFIG
        },
        networkError: {
            message: gr.NETWORK_ERROR
        },
        autoSignInError: {
            message: gr.AUTOSIGNIN_ERROR
        },
        default: {
            message: gr.DEFAULT_MSG
        }
    },
    le = new Ln("AuthClass"),
    YD = "aws.cognito.signin.user.admin",
    Vte = 10 * 1e3,
    Hte = typeof Symbol != "undefined" && typeof Symbol.for == "function" ? Symbol.for("amplify_default") : "@@amplify_default",
    Ke = o(function(r, e, t) {
        Oi.dispatch("auth", {
            event: r,
            data: e,
            message: t
        }, "Auth", Hte)
    }, "dispatchAuthEvent"),
    jte = 60,
    Wte = 180 * 1e3,
    Gte = (function() {
        function r(e) {
            var t = this;
            this.userPool = null, this.user = null, this.oAuthFlowInProgress = !1, this.autoSignInInitiated = !1, this.inflightSessionPromise = null, this.inflightSessionPromiseCounter = 0, this.Credentials = KL, this.wrapRefreshSessionCallback = function(n) {
                var i = o(function(s, a) {
                    return a ? Ke("tokenRefresh", void 0, "New token retrieved") : Ke("tokenRefresh_failure", s, "Failed to retrieve new token"), n(s, a)
                }, "wrapped");
                return i
            }, this.configure(e), this.currentCredentials = this.currentCredentials.bind(this), this.currentUserCredentials = this.currentUserCredentials.bind(this), Oi.listen("auth", function(n) {
                var i = n.payload,
                    s = i.event;
                switch (s) {
                    case "verify":
                    case "signIn":
                        t._storage.setItem("amplify-signin-with-hostedUI", "false");
                        break;
                    case "signOut":
                        t._storage.removeItem("amplify-signin-with-hostedUI");
                        break;
                    case "cognitoHostedUI":
                        t._storage.setItem("amplify-signin-with-hostedUI", "true");
                        break
                }
            }), rte(), GD(OE.framework), OE.observeFrameworkChanges(function() {
                GD(OE.framework)
            })
        }
        return o(r, "AuthClass"), r.prototype.getModuleName = function() {
            return "Auth"
        }, r.prototype.configure = function(e) {
            var t = this;
            if (!e) return this._config || {};
            le.debug("configure Auth");
            var n = Object.assign({}, this._config, FL(e).Auth, e);
            this._config = n;
            var i = this._config,
                s = i.userPoolId,
                a = i.userPoolWebClientId,
                u = i.cookieStorage,
                l = i.oauth,
                c = i.region,
                d = i.identityPoolId,
                f = i.mandatorySignIn,
                h = i.refreshHandlers,
                g = i.identityPoolRegion,
                p = i.clientMetadata,
                m = i.endpoint,
                w = i.storage;
            if (!w) u ? this._storage = new gte(u) : this._storage = e.ssr ? new zQ : new $L().getStorage();
            else {
                if (!this._isValidAuthStorage(w)) throw le.error("The storage in the Auth config is not valid!"), new Error("Empty storage object");
                this._storage = w
            }
            if (this._storageSync = Promise.resolve(), typeof this._storage.sync == "function" && (this._storageSync = this._storage.sync()), s) {
                var T = {
                    UserPoolId: s,
                    ClientId: a,
                    endpoint: m
                };
                T.Storage = this._storage, this.userPool = new hte(T, this.wrapRefreshSessionCallback)
            }
            this.Credentials.configure({
                mandatorySignIn: f,
                region: c,
                userPoolId: s,
                identityPoolId: d,
                refreshHandlers: h,
                storage: this._storage,
                identityPoolRegion: g
            });
            var E = l ? Ao(this._config.oauth) ? l : l.awsCognito : void 0;
            if (E) {
                var b = Object.assign({
                    cognitoClientId: a,
                    UserPoolId: s,
                    domain: E.domain,
                    scopes: E.scope,
                    redirectSignIn: E.redirectSignIn,
                    redirectSignOut: E.redirectSignOut,
                    responseType: E.responseType,
                    Storage: this._storage,
                    urlOpener: E.urlOpener,
                    clientMetadata: p
                }, E.options);
                this._oAuthHandler = new Mte({
                    scopes: b.scopes,
                    config: b,
                    cognitoClientId: b.cognitoClientId
                });
                var R = {};
                kte(function(V) {
                    var z = V.url;
                    R[z] || (R[z] = !0, t._handleAuthResponse(z))
                })
            }
            if (Ke("configured", null, "The Auth category has been configured successfully"), !this.autoSignInInitiated && typeof this._storage.getItem == "function") {
                var L = this.isTrueStorageValue("amplify-polling-started");
                L && (Ke("autoSignIn_failure", null, at.AutoSignInError), this._storage.removeItem("amplify-auto-sign-in")), this._storage.removeItem("amplify-polling-started")
            }
            return this._config
        }, r.prototype.signUp = function(e) {
            for (var t = this, n = [], i = 1; i < arguments.length; i++) n[i - 1] = arguments[i];
            var s, a, u;
            if (!this.userPool) return this.rejectNoUserPool();
            var l = null,
                c = null,
                d = [],
                f = null,
                h, g = {
                    enabled: !1
                },
                p = {},
                m = {};
            if (e && typeof e == "string") {
                l = e, c = n ? n[0] : null;
                var w = n ? n[1] : null,
                    T = n ? n[2] : null;
                w && d.push(new Za({
                    Name: "email",
                    Value: w
                })), T && d.push(new Za({
                    Name: "phone_number",
                    Value: T
                }))
            } else if (e && typeof e == "object") {
                l = e.username, c = e.password, e && e.clientMetadata ? h = e.clientMetadata : this._config.clientMetadata && (h = this._config.clientMetadata);
                var E = e.attributes;
                E && Object.keys(E).map(function(R) {
                    d.push(new Za({
                        Name: R,
                        Value: E[R]
                    }))
                });
                var b = e.validationData;
                b && (f = [], Object.keys(b).map(function(R) {
                    f.push(new Za({
                        Name: R,
                        Value: b[R]
                    }))
                })), g = (s = e.autoSignIn) !== null && s !== void 0 ? s : {
                    enabled: !1
                }, g.enabled && (this._storage.setItem("amplify-auto-sign-in", "true"), p = (a = g.validationData) !== null && a !== void 0 ? a : {}, m = (u = g.clientMetaData) !== null && u !== void 0 ? u : {})
            } else return this.rejectAuthError(at.SignUpError);
            return l ? c ? (le.debug("signUp attrs:", d), le.debug("signUp validation data:", f), new Promise(function(R, L) {
                t.userPool.signUp(l, c, d, f, function(V, z) {
                    V ? (Ke("signUp_failure", V, l + " failed to signup"), L(V)) : (Ke("signUp", z, l + " has signed up successfully"), g.enabled && t.handleAutoSignIn(l, c, p, m, z), R(z))
                }, h)
            })) : this.rejectAuthError(at.EmptyPassword) : this.rejectAuthError(at.EmptyUsername)
        }, r.prototype.handleAutoSignIn = function(e, t, n, i, s) {
            this.autoSignInInitiated = !0;
            var a = new FD({
                Username: e,
                Password: t,
                ValidationData: n,
                ClientMetadata: i
            });
            s.userConfirmed ? this.signInAfterUserConfirmed(a) : this._config.signUpVerificationMethod === "link" ? this.handleLinkAutoSignIn(a) : this.handleCodeAutoSignIn(a)
        }, r.prototype.handleCodeAutoSignIn = function(e) {
            var t = this,
                n = o(function(i) {
                    var s = i.payload;
                    s.event === "confirmSignUp" && t.signInAfterUserConfirmed(e, n)
                }, "listenEvent");
            Oi.listen("auth", n)
        }, r.prototype.handleLinkAutoSignIn = function(e) {
            var t = this;
            this._storage.setItem("amplify-polling-started", "true");
            var n = Date.now(),
                i = setInterval(function() {
                    Date.now() - n > Wte ? (clearInterval(i), Ke("autoSignIn_failure", null, "Please confirm your account and use your credentials to sign in."), t._storage.removeItem("amplify-auto-sign-in")) : t.signInAfterUserConfirmed(e, null, i)
                }, 5e3)
        }, r.prototype.signInAfterUserConfirmed = function(e, t, n) {
            return be(this, void 0, void 0, function() {
                var i, s, a = this;
                return Ze(this, function(u) {
                    switch (u.label) {
                        case 0:
                            i = this.createCognitoUser(e.getUsername()), u.label = 1;
                        case 1:
                            return u.trys.push([1, 3, , 4]), [4, i.authenticateUser(e, this.authCallbacks(i, function(l) {
                                Ke("autoSignIn", l, e.getUsername() + " has signed in successfully"), t && Oi.remove("auth", t), n && (clearInterval(n), a._storage.removeItem("amplify-polling-started")), a._storage.removeItem("amplify-auto-sign-in")
                            }, function(l) {
                                le.error(l), a._storage.removeItem("amplify-auto-sign-in")
                            }))];
                        case 2:
                            return u.sent(), [3, 4];
                        case 3:
                            return s = u.sent(), le.error(s), [3, 4];
                        case 4:
                            return [2]
                    }
                })
            })
        }, r.prototype.confirmSignUp = function(e, t, n) {
            var i = this;
            if (!this.userPool) return this.rejectNoUserPool();
            if (!e) return this.rejectAuthError(at.EmptyUsername);
            if (!t) return this.rejectAuthError(at.EmptyCode);
            var s = this.createCognitoUser(e),
                a = n && typeof n.forceAliasCreation == "boolean" ? n.forceAliasCreation : !0,
                u;
            return n && n.clientMetadata ? u = n.clientMetadata : this._config.clientMetadata && (u = this._config.clientMetadata), new Promise(function(l, c) {
                s.confirmRegistration(t, a, function(d, f) {
                    if (d) c(d);
                    else {
                        Ke("confirmSignUp", f, e + " has been confirmed successfully");
                        var h = i.isTrueStorageValue("amplify-auto-sign-in");
                        h && !i.autoSignInInitiated && (Ke("autoSignIn_failure", null, at.AutoSignInError), i._storage.removeItem("amplify-auto-sign-in")), l(f)
                    }
                }, u)
            })
        }, r.prototype.isTrueStorageValue = function(e) {
            var t = this._storage.getItem(e);
            return t ? t === "true" : !1
        }, r.prototype.resendSignUp = function(e, t) {
            if (t === void 0 && (t = this._config.clientMetadata), !this.userPool) return this.rejectNoUserPool();
            if (!e) return this.rejectAuthError(at.EmptyUsername);
            var n = this.createCognitoUser(e);
            return new Promise(function(i, s) {
                n.resendConfirmationCode(function(a, u) {
                    a ? s(a) : i(u)
                }, t)
            })
        }, r.prototype.signIn = function(e, t, n) {
            if (n === void 0 && (n = this._config.clientMetadata), !this.userPool) return this.rejectNoUserPool();
            var i = null,
                s = null,
                a = {};
            if (typeof e == "string") i = e, s = t;
            else if (AJ(e)) typeof t != "undefined" && le.warn("The password should be defined under the first parameter object!"), i = e.username, s = e.password, a = e.validationData;
            else return this.rejectAuthError(at.InvalidUsername);
            if (!i) return this.rejectAuthError(at.EmptyUsername);
            var u = new FD({
                Username: i,
                Password: s,
                ValidationData: a,
                ClientMetadata: n
            });
            return s ? this.signInWithPassword(u) : this.signInWithoutPassword(u)
        }, r.prototype.authCallbacks = function(e, t, n) {
            var i = this,
                s = this;
            return {
                onSuccess: o(function(a) {
                    return be(i, void 0, void 0, function() {
                        var u, l, c, d;
                        return Ze(this, function(f) {
                            switch (f.label) {
                                case 0:
                                    le.debug(a), delete e.challengeName, delete e.challengeParam, f.label = 1;
                                case 1:
                                    return f.trys.push([1, 4, 5, 9]), [4, this.Credentials.clear()];
                                case 2:
                                    return f.sent(), [4, this.Credentials.set(a, "session")];
                                case 3:
                                    return u = f.sent(), le.debug("succeed to get cognito credentials", u), [3, 9];
                                case 4:
                                    return l = f.sent(), le.debug("cannot get cognito credentials", l), [3, 9];
                                case 5:
                                    return f.trys.push([5, 7, , 8]), [4, this.currentUserPoolUser()];
                                case 6:
                                    return c = f.sent(), s.user = c, Ke("signIn", c, "A user " + e.getUsername() + " has been signed in"), t(c), [3, 8];
                                case 7:
                                    return d = f.sent(), le.error("Failed to get the signed in user", d), n(d), [3, 8];
                                case 8:
                                    return [7];
                                case 9:
                                    return [2]
                            }
                        })
                    })
                }, "onSuccess"),
                onFailure: o(function(a) {
                    le.debug("signIn failure", a), Ke("signIn_failure", a, e.getUsername() + " failed to signin"), n(a)
                }, "onFailure"),
                customChallenge: o(function(a) {
                    le.debug("signIn custom challenge answer required"), e.challengeName = "CUSTOM_CHALLENGE", e.challengeParam = a, t(e)
                }, "customChallenge"),
                mfaRequired: o(function(a, u) {
                    le.debug("signIn MFA required"), e.challengeName = a, e.challengeParam = u, t(e)
                }, "mfaRequired"),
                mfaSetup: o(function(a, u) {
                    le.debug("signIn mfa setup", a), e.challengeName = a, e.challengeParam = u, t(e)
                }, "mfaSetup"),
                newPasswordRequired: o(function(a, u) {
                    le.debug("signIn new password"), e.challengeName = "NEW_PASSWORD_REQUIRED", e.challengeParam = {
                        userAttributes: a,
                        requiredAttributes: u
                    }, t(e)
                }, "newPasswordRequired"),
                totpRequired: o(function(a, u) {
                    le.debug("signIn totpRequired"), e.challengeName = a, e.challengeParam = u, t(e)
                }, "totpRequired"),
                selectMFAType: o(function(a, u) {
                    le.debug("signIn selectMFAType", a), e.challengeName = a, e.challengeParam = u, t(e)
                }, "selectMFAType")
            }
        }, r.prototype.signInWithPassword = function(e) {
            var t = this;
            if (this.pendingSignIn) throw new Error("Pending sign-in attempt already in progress");
            var n = this.createCognitoUser(e.getUsername());
            return this.pendingSignIn = new Promise(function(i, s) {
                n.authenticateUser(e, t.authCallbacks(n, function(a) {
                    t.pendingSignIn = null, i(a)
                }, function(a) {
                    t.pendingSignIn = null, s(a)
                }))
            }), this.pendingSignIn
        }, r.prototype.signInWithoutPassword = function(e) {
            var t = this,
                n = this.createCognitoUser(e.getUsername());
            return n.setAuthenticationFlowType("CUSTOM_AUTH"), new Promise(function(i, s) {
                n.initiateAuth(e, t.authCallbacks(n, i, s))
            })
        }, r.prototype.getMFAOptions = function(e) {
            return new Promise(function(t, n) {
                e.getMFAOptions(function(i, s) {
                    if (i) {
                        le.debug("get MFA Options failed", i), n(i);
                        return
                    }
                    le.debug("get MFA options success", s), t(s)
                })
            })
        }, r.prototype.getPreferredMFA = function(e, t) {
            var n = this,
                i = this;
            return new Promise(function(s, a) {
                var u = n._config.clientMetadata,
                    l = t ? t.bypassCache : !1;
                e.getUserData(function(c, d) {
                    return be(n, void 0, void 0, function() {
                        var f, h;
                        return Ze(this, function(g) {
                            switch (g.label) {
                                case 0:
                                    if (!c) return [3, 5];
                                    if (le.debug("getting preferred mfa failed", c), !this.isSessionInvalid(c)) return [3, 4];
                                    g.label = 1;
                                case 1:
                                    return g.trys.push([1, 3, , 4]), [4, this.cleanUpInvalidSession(e)];
                                case 2:
                                    return g.sent(), [3, 4];
                                case 3:
                                    return f = g.sent(), a(new Error("Session is invalid due to: " + c.message + " and failed to clean up invalid session: " + f.message)), [2];
                                case 4:
                                    return a(c), [2];
                                case 5:
                                    return h = i._getMfaTypeFromUserData(d), h ? (s(h), [2]) : (a("invalid MFA Type"), [2])
                            }
                        })
                    })
                }, {
                    bypassCache: l,
                    clientMetadata: u
                })
            })
        }, r.prototype._getMfaTypeFromUserData = function(e) {
            var t = null,
                n = e.PreferredMfaSetting;
            if (n) t = n;
            else {
                var i = e.UserMFASettingList;
                if (i) i.length === 0 ? t = "NOMFA" : le.debug("invalid case for getPreferredMFA", e);
                else {
                    var s = e.MFAOptions;
                    s ? t = "SMS_MFA" : t = "NOMFA"
                }
            }
            return t
        }, r.prototype._getUserData = function(e, t) {
            var n = this;
            return new Promise(function(i, s) {
                e.getUserData(function(a, u) {
                    return be(n, void 0, void 0, function() {
                        var l;
                        return Ze(this, function(c) {
                            switch (c.label) {
                                case 0:
                                    if (!a) return [3, 5];
                                    if (le.debug("getting user data failed", a), !this.isSessionInvalid(a)) return [3, 4];
                                    c.label = 1;
                                case 1:
                                    return c.trys.push([1, 3, , 4]), [4, this.cleanUpInvalidSession(e)];
                                case 2:
                                    return c.sent(), [3, 4];
                                case 3:
                                    return l = c.sent(), s(new Error("Session is invalid due to: " + a.message + " and failed to clean up invalid session: " + l.message)), [2];
                                case 4:
                                    return s(a), [2];
                                case 5:
                                    i(u), c.label = 6;
                                case 6:
                                    return [2]
                            }
                        })
                    })
                }, t)
            })
        }, r.prototype.setPreferredMFA = function(e, t) {
            return be(this, void 0, void 0, function() {
                var n, i, s, a, u, l, c, d = this;
                return Ze(this, function(f) {
                    switch (f.label) {
                        case 0:
                            return n = this._config.clientMetadata, [4, this._getUserData(e, {
                                bypassCache: !0,
                                clientMetadata: n
                            })];
                        case 1:
                            switch (i = f.sent(), s = null, a = null, u = t, u) {
                                case "TOTP":
                                    return [3, 2];
                                case "SOFTWARE_TOKEN_MFA":
                                    return [3, 2];
                                case "SMS":
                                    return [3, 3];
                                case "SMS_MFA":
                                    return [3, 3];
                                case "NOMFA":
                                    return [3, 4]
                            }
                            return [3, 6];
                        case 2:
                            return a = {
                                PreferredMfa: !0,
                                Enabled: !0
                            }, [3, 7];
                        case 3:
                            return s = {
                                PreferredMfa: !0,
                                Enabled: !0
                            }, [3, 7];
                        case 4:
                            return l = i.UserMFASettingList, [4, this._getMfaTypeFromUserData(i)];
                        case 5:
                            if (c = f.sent(), c === "NOMFA") return [2, Promise.resolve("No change for mfa type")];
                            if (c === "SMS_MFA") s = {
                                PreferredMfa: !1,
                                Enabled: !1
                            };
                            else if (c === "SOFTWARE_TOKEN_MFA") a = {
                                PreferredMfa: !1,
                                Enabled: !1
                            };
                            else return [2, this.rejectAuthError(at.InvalidMFA)];
                            return l && l.length !== 0 && l.forEach(function(h) {
                                h === "SMS_MFA" ? s = {
                                    PreferredMfa: !1,
                                    Enabled: !1
                                } : h === "SOFTWARE_TOKEN_MFA" && (a = {
                                    PreferredMfa: !1,
                                    Enabled: !1
                                })
                            }), [3, 7];
                        case 6:
                            return le.debug("no validmfa method provided"), [2, this.rejectAuthError(at.NoMFA)];
                        case 7:
                            return [2, new Promise(function(h, g) {
                                e.setUserMfaPreference(s, a, function(p, m) {
                                    if (p) return le.debug("Set user mfa preference error", p), g(p);
                                    le.debug("Set user mfa success", m), le.debug("Caching the latest user data into local"), e.getUserData(function(w, T) {
                                        return be(d, void 0, void 0, function() {
                                            var E;
                                            return Ze(this, function(b) {
                                                switch (b.label) {
                                                    case 0:
                                                        if (!w) return [3, 5];
                                                        if (le.debug("getting user data failed", w), !this.isSessionInvalid(w)) return [3, 4];
                                                        b.label = 1;
                                                    case 1:
                                                        return b.trys.push([1, 3, , 4]), [4, this.cleanUpInvalidSession(e)];
                                                    case 2:
                                                        return b.sent(), [3, 4];
                                                    case 3:
                                                        return E = b.sent(), g(new Error("Session is invalid due to: " + w.message + " and failed to clean up invalid session: " + E.message)), [2];
                                                    case 4:
                                                        return [2, g(w)];
                                                    case 5:
                                                        return [2, h(m)]
                                                }
                                            })
                                        })
                                    }, {
                                        bypassCache: !0,
                                        clientMetadata: n
                                    })
                                })
                            })]
                    }
                })
            })
        }, r.prototype.disableSMS = function(e) {
            return new Promise(function(t, n) {
                e.disableMFA(function(i, s) {
                    if (i) {
                        le.debug("disable mfa failed", i), n(i);
                        return
                    }
                    le.debug("disable mfa succeed", s), t(s)
                })
            })
        }, r.prototype.enableSMS = function(e) {
            return new Promise(function(t, n) {
                e.enableMFA(function(i, s) {
                    if (i) {
                        le.debug("enable mfa failed", i), n(i);
                        return
                    }
                    le.debug("enable mfa succeed", s), t(s)
                })
            })
        }, r.prototype.setupTOTP = function(e) {
            return new Promise(function(t, n) {
                e.associateSoftwareToken({
                    onFailure: o(function(i) {
                        le.debug("associateSoftwareToken failed", i), n(i)
                    }, "onFailure"),
                    associateSecretCode: o(function(i) {
                        le.debug("associateSoftwareToken success", i), t(i)
                    }, "associateSecretCode")
                })
            })
        }, r.prototype.verifyTotpToken = function(e, t) {
            le.debug("verification totp token", e, t);
            var n;
            e && typeof e.getSignInUserSession == "function" && (n = e.getSignInUserSession());
            var i = n == null ? void 0 : n.isValid();
            return new Promise(function(s, a) {
                e.verifySoftwareToken(t, "My TOTP device", {
                    onFailure: o(function(u) {
                        le.debug("verifyTotpToken failed", u), a(u)
                    }, "onFailure"),
                    onSuccess: o(function(u) {
                        i || Ke("signIn", e, "A user " + e.getUsername() + " has been signed in"), Ke("verify", e, "A user " + e.getUsername() + " has been verified"), le.debug("verifyTotpToken success", u), s(u)
                    }, "onSuccess")
                })
            })
        }, r.prototype.confirmSignIn = function(e, t, n, i) {
            var s = this;
            if (i === void 0 && (i = this._config.clientMetadata), !t) return this.rejectAuthError(at.EmptyCode);
            var a = this;
            return new Promise(function(u, l) {
                e.sendMFACode(t, {
                    onSuccess: o(function(c) {
                        return be(s, void 0, void 0, function() {
                            var d, f, h, g;
                            return Ze(this, function(p) {
                                switch (p.label) {
                                    case 0:
                                        le.debug(c), p.label = 1;
                                    case 1:
                                        return p.trys.push([1, 4, 5, 10]), [4, this.Credentials.clear()];
                                    case 2:
                                        return p.sent(), [4, this.Credentials.set(c, "session")];
                                    case 3:
                                        return d = p.sent(), le.debug("succeed to get cognito credentials", d), [3, 10];
                                    case 4:
                                        return f = p.sent(), le.debug("cannot get cognito credentials", f), [3, 10];
                                    case 5:
                                        a.user = e, p.label = 6;
                                    case 6:
                                        return p.trys.push([6, 8, , 9]), [4, this.currentUserPoolUser()];
                                    case 7:
                                        return h = p.sent(), e.attributes = h.attributes, [3, 9];
                                    case 8:
                                        return g = p.sent(), le.debug("cannot get updated Cognito User", g), [3, 9];
                                    case 9:
                                        return Ke("signIn", e, "A user " + e.getUsername() + " has been signed in"), u(e), [7];
                                    case 10:
                                        return [2]
                                }
                            })
                        })
                    }, "onSuccess"),
                    onFailure: o(function(c) {
                        le.debug("confirm signIn failure", c), l(c)
                    }, "onFailure")
                }, n, i)
            })
        }, r.prototype.completeNewPassword = function(e, t, n, i) {
            var s = this;
            if (n === void 0 && (n = {}), i === void 0 && (i = this._config.clientMetadata), !t) return this.rejectAuthError(at.EmptyPassword);
            var a = this;
            return new Promise(function(u, l) {
                e.completeNewPasswordChallenge(t, n, {
                    onSuccess: o(function(c) {
                        return be(s, void 0, void 0, function() {
                            var d, f;
                            return Ze(this, function(h) {
                                switch (h.label) {
                                    case 0:
                                        le.debug(c), h.label = 1;
                                    case 1:
                                        return h.trys.push([1, 4, 5, 6]), [4, this.Credentials.clear()];
                                    case 2:
                                        return h.sent(), [4, this.Credentials.set(c, "session")];
                                    case 3:
                                        return d = h.sent(), le.debug("succeed to get cognito credentials", d), [3, 6];
                                    case 4:
                                        return f = h.sent(), le.debug("cannot get cognito credentials", f), [3, 6];
                                    case 5:
                                        return a.user = e, Ke("signIn", e, "A user " + e.getUsername() + " has been signed in"), u(e), [7];
                                    case 6:
                                        return [2]
                                }
                            })
                        })
                    }, "onSuccess"),
                    onFailure: o(function(c) {
                        le.debug("completeNewPassword failure", c), Ke("completeNewPassword_failure", c, s.user + " failed to complete the new password flow"), l(c)
                    }, "onFailure"),
                    mfaRequired: o(function(c, d) {
                        le.debug("signIn MFA required"), e.challengeName = c, e.challengeParam = d, u(e)
                    }, "mfaRequired"),
                    mfaSetup: o(function(c, d) {
                        le.debug("signIn mfa setup", c), e.challengeName = c, e.challengeParam = d, u(e)
                    }, "mfaSetup"),
                    totpRequired: o(function(c, d) {
                        le.debug("signIn mfa setup", c), e.challengeName = c, e.challengeParam = d, u(e)
                    }, "totpRequired")
                }, i)
            })
        }, r.prototype.sendCustomChallengeAnswer = function(e, t, n) {
            var i = this;
            return n === void 0 && (n = this._config.clientMetadata), this.userPool ? t ? new Promise(function(s, a) {
                e.sendCustomChallengeAnswer(t, i.authCallbacks(e, s, a), n)
            }) : this.rejectAuthError(at.EmptyChallengeResponse) : this.rejectNoUserPool()
        }, r.prototype.deleteUserAttributes = function(e, t) {
            var n = this;
            return new Promise(function(i, s) {
                n.userSession(e).then(function(a) {
                    e.deleteAttributes(t, function(u, l) {
                        return u ? s(u) : i(l)
                    })
                })
            })
        }, r.prototype.deleteUser = function() {
            return be(this, void 0, void 0, function() {
                var e, t, n = this;
                return Ze(this, function(i) {
                    switch (i.label) {
                        case 0:
                            return i.trys.push([0, 2, , 3]), [4, this._storageSync];
                        case 1:
                            return i.sent(), [3, 3];
                        case 2:
                            throw e = i.sent(), le.debug("Failed to sync cache info into memory", e), new Error(e);
                        case 3:
                            return t = this._oAuthHandler && this._storage.getItem("amplify-signin-with-hostedUI") === "true", [2, new Promise(function(s, a) {
                                return be(n, void 0, void 0, function() {
                                    var u, l = this;
                                    return Ze(this, function(c) {
                                        if (this.userPool)
                                            if (u = this.userPool.getCurrentUser(), u) u.getSession(function(d, f) {
                                                return be(l, void 0, void 0, function() {
                                                    var h, g = this;
                                                    return Ze(this, function(p) {
                                                        switch (p.label) {
                                                            case 0:
                                                                if (!d) return [3, 5];
                                                                if (le.debug("Failed to get the user session", d), !this.isSessionInvalid(d)) return [3, 4];
                                                                p.label = 1;
                                                            case 1:
                                                                return p.trys.push([1, 3, , 4]), [4, this.cleanUpInvalidSession(u)];
                                                            case 2:
                                                                return p.sent(), [3, 4];
                                                            case 3:
                                                                return h = p.sent(), a(new Error("Session is invalid due to: " + d.message + " and failed to clean up invalid session: " + h.message)), [2];
                                                            case 4:
                                                                return [2, a(d)];
                                                            case 5:
                                                                u.deleteUser(function(m, w) {
                                                                    if (m) a(m);
                                                                    else {
                                                                        Ke("userDeleted", w, "The authenticated user has been deleted."), u.signOut(), g.user = null;
                                                                        try {
                                                                            g.cleanCachedItems()
                                                                        } catch (T) {
                                                                            le.debug("failed to clear cached items")
                                                                        }
                                                                        t ? g.oAuthSignOutRedirect(s, a) : (Ke("signOut", g.user, "A user has been signed out"), s(w))
                                                                    }
                                                                }), p.label = 6;
                                                            case 6:
                                                                return [2]
                                                        }
                                                    })
                                                })
                                            });
                                            else return le.debug("Failed to get user from user pool"), [2, a(new Error("No current user."))];
                                        else le.debug("no Congito User pool"), a(new Error("Cognito User pool does not exist"));
                                        return [2]
                                    })
                                })
                            })]
                    }
                })
            })
        }, r.prototype.updateUserAttributes = function(e, t, n) {
            var i = this;
            n === void 0 && (n = this._config.clientMetadata);
            var s = [],
                a = this;
            return new Promise(function(u, l) {
                a.userSession(e).then(function(c) {
                    for (var d in t)
                        if (d !== "sub" && d.indexOf("_verified") < 0) {
                            var f = {
                                Name: d,
                                Value: t[d]
                            };
                            s.push(f)
                        } e.updateAttributes(s, function(h, g, p) {
                        if (h) return Ke("updateUserAttributes_failure", h, "Failed to update attributes"), l(h);
                        var m = i.createUpdateAttributesResultList(t, p == null ? void 0 : p.CodeDeliveryDetailsList);
                        return Ke("updateUserAttributes", m, "Attributes successfully updated"), u(g)
                    }, n)
                })
            })
        }, r.prototype.createUpdateAttributesResultList = function(e, t) {
            var n = {};
            return Object.keys(e).forEach(function(i) {
                n[i] = {
                    isUpdated: !0
                };
                var s = t == null ? void 0 : t.find(function(a) {
                    return a.AttributeName === i
                });
                s && (n[i].isUpdated = !1, n[i].codeDeliveryDetails = s)
            }), n
        }, r.prototype.userAttributes = function(e) {
            var t = this;
            return new Promise(function(n, i) {
                t.userSession(e).then(function(s) {
                    e.getUserAttributes(function(a, u) {
                        a ? i(a) : n(u)
                    })
                })
            })
        }, r.prototype.verifiedContact = function(e) {
            var t = this;
            return this.userAttributes(e).then(function(n) {
                var i = t.attributesToObject(n),
                    s = {},
                    a = {};
                return i.email && (i.email_verified ? a.email = i.email : s.email = i.email), i.phone_number && (i.phone_number_verified ? a.phone_number = i.phone_number : s.phone_number = i.phone_number), {
                    verified: a,
                    unverified: s
                }
            })
        }, r.prototype.isErrorWithMessage = function(e) {
            return typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "message")
        }, r.prototype.isTokenRevokedError = function(e) {
            return this.isErrorWithMessage(e) && e.message === "Access Token has been revoked"
        }, r.prototype.isRefreshTokenRevokedError = function(e) {
            return this.isErrorWithMessage(e) && e.message === "Refresh Token has been revoked"
        }, r.prototype.isUserDisabledError = function(e) {
            return this.isErrorWithMessage(e) && e.message === "User is disabled."
        }, r.prototype.isUserDoesNotExistError = function(e) {
            return this.isErrorWithMessage(e) && e.message === "User does not exist."
        }, r.prototype.isRefreshTokenExpiredError = function(e) {
            return this.isErrorWithMessage(e) && e.message === "Refresh Token has expired"
        }, r.prototype.isPasswordResetRequiredError = function(e) {
            return this.isErrorWithMessage(e) && e.message === "Password reset required for the user"
        }, r.prototype.isSignedInHostedUI = function() {
            return this._oAuthHandler && this._storage.getItem("amplify-signin-with-hostedUI") === "true"
        }, r.prototype.isSessionInvalid = function(e) {
            return this.isUserDisabledError(e) || this.isUserDoesNotExistError(e) || this.isTokenRevokedError(e) || this.isRefreshTokenRevokedError(e) || this.isRefreshTokenExpiredError(e) || this.isPasswordResetRequiredError(e)
        }, r.prototype.cleanUpInvalidSession = function(e) {
            return be(this, void 0, void 0, function() {
                var t = this;
                return Ze(this, function(n) {
                    switch (n.label) {
                        case 0:
                            e.signOut(), this.user = null, n.label = 1;
                        case 1:
                            return n.trys.push([1, 3, , 4]), [4, this.cleanCachedItems()];
                        case 2:
                            return n.sent(), [3, 4];
                        case 3:
                            return n.sent(), le.debug("failed to clear cached items"), [3, 4];
                        case 4:
                            return this.isSignedInHostedUI() ? [2, new Promise(function(i, s) {
                                t.oAuthSignOutRedirect(i, s)
                            })] : (Ke("signOut", this.user, "A user has been signed out"), [2])
                    }
                })
            })
        }, r.prototype.currentUserPoolUser = function(e) {
            var t = this;
            return this.userPool ? new Promise(function(n, i) {
                t._storageSync.then(function() {
                    return be(t, void 0, void 0, function() {
                        var s, a, u, l, c, d, f, h = this;
                        return Ze(this, function(g) {
                            switch (g.label) {
                                case 0:
                                    return this.isOAuthInProgress() ? (le.debug("OAuth signIn in progress, waiting for resolution..."), [4, new Promise(function(p) {
                                        var m = setTimeout(function() {
                                            le.debug("OAuth signIn in progress timeout"), Oi.remove("auth", w), p()
                                        }, Vte);
                                        Oi.listen("auth", w);

                                        function w(T) {
                                            var E = T.payload,
                                                b = E.event;
                                            (b === "cognitoHostedUI" || b === "cognitoHostedUI_failure") && (le.debug("OAuth signIn resolved: " + b), clearTimeout(m), Oi.remove("auth", w), p())
                                        }
                                        o(w, "hostedUISignCallback")
                                    })]) : [3, 2];
                                case 1:
                                    g.sent(), g.label = 2;
                                case 2:
                                    if (s = this.userPool.getCurrentUser(), !s) return le.debug("Failed to get user from user pool"), i("No current user"), [2];
                                    g.label = 3;
                                case 3:
                                    return g.trys.push([3, 7, , 8]), [4, this._userSession(s)];
                                case 4:
                                    return a = g.sent(), u = e ? e.bypassCache : !1, u ? [4, this.Credentials.clear()] : [3, 6];
                                case 5:
                                    g.sent(), g.label = 6;
                                case 6:
                                    if (l = this._config.clientMetadata, c = a.getAccessToken().decodePayload().scope, d = c === void 0 ? "" : c, d.split(" ").includes(YD)) s.getUserData(function(p, m) {
                                        return be(h, void 0, void 0, function() {
                                            var w, T, E, b, R, L, V;
                                            return Ze(this, function(z) {
                                                switch (z.label) {
                                                    case 0:
                                                        if (!p) return [3, 7];
                                                        if (le.debug("getting user data failed", p), !this.isSessionInvalid(p)) return [3, 5];
                                                        z.label = 1;
                                                    case 1:
                                                        return z.trys.push([1, 3, , 4]), [4, this.cleanUpInvalidSession(s)];
                                                    case 2:
                                                        return z.sent(), [3, 4];
                                                    case 3:
                                                        return w = z.sent(), i(new Error("Session is invalid due to: " + p.message + " and failed to clean up invalid session: " + w.message)), [2];
                                                    case 4:
                                                        return i(p), [3, 6];
                                                    case 5:
                                                        n(s), z.label = 6;
                                                    case 6:
                                                        return [2];
                                                    case 7:
                                                        for (T = m.PreferredMfaSetting || "NOMFA", E = [], b = 0; b < m.UserAttributes.length; b++) R = {
                                                            Name: m.UserAttributes[b].Name,
                                                            Value: m.UserAttributes[b].Value
                                                        }, L = new Za(R), E.push(L);
                                                        return V = this.attributesToObject(E), Object.assign(s, {
                                                            attributes: V,
                                                            preferredMFA: T
                                                        }), [2, n(s)]
                                                }
                                            })
                                        })
                                    }, {
                                        bypassCache: u,
                                        clientMetadata: l
                                    });
                                    else return le.debug("Unable to get the user data because the " + YD + " is not in the scopes of the access token"), [2, n(s)];
                                    return [3, 8];
                                case 7:
                                    return f = g.sent(), i(f), [3, 8];
                                case 8:
                                    return [2]
                            }
                        })
                    })
                }).catch(function(s) {
                    return le.debug("Failed to sync cache info into memory", s), i(s)
                })
            }) : this.rejectNoUserPool()
        }, r.prototype.isOAuthInProgress = function() {
            return this.oAuthFlowInProgress
        }, r.prototype.currentAuthenticatedUser = function(e) {
            return be(this, void 0, void 0, function() {
                var t, n, i, s, a;
                return Ze(this, function(u) {
                    switch (u.label) {
                        case 0:
                            le.debug("getting current authenticated user"), t = null, u.label = 1;
                        case 1:
                            return u.trys.push([1, 3, , 4]), [4, this._storageSync];
                        case 2:
                            return u.sent(), [3, 4];
                        case 3:
                            throw n = u.sent(), le.debug("Failed to sync cache info into memory", n), n;
                        case 4:
                            try {
                                i = JSON.parse(this._storage.getItem("aws-amplify-federatedInfo")), i && (t = Kt(Kt({}, i.user), {
                                    token: i.token
                                }))
                            } catch (l) {
                                le.debug("cannot load federated user from auth storage")
                            }
                            return t ? (this.user = t, le.debug("get current authenticated federated user", this.user), [2, this.user]) : [3, 5];
                        case 5:
                            le.debug("get current authenticated userpool user"), s = null, u.label = 6;
                        case 6:
                            return u.trys.push([6, 8, , 9]), [4, this.currentUserPoolUser(e)];
                        case 7:
                            return s = u.sent(), [3, 9];
                        case 8:
                            return a = u.sent(), a === "No userPool" && le.error("Cannot get the current user because the user pool is missing. Please make sure the Auth module is configured with a valid Cognito User Pool ID"), le.debug("The user is not authenticated by the error", a), [2, Promise.reject("The user is not authenticated")];
                        case 9:
                            return this.user = s, [2, this.user]
                    }
                })
            })
        }, r.prototype.currentSession = function() {
            var e = this;
            return le.debug("Getting current session"), this.userPool ? new Promise(function(t, n) {
                e.currentUserPoolUser().then(function(i) {
                    e.userSession(i).then(function(s) {
                        t(s)
                    }).catch(function(s) {
                        le.debug("Failed to get the current session", s), n(s)
                    })
                }).catch(function(i) {
                    le.debug("Failed to get the current user", i), n(i)
                })
            }) : Promise.reject(new Error("No User Pool in the configuration."))
        }, r.prototype._userSession = function(e) {
            return be(this, void 0, void 0, function() {
                var t, n, i = this;
                return Ze(this, function(s) {
                    switch (s.label) {
                        case 0:
                            if (!e) return le.debug("the user is null"), [2, this.rejectAuthError(at.NoUserSession)];
                            t = this._config.clientMetadata, this.inflightSessionPromiseCounter === 0 && (this.inflightSessionPromise = new Promise(function(a, u) {
                                e.getSession(function(l, c) {
                                    return be(i, void 0, void 0, function() {
                                        var d;
                                        return Ze(this, function(f) {
                                            switch (f.label) {
                                                case 0:
                                                    if (!l) return [3, 5];
                                                    if (le.debug("Failed to get the session from user", e), !this.isSessionInvalid(l)) return [3, 4];
                                                    f.label = 1;
                                                case 1:
                                                    return f.trys.push([1, 3, , 4]), [4, this.cleanUpInvalidSession(e)];
                                                case 2:
                                                    return f.sent(), [3, 4];
                                                case 3:
                                                    return d = f.sent(), u(new Error("Session is invalid due to: " + l.message + " and failed to clean up invalid session: " + d.message)), [2];
                                                case 4:
                                                    return u(l), [2];
                                                case 5:
                                                    return le.debug("Succeed to get the user session", c), a(c), [2]
                                            }
                                        })
                                    })
                                }, {
                                    clientMetadata: t
                                })
                            })), this.inflightSessionPromiseCounter++, s.label = 1;
                        case 1:
                            return s.trys.push([1, , 3, 4]), [4, this.inflightSessionPromise];
                        case 2:
                            return n = s.sent(), e.signInUserSession = n, [2, n];
                        case 3:
                            return this.inflightSessionPromiseCounter--, [7];
                        case 4:
                            return [2]
                    }
                })
            })
        }, r.prototype.userSession = function(e) {
            return this._userSession(e)
        }, r.prototype.currentUserCredentials = function() {
            return be(this, void 0, void 0, function() {
                var e, t, n = this;
                return Ze(this, function(i) {
                    switch (i.label) {
                        case 0:
                            le.debug("Getting current user credentials"), i.label = 1;
                        case 1:
                            return i.trys.push([1, 3, , 4]), [4, this._storageSync];
                        case 2:
                            return i.sent(), [3, 4];
                        case 3:
                            throw e = i.sent(), le.debug("Failed to sync cache info into memory", e), e;
                        case 4:
                            t = null;
                            try {
                                t = JSON.parse(this._storage.getItem("aws-amplify-federatedInfo"))
                            } catch (s) {
                                le.debug("failed to get or parse item aws-amplify-federatedInfo", s)
                            }
                            return t ? [2, this.Credentials.refreshFederatedToken(t)] : [2, this.currentSession().then(function(s) {
                                return le.debug("getting session success", s), n.Credentials.set(s, "session")
                            }).catch(function() {
                                return le.debug("getting guest credentials"), n.Credentials.set(null, "guest")
                            })]
                    }
                })
            })
        }, r.prototype.currentCredentials = function() {
            return le.debug("getting current credentials"), this.Credentials.get()
        }, r.prototype.verifyUserAttribute = function(e, t, n) {
            return n === void 0 && (n = this._config.clientMetadata), new Promise(function(i, s) {
                e.getAttributeVerificationCode(t, {
                    onSuccess: o(function(a) {
                        return i(a)
                    }, "onSuccess"),
                    onFailure: o(function(a) {
                        return s(a)
                    }, "onFailure")
                }, n)
            })
        }, r.prototype.verifyUserAttributeSubmit = function(e, t, n) {
            return n ? new Promise(function(i, s) {
                e.verifyAttribute(t, n, {
                    onSuccess: o(function(a) {
                        i(a)
                    }, "onSuccess"),
                    onFailure: o(function(a) {
                        s(a)
                    }, "onFailure")
                })
            }) : this.rejectAuthError(at.EmptyCode)
        }, r.prototype.verifyCurrentUserAttribute = function(e) {
            var t = this;
            return t.currentUserPoolUser().then(function(n) {
                return t.verifyUserAttribute(n, e)
            })
        }, r.prototype.verifyCurrentUserAttributeSubmit = function(e, t) {
            var n = this;
            return n.currentUserPoolUser().then(function(i) {
                return n.verifyUserAttributeSubmit(i, e, t)
            })
        }, r.prototype.cognitoIdentitySignOut = function(e, t) {
            return be(this, void 0, void 0, function() {
                var n, i, s = this;
                return Ze(this, function(a) {
                    switch (a.label) {
                        case 0:
                            return a.trys.push([0, 2, , 3]), [4, this._storageSync];
                        case 1:
                            return a.sent(), [3, 3];
                        case 2:
                            throw n = a.sent(), le.debug("Failed to sync cache info into memory", n), n;
                        case 3:
                            return i = this._oAuthHandler && this._storage.getItem("amplify-signin-with-hostedUI") === "true", [2, new Promise(function(u, l) {
                                if (e && e.global) {
                                    le.debug("user global sign out", t);
                                    var c = s._config.clientMetadata;
                                    t.getSession(function(d, f) {
                                        return be(s, void 0, void 0, function() {
                                            var h, g = this;
                                            return Ze(this, function(p) {
                                                switch (p.label) {
                                                    case 0:
                                                        if (!d) return [3, 5];
                                                        if (le.debug("failed to get the user session", d), !this.isSessionInvalid(d)) return [3, 4];
                                                        p.label = 1;
                                                    case 1:
                                                        return p.trys.push([1, 3, , 4]), [4, this.cleanUpInvalidSession(t)];
                                                    case 2:
                                                        return p.sent(), [3, 4];
                                                    case 3:
                                                        return h = p.sent(), l(new Error("Session is invalid due to: " + d.message + " and failed to clean up invalid session: " + h.message)), [2];
                                                    case 4:
                                                        return [2, l(d)];
                                                    case 5:
                                                        return t.globalSignOut({
                                                            onSuccess: o(function(m) {
                                                                if (le.debug("global sign out success"), i) g.oAuthSignOutRedirect(u, l);
                                                                else return u()
                                                            }, "onSuccess"),
                                                            onFailure: o(function(m) {
                                                                return le.debug("global sign out failed", m), l(m)
                                                            }, "onFailure")
                                                        }), [2]
                                                }
                                            })
                                        })
                                    }, {
                                        clientMetadata: c
                                    })
                                } else le.debug("user sign out", t), t.signOut(function() {
                                    if (i) s.oAuthSignOutRedirect(u, l);
                                    else return u()
                                })
                            })]
                    }
                })
            })
        }, r.prototype.oAuthSignOutRedirect = function(e, t) {
            var n = ki().isBrowser;
            n ? this.oAuthSignOutRedirectOrReject(t) : this.oAuthSignOutAndResolve(e)
        }, r.prototype.oAuthSignOutAndResolve = function(e) {
            this._oAuthHandler.signOut(), e()
        }, r.prototype.oAuthSignOutRedirectOrReject = function(e) {
            this._oAuthHandler.signOut(), setTimeout(function() {
                return e(Error("Signout timeout fail"))
            }, 3e3)
        }, r.prototype.signOut = function(e) {
            return e === void 0 && (e = {}), be(this, void 0, void 0, function() {
                var t, n;
                return Ze(this, function(i) {
                    switch (i.label) {
                        case 0:
                            return i.trys.push([0, 2, , 3]), [4, this.cleanCachedItems()];
                        case 1:
                            return i.sent(), [3, 3];
                        case 2:
                            return i.sent(), le.debug("failed to clear cached items"), [3, 3];
                        case 3:
                            if (!this.userPool) return [3, 11];
                            i.label = 4;
                        case 4:
                            return i.trys.push([4, 6, , 7]), [4, this._storageSync];
                        case 5:
                            return i.sent(), [3, 7];
                        case 6:
                            throw t = i.sent(), le.debug("Failed to sync cache info into memory", t), t;
                        case 7:
                            return n = this.userPool.getCurrentUser(), n ? [4, this.cognitoIdentitySignOut(e, n)] : [3, 9];
                        case 8:
                            return i.sent(), [3, 10];
                        case 9:
                            le.debug("no current Cognito user"), i.label = 10;
                        case 10:
                            return [3, 12];
                        case 11:
                            le.debug("no Cognito User pool"), i.label = 12;
                        case 12:
                            return Ke("signOut", this.user, "A user has been signed out"), this.user = null, [2]
                    }
                })
            })
        }, r.prototype.cleanCachedItems = function() {
            return be(this, void 0, void 0, function() {
                return Ze(this, function(e) {
                    switch (e.label) {
                        case 0:
                            return [4, this.Credentials.clear()];
                        case 1:
                            return e.sent(), [2]
                    }
                })
            })
        }, r.prototype.changePassword = function(e, t, n, i) {
            var s = this;
            return i === void 0 && (i = this._config.clientMetadata), new Promise(function(a, u) {
                s.userSession(e).then(function(l) {
                    e.changePassword(t, n, function(c, d) {
                        return c ? (le.debug("change password failure", c), u(c)) : a(d)
                    }, i)
                })
            })
        }, r.prototype.forgotPassword = function(e, t) {
            if (t === void 0 && (t = this._config.clientMetadata), !this.userPool) return this.rejectNoUserPool();
            if (!e) return this.rejectAuthError(at.EmptyUsername);
            var n = this.createCognitoUser(e);
            return new Promise(function(i, s) {
                n.forgotPassword({
                    onSuccess: o(function() {
                        i()
                    }, "onSuccess"),
                    onFailure: o(function(a) {
                        le.debug("forgot password failure", a), Ke("forgotPassword_failure", a, e + " forgotPassword failed"), s(a)
                    }, "onFailure"),
                    inputVerificationCode: o(function(a) {
                        Ke("forgotPassword", n, e + " has initiated forgot password flow"), i(a)
                    }, "inputVerificationCode")
                }, t)
            })
        }, r.prototype.forgotPasswordSubmit = function(e, t, n, i) {
            if (i === void 0 && (i = this._config.clientMetadata), !this.userPool) return this.rejectNoUserPool();
            if (!e) return this.rejectAuthError(at.EmptyUsername);
            if (!t) return this.rejectAuthError(at.EmptyCode);
            if (!n) return this.rejectAuthError(at.EmptyPassword);
            var s = this.createCognitoUser(e);
            return new Promise(function(a, u) {
                s.confirmPassword(t, n, {
                    onSuccess: o(function(l) {
                        Ke("forgotPasswordSubmit", s, e + " forgotPasswordSubmit successful"), a(l)
                    }, "onSuccess"),
                    onFailure: o(function(l) {
                        Ke("forgotPasswordSubmit_failure", l, e + " forgotPasswordSubmit failed"), u(l)
                    }, "onFailure")
                }, i)
            })
        }, r.prototype.currentUserInfo = function() {
            return be(this, void 0, void 0, function() {
                var e, l, t, n, i, s, a, u, l;
                return Ze(this, function(c) {
                    switch (c.label) {
                        case 0:
                            return e = this.Credentials.getCredSource(), !e || e === "aws" || e === "userPool" ? [4, this.currentUserPoolUser().catch(function(d) {
                                return le.error(d)
                            })] : [3, 9];
                        case 1:
                            if (l = c.sent(), !l) return [2, null];
                            c.label = 2;
                        case 2:
                            return c.trys.push([2, 8, , 9]), [4, this.userAttributes(l)];
                        case 3:
                            t = c.sent(), n = this.attributesToObject(t), i = null, c.label = 4;
                        case 4:
                            return c.trys.push([4, 6, , 7]), [4, this.currentCredentials()];
                        case 5:
                            return i = c.sent(), [3, 7];
                        case 6:
                            return s = c.sent(), le.debug("Failed to retrieve credentials while getting current user info", s), [3, 7];
                        case 7:
                            return a = {
                                id: i ? i.identityId : void 0,
                                username: l.getUsername(),
                                attributes: n
                            }, [2, a];
                        case 8:
                            return u = c.sent(), le.error("currentUserInfo error", u), [2, {}];
                        case 9:
                            return e === "federated" ? (l = this.user, [2, l || {}]) : [2]
                    }
                })
            })
        }, r.prototype.federatedSignIn = function(e, t, n) {
            return be(this, void 0, void 0, function() {
                var i, l, s, a, u, l, c, d, f, h, g, p;
                return Ze(this, function(m) {
                    switch (m.label) {
                        case 0:
                            if (!this._config.identityPoolId && !this._config.userPoolId) throw new Error("Federation requires either a User Pool or Identity Pool in config");
                            if (typeof e == "undefined" && this._config.identityPoolId && !this._config.userPoolId) throw new Error("Federation with Identity Pools requires tokens passed as arguments");
                            return CE(e) || bJ(e) || SJ(e) || typeof e == "undefined" ? (i = e || {
                                provider: Ip.Cognito
                            }, l = CE(i) ? i.provider : i.customProvider, s = (CE(i), i.customState), this._config.userPoolId && (a = Ao(this._config.oauth) ? this._config.userPoolWebClientId : this._config.oauth.clientID, u = Ao(this._config.oauth) ? this._config.oauth.redirectSignIn : this._config.oauth.redirectUri, this._oAuthHandler.oauthSignIn(this._config.oauth.responseType, this._config.oauth.domain, u, a, l, s)), [3, 4]) : [3, 1];
                        case 1:
                            l = e;
                            try {
                                c = JSON.stringify(JSON.parse(this._storage.getItem("aws-amplify-federatedInfo")).user), c && le.warn("There is already a signed in user: " + c + ` in your app.
																	You should not call Auth.federatedSignIn method again as it may cause unexpected behavior.`)
                            } catch (w) {}
                            return d = t.token, f = t.identity_id, h = t.expires_at, [4, this.Credentials.set({
                                provider: l,
                                token: d,
                                identity_id: f,
                                user: n,
                                expires_at: h
                            }, "federation")];
                        case 2:
                            return g = m.sent(), [4, this.currentAuthenticatedUser()];
                        case 3:
                            return p = m.sent(), Ke("signIn", p, "A user " + p.username + " has been signed in"), le.debug("federated sign in credentials", g), [2, g];
                        case 4:
                            return [2]
                    }
                })
            })
        }, r.prototype._handleAuthResponse = function(e) {
            return be(this, void 0, void 0, function() {
                var t, n, i, s, a, u, l, c, d, f, h, g, p, m;
                return Ze(this, function(w) {
                    switch (w.label) {
                        case 0:
                            if (this.oAuthFlowInProgress) return le.debug("Skipping URL " + e + " current flow in progress"), [2];
                            w.label = 1;
                        case 1:
                            if (w.trys.push([1, , 8, 9]), this.oAuthFlowInProgress = !0, !this._config.userPoolId) throw new Error("OAuth responses require a User Pool defined in config");
                            if (Ke("parsingCallbackUrl", {
                                    url: e
                                }, "The callback url is being parsed"), t = e || (ki().isBrowser ? window.location.href : ""), n = !!(Es(t).query || "").split("&").map(function(T) {
                                    return T.split("=")
                                }).find(function(T) {
                                    var E = dn(T, 1),
                                        b = E[0];
                                    return b === "code" || b === "error"
                                }), i = !!(Es(t).hash || "#").substr(1).split("&").map(function(T) {
                                    return T.split("=")
                                }).find(function(T) {
                                    var E = dn(T, 1),
                                        b = E[0];
                                    return b === "access_token" || b === "error"
                                }), !(n || i)) return [3, 7];
                            this._storage.setItem("amplify-redirected-from-hosted-ui", "true"), w.label = 2;
                        case 2:
                            return w.trys.push([2, 6, , 7]), [4, this._oAuthHandler.handleAuthResponse(t)];
                        case 3:
                            return s = w.sent(), a = s.accessToken, u = s.idToken, l = s.refreshToken, c = s.state, d = new XE({
                                IdToken: new KE({
                                    IdToken: u
                                }),
                                RefreshToken: new YE({
                                    RefreshToken: l
                                }),
                                AccessToken: new zE({
                                    AccessToken: a
                                })
                            }), f = void 0, this._config.identityPoolId ? [4, this.Credentials.set(d, "session")] : [3, 5];
                        case 4:
                            f = w.sent(), le.debug("AWS credentials", f), w.label = 5;
                        case 5:
                            return h = /-/.test(c), g = this.createCognitoUser(d.getIdToken().decodePayload()["cognito:username"]), g.setSignInUserSession(d), window && typeof window.history != "undefined" && window.history.replaceState(window.history.state, "", this._config.oauth.redirectSignIn), Ke("signIn", g, "A user " + g.getUsername() + " has been signed in"), Ke("cognitoHostedUI", g, "A user " + g.getUsername() + " has been signed in via Cognito Hosted UI"), h && (p = c.split("-").splice(1).join("-"), Ke("customOAuthState", hZ(p), "State for user " + g.getUsername())), [2, f];
                        case 6:
                            return m = w.sent(), le.debug("Error in cognito hosted auth response", m), window && typeof window.history != "undefined" && window.history.replaceState(window.history.state, "", this._config.oauth.redirectSignIn), Ke("signIn_failure", m, "The OAuth response flow failed"), Ke("cognitoHostedUI_failure", m, "A failure occurred when returning to the Cognito Hosted UI"), Ke("customState_failure", m, "A failure occurred when returning state"), [3, 7];
                        case 7:
                            return [3, 9];
                        case 8:
                            return this.oAuthFlowInProgress = !1, [7];
                        case 9:
                            return [2]
                    }
                })
            })
        }, r.prototype.essentialCredentials = function(e) {
            return {
                accessKeyId: e.accessKeyId,
                sessionToken: e.sessionToken,
                secretAccessKey: e.secretAccessKey,
                identityId: e.identityId,
                authenticated: e.authenticated
            }
        }, r.prototype.attributesToObject = function(e) {
            var t = this,
                n = {};
            return e && e.map(function(i) {
                i.Name === "email_verified" || i.Name === "phone_number_verified" ? n[i.Name] = t.isTruthyString(i.Value) || i.Value === !0 : n[i.Name] = i.Value
            }), n
        }, r.prototype.isTruthyString = function(e) {
            return typeof e.toLowerCase == "function" && e.toLowerCase() === "true"
        }, r.prototype.createCognitoUser = function(e) {
            var t = {
                Username: e,
                Pool: this.userPool
            };
            t.Storage = this._storage;
            var n = this._config.authenticationFlowType,
                i = new JE(t);
            return n && i.setAuthenticationFlowType(n), i
        }, r.prototype._isValidAuthStorage = function(e) {
            return !!e && typeof e.getItem == "function" && typeof e.setItem == "function" && typeof e.removeItem == "function" && typeof e.clear == "function"
        }, r.prototype.noUserPoolErrorHandler = function(e) {
            return e && (!e.userPoolId || !e.identityPoolId) ? at.MissingAuthConfig : at.NoConfig
        }, r.prototype.rejectAuthError = function(e) {
            return Promise.reject(new ws(e))
        }, r.prototype.rejectNoUserPool = function() {
            var e = this.noUserPoolErrorHandler(this._config);
            return Promise.reject(new $te(e))
        }, r.prototype.rememberDevice = function() {
            return be(this, void 0, void 0, function() {
                var e, t;
                return Ze(this, function(n) {
                    switch (n.label) {
                        case 0:
                            return n.trys.push([0, 2, , 3]), [4, this.currentUserPoolUser()];
                        case 1:
                            return e = n.sent(), [3, 3];
                        case 2:
                            return t = n.sent(), le.debug("The user is not authenticated by the error", t), [2, Promise.reject("The user is not authenticated")];
                        case 3:
                            return e.getCachedDeviceKeyAndPassword(), [2, new Promise(function(i, s) {
                                e.setDeviceStatusRemembered({
                                    onSuccess: o(function(a) {
                                        i(a)
                                    }, "onSuccess"),
                                    onFailure: o(function(a) {
                                        a.code === "InvalidParameterException" ? s(new ws(at.DeviceConfig)) : a.code === "NetworkError" ? s(new ws(at.NetworkError)) : s(a)
                                    }, "onFailure")
                                })
                            })]
                    }
                })
            })
        }, r.prototype.forgetDevice = function() {
            return be(this, void 0, void 0, function() {
                var e, t;
                return Ze(this, function(n) {
                    switch (n.label) {
                        case 0:
                            return n.trys.push([0, 2, , 3]), [4, this.currentUserPoolUser()];
                        case 1:
                            return e = n.sent(), [3, 3];
                        case 2:
                            return t = n.sent(), le.debug("The user is not authenticated by the error", t), [2, Promise.reject("The user is not authenticated")];
                        case 3:
                            return e.getCachedDeviceKeyAndPassword(), [2, new Promise(function(i, s) {
                                e.forgetDevice({
                                    onSuccess: o(function(a) {
                                        i(a)
                                    }, "onSuccess"),
                                    onFailure: o(function(a) {
                                        a.code === "InvalidParameterException" ? s(new ws(at.DeviceConfig)) : a.code === "NetworkError" ? s(new ws(at.NetworkError)) : s(a)
                                    }, "onFailure")
                                })
                            })]
                    }
                })
            })
        }, r.prototype.fetchDevices = function() {
            return be(this, void 0, void 0, function() {
                var e, t;
                return Ze(this, function(n) {
                    switch (n.label) {
                        case 0:
                            return n.trys.push([0, 2, , 3]), [4, this.currentUserPoolUser()];
                        case 1:
                            return e = n.sent(), [3, 3];
                        case 2:
                            throw t = n.sent(), le.debug("The user is not authenticated by the error", t), new Error("The user is not authenticated");
                        case 3:
                            return e.getCachedDeviceKeyAndPassword(), [2, new Promise(function(i, s) {
                                var a = {
                                    onSuccess: o(function(u) {
                                        var l = u.Devices.map(function(c) {
                                            var d = c.DeviceAttributes.find(function(h) {
                                                    var g = h.Name;
                                                    return g === "device_name"
                                                }) || {},
                                                f = {
                                                    id: c.DeviceKey,
                                                    name: d.Value
                                                };
                                            return f
                                        });
                                        i(l)
                                    }, "onSuccess"),
                                    onFailure: o(function(u) {
                                        u.code === "InvalidParameterException" ? s(new ws(at.DeviceConfig)) : u.code === "NetworkError" ? s(new ws(at.NetworkError)) : s(u)
                                    }, "onFailure")
                                };
                                e.listDevices(jte, null, a)
                            })]
                    }
                })
            })
        }, r
    })(),
    Nn = new Gte(null);
wd.register(Nn);
var _d = "client_runtime",
    zte = "os-runtime",
    qte = "identity-endpoints",
    Kte = "token",
    Yte = "currentAuthType",
    Xte = "currentAuthConfig",
    Qa, Lb = class Lb {
        constructor(e) {
            Qa.set(this, void 0), Ae(this, Qa, e, "f")
        }
        read() {
            return localStorage.getItem(H(this, Qa, "f"))
        }
        write(e) {
            localStorage.setItem(H(this, Qa, "f"), e)
        }
        clear() {
            localStorage.removeItem(H(this, Qa, "f"))
        }
    };
o(Lb, "LocalStorageItem");
var su = Lb;
Qa = new WeakMap;
var eu, tu, ru, Jl, xb = class xb {
    constructor() {
        let {
            prefix: e = zte,
            localEndpointKey: t = qte,
            tokenKey: n = Kte,
            currentAuthTypeKey: i = Yte,
            currentAuthConfigKey: s = Xte
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        eu.set(this, void 0), tu.set(this, void 0), ru.set(this, void 0), Jl.set(this, void 0), Ae(this, eu, new su(`${e}-${t}`), "f"), Ae(this, tu, new su(`${e}-${n}`), "f"), Ae(this, ru, new su(`${e}-${i}`), "f"), Ae(this, Jl, new su(`${e}-${s}`), "f")
    }
    storeEndpoints(e) {
        H(this, eu, "f").write(JSON.stringify(e))
    }
    readEndpoints() {
        let e = H(this, eu, "f").read();
        return e ? JSON.parse(e) : null
    }
    storeToken(e) {
        H(this, tu, "f").write(JSON.stringify(e))
    }
    readToken() {
        let e = H(this, tu, "f").read();
        return e ? JSON.parse(e) : null
    }
    readAccessToken() {
        var e;
        let t = this.readToken();
        return (e = t == null ? void 0 : t.access_token) !== null && e !== void 0 ? e : null
    }
    readRefreshToken() {
        var e;
        let t = this.readToken();
        return (e = t == null ? void 0 : t.refresh_token) !== null && e !== void 0 ? e : null
    }
    readIdToken() {
        var e;
        let t = this.readToken();
        return (e = t == null ? void 0 : t.id_token) !== null && e !== void 0 ? e : null
    }
    storeCurrentAuthType(e) {
        H(this, ru, "f").write(e)
    }
    readCurrentAuthType() {
        var e;
        return (e = H(this, ru, "f").read()) !== null && e !== void 0 ? e : null
    }
    storeCurrentAuthConfig(e) {
        H(this, Jl, "f").write(JSON.stringify(e))
    }
    readCurrentAuthConfig() {
        let e = H(this, Jl, "f").read();
        return e ? JSON.parse(e) : null
    }
    clearAuthData() {
        H(this, eu, "f").clear(), H(this, tu, "f").clear(), H(this, ru, "f").clear()
    }
};
o(xb, "LocalStorageAuthData");
var Ro = xb;
eu = new WeakMap, tu = new WeakMap, ru = new WeakMap, Jl = new WeakMap;
var nb;
(function(r) {
    r.InvalidCredentials = "InvalidCredentials", r.TooManyFailedAttempts = "TooManyFailedAttempts", r.UnknownFailure = "UnknownFailure", r.PasswordComplexityPolicyFailed = "PasswordComplexityPolicyFailed", r.InvalidToken = "InvalidToken", r.IdentityTokenEndpointFailed = "IdentityTokenEndpointFailed", r.InvalidVerificationCode = "InvalidVerificationCode"
})(nb || (nb = {}));
var Qe = nb,
    Ub = class Ub extends Error {
        constructor(e, t) {
            super(t), this.errorCode = e
        }
    };
o(Ub, "AuthError");
var ei = Ub,
    Mb = class Mb {
        static create(e) {
            let {
                name: t,
                message: n,
                code: i = "OS-CLRT-40100"
            } = e, s = new ei(i, n);
            return s.name = t, s
        }
    };
o(Mb, "ErrorFactory");
var sr = Mb;

function ib(r) {
    this.message = r
}
o(ib, "e");
ib.prototype = new Error, ib.prototype.name = "InvalidCharacterError";
var XD = typeof window != "undefined" && window.atob && window.atob.bind(window) || function(r) {
    var e = String(r).replace(/=+$/, "");
    if (e.length % 4 == 1) throw new ib("'atob' failed: The string to be decoded is not correctly encoded.");
    for (var t, n, i = 0, s = 0, a = ""; n = e.charAt(s++); ~n && (t = i % 4 ? 64 * t + n : n, i++ % 4) ? a += String.fromCharCode(255 & t >> (-2 * i & 6)) : 0) n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(n);
    return a
};

function Jte(r) {
    var e = r.replace(/-/g, "+").replace(/_/g, "/");
    switch (e.length % 4) {
        case 0:
            break;
        case 2:
            e += "==";
            break;
        case 3:
            e += "=";
            break;
        default:
            throw "Illegal base64url string!"
    }
    try {
        return (function(t) {
            return decodeURIComponent(XD(t).replace(/(.)/g, function(n, i) {
                var s = i.charCodeAt(0).toString(16).toUpperCase();
                return s.length < 2 && (s = "0" + s), "%" + s
            }))
        })(e)
    } catch (t) {
        return XD(e)
    }
}
o(Jte, "t");

function Mp(r) {
    this.message = r
}
o(Mp, "n");

function Zte(r, e) {
    if (typeof r != "string") throw new Mp("Invalid token specified");
    var t = (e = e || {}).header === !0 ? 0 : 1;
    try {
        return JSON.parse(Jte(r.split(".")[t]))
    } catch (n) {
        throw new Mp("Invalid token specified: " + n.message)
    }
}
o(Zte, "o");
Mp.prototype = new Error, Mp.prototype.name = "InvalidTokenError";
var nx = "JWT_DECODING",
    Qte = 1e4,
    Td = o(function(r) {
        return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Zte)(r)
    }, "jwtDecoder"),
    ere = o(r => {
        let {
            jwtEncoded: e,
            decoder: t = Td,
            logger: n
        } = r;
        try {
            return t(e)
        } catch (i) {
            n == null || n.error({
                category: nx,
                message: "Issue decoding token",
                error: i
            });
            return
        }
    }, "safeJwtDecoder"),
    tre = o(r => r ? `${r.token_type} ${r.access_token}` : null, "formatAccessToken"),
    fp = o(r => {
        let {
            token: e,
            now: t = Date.now,
            tokenDecoder: n,
            logger: i
        } = r;
        if (!e) return !1;
        try {
            let a = n(e).exp * 1e3 - Qte;
            return t() < a
        } catch (s) {
            return i == null || i.error({
                category: nx,
                message: "Issue validating token",
                error: s
            }), !1
        }
    }, "isTokenValid"),
    kp = {
        exports: {}
    };
kp.exports;
(function(r, e) {
    var t = 200,
        n = "__lodash_hash_undefined__",
        i = 1,
        s = 2,
        a = 9007199254740991,
        u = "[object Arguments]",
        l = "[object Array]",
        c = "[object AsyncFunction]",
        d = "[object Boolean]",
        f = "[object Date]",
        h = "[object Error]",
        g = "[object Function]",
        p = "[object GeneratorFunction]",
        m = "[object Map]",
        w = "[object Number]",
        T = "[object Null]",
        E = "[object Object]",
        b = "[object Promise]",
        R = "[object Proxy]",
        L = "[object RegExp]",
        V = "[object Set]",
        z = "[object String]",
        j = "[object Symbol]",
        Y = "[object Undefined]",
        q = "[object WeakMap]",
        P = "[object ArrayBuffer]",
        Z = "[object DataView]",
        oe = "[object Float32Array]",
        S = "[object Float64Array]",
        K = "[object Int8Array]",
        M = "[object Int16Array]",
        Oe = "[object Int32Array]",
        Ye = "[object Uint8Array]",
        Xe = "[object Uint8ClampedArray]",
        de = "[object Uint16Array]",
        N = "[object Uint32Array]",
        x = /[\\^$.*+?()[\]{}|]/g,
        U = /^\[object .+?Constructor\]$/,
        ve = /^(?:0|[1-9]\d*)$/,
        Te = {};
    Te[oe] = Te[S] = Te[K] = Te[M] = Te[Oe] = Te[Ye] = Te[Xe] = Te[de] = Te[N] = !0, Te[u] = Te[l] = Te[P] = Te[d] = Te[Z] = Te[f] = Te[h] = Te[g] = Te[m] = Te[w] = Te[E] = Te[L] = Te[V] = Te[z] = Te[q] = !1;
    var Fe = typeof Ui == "object" && Ui && Ui.Object === Object && Ui,
        rt = typeof self == "object" && self && self.Object === Object && self,
        xe = Fe || rt || Function("return this")(),
        fe = e && !e.nodeType && e,
        $ = fe && !0 && r && !r.nodeType && r,
        X = $ && $.exports === fe,
        W = X && Fe.process,
        te = (function() {
            try {
                return W && W.binding && W.binding("util")
            } catch (I) {}
        })(),
        _e = te && te.isTypedArray;

    function we(I, F) {
        for (var ae = -1, Ee = I == null ? 0 : I.length, At = 0, $e = []; ++ae < Ee;) {
            var Lt = I[ae];
            F(Lt, ae, I) && ($e[At++] = Lt)
        }
        return $e
    }
    o(we, "arrayFilter");

    function Ie(I, F) {
        for (var ae = -1, Ee = F.length, At = I.length; ++ae < Ee;) I[At + ae] = F[ae];
        return I
    }
    o(Ie, "arrayPush");

    function Me(I, F) {
        for (var ae = -1, Ee = I == null ? 0 : I.length; ++ae < Ee;)
            if (F(I[ae], ae, I)) return !0;
        return !1
    }
    o(Me, "arraySome");

    function A(I, F) {
        for (var ae = -1, Ee = Array(I); ++ae < I;) Ee[ae] = F(ae);
        return Ee
    }
    o(A, "baseTimes");

    function v(I) {
        return function(F) {
            return I(F)
        }
    }
    o(v, "baseUnary");

    function y(I, F) {
        return I.has(F)
    }
    o(y, "cacheHas");

    function C(I, F) {
        return I == null ? void 0 : I[F]
    }
    o(C, "getValue");

    function B(I) {
        var F = -1,
            ae = Array(I.size);
        return I.forEach(function(Ee, At) {
            ae[++F] = [At, Ee]
        }), ae
    }
    o(B, "mapToArray");

    function se(I, F) {
        return function(ae) {
            return I(F(ae))
        }
    }
    o(se, "overArg");

    function ce(I) {
        var F = -1,
            ae = Array(I.size);
        return I.forEach(function(Ee) {
            ae[++F] = Ee
        }), ae
    }
    o(ce, "setToArray");
    var Ge = Array.prototype,
        it = Function.prototype,
        st = Object.prototype,
        _t = xe["__core-js_shared__"],
        mt = it.toString,
        $t = st.hasOwnProperty,
        Zi = (function() {
            var I = /[^.]+$/.exec(_t && _t.keys && _t.keys.IE_PROTO || "");
            return I ? "Symbol(src)_1." + I : ""
        })(),
        Qi = st.toString,
        Gs = RegExp("^" + mt.call($t).replace(x, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
        kr = X ? xe.Buffer : void 0,
        Pr = xe.Symbol,
        OR = xe.Uint8Array,
        PR = st.propertyIsEnumerable,
        t2 = Ge.splice,
        zs = Pr ? Pr.toStringTag : void 0,
        NR = Object.getOwnPropertySymbols,
        r2 = kr ? kr.isBuffer : void 0,
        n2 = se(Object.keys, Object),
        Py = ea(xe, "DataView"),
        kc = ea(xe, "Map"),
        Ny = ea(xe, "Promise"),
        Dy = ea(xe, "Set"),
        Ly = ea(xe, "WeakMap"),
        Fc = ea(Object, "create"),
        i2 = Ys(Py),
        s2 = Ys(kc),
        o2 = Ys(Ny),
        a2 = Ys(Dy),
        u2 = Ys(Ly),
        DR = Pr ? Pr.prototype : void 0,
        xy = DR ? DR.valueOf : void 0;

    function qs(I) {
        var F = -1,
            ae = I == null ? 0 : I.length;
        for (this.clear(); ++F < ae;) {
            var Ee = I[F];
            this.set(Ee[0], Ee[1])
        }
    }
    o(qs, "Hash");

    function c2() {
        this.__data__ = Fc ? Fc(null) : {}, this.size = 0
    }
    o(c2, "hashClear");

    function l2(I) {
        var F = this.has(I) && delete this.__data__[I];
        return this.size -= F ? 1 : 0, F
    }
    o(l2, "hashDelete");

    function d2(I) {
        var F = this.__data__;
        if (Fc) {
            var ae = F[I];
            return ae === n ? void 0 : ae
        }
        return $t.call(F, I) ? F[I] : void 0
    }
    o(d2, "hashGet");

    function f2(I) {
        var F = this.__data__;
        return Fc ? F[I] !== void 0 : $t.call(F, I)
    }
    o(f2, "hashHas");

    function h2(I, F) {
        var ae = this.__data__;
        return this.size += this.has(I) ? 0 : 1, ae[I] = Fc && F === void 0 ? n : F, this
    }
    o(h2, "hashSet"), qs.prototype.clear = c2, qs.prototype.delete = l2, qs.prototype.get = d2, qs.prototype.has = f2, qs.prototype.set = h2;

    function ci(I) {
        var F = -1,
            ae = I == null ? 0 : I.length;
        for (this.clear(); ++F < ae;) {
            var Ee = I[F];
            this.set(Ee[0], Ee[1])
        }
    }
    o(ci, "ListCache");

    function g2() {
        this.__data__ = [], this.size = 0
    }
    o(g2, "listCacheClear");

    function p2(I) {
        var F = this.__data__,
            ae = xf(F, I);
        if (ae < 0) return !1;
        var Ee = F.length - 1;
        return ae == Ee ? F.pop() : t2.call(F, ae, 1), --this.size, !0
    }
    o(p2, "listCacheDelete");

    function m2(I) {
        var F = this.__data__,
            ae = xf(F, I);
        return ae < 0 ? void 0 : F[ae][1]
    }
    o(m2, "listCacheGet");

    function v2(I) {
        return xf(this.__data__, I) > -1
    }
    o(v2, "listCacheHas");

    function y2(I, F) {
        var ae = this.__data__,
            Ee = xf(ae, I);
        return Ee < 0 ? (++this.size, ae.push([I, F])) : ae[Ee][1] = F, this
    }
    o(y2, "listCacheSet"), ci.prototype.clear = g2, ci.prototype.delete = p2, ci.prototype.get = m2, ci.prototype.has = v2, ci.prototype.set = y2;

    function Ks(I) {
        var F = -1,
            ae = I == null ? 0 : I.length;
        for (this.clear(); ++F < ae;) {
            var Ee = I[F];
            this.set(Ee[0], Ee[1])
        }
    }
    o(Ks, "MapCache");

    function _2() {
        this.size = 0, this.__data__ = {
            hash: new qs,
            map: new(kc || ci),
            string: new qs
        }
    }
    o(_2, "mapCacheClear");

    function w2(I) {
        var F = Uf(this, I).delete(I);
        return this.size -= F ? 1 : 0, F
    }
    o(w2, "mapCacheDelete");

    function T2(I) {
        return Uf(this, I).get(I)
    }
    o(T2, "mapCacheGet");

    function E2(I) {
        return Uf(this, I).has(I)
    }
    o(E2, "mapCacheHas");

    function b2(I, F) {
        var ae = Uf(this, I),
            Ee = ae.size;
        return ae.set(I, F), this.size += ae.size == Ee ? 0 : 1, this
    }
    o(b2, "mapCacheSet"), Ks.prototype.clear = _2, Ks.prototype.delete = w2, Ks.prototype.get = T2, Ks.prototype.has = E2, Ks.prototype.set = b2;

    function Lf(I) {
        var F = -1,
            ae = I == null ? 0 : I.length;
        for (this.__data__ = new Ks; ++F < ae;) this.add(I[F])
    }
    o(Lf, "SetCache");

    function S2(I) {
        return this.__data__.set(I, n), this
    }
    o(S2, "setCacheAdd");

    function A2(I) {
        return this.__data__.has(I)
    }
    o(A2, "setCacheHas"), Lf.prototype.add = Lf.prototype.push = S2, Lf.prototype.has = A2;

    function es(I) {
        var F = this.__data__ = new ci(I);
        this.size = F.size
    }
    o(es, "Stack");

    function I2() {
        this.__data__ = new ci, this.size = 0
    }
    o(I2, "stackClear");

    function C2(I) {
        var F = this.__data__,
            ae = F.delete(I);
        return this.size = F.size, ae
    }
    o(C2, "stackDelete");

    function R2(I) {
        return this.__data__.get(I)
    }
    o(R2, "stackGet");

    function O2(I) {
        return this.__data__.has(I)
    }
    o(O2, "stackHas");

    function P2(I, F) {
        var ae = this.__data__;
        if (ae instanceof ci) {
            var Ee = ae.__data__;
            if (!kc || Ee.length < t - 1) return Ee.push([I, F]), this.size = ++ae.size, this;
            ae = this.__data__ = new Ks(Ee)
        }
        return ae.set(I, F), this.size = ae.size, this
    }
    o(P2, "stackSet"), es.prototype.clear = I2, es.prototype.delete = C2, es.prototype.get = R2, es.prototype.has = O2, es.prototype.set = P2;

    function N2(I, F) {
        var ae = Mf(I),
            Ee = !ae && z2(I),
            At = !ae && !Ee && Uy(I),
            $e = !ae && !Ee && !At && VR(I),
            Lt = ae || Ee || At || $e,
            er = Lt ? A(I.length, String) : [],
            lr = er.length;
        for (var Pt in I) $t.call(I, Pt) && !(Lt && (Pt == "length" || At && (Pt == "offset" || Pt == "parent") || $e && (Pt == "buffer" || Pt == "byteLength" || Pt == "byteOffset") || V2(Pt, lr))) && er.push(Pt);
        return er
    }
    o(N2, "arrayLikeKeys");

    function xf(I, F) {
        for (var ae = I.length; ae--;)
            if (kR(I[ae][0], F)) return ae;
        return -1
    }
    o(xf, "assocIndexOf");

    function D2(I, F, ae) {
        var Ee = F(I);
        return Mf(I) ? Ee : Ie(Ee, ae(I))
    }
    o(D2, "baseGetAllKeys");

    function $c(I) {
        return I == null ? I === void 0 ? Y : T : zs && zs in Object(I) ? $2(I) : G2(I)
    }
    o($c, "baseGetTag");

    function LR(I) {
        return Bc(I) && $c(I) == u
    }
    o(LR, "baseIsArguments");

    function xR(I, F, ae, Ee, At) {
        return I === F ? !0 : I == null || F == null || !Bc(I) && !Bc(F) ? I !== I && F !== F : L2(I, F, ae, Ee, xR, At)
    }
    o(xR, "baseIsEqual");

    function L2(I, F, ae, Ee, At, $e) {
        var Lt = Mf(I),
            er = Mf(F),
            lr = Lt ? l : ts(I),
            Pt = er ? l : ts(F);
        lr = lr == u ? E : lr, Pt = Pt == u ? E : Pt;
        var qr = lr == E,
            An = Pt == E,
            yr = lr == Pt;
        if (yr && Uy(I)) {
            if (!Uy(F)) return !1;
            Lt = !0, qr = !1
        }
        if (yr && !qr) return $e || ($e = new es), Lt || VR(I) ? UR(I, F, ae, Ee, At, $e) : k2(I, F, lr, ae, Ee, At, $e);
        if (!(ae & i)) {
            var nn = qr && $t.call(I, "__wrapped__"),
                sn = An && $t.call(F, "__wrapped__");
            if (nn || sn) {
                var rs = nn ? I.value() : I,
                    li = sn ? F.value() : F;
                return $e || ($e = new es), At(rs, li, ae, Ee, $e)
            }
        }
        return yr ? ($e || ($e = new es), F2(I, F, ae, Ee, At, $e)) : !1
    }
    o(L2, "baseIsEqualDeep");

    function x2(I) {
        if (!BR(I) || j2(I)) return !1;
        var F = FR(I) ? Gs : U;
        return F.test(Ys(I))
    }
    o(x2, "baseIsNative");

    function U2(I) {
        return Bc(I) && $R(I.length) && !!Te[$c(I)]
    }
    o(U2, "baseIsTypedArray");

    function M2(I) {
        if (!W2(I)) return n2(I);
        var F = [];
        for (var ae in Object(I)) $t.call(I, ae) && ae != "constructor" && F.push(ae);
        return F
    }
    o(M2, "baseKeys");

    function UR(I, F, ae, Ee, At, $e) {
        var Lt = ae & i,
            er = I.length,
            lr = F.length;
        if (er != lr && !(Lt && lr > er)) return !1;
        var Pt = $e.get(I);
        if (Pt && $e.get(F)) return Pt == F;
        var qr = -1,
            An = !0,
            yr = ae & s ? new Lf : void 0;
        for ($e.set(I, F), $e.set(F, I); ++qr < er;) {
            var nn = I[qr],
                sn = F[qr];
            if (Ee) var rs = Lt ? Ee(sn, nn, qr, F, I, $e) : Ee(nn, sn, qr, I, F, $e);
            if (rs !== void 0) {
                if (rs) continue;
                An = !1;
                break
            }
            if (yr) {
                if (!Me(F, function(li, Xs) {
                        if (!y(yr, Xs) && (nn === li || At(nn, li, ae, Ee, $e))) return yr.push(Xs)
                    })) {
                    An = !1;
                    break
                }
            } else if (!(nn === sn || At(nn, sn, ae, Ee, $e))) {
                An = !1;
                break
            }
        }
        return $e.delete(I), $e.delete(F), An
    }
    o(UR, "equalArrays");

    function k2(I, F, ae, Ee, At, $e, Lt) {
        switch (ae) {
            case Z:
                if (I.byteLength != F.byteLength || I.byteOffset != F.byteOffset) return !1;
                I = I.buffer, F = F.buffer;
            case P:
                return !(I.byteLength != F.byteLength || !$e(new OR(I), new OR(F)));
            case d:
            case f:
            case w:
                return kR(+I, +F);
            case h:
                return I.name == F.name && I.message == F.message;
            case L:
            case z:
                return I == F + "";
            case m:
                var er = B;
            case V:
                var lr = Ee & i;
                if (er || (er = ce), I.size != F.size && !lr) return !1;
                var Pt = Lt.get(I);
                if (Pt) return Pt == F;
                Ee |= s, Lt.set(I, F);
                var qr = UR(er(I), er(F), Ee, At, $e, Lt);
                return Lt.delete(I), qr;
            case j:
                if (xy) return xy.call(I) == xy.call(F)
        }
        return !1
    }
    o(k2, "equalByTag");

    function F2(I, F, ae, Ee, At, $e) {
        var Lt = ae & i,
            er = MR(I),
            lr = er.length,
            Pt = MR(F),
            qr = Pt.length;
        if (lr != qr && !Lt) return !1;
        for (var An = lr; An--;) {
            var yr = er[An];
            if (!(Lt ? yr in F : $t.call(F, yr))) return !1
        }
        var nn = $e.get(I);
        if (nn && $e.get(F)) return nn == F;
        var sn = !0;
        $e.set(I, F), $e.set(F, I);
        for (var rs = Lt; ++An < lr;) {
            yr = er[An];
            var li = I[yr],
                Xs = F[yr];
            if (Ee) var HR = Lt ? Ee(Xs, li, yr, F, I, $e) : Ee(li, Xs, yr, I, F, $e);
            if (!(HR === void 0 ? li === Xs || At(li, Xs, ae, Ee, $e) : HR)) {
                sn = !1;
                break
            }
            rs || (rs = yr == "constructor")
        }
        if (sn && !rs) {
            var kf = I.constructor,
                Ff = F.constructor;
            kf != Ff && "constructor" in I && "constructor" in F && !(typeof kf == "function" && kf instanceof kf && typeof Ff == "function" && Ff instanceof Ff) && (sn = !1)
        }
        return $e.delete(I), $e.delete(F), sn
    }
    o(F2, "equalObjects");

    function MR(I) {
        return D2(I, Y2, B2)
    }
    o(MR, "getAllKeys");

    function Uf(I, F) {
        var ae = I.__data__;
        return H2(F) ? ae[typeof F == "string" ? "string" : "hash"] : ae.map
    }
    o(Uf, "getMapData");

    function ea(I, F) {
        var ae = C(I, F);
        return x2(ae) ? ae : void 0
    }
    o(ea, "getNative");

    function $2(I) {
        var F = $t.call(I, zs),
            ae = I[zs];
        try {
            I[zs] = void 0;
            var Ee = !0
        } catch ($e) {}
        var At = Qi.call(I);
        return Ee && (F ? I[zs] = ae : delete I[zs]), At
    }
    o($2, "getRawTag");
    var B2 = NR ? function(I) {
            return I == null ? [] : (I = Object(I), we(NR(I), function(F) {
                return PR.call(I, F)
            }))
        } : X2,
        ts = $c;
    (Py && ts(new Py(new ArrayBuffer(1))) != Z || kc && ts(new kc) != m || Ny && ts(Ny.resolve()) != b || Dy && ts(new Dy) != V || Ly && ts(new Ly) != q) && (ts = o(function(I) {
        var F = $c(I),
            ae = F == E ? I.constructor : void 0,
            Ee = ae ? Ys(ae) : "";
        if (Ee) switch (Ee) {
            case i2:
                return Z;
            case s2:
                return m;
            case o2:
                return b;
            case a2:
                return V;
            case u2:
                return q
        }
        return F
    }, "getTag"));

    function V2(I, F) {
        return F = F == null ? a : F, !!F && (typeof I == "number" || ve.test(I)) && I > -1 && I % 1 == 0 && I < F
    }
    o(V2, "isIndex");

    function H2(I) {
        var F = typeof I;
        return F == "string" || F == "number" || F == "symbol" || F == "boolean" ? I !== "__proto__" : I === null
    }
    o(H2, "isKeyable");

    function j2(I) {
        return !!Zi && Zi in I
    }
    o(j2, "isMasked");

    function W2(I) {
        var F = I && I.constructor,
            ae = typeof F == "function" && F.prototype || st;
        return I === ae
    }
    o(W2, "isPrototype");

    function G2(I) {
        return Qi.call(I)
    }
    o(G2, "objectToString");

    function Ys(I) {
        if (I != null) {
            try {
                return mt.call(I)
            } catch (F) {}
            try {
                return I + ""
            } catch (F) {}
        }
        return ""
    }
    o(Ys, "toSource");

    function kR(I, F) {
        return I === F || I !== I && F !== F
    }
    o(kR, "eq");
    var z2 = LR((function() {
            return arguments
        })()) ? LR : function(I) {
            return Bc(I) && $t.call(I, "callee") && !PR.call(I, "callee")
        },
        Mf = Array.isArray;

    function q2(I) {
        return I != null && $R(I.length) && !FR(I)
    }
    o(q2, "isArrayLike");
    var Uy = r2 || J2;

    function K2(I, F) {
        return xR(I, F)
    }
    o(K2, "isEqual");

    function FR(I) {
        if (!BR(I)) return !1;
        var F = $c(I);
        return F == g || F == p || F == c || F == R
    }
    o(FR, "isFunction");

    function $R(I) {
        return typeof I == "number" && I > -1 && I % 1 == 0 && I <= a
    }
    o($R, "isLength");

    function BR(I) {
        var F = typeof I;
        return I != null && (F == "object" || F == "function")
    }
    o(BR, "isObject");

    function Bc(I) {
        return I != null && typeof I == "object"
    }
    o(Bc, "isObjectLike");
    var VR = _e ? v(_e) : U2;

    function Y2(I) {
        return q2(I) ? N2(I) : M2(I)
    }
    o(Y2, "keys");

    function X2() {
        return []
    }
    o(X2, "stubArray");

    function J2() {
        return !1
    }
    o(J2, "stubFalse"), r.exports = K2
})(kp, kp.exports);
var rre = kp.exports,
    nre = dZ(rre),
    kb = class kb {
        serialize(e) {
            if (!(e === null || typeof e == "undefined")) return JSON.stringify(e)
        }
        deserialize(e) {
            if (!(e === null || typeof e == "undefined")) return JSON.parse(e)
        }
    };
o(kb, "JsonSerializer");
var sb = kb,
    Qn, fn, Ni, od, Fp, hp, ad, ud, cd, $p, ix, JD, ZD, sx, ox, QD, ob, Fb = class Fb {
        get validityKey() {
            return `${H(this,Ni,"f")}__expires`
        }
        constructor(e) {
            let {
                storage: t = localStorage,
                key: n,
                timespan: i = 0,
                canFetch: s,
                fetch: a,
                serializer: u = new sb,
                serialize: l = !0,
                validate: c = o(() => !0, "validate"),
                logger: d
            } = e;
            Qn.add(this), fn.set(this, void 0), Ni.set(this, void 0), od.set(this, void 0), Fp.set(this, void 0), hp.set(this, void 0), ad.set(this, void 0), ud.set(this, void 0), cd.set(this, void 0), $p.set(this, void 0), Ae(this, fn, t, "f"), Ae(this, Ni, n, "f"), Ae(this, od, i, "f"), Ae(this, Fp, s, "f"), Ae(this, hp, a, "f"), Ae(this, ad, u, "f"), Ae(this, ud, l, "f"), Ae(this, cd, c, "f"), Ae(this, $p, d, "f")
        }
        get() {
            return be(this, void 0, void 0, function*() {
                let [e, t] = yield H(this, Qn, "m", ox).call(this);
                if (e) return t;
                let n = yield H(this, hp, "f").call(this);
                return typeof n == "undefined" ? t : (H(this, Qn, "m", ix).call(this, n), H(this, Qn, "m", sx).call(this), n)
            })
        }
        invalidate() {
            H(this, fn, "f").removeItem(this.validityKey)
        }
        getCached() {
            return H(this, Qn, "m", ob).call(this)[1]
        }
        clear() {
            H(this, fn, "f").removeItem(H(this, Ni, "f")), H(this, fn, "f").removeItem(this.validityKey)
        }
    };
o(Fb, "CachedData");
var ab = Fb;
fn = new WeakMap, Ni = new WeakMap, od = new WeakMap, Fp = new WeakMap, hp = new WeakMap, ad = new WeakMap, ud = new WeakMap, cd = new WeakMap, $p = new WeakMap, Qn = new WeakSet, ix = o(function(e) {
    let t = H(this, Qn, "m", ZD).call(this, e);
    typeof t == "string" ? H(this, fn, "f").setItem(H(this, Ni, "f"), t) : H(this, fn, "f").removeItem(H(this, Ni, "f"))
}, "_CachedData_updateCache"), JD = o(function(e) {
    return H(this, ud, "f") ? H(this, ad, "f").deserialize(e) : e
}, "_CachedData_parseValue"), ZD = o(function(e) {
    return H(this, ud, "f") ? H(this, ad, "f").serialize(e) : e
}, "_CachedData_formatValue"), sx = o(function() {
    if (H(this, od, "f") === 0) {
        H(this, fn, "f").setItem(this.validityKey, "0");
        return
    }
    let e = (new Date().getTime() + H(this, od, "f")).toString();
    H(this, fn, "f").setItem(this.validityKey, e)
}, "_CachedData_updateValidity"), ox = o(function() {
    return be(this, void 0, void 0, function*() {
        var e;
        let [t, n] = H(this, Qn, "m", ob).call(this);
        return H(this, Fp, "f").call(this) ? typeof t == "undefined" ? [!1, void 0] : H(this, Qn, "m", QD).call(this) ? [!1, n] : typeof H(this, cd, "f") == "function" ? [yield H(this, cd, "f").call(this, n), n] : [!0, n] : (n || (e = H(this, $p, "f")) === null || e === void 0 || e.warning({
            category: "CachedData",
            message: `[${H(this,Ni,"f")}] No value in cache (${n}) and can't fetch new data`
        }), [!0, n])
    })
}, "_CachedData_validateCacheValue"), QD = o(function() {
    let e = H(this, fn, "f").getItem(this.validityKey),
        t = parseInt(e != null ? e : "", 10);
    return isNaN(t) || t < 0 ? !0 : t > 0 && t <= new Date().getTime()
}, "_CachedData_cacheHasExpired"), ob = o(function() {
    var e;
    let t = (e = H(this, fn, "f").getItem(H(this, Ni, "f"))) !== null && e !== void 0 ? e : void 0,
        n = H(this, Qn, "m", JD).call(this, t);
    return [t, n]
}, "_CachedData_readCachedValue");
var up = "/api/user-information/v1/claims";

function ire(r) {
    return be(this, arguments, void 0, function(e) {
        let {
            getAccessToken: t,
            httpClient: n
        } = e;
        return (function*() {
            let i = yield t();
            if (!i) throw new Error("Missing access token");
            let s;
            try {
                s = yield n.get({
                    url: up,
                    headers: {
                        Authorization: i
                    }
                })
            } catch (a) {
                throw a instanceof Error ? (a.message = `Failed to fetch user claims [${up}]: ${a.message}`, a) : new Error(`Failed to fetch user claims [${up}]: ${a}`)
            }
            if (s === void 0) throw new Error(`Couldn't get any response from server while fetching user claims url: ${up}`);
            return s
        })()
    })
}
o(ire, "fetchUserClaims");
var cp = "/api/user-information/v1/profiles/me";

function sre(r) {
    return be(this, arguments, void 0, function(e) {
        let {
            getAccessToken: t,
            httpClient: n
        } = e;
        return (function*() {
            let i = yield t();
            if (!i) throw new Error("Missing access token");
            let s;
            try {
                s = yield n.get({
                    url: cp,
                    headers: {
                        Authorization: i
                    },
                    params: {
                        embed: "UserIdentityProviders"
                    }
                })
            } catch (a) {
                throw a instanceof Error ? (a.message = `Failed to fetch user info [${cp}]: ${a.message}`, a) : new Error(`Failed to fetch user info [${cp}]: ${a}`)
            }
            if (s === void 0) throw new Error(`Couldn't get any response from server while fetching user info url: ${cp}`);
            return s
        })()
    })
}
o(sre, "fetchUserProfile");

function ore(r) {
    let {
        getAccessToken: e,
        logger: t,
        httpClient: n,
        canFetch: i,
        key: s = "user_info",
        timespan: a = 1e3 * 60 * 5,
        decodeJwt: u = ere
    } = r;
    return new ab({
        fetch: o(() => be(this, void 0, void 0, function*() {
            var l;
            try {
                let [c, d, f] = yield Promise.all([sre({
                    getAccessToken: e,
                    httpClient: n
                }), ire({
                    getAccessToken: e,
                    httpClient: n
                }), e()]);
                if (!f) throw new Error("Missing access token");
                let h = (l = u({
                    jwtEncoded: f
                })) === null || l === void 0 ? void 0 : l.idp_id;
                return are({
                    userProfile: c,
                    userClaims: d,
                    idpId: h
                })
            } catch (c) {
                t == null || t.error({
                    message: "Failed to load user info",
                    error: c instanceof Error ? c : new Error("Unknown error"),
                    category: "UserInfoCache"
                });
                return
            }
        }), "fetch"),
        canFetch: i,
        key: s,
        timespan: a,
        logger: t
    })
}
o(ore, "createUserInfoCache");

function are(r) {
    let {
        userProfile: e,
        userClaims: t,
        idpId: n
    } = r;
    var i;
    return {
        email: e.email,
        name: e.name,
        preferred_username: ure((i = e._embedded) === null || i === void 0 ? void 0 : i.userIdentityProviders, n),
        picture: e.photoUrl,
        os_access: {
            userId: e.id,
            roles: t.claims
        }
    }
}
o(are, "mapToUserInfo");

function ure(r, e) {
    if (!r || !e) return "";
    for (let t of r)
        if (t.identityProviderKey === e) return t.userName;
    return ""
}
o(ure, "getUserNameFromUserIdentityProviders");
var ub;
(function(r) {
    r[r.Internal = 0] = "Internal", r[r.External = 1] = "External", r[r.Client = 2] = "Client"
})(ub || (ub = {}));
var gn = ub,
    gp, pp, mp, ou, Bp, vp, cb, cre = "AuthenticationSynchronizer",
    lre = 6e4,
    $b = class $b {
        constructor(e) {
            let {
                synchronize: t,
                logger: n,
                setTimeoutOverride: i = setTimeout,
                clearTimeoutOverride: s = clearTimeout,
                timeout: a,
                start: u = !0
            } = e;
            gp.add(this), pp.set(this, void 0), mp.set(this, void 0), ou.set(this, void 0), Bp.set(this, void 0), vp.set(this, void 0), Ae(this, pp, t, "f"), Ae(this, mp, n, "f"), Ae(this, Bp, i, "f"), Ae(this, vp, s, "f"), Ae(this, ou, a, "f"), u && H(this, gp, "m", cb).call(this)
        }
        trySynchronize() {
            return be(this, void 0, void 0, function*() {
                var e;
                H(this, ou, "f") && H(this, vp, "f").call(this, H(this, ou, "f"));
                try {
                    yield H(this, pp, "f").call(this)
                } catch (t) {
                    (e = H(this, mp, "f")) === null || e === void 0 || e.error({
                        category: cre,
                        message: "Error while synchronizing information.",
                        error: t,
                        code: "OS-CLRT-40300"
                    }), H(this, gp, "m", cb).call(this)
                }
            })
        }
    };
o($b, "Synchronizer");
var lb = $b;
pp = new WeakMap, mp = new WeakMap, ou = new WeakMap, Bp = new WeakMap, vp = new WeakMap, gp = new WeakSet, cb = o(function() {
    Ae(this, ou, H(this, Bp, "f").call(this, () => this.trySynchronize(), lre), "f")
}, "_Synchronizer_retry");

function dre(r) {
    return typeof r == "string" ? new Error(r) : r instanceof Error ? r : new Error("Unknown error")
}
o(dre, "sanitizeError");
var au, nu, du, Dn, Zl, Ql, Di, ax, ux, eL, cx, uu = "authentication-token-handler",
    tL = "[]",
    Bb = class Bb {
        constructor(e) {
            let {
                authData: t,
                decodeJwt: n = Td,
                logger: i,
                tokenValidator: s = fp
            } = e;
            au.add(this), nu.set(this, void 0), du.set(this, void 0), Dn.set(this, void 0), Zl.set(this, void 0), Ql.set(this, void 0), Di.set(this, void 0), Ae(this, nu, t, "f"), Ae(this, Zl, n, "f"), Ae(this, Di, i, "f"), Ae(this, Ql, s, "f")
        }
        invalidateAccessToken(e) {
            typeof e == "string" && e.length > 0 && Ae(this, du, e, "f")
        }
        isAccessTokenValid(e, t) {
            return typeof e == "string" && e !== H(this, du, "f") && (t != null ? t : H(this, Ql, "f"))({
                token: e,
                tokenDecoder: H(this, Zl, "f")
            })
        }
        isRefreshTokenValid(e, t) {
            let n = e != null ? e : H(this, nu, "f").readRefreshToken();
            return typeof n == "string" && n !== H(this, Dn, "f") && (t != null ? t : H(this, Ql, "f"))({
                token: n,
                tokenDecoder: H(this, Zl, "f")
            })
        }
        refreshToken(e) {
            return be(this, arguments, void 0, function(t) {
                var n = this;
                let {
                    refreshEndpoint: i,
                    client: s,
                    scope: a,
                    clientId: u,
                    timeoutHandler: l
                } = t;
                return (function*() {
                    var c, d, f;
                    n.invalidateAccessToken((c = H(n, nu, "f").readAccessToken()) !== null && c !== void 0 ? c : "");
                    let h = H(n, nu, "f").readRefreshToken();
                    if (!h) return H(n, Dn, "f") !== tL && ((d = H(n, Di, "f")) === null || d === void 0 || d.info({
                        category: uu,
                        message: "No refresh token stored. Could not refresh the tokens.",
                        visibility: gn.Internal
                    }), Ae(n, Dn, tL, "f")), {
                        type: "invalid-state"
                    };
                    if (!n.isRefreshTokenValid(h)) return h === H(n, Dn, "f") ? {
                        type: "invalid-state"
                    } : {
                        type: "error",
                        error: H(n, au, "m", ax).call(n, h)
                    };
                    try {
                        let g = yield s.post({
                            url: i,
                            payload: {
                                grant_type: "refresh_token",
                                refresh_token: h,
                                client_id: u,
                                scope: a
                            },
                            timeoutHandler: l
                        });
                        if (g === void 0) {
                            let p = new Error("Couldn't get any response from server while refreshing tokens.");
                            throw (f = H(n, Di, "f")) === null || f === void 0 || f.error({
                                category: uu,
                                code: "OS-CLRT-40100",
                                error: p,
                                visibility: gn.Internal
                            }), p
                        }
                        return Ae(n, Dn, h, "f"), H(n, au, "m", cx).call(n, g), {
                            type: "success",
                            token: g
                        }
                    } catch (g) {
                        let p = H(n, au, "m", ux).call(n, g);
                        return p.errorCode !== "OS-CLRT-40112" && Ae(n, Dn, h, "f"), {
                            type: "error",
                            error: p
                        }
                    }
                })()
            })
        }
    };
o(Bb, "TokenHandler");
var db = Bb;
nu = new WeakMap, du = new WeakMap, Dn = new WeakMap, Zl = new WeakMap, Ql = new WeakMap, Di = new WeakMap, au = new WeakSet, ax = o(function(e) {
    var t;
    Ae(this, Dn, e, "f");
    let n = new ei("OS-CLRT-40103", "Refresh token not valid.");
    return (t = H(this, Di, "f")) === null || t === void 0 || t.error({
        error: n,
        category: uu,
        code: n.errorCode
    }), n
}, "_TokenHandler_createInvalidTokenError"), ux = o(function(e) {
    var t;
    let n = dre(e);
    if (n instanceof ei) return n;
    let i = H(this, au, "m", eL).call(this, n),
        s = `Failed to call refresh token endpoint: ${n.message}`;
    return (t = H(this, Di, "f")) === null || t === void 0 || t.error({
        error: n,
        category: uu,
        code: i,
        message: s
    }), new ei(i, s)
}, "_TokenHandler_createRequestFailedError"), eL = o(function(e) {
    return e instanceof Fr ? gO(e) ? "OS-CLRT-40112" : "OS-CLRT-40100" : "OS-CLRT-40112"
}, "_TokenHandler_calcRefreshTokenErrorCode"), cx = o(function(e) {
    var t, n;
    e.access_token !== H(this, du, "f") ? Ae(this, du, void 0, "f") : (t = H(this, Di, "f")) === null || t === void 0 || t.warning({
        category: uu,
        message: "Access token already invalidated."
    }), e.refresh_token !== H(this, Dn, "f") ? Ae(this, Dn, void 0, "f") : (n = H(this, Di, "f")) === null || n === void 0 || n.warning({
        category: uu,
        message: "Refresh token already invalidated."
    })
}, "_TokenHandler_assertToken");
var Nb = "/moduleservices/users/userinfosync",
    fre = "/moduleservices/users/registration",
    hre = "/moduleservices/users/passwordrecovery",
    gre = "/moduleservices/users/updateemail",
    rL;
(function(r) {
    r.Authorization = "authorization_endpoint", r.Token = "token_endpoint", r.Logout = "end_session_endpoint", r.Refresh = "token_endpoint", r.UserInfo = "userinfo_endpoint"
})(rL || (rL = {}));
var ld, ed, yp, bo, lx, nL, dx, pre = "/identity/.well-known/openid-configuration",
    Tt = "Authentication",
    Vb = class Vb {
        constructor(e) {
            let {
                scope: t = "",
                identityEndpoint: n = pre,
                appUrl: i,
                appSyncEndpoint: s = Nb,
                authData: a,
                httpClient: u,
                decodeJwt: l = Td,
                logger: c,
                validator: d = fp,
                tokenHandler: f = new db({
                    authData: a,
                    decodeJwt: l,
                    logger: c,
                    tokenValidator: d
                }),
                synchronizer: h,
                userInfo: g,
                isOnline: p = o(() => !0, "isOnline"),
                changeEmailEndpoint: m = gre
            } = e;
            ld.add(this), ed.set(this, void 0), yp.set(this, void 0), bo.set(this, void 0), this.scope = t, Ae(this, ed, n, "f"), this.appUrl = i, this.appSyncEndpoint = s, this.authData = a, this.httpClient = u, this.decodeJwt = l, this.logger = c, this.tokenHandler = f, this.isOnline = p, this.changeEmailEndpoint = m, Ae(this, yp, h != null ? h : new lb({
                synchronize: o(() => this.synchronizeUserInfo(), "synchronize"),
                logger: c
            }), "f"), this.userInfo = g != null ? g : ore({
                canFetch: o(() => this.isAuthenticated() && p(), "canFetch"),
                getAccessToken: o(() => this.getValidAccessToken(), "getAccessToken"),
                httpClient: u,
                logger: c
            })
        }
        getValidAccessToken() {
            return be(this, arguments, void 0, function() {
                var e = this;
                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1,
                    n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
                return (function*() {
                    var i, s;
                    let a = n ? e.logger : void 0;
                    if (!e.isOnline()) return a == null || a.info({
                        category: Tt,
                        message: "Device is offline, using last known access token."
                    }), (i = e.getAccessToken()) !== null && i !== void 0 ? i : void 0;
                    if (!e.authData.readToken()) {
                        a == null || a.info({
                            category: Tt,
                            message: "Cannot get access token because there is no token stored."
                        });
                        return
                    }
                    return (t || !e.isAccessTokenValid()) && (a == null || a.debug({
                        category: Tt,
                        message: "Refreshing tokens."
                    }), yield e.refreshTokens()), (s = e.getAccessToken()) !== null && s !== void 0 ? s : void 0
                })()
            })
        }
        fetchEndpoints() {
            return be(this, void 0, void 0, function*() {
                var e, t;
                let n = this.authData.readEndpoints();
                if (n) return n; {
                    let i;
                    try {
                        i = yield this.httpClient.get({
                            url: H(this, ed, "f")
                        })
                    } catch (s) {
                        throw (e = this.logger) === null || e === void 0 || e.error({
                            category: Tt,
                            code: "OS-CLRT-40300",
                            message: `Failed to fetch endpoints from ${H(this,ed,"f")}`,
                            error: s instanceof Error ? s : new Error(`Unknown error: ${s}`)
                        }), s
                    }
                    if (i === void 0) {
                        let s = new Error("Couldn't get any response from server while fetching tokens.");
                        throw (t = this.logger) === null || t === void 0 || t.error({
                            category: Tt,
                            code: "OS-CLRT-40100",
                            error: s
                        }), s
                    }
                    return this.authData.storeEndpoints(i), i
                }
            })
        }
        getUserId() {
            var e, t;
            if (!this.isAuthenticated()) return null;
            let n = this.userInfo.getCached();
            return (t = (e = n == null ? void 0 : n.os_access) === null || e === void 0 ? void 0 : e.userId) !== null && t !== void 0 ? t : null
        }
        isAuthenticated() {
            let e = this.authData.readToken();
            return !!(e != null && e.access_token) && !!(e != null && e.refresh_token) && !!(e != null && e.id_token)
        }
        getAccessToken() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : tre,
                t = this.authData.readToken();
            return e(t)
        }
        isAccessTokenValid() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : fp,
                t = this.getAccessToken();
            return this.tokenHandler.isAccessTokenValid(t != null ? t : "", e)
        }
        isRefreshTokenValid() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : fp,
                t = this.authData.readRefreshToken();
            return this.tokenHandler.isRefreshTokenValid(t != null ? t : "", e)
        }
        refreshTokens() {
            return H(this, bo, "f") || Ae(this, bo, H(this, ld, "m", lx).call(this), "f"), H(this, bo, "f")
        }
        logout() {
            return be(this, arguments, void 0, function() {
                var e = this;
                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : () => Nn.signOut();
                return (function*() {
                    var n, i, s;
                    let a = yield e.fetchEndpoints(), u = e.authData.readIdToken();
                    if (e.authData.clearAuthData(), e.userInfo.clear(), !u) {
                        (n = e.logger) === null || n === void 0 || n.info({
                            category: Tt,
                            message: "No id token stored. Logout not completed.",
                            visibility: gn.Internal
                        });
                        return
                    }
                    try {
                        yield t()
                    } catch (c) {
                        (i = e.logger) === null || i === void 0 || i.error({
                            category: Tt,
                            message: "Error calling the auth signout",
                            error: c,
                            code: "OS-CLRT-40108"
                        })
                    }
                    let l = {
                        id_token_hint: u
                    };
                    try {
                        yield e.httpClient.post({
                            url: a.end_session_endpoint,
                            payload: l
                        })
                    } catch (c) {
                        (s = e.logger) === null || s === void 0 || s.error({
                            category: Tt,
                            message: "Error calling the logout endpoint",
                            error: c,
                            code: "OS-CLRT-40108"
                        })
                    }
                })()
            })
        }
        clearAuthenticationData() {
            Ae(this, bo, void 0, "f"), this.authData.clearAuthData(), this.userInfo.clear()
        }
        hasRole(e) {
            var t, n, i;
            let s = this.userInfo.getCached();
            return (i = (n = (t = s == null ? void 0 : s.os_access) === null || t === void 0 ? void 0 : t.roles) === null || n === void 0 ? void 0 : n.includes(e)) !== null && i !== void 0 ? i : !1
        }
        buildUrl(e) {
            return `/${this.appUrl}/${e}`.replace(/\/(\/)+/gm, "/")
        }
        getUserSyncUrl() {
            return this.buildUrl(this.appSyncEndpoint)
        }
        storeUserInfo(e) {
            return be(this, void 0, void 0, function*() {
                var t, n, i;
                if (!this.tokenHandler.isAccessTokenValid(e.access_token)) {
                    let c = new ei("OS-CLRT-40113", "Access token provided by the Identity Service is invalid. System clock might be set to the wrong time.");
                    throw (t = this.logger) === null || t === void 0 || t.error({
                        category: Tt,
                        error: c
                    }), c
                }
                let s = this.authData.readToken();
                this.authData.storeToken(e);
                let a = this.userInfo.getCached();
                this.userInfo.invalidate();
                let u = yield H(this, ld, "m", dx).call(this);
                if (u.type === "error") {
                    let c = u.error instanceof Error ? u.error.message : "Unknown error";
                    throw new ei("OS-CLRT-40113", c)
                }
                let l = (i = (n = u.user) === null || n === void 0 ? void 0 : n.os_access) === null || i === void 0 ? void 0 : i.userId;
                if (!l) throw new ei("OS-CLRT-40111", "User ID is missing.");
                return (!s || !nre(a, u.user)) && H(this, yp, "f").trySynchronize(), l
            })
        }
        synchronizeUserInfo() {
            return be(this, void 0, void 0, function*() {
                if (this.isOnline() && this.isAuthenticated()) {
                    let e = yield this.getValidAccessToken();
                    if (!e) throw new Error("No token available to synchronize user info.");
                    yield this.httpClient.post({
                        url: this.getUserSyncUrl(),
                        headers: {
                            Authorization: e
                        }
                    })
                }
            })
        }
        getUserInfo() {
            return be(this, void 0, void 0, function*() {
                var e, t, n, i;
                let s = yield this.userInfo.get();
                return {
                    email: (e = s == null ? void 0 : s.email) !== null && e !== void 0 ? e : "",
                    username: (t = s == null ? void 0 : s.preferred_username) !== null && t !== void 0 ? t : "",
                    name: (n = s == null ? void 0 : s.name) !== null && n !== void 0 ? n : "",
                    pictureUrl: (i = s == null ? void 0 : s.picture) !== null && i !== void 0 ? i : ""
                }
            })
        }
        isAuthEndpoint(e) {
            var t;
            let [n] = e.split("?"), i = (t = this.authData.readEndpoints()) !== null && t !== void 0 ? t : {};
            for (let s of Object.values(i))
                if (n === s) return !0;
            return !1
        }
        changeEmail(e) {
            return be(this, void 0, void 0, function*() {
                var t, n, i, s, a, u, l, c, d, f;
                if (typeof e != "string" || e.trim() === "") throw sr.create({
                    name: Qe.InvalidVerificationCode,
                    message: "Verification code is empty",
                    code: "OS-CLRT-40114"
                });
                try {
                    return yield this.httpClient.post({
                        payload: {
                            verificationCode: e,
                            accessToken: (t = this.authData.readAccessToken()) !== null && t !== void 0 ? t : ""
                        },
                        url: this.buildUrl(this.changeEmailEndpoint),
                        contentType: ir.Json,
                        headers: {
                            Authorization: (n = this.getAccessToken()) !== null && n !== void 0 ? n : ""
                        }
                    }), this.userInfo.invalidate(), {
                        success: !0
                    }
                } catch (h) {
                    let g = h,
                        p = (s = (i = g == null ? void 0 : g.response) === null || i === void 0 ? void 0 : i.errorCode) !== null && s !== void 0 ? s : "OS-CLRT-40115",
                        m = (d = (c = (u = (a = g == null ? void 0 : g.response) === null || a === void 0 ? void 0 : a.detail) !== null && u !== void 0 ? u : (l = g == null ? void 0 : g.response) === null || l === void 0 ? void 0 : l.title) !== null && c !== void 0 ? c : g.message) !== null && d !== void 0 ? d : "Unknown error";
                    return (f = this.logger) === null || f === void 0 || f.error({
                        category: Tt,
                        message: m,
                        error: g instanceof Error ? g : new Error("Error calling the change email endpoint"),
                        code: p
                    }), {
                        success: !1,
                        errorCode: p,
                        errorMessage: m
                    }
                }
            })
        }
    };
o(Vb, "BaseAuth");
var Vp = Vb;
ed = new WeakMap, yp = new WeakMap, bo = new WeakMap, ld = new WeakSet, lx = o(function() {
    return be(this, void 0, void 0, function*() {
        try {
            let e = yield this.fetchEndpoints(), t = yield this.tokenHandler.refreshToken({
                refreshEndpoint: e.token_endpoint,
                client: this.httpClient,
                clientId: _d,
                scope: this.scope
            });
            switch (t.type) {
                case "success":
                    yield this.storeUserInfo(t.token);
                    break;
                case "error":
                    throw t.error;
                case "invalid-state":
                    this.clearAuthenticationData();
                    break;
                default:
            }
        } catch (e) {
            throw H(this, ld, "m", nL).call(this, e) && this.clearAuthenticationData(), e
        } finally {
            Ae(this, bo, void 0, "f")
        }
    })
}, "_BaseAuth_refreshTokens"), nL = o(function(e) {
    if (!(e instanceof ei)) return !1;
    switch (e.errorCode) {
        case "OS-CLRT-40112":
            return !1;
        default:
            return !0
    }
}, "_BaseAuth_shouldClearAuthData"), dx = o(function() {
    return be(this, void 0, void 0, function*() {
        var e;
        try {
            let t = yield this.userInfo.get();
            if (!t) throw this.isAuthenticated() ? this.isOnline() ? new Error("User info is missing.") : new Error("Device is offline, cannot get user info.") : new Error("User is not authenticated, cannot get user info.");
            return {
                type: "success",
                user: t
            }
        } catch (t) {
            return (e = this.logger) === null || e === void 0 || e.error({
                category: Tt,
                message: "Error getting user info",
                error: t instanceof Error ? t : new Error("Unknown error"),
                code: "OS-CLRT-40100",
                visibility: gn.Internal
            }), {
                type: "error",
                error: t
            }
        }
    })
}, "_BaseAuth_tryGetUserInfo");
var _p, Hb = class Hb extends Vp {
    constructor(e) {
        let {
            appKey: t,
            identityProvider: n,
            appUrl: i,
            baseUrl: s,
            region: a,
            poolId: u,
            clientId: l,
            scope: c = "",
            identityEndpoint: d,
            httpClient: f = new mi({
                baseUrl: s
            }),
            appSyncEndpoint: h = Nb,
            authData: g = new Ro,
            decodeJwt: p = Td,
            configureAmplify: m = o(z => wd.configure(z), "configureAmplify"),
            logger: w,
            validator: T,
            tokenHandler: E,
            synchronizer: b,
            isOnline: R,
            userInfo: L
        } = e;
        var V;
        if (super({
                scope: c,
                identityEndpoint: d,
                appUrl: i,
                appSyncEndpoint: h,
                authData: g,
                httpClient: f,
                decodeJwt: p,
                logger: w,
                validator: T,
                tokenHandler: E,
                synchronizer: b,
                isOnline: R,
                userInfo: L
            }), _p.set(this, void 0), Ae(this, _p, n, "f"), a && u && l) try {
            m({
                Auth: {
                    region: a,
                    userPoolId: u,
                    userPoolWebClientId: l
                }
            })
        } catch (z) {
            (V = this.logger) === null || V === void 0 || V.error({
                category: Tt,
                message: "Error while configuring Amplify",
                error: z,
                code: "OS-CLRT-40110"
            })
        }
    }
    isExternalUser() {
        return !0
    }
    getLoginUrl(e) {
        return be(this, arguments, void 0, function(t) {
            var n = this;
            let {
                redirectUri: i,
                callbackUrl: s
            } = t;
            return (function*() {
                let a = yield n.fetchEndpoints(), u = new URLSearchParams(s ? {
                    callback_url: s
                } : {}).toString(), l = {
                    client_id: _d,
                    scope: n.scope,
                    redirect_uri: u ? `${i}?${u}` : i,
                    response_type: "code",
                    kc_idp_hint: H(n, _p, "f")
                }, c = new URLSearchParams(l).toString();
                return `${a.authorization_endpoint}?${c}`
            })()
        })
    }
    login(e) {
        return be(this, arguments, void 0, function(t) {
            var n = this;
            let {
                redirectUri: i,
                callbackUrl: s,
                navigationHandler: a = o(u => window.location.replace(u), "navigationHandler")
            } = t;
            return (function*() {
                let u = yield n.getLoginUrl({
                    redirectUri: i,
                    callbackUrl: s
                });
                a(u)
            })()
        })
    }
    resumeLogin(e) {
        return be(this, arguments, void 0, function(t) {
            var n = this;
            let {
                url: i,
                redirectUri: s
            } = t;
            return (function*() {
                let a = yield n.fetchEndpoints(), u = new URL(i).searchParams, l = u.get("code"), c = u.get("callback_url"), d = new URLSearchParams(c ? {
                    callback_url: c
                } : {}).toString();
                if (!l) throw n.authData.clearAuthData(), n.userInfo.clear(), Error(`Missing mandatory parameters to continue the login: authz_code: ${l}`);
                try {
                    let f = d ? `${s}?${d}` : s,
                        h = yield n.requestToken(a.token_endpoint, f, l);
                    yield n.storeUserInfo(h)
                } catch (f) {
                    throw n.authData.clearAuthData(), n.userInfo.clear(), f
                }
                return c
            })()
        })
    }
    requestToken(e, t, n) {
        return be(this, void 0, void 0, function*() {
            var i;
            try {
                let s = yield this.httpClient.post({
                    url: e,
                    payload: {
                        grant_type: "authorization_code",
                        code: n,
                        redirect_uri: t,
                        client_id: _d
                    }
                });
                if (s === void 0) {
                    let a = new Error("Couldn't get any response from server while getting tokens.");
                    throw (i = this.logger) === null || i === void 0 || i.error({
                        category: Tt,
                        code: "OS-CLRT-40100",
                        error: a
                    }), a
                }
                return s
            } catch (s) {
                throw sr.create({
                    name: Qe.IdentityTokenEndpointFailed,
                    message: "Error calling the external auth token endpoint",
                    code: "OS-ID-BIZ-40021"
                })
            }
        })
    }
    getLogoutUrl(e) {
        return be(this, arguments, void 0, function(t) {
            var n = this;
            let {
                redirectUri: i,
                callbackUrl: s
            } = t;
            return (function*() {
                let a = yield n.fetchEndpoints(), u = n.authData.readIdToken();
                if (!u) throw new Error("No id token stored. Could not logout.");
                let l = new URLSearchParams(s ? {
                        callback_url: s
                    } : {}).toString(),
                    c = {
                        id_token_hint: u,
                        post_logout_redirect_uri: l ? `${i}?${l}` : i
                    },
                    d = new URLSearchParams(c).toString();
                return `${a.end_session_endpoint}?${d}`
            })()
        })
    }
    resumeLogout(e) {
        return be(this, arguments, void 0, function(t) {
            var n = this;
            let {
                url: i,
                authSignOut: s = o(() => Nn.signOut(), "authSignOut")
            } = t;
            return (function*() {
                var a;
                let l = new URL(i).searchParams.get("callback_url");
                try {
                    yield s()
                } catch (c) {
                    throw (a = n.logger) === null || a === void 0 || a.error({
                        category: Tt,
                        message: "Error calling the external auth signout",
                        error: c,
                        code: "OS-CLRT-40108"
                    }), c
                }
                return n.authData.clearAuthData(), n.userInfo.clear(), l ? decodeURIComponent(l) : null
            })()
        })
    }
};
o(Hb, "ExternalAuth");
var fb = Hb;
_p = new WeakMap;
var Zr, Ri, wp, Hp, Tp, Ep, jp, Wp, hb, fx, hx, gx, px, iL, gb, mx, sL, mre = {
        minimumLength: 12,
        upperCaseLetterRequired: !0,
        lowerCaseLetterRequired: !0,
        numberRequired: !0,
        specialCharacterRequired: !0
    },
    vre = ["OS-ID-BIZ-40001", "OS-ID-BIZ-40051", "OS-ID-BIZ-50047", "OS-ID-BIZ-40415", "OS-ID-BIZ-40052"],
    yre = ["OS-ID-BIZ-40401"],
    jb = class jb extends Vp {
        constructor(e) {
            let {
                appKey: t,
                identityProvider: n,
                region: i,
                poolId: s,
                clientId: a,
                appUrl: u,
                baseUrl: l,
                scope: c,
                appSyncEndpoint: d = Nb,
                passwordComplexityPolicy: f = mre,
                authData: h = new Ro,
                httpClient: g = new mi({
                    baseUrl: l
                }),
                decodeJwt: p = Td,
                configureAmplify: m = o(q => wd.configure(q), "configureAmplify"),
                logger: w,
                persistentStorage: T = localStorage,
                temporaryStorage: E = sessionStorage,
                endpointRegistration: b = fre,
                endpointResetPass: R = hre,
                synchronizer: L,
                isOnline: V,
                userInfo: z,
                tokenHandler: j
            } = e;
            var Y;
            super({
                authData: h,
                httpClient: g,
                appUrl: u,
                appSyncEndpoint: d,
                scope: c,
                decodeJwt: p,
                logger: w,
                synchronizer: L,
                isOnline: V,
                userInfo: z,
                tokenHandler: j
            }), Zr.add(this), Ri.set(this, void 0), wp.set(this, void 0), Hp.set(this, void 0), Tp.set(this, void 0), Ep.set(this, void 0), jp.set(this, void 0), Wp.set(this, void 0), Ae(this, Tp, T, "f"), Ae(this, Ep, E, "f"), Ae(this, Hp, n, "f"), Ae(this, wp, a, "f"), Ae(this, Ri, f, "f"), Ae(this, jp, b, "f"), Ae(this, Wp, R, "f");
            try {
                m({
                    Auth: {
                        region: i,
                        userPoolId: s,
                        userPoolWebClientId: a
                    }
                })
            } catch (q) {
                (Y = this.logger) === null || Y === void 0 || Y.error({
                    category: Tt,
                    message: "Error while configuring Amplify",
                    error: q,
                    code: "OS-CLRT-40110"
                })
            }
        }
        login(e) {
            return be(this, arguments, void 0, function(t) {
                var n = this;
                let {
                    username: i,
                    password: s,
                    newPassword: a,
                    redirectUri: u = `${window.location.protocol}//${window.location.host}/identity`,
                    persistLogin: l = !0,
                    configureAuth: c = o(g => Nn.configure(g), "configureAuth"),
                    authSignIn: d = o((g, p) => Nn.signIn(g, p), "authSignIn"),
                    completeNewPassword: f = o((g, p) => Nn.completeNewPassword(g, p), "completeNewPassword"),
                    changePassword: h = o((g, p, m) => Nn.changePassword(g, p, m), "changePassword")
                } = t;
                return (function*() {
                    var g, p, m, w, T;
                    try {
                        if (s === "" || i === "") throw sr.create({
                            name: Qe.InvalidCredentials,
                            message: `${i===""?"Username":"Password"} cannot be empty.`,
                            code: "OS-CLRT-40104"
                        });
                        let E = H(n, Zr, "m", px).call(n, u);
                        c({
                            storage: l ? H(n, Tp, "f") : H(n, Ep, "f")
                        });
                        let b = yield n.fetchEndpoints(), R = yield H(n, Zr, "m", hx).call(n, b.authorization_endpoint, E), L = new URL(R).searchParams, V = L.get("code"), z = yield d(i, s);
                        if ((z == null ? void 0 : z.challengeName) === "NEW_PASSWORD_REQUIRED" && a ? yield f(z, a): a && (yield h(z, s, a)), !V) {
                            let Y = z == null ? void 0 : z.getSignInUserSession();
                            if (!Y) {
                                let M = new Error("Couldn't find current user session.");
                                throw (g = n.logger) === null || g === void 0 || g.error({
                                    category: Tt,
                                    code: "OS-CLRT-40101",
                                    error: M,
                                    visibility: gn.Internal
                                }), M
                            }
                            let q = yield n.httpClient.post({
                                url: H(n, Zr, "m", fx).call(n),
                                payload: {
                                    clientId: H(n, wp, "f"),
                                    idToken: Y.getIdToken().getJwtToken(),
                                    accessToken: Y.getAccessToken().getJwtToken(),
                                    refreshToken: Y.getRefreshToken().getToken()
                                },
                                contentType: ir.Json
                            });
                            if (q === void 0) {
                                let M = new Error("Couldn't get any response from server while exchanging tokens.");
                                throw (p = n.logger) === null || p === void 0 || p.error({
                                    category: Tt,
                                    code: "OS-CLRT-40100",
                                    error: M
                                }), M
                            }
                            let P = q.authCode,
                                Z = (m = L.get("redirect_uri")) !== null && m !== void 0 ? m : "",
                                oe = (w = L.get("state")) !== null && w !== void 0 ? w : "",
                                S = yield H(n, Zr, "m", gx).call(n, Z, P, oe);
                            V = (T = new URL(S).searchParams.get("code")) !== null && T !== void 0 ? T : ""
                        }
                        let j = yield H(n, Zr, "m", mx).call(n, b.token_endpoint, V, E);
                        return yield n.storeUserInfo(j)
                    } catch (E) {
                        throw n.authData.clearAuthData(), n.userInfo.clear(), H(n, Zr, "m", hb).call(n, E)
                    }
                })()
            })
        }
        sendResetPasswordEmail(e) {
            return be(this, arguments, void 0, function(t) {
                let {
                    username: n,
                    authForgotPassword: i = o(s => Nn.forgotPassword(s), "authForgotPassword")
                } = t;
                return (function*() {
                    return i(n)
                })()
            })
        }
        confirmRegistration(e) {
            return be(this, arguments, void 0, function(t) {
                var n = this;
                let {
                    username: i,
                    password: s,
                    code: a
                } = t;
                return (function*() {
                    var u;
                    if (!n.validatePasswordComplexityPolicy(s).isValid) throw sr.create({
                        name: Qe.PasswordComplexityPolicyFailed,
                        message: "Password complexity policy failed.",
                        code: "OS-CLRT-40106"
                    });
                    let c = yield H(n, Zr, "m", gb).call(n, {
                        email: i,
                        verificationCode: a
                    }, "REGISTRATION");
                    try {
                        yield n.login({
                            username: i,
                            password: c,
                            newPassword: s
                        })
                    } catch (d) {
                        let f = d;
                        throw (u = n.logger) === null || u === void 0 || u.error({
                            category: Tt,
                            message: "Error confirming user registration",
                            error: f,
                            code: "OS-CLRT-40100",
                            visibility: gn.External
                        }), f.name === Qe.InvalidCredentials || f.name === Qe.TooManyFailedAttempts ? sr.create({
                            name: Qe.InvalidToken,
                            message: "Invalid temporary password.",
                            code: "OS-CLRT-40107"
                        }) : f
                    }
                })()
            })
        }
        changePassword(e) {
            return be(this, arguments, void 0, function(t) {
                var n = this;
                let {
                    username: i,
                    oldPassword: s,
                    newPassword: a,
                    authCurrentAuthenticatedUser: u = o(() => Nn.currentAuthenticatedUser(), "authCurrentAuthenticatedUser"),
                    authChangePassword: l = o((c, d, f) => Nn.changePassword(c, d, f), "authChangePassword")
                } = t;
                return (function*() {
                    var c, d, f;
                    let h = null;
                    try {
                        h = yield u()
                    } catch (p) {
                        let m = sr.create({
                            name: Qe.InvalidCredentials,
                            message: typeof p == "string" ? p : p.message,
                            code: "OS-CLRT-40101"
                        });
                        (c = n.logger) === null || c === void 0 || c.error({
                            category: Tt,
                            message: "Error in current authenticated user",
                            error: m,
                            code: m.errorCode
                        })
                    }
                    if (!h || i !== ((d = h == null ? void 0 : h.attributes) === null || d === void 0 ? void 0 : d.preferred_username)) throw sr.create({
                        name: Qe.InvalidCredentials,
                        message: "Invalid credentials",
                        code: "OS-CLRT-40104"
                    });
                    let g = n.validatePasswordComplexityPolicy(a);
                    if (!a || !g.isValid) throw sr.create({
                        name: Qe.PasswordComplexityPolicyFailed,
                        message: "Password complexity policy failed.",
                        code: "OS-CLRT-40106"
                    });
                    try {
                        yield l(h, s, a)
                    } catch (p) {
                        let m = H(n, Zr, "m", hb).call(n, p);
                        throw (f = n.logger) === null || f === void 0 || f.error({
                            category: Tt,
                            message: "Error changing password",
                            error: m,
                            code: m.errorCode,
                            visibility: gn.External
                        }), m
                    }
                })()
            })
        }
        finishResetPassword(e) {
            return be(this, arguments, void 0, function(t) {
                var n = this;
                let {
                    username: i,
                    resetToken: s,
                    newPassword: a,
                    changePassword: u = o((l, c, d) => this.login({
                        username: l,
                        password: c,
                        newPassword: d
                    }), "changePassword")
                } = t;
                return (function*() {
                    var l;
                    let c = n.validatePasswordComplexityPolicy(a);
                    if (!a || !c.isValid) throw sr.create({
                        name: Qe.PasswordComplexityPolicyFailed,
                        message: "Password complexity policy failed.",
                        code: "OS-CLRT-40106"
                    });
                    let d = yield H(n, Zr, "m", gb).call(n, {
                        email: i,
                        verificationCode: s
                    }, "RESET_PASSWORD");
                    try {
                        yield u(i, d, a)
                    } catch (f) {
                        throw (l = n.logger) === null || l === void 0 || l.error({
                            category: Tt,
                            message: "Error resetting password",
                            error: f,
                            code: "OS-CLRT-40107",
                            visibility: gn.External
                        }), sr.create({
                            name: Qe.InvalidToken,
                            message: "Invalid password reset token.",
                            code: "OS-CLRT-40107"
                        })
                    }
                })()
            })
        }
        resetPassword(e) {
            return be(this, arguments, void 0, function(t) {
                var n = this;
                let {
                    username: i,
                    resetToken: s,
                    newPassword: a,
                    authForgotPassword: u = o((l, c, d) => Nn.forgotPasswordSubmit(l, c, d), "authForgotPassword")
                } = t;
                return (function*() {
                    var l;
                    let c = n.validatePasswordComplexityPolicy(a);
                    if (!a || !c.isValid) throw sr.create({
                        name: Qe.PasswordComplexityPolicyFailed,
                        message: "Password complexity policy failed.",
                        code: "OS-CLRT-40106"
                    });
                    try {
                        yield u(i, s, a)
                    } catch (d) {
                        throw (l = n.logger) === null || l === void 0 || l.error({
                            category: Tt,
                            message: "Error resetting password",
                            error: d,
                            code: "OS-CLRT-40107",
                            visibility: gn.External
                        }), sr.create({
                            name: Qe.InvalidToken,
                            message: "Invalid password reset token.",
                            code: "OS-CLRT-40107"
                        })
                    }
                })()
            })
        }
        getPasswordComplexityPolicy() {
            return H(this, Ri, "f")
        }
        validatePasswordComplexityPolicy() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "",
                t = e.length < H(this, Ri, "f").minimumLength,
                n = H(this, Ri, "f").upperCaseLetterRequired && !/[A-Z]/.test(e),
                i = H(this, Ri, "f").lowerCaseLetterRequired && !/[a-z]/.test(e),
                s = H(this, Ri, "f").numberRequired && !/\d/.test(e),
                a = H(this, Ri, "f").specialCharacterRequired && !/[\^$*.[\]{}()?"!@#%&/\\,><':;|_~`=+\- ]/.test(e);
            return {
                isValid: !t && !n && !i && !s && !s && !a,
                missingMinimumLength: t,
                missingUpperCaseLetter: n,
                missingLowerCaseLetter: i,
                missingNumber: s,
                missingSpecialCharacter: a
            }
        }
        isExternalUser() {
            return !1
        }
    };
o(jb, "BuiltinAuth");
var pb = jb;
Ri = new WeakMap, wp = new WeakMap, Hp = new WeakMap, Tp = new WeakMap, Ep = new WeakMap, jp = new WeakMap, Wp = new WeakMap, Zr = new WeakSet, hb = o(function(e) {
    var t, n, i;
    let s = e,
        a = (t = s.name) !== null && t !== void 0 ? t : Qe.UnknownFailure,
        u = !s.errorCode || s.errorCode.startsWith("OS-CLRT-6") ? "OS-CLRT-40100" : s.errorCode;
    return s.name === "NotAuthorizedException" ? !((n = s.message) === null || n === void 0) && n.includes("Incorrect username or password") ? (a = Qe.InvalidCredentials, u = "OS-CLRT-40104") : !((i = s.message) === null || i === void 0) && i.includes("Password attempts exceeded") && (a = Qe.TooManyFailedAttempts, u = "OS-CLRT-40105") : s.name === "LimitExceededException" && (a = Qe.TooManyFailedAttempts, u = "OS-CLRT-40105"), sr.create({
        name: a,
        message: s.message,
        code: u
    })
}, "_BuiltinAuth_sanitizeError"), fx = o(function() {
    return "/identityapi/v1alpha1/oidc/store-token"
}, "_BuiltinAuth_getTokenExchangeUrl"), hx = o(function(e, t) {
    return be(this, void 0, void 0, function*() {
        let n = {
            client_id: _d,
            scope: this.scope,
            redirect_uri: t != null ? t : "",
            response_type: "code",
            kc_idp_hint: H(this, Hp, "f")
        };
        return this.httpClient.getResponseUrl({
            url: e,
            params: n
        })
    })
}, "_BuiltinAuth_getRedirectUrl"), gx = o(function(e, t, n) {
    return be(this, void 0, void 0, function*() {
        let i = {
            code: t,
            state: n
        };
        return this.httpClient.getResponseUrl({
            url: e,
            params: i
        })
    })
}, "_BuiltinAuth_getAuthCode"), px = o(function(e) {
    return e.replace("outsystems://", "https://")
}, "_BuiltinAuth_getSafeRedirectUri"), iL = o(function(e) {
    return e && vre.includes(e) ? Qe.InvalidToken : e && yre.includes(e) ? Qe.InvalidCredentials : Qe.UnknownFailure
}, "_BuiltinAuth_mapErrorCodeToFailureReason"), gb = o(function(e, t) {
    return be(this, void 0, void 0, function*() {
        var n, i, s, a, u, l, c;
        try {
            let d = t === "REGISTRATION" ? this.buildUrl(H(this, jp, "f")) : this.buildUrl(H(this, Wp, "f")),
                f = yield this.httpClient.post({
                    url: d,
                    payload: e,
                    contentType: ir.Json
                });
            if (f === void 0) {
                let h = new Error("Couldn't get any response from server while getting temporary password.");
                throw (n = this.logger) === null || n === void 0 || n.error({
                    category: Tt,
                    code: "OS-CLRT-40100",
                    error: h
                }), h
            }
            return f.registrationToken
        } catch (d) {
            let f = d,
                h = (i = f.response) === null || i === void 0 ? void 0 : i.detail,
                g = "Error getting temporary password";
            throw (s = this.logger) === null || s === void 0 || s.error({
                category: Tt,
                error: f,
                message: `${g}: ${h!=null?h:""}`,
                visibility: gn.Client
            }), (a = this.logger) === null || a === void 0 || a.error({
                category: Tt,
                error: new Error(`[${t}]${g}: code = ${(l=(u=f.response)===null||u===void 0?void 0:u.errorCode)!==null&&l!==void 0?l:"UNKNOWN"}`),
                visibility: gn.Internal
            }), sr.create({
                name: H(this, Zr, "m", iL).call(this, (c = f.response) === null || c === void 0 ? void 0 : c.errorCode),
                message: g
            })
        }
    })
}, "_BuiltinAuth_getTemporaryPassword"), mx = o(function(e, t, n) {
    return be(this, void 0, void 0, function*() {
        var i;
        try {
            let s = yield this.httpClient.post({
                url: e,
                payload: {
                    grant_type: "authorization_code",
                    code: t,
                    client_id: _d,
                    redirect_uri: n
                }
            });
            if (s === void 0) {
                let a = new Error("Couldn't get any response from server while getting tokens.");
                throw (i = this.logger) === null || i === void 0 || i.error({
                    category: Tt,
                    code: "OS-CLRT-40100",
                    error: a
                }), a
            }
            return s
        } catch (s) {
            throw H(this, Zr, "m", sL).call(this, s)
        }
    })
}, "_BuiltinAuth_requestToken"), sL = o(function(e) {
    var t;
    let n = e instanceof Error ? `[Token endpoint] ${e.message}` : "Token endpoint call failed",
        i = (t = e == null ? void 0 : e.response) === null || t === void 0 ? void 0 : t.error_description;
    return i && (n += `: ${i}`), sr.create({
        name: Qe.IdentityTokenEndpointFailed,
        code: "OS-ID-BIZ-40021",
        message: n
    })
}, "_BuiltinAuth_parseTokenError");
var mb;
(function(r) {
    r.External = "external", r.Builtin = "builtin"
})(mb || (mb = {}));
var Yt = mb,
    hr, dd, Li, iu, bp, vb, td, vx, yx, Sp, _x, Wb = class Wb {
        constructor(e) {
            let {
                info: t,
                data: n = new Ro
            } = e;
            hr.add(this), dd.set(this, void 0), Li.set(this, void 0), iu.set(this, ""), Ae(this, dd, t, "f"), Ae(this, Li, n, "f")
        }
        setAuthInfo(e, t) {
            Ae(this, dd, e, "f"), Ae(this, Li, new Ro, "f"), H(this, hr, "m", Sp).call(this, e) !== H(this, iu, "f") && (Ae(this, iu, "", "f"), H(this, Li, "f").clearAuthData()), t && Ae(this, hr, t, "a", vb)
        }
        getBuiltinAuthInfo() {
            let e = H(this, hr, "m", td).call(this);
            if (H(this, hr, "m", vx).call(this, e)) return e
        }
        getExternalAuthInfo(e) {
            let t = H(this, hr, "m", td).call(this, e, !0);
            if (H(this, hr, "m", yx).call(this, t)) return t
        }
        saveConfig(e, t) {
            let n = H(this, hr, "m", _x).call(this, t);
            n && H(this, Li, "f").storeCurrentAuthConfig(n), Ae(this, hr, e, "a", vb), Ae(this, iu, H(this, hr, "m", Sp).call(this, t), "f")
        }
        getAuthType() {
            return H(this, hr, "a", bp)
        }
        hasChanges(e, t) {
            if (e && e !== H(this, hr, "a", bp)) return !0;
            let n = H(this, hr, "a", bp) === Yt.Builtin ? H(this, hr, "m", td).call(this) : H(this, hr, "m", td).call(this, t, !0);
            return H(this, iu, "f") !== H(this, hr, "m", Sp).call(this, n)
        }
    };
o(Wb, "ConfigHandler");
var yb = Wb;
dd = new WeakMap, Li = new WeakMap, iu = new WeakMap, hr = new WeakSet, bp = o(function() {
    var e;
    return (e = H(this, Li, "f").readCurrentAuthType()) !== null && e !== void 0 ? e : void 0
}, "_ConfigHandler_authType_get"), vb = o(function(e) {
    e && H(this, Li, "f").storeCurrentAuthType(e)
}, "_ConfigHandler_authType_set"), td = o(function(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    var n;
    let i = e;
    return t && typeof i == "undefined" && (i = (n = H(this, Li, "f").readCurrentAuthConfig()) !== null && n !== void 0 ? n : void 0), Object.assign(Object.assign({}, H(this, dd, "f")), i != null ? i : {})
}, "_ConfigHandler_getAuthInfo"), vx = o(function(e) {
    return e.region !== void 0 && e.poolId !== void 0 && e.clientId !== void 0 && e.identityProvider !== void 0
}, "_ConfigHandler_isBuiltinAuthInfo"), yx = o(function(e) {
    return e.clientId !== void 0 && e.identityProvider !== void 0
}, "_ConfigHandler_isExternalAuthInfo"), Sp = o(function(e) {
    let {
        identityProvider: t,
        clientId: n,
        passwordComplexityPolicy: i,
        poolId: s,
        region: a
    } = e, {
        lowerCaseLetterRequired: u,
        minimumLength: l,
        numberRequired: c,
        specialCharacterRequired: d,
        upperCaseLetterRequired: f
    } = i != null ? i : {}, h = `${u}${l}|${c}|${d}|${f}`;
    return `${t}|${n}|${h}|${s}|${a}`
}, "_ConfigHandler_buildHash"), _x = o(function(e) {
    let {
        region: t,
        poolId: n,
        clientId: i,
        identityProvider: s
    } = e;
    if (i && s) return {
        region: t,
        poolId: n,
        clientId: i,
        identityProvider: s
    }
}, "_ConfigHandler_getAuthConfig");
var Jn, fd, hd, So, cu, gd, xi, pd, _b, kE, oL, aL, FE, Gb = class Gb {
    constructor(e) {
        let {
            appKey: t,
            identityProvider: n,
            appUrl: i,
            region: s,
            poolId: a,
            clientId: u,
            scope: l = "",
            passwordComplexityPolicy: c,
            authData: d = new Ro,
            authInstance: f,
            logger: h,
            httpClient: g,
            configHandler: p = new yb({
                info: {
                    identityProvider: n,
                    clientId: u,
                    passwordComplexityPolicy: c,
                    poolId: a,
                    region: s,
                    scope: l
                },
                data: d
            }),
            isOnline: m
        } = e;
        Jn.add(this), fd.set(this, void 0), hd.set(this, void 0), So.set(this, void 0), cu.set(this, void 0), gd.set(this, void 0), xi.set(this, void 0), pd.set(this, void 0), Ae(this, fd, t, "f"), Ae(this, hd, i, "f"), Ae(this, So, f, "f"), Ae(this, cu, h, "f"), Ae(this, gd, g, "f"), Ae(this, xi, p, "f"), Ae(this, pd, m, "f")
    }
    getInstance(e, t) {
        var n;
        let i = e != null ? e : H(this, xi, "f").getAuthType(),
            s = H(this, xi, "f").hasChanges(e, t),
            a = !!(!((n = H(this, So, "f")) === null || n === void 0) && n.isAuthenticated());
        if (!H(this, So, "f") && i) H(this, Jn, "m", _b).call(this, i, t);
        else if (!a && i && s) H(this, Jn, "m", _b).call(this, i, t);
        else if (a && s) throw new Error("Error getting new instance of auth because a user is already authenticated using another mechanism");
        return H(this, So, "f")
    }
    updateConfig(e, t) {
        H(this, xi, "f").setAuthInfo(e, t)
    }
};
o(Gb, "AuthFactory");
var Gp = Gb;
fd = new WeakMap, hd = new WeakMap, So = new WeakMap, cu = new WeakMap, gd = new WeakMap, xi = new WeakMap, pd = new WeakMap, Jn = new WeakSet, _b = o(function(e, t) {
    switch (e) {
        case Yt.External:
            return H(this, Jn, "m", oL).call(this, t);
        case Yt.Builtin:
            return H(this, Jn, "m", aL).call(this);
        default:
            throw new Error(`Invalid new auth type: ${e}`)
    }
}, "_AuthFactory_createInstance"), kE = o(function(e, t, n) {
    Ae(this, So, e, "f"), H(this, xi, "f").saveConfig(t, n)
}, "_AuthFactory_setInstance"), oL = o(function(e) {
    let t = H(this, xi, "f").getExternalAuthInfo(e);
    H(this, Jn, "m", FE).call(this, t);
    let n = new fb({
        appKey: H(this, fd, "f"),
        appUrl: H(this, hd, "f"),
        scope: t.scope,
        region: t.region,
        poolId: t.poolId,
        clientId: t.clientId,
        identityProvider: t.identityProvider,
        logger: H(this, cu, "f"),
        httpClient: H(this, gd, "f"),
        isOnline: H(this, pd, "f")
    });
    H(this, Jn, "m", kE).call(this, n, Yt.External, t)
}, "_AuthFactory_createExternalAuth"), aL = o(function() {
    let e = H(this, xi, "f").getBuiltinAuthInfo();
    H(this, Jn, "m", FE).call(this, e);
    let t = new pb({
        appKey: H(this, fd, "f"),
        appUrl: H(this, hd, "f"),
        scope: e.scope,
        region: e.region,
        poolId: e.poolId,
        clientId: e.clientId,
        identityProvider: e.identityProvider,
        passwordComplexityPolicy: e.passwordComplexityPolicy,
        logger: H(this, cu, "f"),
        httpClient: H(this, gd, "f"),
        isOnline: H(this, pd, "f")
    });
    H(this, Jn, "m", kE).call(this, t, Yt.Builtin, e)
}, "_AuthFactory_createBuiltinAuth"), FE = o(function(e) {
    var t;
    if (!e) {
        let n = sr.create({
            name: "Error loading auth configuration",
            message: "Identity provider configurations missing.",
            code: "OS-CLRT-40109"
        });
        throw (t = H(this, cu, "f")) === null || t === void 0 || t.error({
            category: Tt,
            message: n.message,
            error: n,
            code: n.errorCode,
            visibility: gn.External
        }), n
    }
}, "_AuthFactory_validateAuthInfo");
var uL;
(function(r) {
    r.Auth_Default = "OS-CLRT-40100", r.Auth_No_Login = "OS-CLRT-40101", r.Auth_Invalid_Mechanism = "OS-CLRT-40102", r.Auth_Invalid_RefreshToken = "OS-CLRT-40103", r.Auth_Invalid_Credentials = "OS-CLRT-40104", r.Auth_Login_Attempts = "OS-CLRT-40105", r.Auth_Password_Policy = "OS-CLRT-40106", r.Auth_Invalid_Inputs = "OS-CLRT-40107", r.Auth_Logout_Failed = "OS-CLRT-40108", r.Auth_No_Configuration = "OS-CLRT-40109", r.Auth_Configuration_Failed = "OS-CLRT-40110", r.Auth_UserIdMissing = "OS-CLRT-40111", r.Auth_RefreshToken_Unavailable = "OS-CLRT-40112", r.Auth_FailedToGetUserInfo = "OS-CLRT-40113", r.Auth_ChangeEmailEmptyVerificationCode = "OS-CLRT-40114", r.Auth_CallingChangeEmail_Failed = "OS-CLRT-40115", r.AuthZ_Default = "OS-CLRT-40300", r.AuthZ_Screen_No_Roles = "OS-CLRT-40301", r.AuthZ_No_Permissions = "OS-CLRT-40302", r.AuthZ_Not_Registered = "OS-CLRT-40303", r.IdentityTokenFailure = "OS-ID-BIZ-40021"
})(uL || (uL = {}));
var YA = new Map,
    uU = "Client Runtime Packages",
    fm;

function XA(r, e) {
    fm = null, YA.set(r, e)
}
o(XA, "registerPackage");
var cU = o(r => {
    let {
        versionsMap: e = YA,
        packageKey: t
    } = r;
    var n;
    return (n = e == null ? void 0 : e.get(t)) !== null && n !== void 0 ? n : null
}, "getPackageVersion");

function _re() {
    if (!fm) {
        let r = {
            "Client Runtime Packages": ""
        };
        YA.forEach((e, t) => {
            e && t && (r[uU] += `${t}= ${e};`)
        }), fm = r
    }
    return fm
}
o(_re, "toObject$1");
var wre = Object.freeze({
    __proto__: null,
    clientRuntimeKey: uU,
    getPackageVersion: cU,
    registerPackage: XA,
    toObject: _re
});

function nt(r, e, t, n) {
    var i = arguments.length,
        s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n,
        a;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, n);
    else
        for (var u = r.length - 1; u >= 0; u--)(a = r[u]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, t, s) : a(e, t)) || s);
    return i > 3 && s && Object.defineProperty(e, t, s), s
}
o(nt, "__decorate");

function k(r, e, t, n) {
    function i(s) {
        return s instanceof t ? s : new t(function(a) {
            a(s)
        })
    }
    return o(i, "adopt"), new(t || (t = Promise))(function(s, a) {
        function u(d) {
            try {
                c(n.next(d))
            } catch (f) {
                a(f)
            }
        }
        o(u, "fulfilled");

        function l(d) {
            try {
                c(n.throw(d))
            } catch (f) {
                a(f)
            }
        }
        o(l, "rejected");

        function c(d) {
            d.done ? s(d.value) : i(d.value).then(u, l)
        }
        o(c, "step"), c((n = n.apply(r, e || [])).next())
    })
}
o(k, "__awaiter");

function ie(r, e, t, n) {
    if (t === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? r !== e || !n : !e.has(r)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return t === "m" ? n : t === "a" ? n.call(r) : n ? n.value : e.get(r)
}
o(ie, "__classPrivateFieldGet");

function dt(r, e, t, n, i) {
    if (n === "m") throw new TypeError("Private method is not writable");
    if (n === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? r !== e || !i : !e.has(r)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return n === "a" ? i.call(r, t) : i ? i.value = t : e.set(r, t), t
}
o(dt, "__classPrivateFieldSet");
var xm;
(function(r) {
    r[r.None = 0] = "None", r[r.Default = 1] = "Default", r[r.Fade = 2] = "Fade", r[r.SlideFromLeft = 3] = "SlideFromLeft", r[r.SlideFromRight = 4] = "SlideFromRight", r[r.SlideFromBottom = 5] = "SlideFromBottom", r[r.SlideFromTop = 6] = "SlideFromTop"
})(xm || (xm = {}));
var Tre = Object.freeze({
        __proto__: null,
        get TransitionAnimation() {
            return xm
        }
    }),
    ni = xm,
    ZI = class ZI {
        constructor() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
            this.name = e
        }
    };
o(ZI, "Transition");
var Zt = ZI,
    Ere = new Zt,
    cS = new Zt("fade"),
    lS = new Zt("slide-from-left"),
    dS = new Zt("slide-from-right"),
    fS = new Zt("slide-from-bottom"),
    hS = new Zt("slide-from-top"),
    Af = new Zt;

function lU(r) {
    Af = r
}
o(lU, "setDefaultTransition");

function bre(r) {
    return new Zt(r ? r.name : "")
}
o(bre, "sanitizeTransition");

function ty(r, e) {
    if (typeof r == "string") return new Zt(r);
    switch (r) {
        case ni.None:
            return Ere;
        case ni.Fade:
            return cS;
        case ni.SlideFromLeft:
            return lS;
        case ni.SlideFromRight:
            return dS;
        case ni.SlideFromBottom:
            return fS;
        case ni.SlideFromTop:
            return hS;
        case ni.Default:
            return Af;
        default:
            return e
    }
}
o(ty, "createTransition");

function Sre(r) {
    if (!(r != null && r.name)) return new Zt("");
    switch (r.name) {
        case cS.name:
            return new Zt(cS.name);
        case fS.name:
            return new Zt(hS.name);
        case lS.name:
            return new Zt(dS.name);
        case dS.name:
            return new Zt(lS.name);
        case hS.name:
            return new Zt(fS.name);
        default:
            return new Zt(r.name + "-back")
    }
}
o(Sre, "reverseTransition");
var Are = Object.freeze({
        __proto__: null,
        get Default() {
            return Af
        },
        Transition: Zt,
        TransitionAnimation: ni,
        createTransition: ty,
        reverseTransition: Sre,
        sanitizeTransition: bre,
        setDefaultTransition: lU
    }),
    Fi = "",
    ct = {
        applicationKey: Fi,
        applicationName: Fi,
        userProviderName: Fi,
        debugEnabled: !1,
        debugUseWebSockets: !1,
        homeModuleName: Fi,
        homeModuleKey: Fi,
        modules: {},
        serverRequestTimeoutOverrideInSeconds: void 0,
        isWeb: !1,
        frontendBuildWorkerVersion: Fi,
        clientRuntimeVersion: Fi,
        appVersion: ""
    };

function dU(r) {
    ct = r
}
o(dU, "setApplicationDefinition");

function js() {
    return ct.applicationKey
}
o(js, "getApplicationKey");

function ry() {
    return ct.applicationName
}
o(ry, "getApplicationName");

function gS() {
    var r;
    return (r = ct.databaseName) !== null && r !== void 0 ? r : ""
}
o(gS, "getDatabaseName");

function fU(r) {
    ct.modules = r
}
o(fU, "setModules");

function hU() {
    var r;
    return (r = ct.modules) !== null && r !== void 0 ? r : {}
}
o(hU, "getModules");

function gU(r) {
    let e = ct.modules;
    return !(e == null ? void 0 : e[r]) && e && (e[r] = {
        moduleName: null,
        homeScreenName: null,
        splashScreenName: null,
        screens: [],
        staticEntities: {}
    }), e == null ? void 0 : e[r]
}
o(gU, "getModuleFromKey");

function pU(r) {
    return r != null && r.homeScreenName ? JA(r, r.homeScreenName) : r != null && r.screens && r.screens.length > 0 ? r.screens[0] : null
}
o(pU, "getHomeScreen");

function mU() {
    return ct.clientEntitiesModuleImporter
}
o(mU, "getClientEntitiesModuleImporter");

function vU(r) {
    ct.databaseName = r
}
o(vU, "setDatabaseName");

function Gr() {
    return ct.homeModuleName
}
o(Gr, "getHomeModuleName");

function yU() {
    return ct.homeModuleKey
}
o(yU, "getHomeModuleKey");

function ny() {
    if (ct.homeModuleName && ct.modules) {
        let r = ct.modules[ct.homeModuleKey];
        return r || null
    }
    return null
}
o(ny, "getHomeModuleDefinition");

function JA(r, e) {
    for (let t of r.screens)
        if (t.screenName === e) return t;
    return null
}
o(JA, "getScreenDefinitionFromScreenName");

function Ire() {
    let r = ny(),
        e = pU(r);
    return e ? `/${r==null?void 0:r.moduleName}/${e.screenUrl}` : null
}
o(Ire, "getDefaultModuleHomeScreenURL");

function ZA() {
    return ct.userProviderName
}
o(ZA, "getUserProviderName");

function _U() {
    var r;
    return (r = ct.debugEnabled) !== null && r !== void 0 ? r : !1
}
o(_U, "isDebugEnabled$1");

function wU() {
    var r;
    return (r = ct.debugUseWebSockets) !== null && r !== void 0 ? r : !1
}
o(wU, "debugUseWebSockets");

function TU() {
    return ct.homeModuleControllerImporter
}
o(TU, "getHomeModuleControllerImporter");

function EU() {
    return ct.homeModuleLanguageResourcesImporter
}
o(EU, "getHomeModuleLanguageResourcesImporter");

function bU() {
    return ct.serverRequestTimeoutOverrideInSeconds
}
o(bU, "getServerRequestTimeoutOverrideInSeconds");

function SU(r) {
    ct.serverRequestTimeoutOverrideInSeconds = r
}
o(SU, "setServerRequestTimeoutOverrideInSeconds");

function AU() {
    var r;
    let e = ni[(r = ct.defaultTransition) !== null && r !== void 0 ? r : ni.None];
    return ty(e)
}
o(AU, "getDefaultTransition");

function QA() {
    return ct.errorPageConfig
}
o(QA, "getErrorPageConfig");

function If() {
    var r;
    return (r = ct.isWeb) !== null && r !== void 0 ? r : !1
}
o(If, "isWebApplication");

function IU() {
    var r;
    return (r = ct.frontendBuildWorkerVersion) !== null && r !== void 0 ? r : Fi
}
o(IU, "getFrontendBuildWorkerVersion");

function CU() {
    var r;
    return (r = ct.clientRuntimeVersion) !== null && r !== void 0 ? r : Fi
}
o(CU, "getClientRuntimeVersion");

function Cre(r) {
    var e, t;
    let n = (e = ct.modules) !== null && e !== void 0 ? e : {};
    return ((t = Object.keys(n).map(s => n[s]).filter(s => s.moduleName === r)[0]) === null || t === void 0 ? void 0 : t.ownerAppKey) === js()
}
o(Cre, "moduleBelongsToApp");

function Dt() {
    let {
        applicationHomeModule: r = Gr
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var e, t;
    return `/${(t=(e=(typeof window!="undefined"?window:globalThis).OutSystemsApp)===null||e===void 0?void 0:e.basePath)!==null&&t!==void 0?t:r()}/`.replace(/\/(\/)+/gm, "/")
}
o(Dt, "getBasePath");

function eI() {
    let {
        windowLocation: r = window.location,
        applicationHomeModule: e = Gr
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return `${r.protocol}//${r.host}${Dt({applicationHomeModule:e})}`
}
o(eI, "getAppUrl");

function Rre() {
    return ct.screensDefinition
}
o(Rre, "getScreensDefinition");

function RU() {
    return ct.appVersion
}
o(RU, "getAppVersion");

function tI() {
    return ct.syncConfiguration
}
o(tI, "getSyncConfiguration");
var Ore = Object.freeze({
        __proto__: null,
        debugUseWebSockets: wU,
        getAppUrl: eI,
        getAppVersion: RU,
        getApplicationKey: js,
        getApplicationName: ry,
        getBasePath: Dt,
        getClientEntitiesModuleImporter: mU,
        getClientRuntimeVersion: CU,
        getDatabaseName: gS,
        getDefaultModuleHomeScreenURL: Ire,
        getDefaultTransition: AU,
        getErrorPageConfig: QA,
        getFrontendBuildWorkerVersion: IU,
        getHomeModuleControllerImporter: TU,
        getHomeModuleDefinition: ny,
        getHomeModuleKey: yU,
        getHomeModuleLanguageResourcesImporter: EU,
        getHomeModuleName: Gr,
        getHomeScreen: pU,
        getModuleFromKey: gU,
        getModules: hU,
        getScreenDefinitionFromScreenName: JA,
        getScreensDefinition: Rre,
        getServerRequestTimeoutOverrideInSeconds: bU,
        getSyncConfiguration: tI,
        getUserProviderName: ZA,
        isDebugEnabled: _U,
        isWebApplication: If,
        moduleBelongsToApp: Cre,
        setApplicationDefinition: dU,
        setDatabaseName: vU,
        setModules: fU,
        setServerRequestTimeoutOverrideInSeconds: SU
    }),
    pS;
(function(r) {
    r[r.Persistent = 0] = "Persistent", r[r.Session = 1] = "Session"
})(pS || (pS = {}));
var ar = pS,
    QI = class QI {
        get length() {
            return Object.keys(this.storageObj).length
        }
        clear() {
            this.storageObj = {}
        }
        getItem(e) {
            return this.storageObj.hasOwnProperty(e) ? this.storageObj[e] : null
        }
        key(e) {
            let t = Object.keys(this.storageObj);
            return e < t.length ? t[e] : null
        }
        removeItem(e) {
            this.storageObj.hasOwnProperty(e) && delete this.storageObj[e]
        }
        setItem(e, t) {
            this.storageObj[e] = t
        }
        constructor(e) {
            if (this.storageObj = {}, e) {
                let t = 0,
                    n = e.key(t);
                for (; n !== null;) this.storageObj[n] = e.getItem(n), n = e.key(++t)
            }
        }
    };
o(QI, "InMemoryStorage");
var Go = QI,
    Um = "$OS_",
    OU = "OS";

function PU() {
    return OU
}
o(PU, "getDefaultStorageNamespace");

function NU(r) {
    OU = r
}
o(NU, "setDefaultStorageNamespace");
var DU = typeof window == "undefined" ? void 0 : window.localStorage,
    LU = typeof window == "undefined" ? void 0 : window.sessionStorage,
    rI = o(r => r === ar.Persistent ? DU : LU, "getBuiltInStorage"),
    Pd = xU(ar.Persistent) ? rI(ar.Persistent) : new Go,
    Nd = xU(ar.Session) ? rI(ar.Session) : new Go;

function xU(r) {
    let e = Um + "test",
        t = "1";
    try {
        let n = rI(r);
        n.setItem(e, t);
        let i = n.getItem(e) === t;
        return n.removeItem(e), i
    } catch (n) {
        return !1
    }
}
o(xU, "isSpecificStorageAvailable");

function UU() {
    return Pd
}
o(UU, "getPersistentStorage");

function MU() {
    return Nd
}
o(MU, "getSessionStorage");

function Pre(r) {
    Pd = r
}
o(Pre, "setCustomPersistentStorage");

function Nre(r) {
    Nd = r
}
o(Nre, "setCustomSessionStorage");

function Dre(r) {
    return r === ar.Persistent && Pd !== DU ? (console.warn("The localStorage is full... Proceding with a static Javascript object"), Pd = new Go(Pd), !0) : r === ar.Session && Nd !== LU ? (console.warn("The sessionStorage is full... Proceding with a static Javascript object"), Nd = new Go(Nd), !0) : !1
}
o(Dre, "tryExpandStorage");
var wx = Object.freeze(Object()),
    eC = class eC {
        constructor(e, t, n, i) {
            this.storageType = e, this.key = t, this.defaultValue = n, this.getStorageName = () => PU(), this.clearCache(), i && (this.getStorageName = i)
        }
        get() {
            return this.getValue()
        }
        set(e) {
            this.setValueInStorage(e)
        }
        remove() {
            this.storage.removeItem(this.storageKey), this.clearCache()
        }
        isDefined() {
            let e = this.storage.getItem(this.storageKey);
            return e != null && e !== "undefined"
        }
        get storageKey() {
            return Um + this.getStorageName() + "$" + this.key
        }
        get storage() {
            return this.storageType === ar.Persistent ? UU() : MU()
        }
        getValue() {
            return this.cachedValue === wx && (this.cachedValue = this.getValueFromStorage()), this.cachedValue
        }
        getValueFromStorage() {
            let e = this.storage.getItem(this.storageKey);
            return e === null ? this.defaultValue : e === "undefined" || e === void 0 ? void 0 : JSON.parse(e)
        }
        setValueInStorage(e) {
            let t = this.storageKey,
                n = JSON.stringify(e),
                i = this.storage;
            if (!(i != null && i.setItem)) throw Error("The storage object for " + this.key + " is invalid.");
            try {
                i.setItem(t, n), this.cachedValue = e
            } catch (s) {
                if (Dre(this.storageType)) this.storage.setItem(t, n);
                else throw s
            }
        }
        clearCache() {
            this.cachedValue = wx
        }
    };
o(eC, "StorageObject");
var wn = eC,
    Lre = Object.freeze({
        __proto__: null,
        DummyStorage: Go,
        StorageObject: wn,
        StorageType: ar,
        getDefaultStorageNamespace: PU,
        getPersistentStorage: UU,
        getSessionStorage: MU,
        setCustomPersistentStorage: Pre,
        setCustomSessionStorage: Nre,
        setDefaultStorageNamespace: NU
    }),
    tC = class tC {
        constructor(e) {
            this._device = e
        }
        get device() {
            return this._device
        }
    };
o(tC, "ClientInfo");
var Mm = tC,
    rC = class rC {
        constructor(e, t, n, i, s, a, u, l) {
            this._platform = e, this._version = t, this._manufacturer = n, this._model = i, this._uuid = s, this._serial = a, this._cordova = u, this._isVirtual = l
        }
        get platform() {
            return this._platform
        }
        get version() {
            return this._version
        }
        get manufacturer() {
            return this._manufacturer
        }
        get model() {
            return this._model
        }
        get uuid() {
            return this._uuid
        }
        get serial() {
            return this._serial
        }
        get cordova() {
            return this._cordova
        }
        get isVirtual() {
            return this._isVirtual
        }
    };
o(rC, "DeviceInfo");
var km = rC,
    mS;
(function(r) {
    function e(u) {
        let l = t(u);
        if (l) return JSON.stringify(l)
    }
    o(e, "serializeClientInfo"), r.serializeClientInfo = e;

    function t(u) {
        if (u) return {
            device: u.device ? n(u.device) : void 0
        }
    }
    o(t, "clientInfoToObject");

    function n(u) {
        if (u) return {
            platform: u.platform,
            version: u.version,
            manufacturer: u.manufacturer,
            model: u.model,
            uuid: u.uuid,
            serial: u.serial,
            cordova: u.cordova,
            isVirtual: u.isVirtual
        }
    }
    o(n, "deviceInfoToObject");

    function i(u) {
        let l;
        try {
            l = JSON.parse(u)
        } catch (c) {}
        if (l) return s(l)
    }
    o(i, "deserializeClientInfo"), r.deserializeClientInfo = i;

    function s(u) {
        if (u) return new Mm(a(u.device))
    }
    o(s, "objectToClientInfo");

    function a(u) {
        if (u) return new km(typeof u.platform == "string" ? u.platform : void 0, typeof u.version == "string" ? u.version : void 0, typeof u.manufacturer == "string" ? u.manufacturer : void 0, typeof u.model == "string" ? u.model : void 0, typeof u.uuid == "string" ? u.uuid : void 0, typeof u.serial == "string" ? u.serial : void 0, typeof u.cordova == "string" ? u.cordova : void 0, typeof u.isVirtual == "boolean" ? u.isVirtual : void 0)
    }
    o(a, "objectToDeviceInfo")
})(mS || (mS = {}));
var xre = new wn(ar.Persistent, "ClientInfo");

function Ure() {
    let r = window.device;
    if (r) {
        let e = new Mm(new km(r.platform, r.version, r.manufacturer, r.model, r.uuid, r.serial, r.cordova, r.isVirtual));
        xre.set(mS.serializeClientInfo(e))
    }
}
o(Ure, "setClientInfo");
var pe;
(function(r) {
    r.CustomError = function(X) {
        let W = Error.call(this, X);
        typeof Object.setPrototypeOf == "function" ? Object.setPrototypeOf(W, this.constructor.prototype) : W.__proto__ = this.constructor.prototype, (!("stack" in this) || this.stack === "") && (Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = W.stack)
    }, r.CustomError.prototype = Error.prototype;
    let j = class j extends r.CustomError {
        constructor(W, te, _e, we) {
            super(W != null ? W : ""), this.extraStack = te, this.message = W != null ? W : "", this.name = "Exception", this.errorCode = _e, this.category = we
        }
    };
    o(j, "Exception");
    let e = j;
    r.Exception = e;
    let Y = class Y extends e {
        constructor(W, te, _e, we) {
            super(te, _e, we), this.specificType = W, this.name = W
        }
    };
    o(Y, "ServerException");
    let t = Y;
    r.ServerException = t;
    let q = class q extends e {
        constructor(W, te, _e, we) {
            super(te, _e, we), this.specificType = W, this.name = W
        }
    };
    o(q, "DataBaseException");
    let n = q;
    r.DataBaseException = n;
    let P = class P extends n {
        constructor(W, te, _e) {
            super("OpenDatabaseException", W, te, _e)
        }
    };
    o(P, "OpenDatabaseException");
    let i = P;
    r.OpenDatabaseException = i;
    let Z = class Z extends e {
        constructor(W, te, _e, we) {
            super(W, te, _e, we), this.name = "CommunicationException"
        }
    };
    o(Z, "CommunicationException");
    let s = Z;
    r.CommunicationException = s;
    let oe = class oe extends e {
        constructor(W, te) {
            super(W, te), this.name = "NumberOverflowException"
        }
        valueOf() {
            return this.name + ": " + this.message
        }
    };
    o(oe, "NumberOverflowException");
    let a = oe;
    r.NumberOverflowException = a;
    let S = class S extends e {
        constructor(W, te) {
            super(W, te), this.name = "InvalidJavascriptType"
        }
        valueOf() {
            return this.name + ": " + this.message
        }
    };
    o(S, "InvalidJavascriptType");
    let u = S;
    r.InvalidJavascriptType = u;
    let K = class K extends e {
        constructor(W, te, _e) {
            super(W, te, _e), this.name = "SecurityException"
        }
    };
    o(K, "SecurityException");
    let l = K;
    r.SecurityException = l;
    let M = class M extends l {
        constructor(W, te, _e) {
            super(W, te, _e), this.name = "InvalidLoginException"
        }
    };
    o(M, "InvalidLoginException");
    let c = M;
    r.InvalidLoginException = c;
    let Oe = class Oe extends l {
        constructor(W, te, _e, we) {
            super(te, _e, we), this.specificType = W, this.name = W
        }
    };
    o(Oe, "NotRegisteredException");
    let d = Oe;
    r.NotRegisteredException = d;
    let Ye = class Ye extends e {
        constructor(W, te) {
            super(W, te), this.name = "SystemException"
        }
    };
    o(Ye, "SystemException");
    let f = Ye;
    r.SystemException = f;
    let Xe = class Xe extends f {
        constructor(W, te) {
            super(W, te), this.name = "IgnorableSystemException"
        }
    };
    o(Xe, "IgnorableSystemException");
    let h = Xe;
    r.IgnorableSystemException = h;
    let de = class de extends h {
        constructor(W, te) {
            super(W, te), this.name = "ViewHasChangedException"
        }
    };
    o(de, "ViewHasChangedException");
    let g = de;
    r.ViewHasChangedException = g;
    let N = class N extends h {
        constructor(W, te) {
            super(W, te), this.name = "OutOfContextException"
        }
    };
    o(N, "OutOfContextException");
    let p = N;
    r.OutOfContextException = p;
    let x = class x extends h {
        constructor(W, te) {
            super(W, te), this.name = "RedirectOccurredException"
        }
    };
    o(x, "RedirectOccurredException");
    let m = x;
    r.RedirectOccurredException = m;
    let U = class U extends h {
        constructor(W, te) {
            super(W, te), this.name = "UnhandledOrIgnoredErrorInEventException"
        }
        get handleErrorResult() {
            return this._handleErrorResult
        }
        static create(W, te, _e) {
            let we = new U(te, _e);
            return we._handleErrorResult = W, we
        }
        static ignore(W) {
            if (!Bn(W, U)) throw W
        }
    };
    o(U, "UnhandledOrIgnoredErrorInEventException");
    let w = U;
    r.UnhandledOrIgnoredErrorInEventException = w;
    let ve = class ve extends h {
        constructor(W, te) {
            super(W, te), this.name = "AbortedRequestException"
        }
    };
    o(ve, "AbortedRequestException");
    let T = ve;
    r.AbortedRequestException = T;
    let Te = class Te extends f {
        constructor(W, te) {
            super(W, te), this.name = "ApplicationBackendUnavailableException"
        }
    };
    o(Te, "ApplicationBackendUnavailableException");
    let E = Te;
    r.ApplicationBackendUnavailableException = E;
    let Fe = class Fe extends f {
        constructor(W, te) {
            super(W, te), this.name = "LicensingException"
        }
    };
    o(Fe, "LicensingException");
    let b = Fe;
    r.LicensingException = b;
    let rt = class rt extends f {
        constructor(W, te) {
            super(W, te), this.name = "IncompatibleProducerException"
        }
    };
    o(rt, "IncompatibleProducerException");
    let R = rt;
    r.IncompatibleProducerException = R;
    let xe = class xe extends h {
        constructor(W, te) {
            super(W, te), this.name = "ControllerDisposedException"
        }
    };
    o(xe, "ControllerDisposedException");
    let L = xe;
    r.ControllerDisposedException = L;
    let fe = class fe extends e {
        constructor(W, te, _e) {
            super(W, te, _e), this.name = "AbortActivityChangeException"
        }
    };
    o(fe, "AbortActivityChangeException");
    let V = fe;
    r.AbortActivityChangeException = V;
    let $ = class $ extends e {
        constructor(W, te, _e, we, Ie) {
            super(te, _e, we, Ie), this.specificType = W, this.name = W
        }
    };
    o($, "UserException");
    let z = $;
    r.UserException = z
})(pe || (pe = {}));

function Bn(r, e) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    return e === pe.Exception ? !0 : r instanceof e ? t !== "" ? r.specificType ? r.specificType === t : !1 : !0 : !1
}
o(Bn, "isInstanceOf");

function ks(r) {
    if (r === void 0) return "";
    if (r instanceof Error) return r.message; {
        let e = r.toString();
        return e === "[object SQLError]" ? r.message.toString() : e
    }
}
o(ks, "getMessage");

function qi(r) {
    return (r.extraStack !== void 0 ? r.extraStack + `\r
 ` : "") + (r.stack || "") || ""
}
o(qi, "getStack");

function kU(r) {
    var e, t, n;
    return {
        name: r.name,
        message: ks(r),
        stack: qi(r),
        extraStack: (e = r.extraStack) !== null && e !== void 0 ? e : void 0,
        errorCode: (t = r.errorCode) !== null && t !== void 0 ? t : "OS-CLRT-00000",
        category: (n = r.category) !== null && n !== void 0 ? n : void 0
    }
}
o(kU, "getExceptionInfo");

function FU(r) {
    return r.name ? r.specificType ? new pe[r.name](r.specificType, r.message, r.extraStack, r.errorCode, r.category) : new pe[r.name](r.message, r.extraStack, r.errorCode, r.category) : new pe.Exception(r.message, r.extraStack, r.errorCode, r.category)
}
o(FU, "getException");

function nI(r) {
    return Bn(r, pe.SystemException)
}
o(nI, "isSystem");

function iI(r) {
    return Bn(r, pe.LicensingException)
}
o(iI, "isApplicationOffline");
var Mre = Object.freeze({
    __proto__: null,
    get Exceptions() {
        return pe
    },
    getException: FU,
    getExceptionInfo: kU,
    getMessage: ks,
    getStack: qi,
    isApplicationOffline: iI,
    isInstanceOf: Bn,
    isSystem: nI
});

function kre(r) {
    for (var e = [], t = 0; t < r.length;) {
        var n = r[t];
        if (n === "*" || n === "+" || n === "?") {
            e.push({
                type: "MODIFIER",
                index: t,
                value: r[t++]
            });
            continue
        }
        if (n === "\\") {
            e.push({
                type: "ESCAPED_CHAR",
                index: t++,
                value: r[t++]
            });
            continue
        }
        if (n === "{") {
            e.push({
                type: "OPEN",
                index: t,
                value: r[t++]
            });
            continue
        }
        if (n === "}") {
            e.push({
                type: "CLOSE",
                index: t,
                value: r[t++]
            });
            continue
        }
        if (n === ":") {
            for (var i = "", s = t + 1; s < r.length;) {
                var a = r.charCodeAt(s);
                if (a >= 48 && a <= 57 || a >= 65 && a <= 90 || a >= 97 && a <= 122 || a === 95) {
                    i += r[s++];
                    continue
                }
                break
            }
            if (!i) throw new TypeError("Missing parameter name at ".concat(t));
            e.push({
                type: "NAME",
                index: t,
                value: i
            }), t = s;
            continue
        }
        if (n === "(") {
            var u = 1,
                l = "",
                s = t + 1;
            if (r[s] === "?") throw new TypeError('Pattern cannot start with "?" at '.concat(s));
            for (; s < r.length;) {
                if (r[s] === "\\") {
                    l += r[s++] + r[s++];
                    continue
                }
                if (r[s] === ")") {
                    if (u--, u === 0) {
                        s++;
                        break
                    }
                } else if (r[s] === "(" && (u++, r[s + 1] !== "?")) throw new TypeError("Capturing groups are not allowed at ".concat(s));
                l += r[s++]
            }
            if (u) throw new TypeError("Unbalanced pattern at ".concat(t));
            if (!l) throw new TypeError("Missing pattern at ".concat(t));
            e.push({
                type: "PATTERN",
                index: t,
                value: l
            }), t = s;
            continue
        }
        e.push({
            type: "CHAR",
            index: t,
            value: r[t++]
        })
    }
    return e.push({
        type: "END",
        index: t,
        value: ""
    }), e
}
o(kre, "lexer");

function iy(r, e) {
    e === void 0 && (e = {});
    for (var t = kre(r), n = e.prefixes, i = n === void 0 ? "./" : n, s = e.delimiter, a = s === void 0 ? "/#?" : s, u = [], l = 0, c = 0, d = "", f = o(function(Y) {
            if (c < t.length && t[c].type === Y) return t[c++].value
        }, "tryConsume"), h = o(function(Y) {
            var q = f(Y);
            if (q !== void 0) return q;
            var P = t[c],
                Z = P.type,
                oe = P.index;
            throw new TypeError("Unexpected ".concat(Z, " at ").concat(oe, ", expected ").concat(Y))
        }, "mustConsume"), g = o(function() {
            for (var Y = "", q; q = f("CHAR") || f("ESCAPED_CHAR");) Y += q;
            return Y
        }, "consumeText"), p = o(function(Y) {
            for (var q = 0, P = a; q < P.length; q++) {
                var Z = P[q];
                if (Y.indexOf(Z) > -1) return !0
            }
            return !1
        }, "isSafe"), m = o(function(Y) {
            var q = u[u.length - 1],
                P = Y || (q && typeof q == "string" ? q : "");
            if (q && !P) throw new TypeError('Must have text between two parameters, missing text after "'.concat(q.name, '"'));
            return !P || p(P) ? "[^".concat(Ns(a), "]+?") : "(?:(?!".concat(Ns(P), ")[^").concat(Ns(a), "])+?")
        }, "safePattern"); c < t.length;) {
        var w = f("CHAR"),
            T = f("NAME"),
            E = f("PATTERN");
        if (T || E) {
            var b = w || "";
            i.indexOf(b) === -1 && (d += b, b = ""), d && (u.push(d), d = ""), u.push({
                name: T || l++,
                prefix: b,
                suffix: "",
                pattern: E || m(b),
                modifier: f("MODIFIER") || ""
            });
            continue
        }
        var R = w || f("ESCAPED_CHAR");
        if (R) {
            d += R;
            continue
        }
        d && (u.push(d), d = "");
        var L = f("OPEN");
        if (L) {
            var b = g(),
                V = f("NAME") || "",
                z = f("PATTERN") || "",
                j = g();
            h("CLOSE"), u.push({
                name: V || (z ? l++ : ""),
                pattern: V && !z ? m(b) : z,
                prefix: b,
                suffix: j,
                modifier: f("MODIFIER") || ""
            });
            continue
        }
        h("END")
    }
    return u
}
o(iy, "parse");

function Fre(r, e) {
    return $re(iy(r, e), e)
}
o(Fre, "compile");

function $re(r, e) {
    e === void 0 && (e = {});
    var t = sI(e),
        n = e.encode,
        i = n === void 0 ? function(l) {
            return l
        } : n,
        s = e.validate,
        a = s === void 0 ? !0 : s,
        u = r.map(function(l) {
            if (typeof l == "object") return new RegExp("^(?:".concat(l.pattern, ")$"), t)
        });
    return function(l) {
        for (var c = "", d = 0; d < r.length; d++) {
            var f = r[d];
            if (typeof f == "string") {
                c += f;
                continue
            }
            var h = l ? l[f.name] : void 0,
                g = f.modifier === "?" || f.modifier === "*",
                p = f.modifier === "*" || f.modifier === "+";
            if (Array.isArray(h)) {
                if (!p) throw new TypeError('Expected "'.concat(f.name, '" to not repeat, but got an array'));
                if (h.length === 0) {
                    if (g) continue;
                    throw new TypeError('Expected "'.concat(f.name, '" to not be empty'))
                }
                for (var m = 0; m < h.length; m++) {
                    var w = i(h[m], f);
                    if (a && !u[d].test(w)) throw new TypeError('Expected all "'.concat(f.name, '" to match "').concat(f.pattern, '", but got "').concat(w, '"'));
                    c += f.prefix + w + f.suffix
                }
                continue
            }
            if (typeof h == "string" || typeof h == "number") {
                var w = i(String(h), f);
                if (a && !u[d].test(w)) throw new TypeError('Expected "'.concat(f.name, '" to match "').concat(f.pattern, '", but got "').concat(w, '"'));
                c += f.prefix + w + f.suffix;
                continue
            }
            if (!g) {
                var T = p ? "an array" : "a string";
                throw new TypeError('Expected "'.concat(f.name, '" to be ').concat(T))
            }
        }
        return c
    }
}
o($re, "tokensToFunction");

function Ns(r) {
    return r.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1")
}
o(Ns, "escapeString");

function sI(r) {
    return r && r.sensitive ? "" : "i"
}
o(sI, "flags");

function Bre(r, e) {
    return r
}
o(Bre, "regexpToRegexp");

function Vre(r, e, t) {
    var n = r.map(function(i) {
        return $U(i, e, t).source
    });
    return new RegExp("(?:".concat(n.join("|"), ")"), sI(t))
}
o(Vre, "arrayToRegexp");

function Hre(r, e, t) {
    return jre(iy(r, t), e, t)
}
o(Hre, "stringToRegexp");

function jre(r, e, t) {
    t === void 0 && (t = {});
    for (var n = t.strict, i = n === void 0 ? !1 : n, s = t.start, a = s === void 0 ? !0 : s, u = t.end, l = u === void 0 ? !0 : u, c = t.encode, d = c === void 0 ? function(q) {
            return q
        } : c, f = t.delimiter, h = f === void 0 ? "/#?" : f, g = t.endsWith, p = g === void 0 ? "" : g, m = "[".concat(Ns(p), "]|$"), w = "[".concat(Ns(h), "]"), T = a ? "^" : "", E = 0, b = r; E < b.length; E++) {
        var R = b[E];
        if (typeof R == "string") T += Ns(d(R));
        else {
            var L = Ns(d(R.prefix)),
                V = Ns(d(R.suffix));
            if (R.pattern)
                if (L || V)
                    if (R.modifier === "+" || R.modifier === "*") {
                        var z = R.modifier === "*" ? "?" : "";
                        T += "(?:".concat(L, "((?:").concat(R.pattern, ")(?:").concat(V).concat(L, "(?:").concat(R.pattern, "))*)").concat(V, ")").concat(z)
                    } else T += "(?:".concat(L, "(").concat(R.pattern, ")").concat(V, ")").concat(R.modifier);
            else {
                if (R.modifier === "+" || R.modifier === "*") throw new TypeError('Can not repeat "'.concat(R.name, '" without a prefix and suffix'));
                T += "(".concat(R.pattern, ")").concat(R.modifier)
            } else T += "(?:".concat(L).concat(V, ")").concat(R.modifier)
        }
    }
    if (l) i || (T += "".concat(w, "?")), T += t.endsWith ? "(?=".concat(m, ")") : "$";
    else {
        var j = r[r.length - 1],
            Y = typeof j == "string" ? w.indexOf(j[j.length - 1]) > -1 : j === void 0;
        i || (T += "(?:".concat(w, "(?=").concat(m, "))?")), Y || (T += "(?=".concat(w, "|").concat(m, ")"))
    }
    return new RegExp(T, sI(t))
}
o(jre, "tokensToRegexp");

function $U(r, e, t) {
    return r instanceof RegExp ? Bre(r) : Array.isArray(r) ? Vre(r, e, t) : Hre(r, e, t)
}
o($U, "pathToRegexp");
var nC = class nC {
    constructor(e) {
        this.returnValue = e
    }
};
o(nC, "MethodSignalReturn");
var Fm = nC,
    BU = new Object,
    VU = new Object;

function HU(r) {
    let e = r;
    return e && typeof e.then == "function" && typeof e.catch == "function"
}
o(HU, "isPromiseCompatible");

function vS(r, e) {
    switch (e) {
        case VU:
            return r();
        case BU:
            return;
        default:
            return Promise.reject(e)
    }
}
o(vS, "handleLoopSignal");

function yS(r) {
    return r() ? Promise.resolve(void 0) : WU()
}
o(yS, "createLoopCond");

function jU(r) {
    return new Promise(r)
}
o(jU, "promise");

function Wre(r) {
    return Promise.resolve(r)
}
o(Wre, "resolve$1");

function WU() {
    return Promise.reject(BU)
}
o(WU, "breakAsync");

function Gre() {
    return Promise.reject(VU)
}
o(Gre, "continueAsync");

function zre(r) {
    return Promise.reject(new Fm(r))
}
o(zre, "returnAsync");

function qre(r) {
    return Promise.reject(r)
}
o(qre, "throwAsync");

function _n(r) {
    return Ad(r)
}
o(_n, "executeSequence");

function Ad(r, e) {
    let t, n, i = o(() => {
            throw n
        }, "raiseError"),
        s = o(() => {
            clearTimeout(e), e = window.setTimeout(i, 0)
        }, "postponeRaiseError");

    function a(u, l) {
        return n ? l ? (clearTimeout(e), Ad(() => l(n))) : (s(), Ad(i, e)) : Ad(u ? () => u(t) : () => t)
    }
    o(a, "handleResult");
    try {
        t = r()
    } catch (u) {
        n = u, s()
    }
    return HU(t) ? t : {
        then(u, l) {
            return a(u, l)
        },
        catch (u) {
            return a(void 0, u)
        }
    }
}
o(Ad, "innerExecuteSequence");

function sy(r) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : n => Promise.reject(n),
        t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : () => Promise.resolve(void 0);
    return _n(r).catch(e).then(n => _n(t).then(i => i != null ? i : n), n => _n(t).then(() => Promise.reject(n)))
}
o(sy, "tryCatchFinally");

function GU(r, e) {
    return sy(r, e, void 0)
}
o(GU, "tryCatch");

function $m(r, e) {
    return sy(r, void 0, e)
}
o($m, "tryFinally");

function Kre() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : () => {};
    return _n(r).catch(Zre)
}
o(Kre, "executeAsyncFlow");

function oI(r, e) {
    function t() {
        return yS(r).then(e).then(t, vS.bind(null, t))
    }
    return o(t, "loop"), t()
}
o(oI, "whileAsync");

function Yre(r, e) {
    let t = 0;
    return oI(() => t < r.length, () => {
        let n = r[t++];
        return e(n)
    })
}
o(Yre, "forEachAsync");

function Xre(r, e) {
    function t() {
        return yS(r).then(n, vS.bind(null, n))
    }
    o(t, "conditionAndLoop");

    function n() {
        return _n(e).then(() => yS(r)).then(n, vS.bind(null, t))
    }
    return o(n, "loop"), n()
}
o(Xre, "doWhileAsync");
var Jre = oI.bind(null, () => !0);

function Zre(r) {
    return r instanceof Fm ? r.returnValue : Promise.reject(r)
}
o(Zre, "handleReturnSignal");
var Qre = Object.freeze({
    __proto__: null,
    breakAsync: WU,
    continueAsync: Gre,
    doWhileAsync: Xre,
    executeAsyncFlow: Kre,
    executeSequence: _n,
    forEachAsync: Yre,
    isPromiseCompatible: HU,
    promise: jU,
    resolve: Wre,
    returnAsync: zre,
    throwAsync: qre,
    tryCatch: GU,
    tryCatchFinally: sy,
    tryFinally: $m,
    whileAsync: oI,
    whileTrueAsync: Jre
});

function ene(r) {
    try {
        return r.self !== r.top
    } catch (e) {
        return !0
    }
}
o(ene, "windowInsideIframe");

function tne(r) {
    return /^((?!chrome|android).)*safari/i.test(r)
}
o(tne, "isSafari");
var rne = o(function() {
        let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : navigator;
        var e;
        return (e = r == null ? void 0 : r.userAgent) !== null && e !== void 0 ? e : ""
    }, "getUserAgent$1"),
    zo = o(function() {
        let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window,
            e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : globalThis;
        return r != null ? r : e
    }, "getGlobalObject"),
    iC = class iC {
        constructor() {
            this.stack = [], this.map = {}, this.counter = 0
        }
        push(e) {
            let t = this.counter++;
            return this.stack.push(t), this.map[t] = e, t
        }
        remove(e) {
            let t = this.stack.indexOf(e),
                n = t > -1;
            return n && (this.stack.splice(t, 1), delete this.map[e]), n
        }
        pop() {
            if (this.stack.length === 0) throw new Error("IndexedStack: pop from empty stack.");
            let e = this.stack.pop(),
                t = this.map[e];
            return delete this.map[e], t
        }
        clear() {
            this.stack = [], this.map = {}
        }
        get isEmpty() {
            return this.stack.length === 0
        }
    };
o(iC, "IndexedStack");
var _S = iC,
    sC = class sC {
        constructor(e, t) {
            this._groups = e, this._index = t - this._groups[0].length
        }
        get value() {
            return this._groups[0]
        }
        get index() {
            return this._index
        }
        get length() {
            return this._groups[0].length
        }
        get groups() {
            return this._groups
        }
    };
o(sC, "Match");
var wS = sC;

function Bm(r, e) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
        n = [],
        i = new RegExp(e, "g" + (t ? "i" : "")),
        s = i.exec(r);
    for (; s;) n.push(new wS(s, i.lastIndex)), s = i.exec(r);
    return n
}
o(Bm, "matches");

function Vm(r, e, t, n) {
    let i = Bm(r, e, t),
        s = r,
        a = 0;
    for (let u = 0; u < i.length; u++) {
        let l = i[u],
            c = n(l);
        s = s.substr(0, l.index + a) + c + s.substr(a + l.index + l.length), a += c.length - l.length
    }
    return s
}
o(Vm, "replace$1");

function jo(r) {
    return r && r.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
}
o(jo, "escape");
var oy = o((r, e, t) => {
        if (e.toLowerCase() === t.toLowerCase()) return r;
        let n = new RegExp(`^${jo(e)}`, "i");
        return r.replace(n, t)
    }, "replaceBasePath"),
    ay = o((r, e) => `${r}${e}`, "buildURLFromVersionedResource"),
    zU = o(function() {
        let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;
        var e, t;
        return (t = (e = r == null ? void 0 : r.location) === null || e === void 0 ? void 0 : e.href) !== null && t !== void 0 ? t : ""
    }, "getCurrentUrl"),
    qU = o(function() {
        let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;
        var e, t, n;
        return (n = (t = (e = r == null ? void 0 : r.location) === null || e === void 0 ? void 0 : e.protocol) === null || t === void 0 ? void 0 : t.replace(/:/g, "")) !== null && n !== void 0 ? n : ""
    }, "getHttpScheme"),
    TS = o(r => r.replace(/([^:]\/)\/+/g, "$1"), "sanitizeUrl"),
    Cf = o(r => r.replace(/((outsystems|https|http):\/\/[^ ]*?)\?[^ ]*/g, "$1"), "removeQueryParametersFromUrls"),
    nne = Object.freeze({
        __proto__: null,
        buildURLFromVersionedResource: ay,
        getCurrentUrl: zU,
        getHttpScheme: qU,
        removeQueryParametersFromUrls: Cf,
        replaceBasePath: oy,
        sanitizeUrl: TS
    }),
    Tx = "Injector",
    aI = {},
    Us = {};

function uI(r, e) {
    try {
        ee(Tx, `Registering ${r} service`);
        let t = e();
        return aI[r] = t, r in Us && Us[r].forEach(n => n(r, t)), !0
    } catch (t) {
        return ft(Tx, `Failed to initialize ${r} service: ${t}`), !1
    }
}
o(uI, "register");

function KU(r) {
    delete aI[r]
}
o(KU, "unregister");

function YU(r, e) {
    r in Us ? Us[r].push(e) : Us[r] = [e]
}
o(YU, "addRegistrationListener");

function XU(r, e) {
    r in Us && (Us[r] = Us[r].filter(t => t !== e))
}
o(XU, "removeRegistrationListener");

function Lc(r) {
    return aI[r]
}
o(Lc, "resolve");
var ge = {
        register: uI,
        unregister: KU,
        resolve: Lc,
        addRegistrationListener: YU,
        removeRegistrationListener: XU
    },
    ine = Object.freeze({
        __proto__: null,
        addRegistrationListener: YU,
        default: ge,
        register: uI,
        removeRegistrationListener: XU,
        resolve: Lc,
        unregister: KU
    }),
    J;
(function(r) {
    r.DeviceHelperClassProvider = "DeviceHelperClassProvider", r.ClientVariablesService = "ClientVariablesService", r.TranslationsService = "TranslationsService", r.LocaleService = "LocaleService", r.EntityService = "EntityService", r.GlobalExceptionHandler = "GlobalExceptionHandler", r.SettingsManager = "SettingsManager", r.AuthConfigsManager = "AuthConfigsManager", r.Auth = "Auth", r.HttpClient = "HttpClient", r.UnauthenticatedHttpClient = "UnauthenticatedHttpClient", r.DebuggerHttpClient = "DebuggerHttpClient", r.NonDebuggerHttpClient = "NonDebuggerHttpClient", r.LoggerHttpClient = "LoggerHttpClient", r.NativeStatus = "NativeStatus", r.LifecycleEventsManager = "LifecycleEventsManager", r.Debugger = "Debugger", r.InstrumentationFactory = "InstrumentationFactory", r.BinaryUrlCache = "BinaryUrlCache", r.OfflineDataSync = "OfflineDataSync"
})(J || (J = {}));
var zb = "NativeStatus",
    oC = class oC {
        constructor() {
            let {
                win: e = window,
                isRunningOnNativeFn: t = Cr,
                deviceReadyPromise: n = lI
            } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this.cachedReadyValue = null, this.win = e, this.isRunningOnNativeFn = t, this.deviceReadyPromise = n
        }
        raiseCordovaNotLoadedError() {
            let e = "Running on native but cordova wasn't loaded";
            throw Ue(zb, e, "OS-CLRT-00000", void 0, Pe.External), new Error(e)
        }
        ensureIsReady() {
            return k(this, void 0, void 0, function*() {
                return this.cachedReadyValue === null ? (ee(zb, "Waiting for 'deviceready' event"), this.isRunningOnNativeFn() ? this.win.cordova === void 0 ? (this.cachedReadyValue = !1, this.raiseCordovaNotLoadedError()) : (yield this.deviceReadyPromise(), this.cachedReadyValue = !0, !0) : (ee(zb, "'deviceready' event wait ignored"), this.cachedReadyValue = !0, !0)) : this.cachedReadyValue ? !0 : this.raiseCordovaNotLoadedError()
            })
        }
    };
o(oC, "NativeStatus");
var ES = oC,
    sne = "OutSystemsApp",
    JU = {
        Android: "Android",
        iOS: "iOS"
    },
    Cr = o(function() {
        let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : navigator;
        return !!(r && new RegExp(sne, "i").test(r.userAgent))
    }, "isRunningOnNative"),
    cI = o(function() {
        let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;
        var e;
        return (e = r == null ? void 0 : r.device) === null || e === void 0 ? void 0 : e.platform
    }, "getPlatformName"),
    ZU = o(function(r) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Cr,
            t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : window,
            n = cI(t);
        return e() && typeof n == "string" && n.toLowerCase() === r.toLowerCase()
    }, "isRunningOnPlatform"),
    QU = o(function() {
        let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Cr,
            e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window;
        return ZU(JU.Android, r, e)
    }, "isAndroid"),
    one = o(function() {
        let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Cr,
            e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window;
        return ZU(JU.iOS, r, e)
    }, "isIOS"),
    eM = o(function(r, e) {
        let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : document;
        return t != null && t.addEventListener ? (t.addEventListener(r, e), !0) : !1
    }, "addEventListener"),
    lI = o(function() {
        let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
        return new Promise((e, t) => {
            eM("deviceready", () => e(), r) || e()
        })
    }, "whenDeviceReady"),
    En = o(() => {
        let r = ge.resolve(J.NativeStatus);
        return r || (ge.register(J.NativeStatus, () => new ES), r = ge.resolve(J.NativeStatus)), r.ensureIsReady()
    }, "ensureNativeReady"),
    bS = o(function(r, e) {
        for (var t = arguments.length, n = new Array(t > 2 ? t - 2 : 0), i = 2; i < t; i++) n[i - 2] = arguments[i];
        return k(void 0, [r, e, ...n], void 0, function(s, a) {
            let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : En,
                l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : eM;
            return (function*() {
                yield u(), l(s, a)
            })()
        })
    }, "addNativeEventListener"),
    tM = o(function() {
        let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : QU,
            e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : navigator;
        return r() ? (e.app.exitApp(), !0) : !1
    }, "exitApp"),
    rM = o(function() {
        for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++) e[t] = arguments[t];
        return k(void 0, [...e], void 0, function() {
            let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : En,
                i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ane;
            return (function*() {
                var s, a;
                try {
                    yield n();
                    let u = i();
                    return (a = (s = u == null ? void 0 : u.OutSystemsNative) === null || s === void 0 ? void 0 : s.OTLogger) !== null && a !== void 0 ? a : null
                } catch (u) {
                    return console.error("Native is not ready", u), null
                }
            })()
        })
    }, "getNativeOTLogger"),
    ane = o(() => window, "getOutSystemsNativeHost"),
    uy = o(r => !!(r != null && r.OutSystemsNative), "isIOutSystemsNativeHost"),
    une = Object.freeze({
        __proto__: null,
        addNativeEventListener: bS,
        ensureNativeReady: En,
        exitApp: tM,
        getNativeOTLogger: rM,
        getPlatformName: cI,
        isAndroid: QU,
        isIOS: one,
        isIOutSystemsNativeHost: uy,
        isRunningOnNative: Cr,
        whenDeviceReady: lI
    }),
    cne = "NativeAuthPlugin",
    lne = o(r => k(void 0, [r], void 0, function(e) {
        let {
            w: t = window,
            awaitNative: n = En
        } = e;
        return (function*() {
            if (yield n(), uy(t) && t.OutSystemsNative.Auth) return t.OutSystemsNative.Auth;
            throw new Error("Could not find the OSAuth plugin.")
        })()
    }), "getNativeAuthPlugin"),
    dne = o(r => k(void 0, [r], void 0, function(e) {
        let {
            url: t,
            redirectUri: n,
            w: i,
            awaitNative: s
        } = e;
        return (function*() {
            var a;
            let u = yield lne({
                w: i,
                awaitNative: s
            });
            try {
                return yield u.startFlow(t, n)
            } catch (l) {
                throw Ue(cne, (a = l.message) !== null && a !== void 0 ? a : "Error starting the external auth flow", "OS-CLRT-40100", l instanceof Error ? l : void 0), new Error("Error starting the external auth flow")
            }
        })()
    }), "startExternalAuthFlow"),
    Rf = "Navigation",
    fne = new RegExp("/([^/]*)"),
    hne = new RegExp(/\/(\/)+/gm),
    SS = "?",
    nM = "#",
    iM = "&",
    sM = "_ts",
    gne = 10,
    pne = 1e3,
    mne = ["localhost", "10.0.2.2"],
    vne = "PUSH",
    oM = "POP",
    yne = "-",
    Ed = [],
    qo = [],
    Dd = new _S,
    AS;

function cy(r) {
    if (!dI(r)) throw new pe.OutOfContextException
}
o(cy, "validateContext");

function dI(r) {
    return !(r && r.isOutOfContext)
}
o(dI, "isValidContext");

function ly(r) {
    if (r) throw new pe.RedirectOccurredException
}
o(ly, "throwRedirectOccurredExceptionIfNeeded");

function aM(r) {
    qo.push(r)
}
o(aM, "setNavigationCallbacks");

function Ko() {
    return qo[qo.length - 1]
}
o(Ko, "getNavigationCallbacks");

function uM() {
    return qo.pop()
}
o(uM, "removeNavigationCallbacks");
var Nu = !1,
    fI = !1;

function cM() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    ee(Rf, "Next navigation will force a reload..."), Nu = !0, fI = r
}
o(cM, "forceReloadOnNextNavigation");

function _ne() {
    return Nu
}
o(_ne, "willReloadInNextNavigation");

function wne() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1,
        e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    Nu = r, fI = e
}
o(wne, "resetReloadState");
var dy = o(() => {
        let {
            protocol: r,
            pathname: e,
            href: t,
            search: n
        } = window.location, i = window.location.hostname || window.location.host.split(":")[0];
        return {
            protocol: r,
            pathname: e,
            href: t,
            search: n,
            hostname: i
        }
    }, "getCurrentLocation"),
    lM = o(r => {
        if (r === void 0) return null;
        let e = window.location.search.substr(1);
        return wM(e)[r]
    }, "getSearchParameterValue"),
    dM = o(function(r) {
        let {
            getLocation: e = dy,
            getBasePath: t = Dt
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (!(r.protocol === "http:" || r.protocol === "https:" || r.protocol === "outsystems:")) return !1;
        let i = e().hostname,
            s = r.hostname !== "" ? r.hostname : i;
        if (i !== s) return !1;
        let a = fne.exec(r.pathname);
        return !a || a.length < 2 ? !1 : new RegExp(`^${jo(t())}`, "i").test(`${r.pathname}/`)
    }, "urlBelongsToCurrentApplication"),
    fM = o(function(r) {
        let e = document.createElement("a");
        return e.href = r, e
    }, "getLocationFromUrl"),
    hM = !1;

function hI() {
    return hM
}
o(hI, "hasPendingReload");
var Xi = o(function(r) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
        t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
        n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : zo();
    e && (r = pM(r));
    let i = Cf(r);
    ee(Rf, `Reloading application with url: '${i}' (replace = ${t})`);
    let s = o(() => {
        t ? n.location.replace(r) : n.location.href = r
    }, "redirect");
    return hM = !0, YM().then(s).catch(s)
}, "changeWindowLocation");

function gM() {
    return typeof window != "undefined" && window.location.search.indexOf(sM) >= 0
}
o(gM, "currentLocationHasTimestamp");

function pM(r) {
    let t = `${r.indexOf(SS)<0?SS:iM}${sM}=${new Date().valueOf()}`,
        n = r.indexOf(nM);
    return n >= 0 ? [r.slice(0, n), t, r.slice(n)].join("") : `${r}${t}`
}
o(pM, "addInvalidationSuffixToUrl");

function gI() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1,
        e = Fs();
    Xi(e, r)
}
o(gI, "reloadApplication$1");

function mM() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    Xi(dy().href, r, !0)
}
o(mM, "reloadCurrentLocation");

function Tne(r) {
    return Fs(Dt(), r)
}
o(Tne, "concatApplicationToRelativeURL");

function Ene(r) {
    let e = new Date().getTime(),
        t = e - pne;
    for (; Ed.length > 0 && Ed[0].timestamp < t;) Ed.shift();
    if (Ed.reduce(function(i, s) {
            return s.url === r ? i + 1 : i
        }, 0) < gne) return Ed.push({
        timestamp: e,
        url: r
    }), !1; {
        let i = Cf(r);
        return tn(Rf, `Identified a recursive navigation to '${i}'.`, Pe.Internal), !0
    }
}
o(Ene, "isRecursiveNavigation");

function vM(r) {
    return Dd.push(r)
}
o(vM, "registerBackNavigationHandler");

function yM(r) {
    Dd.remove(r)
}
o(yM, "unregisterBackNavigationHandler");

function _M(r) {
    AS = r
}
o(_M, "registerNavigationHandler");
var pI = o(function(r) {
    let e = !1,
        t, n = "",
        i = r,
        s = r.indexOf(":") !== -1 || r.indexOf("/") === 0,
        a = i.indexOf(nM);
    a !== -1 && (t = i.substr(a + 1).trim(), i = i.substr(0, a));
    let u = i.indexOf(SS);
    if (u !== -1 && (n = i.substr(u + 1).trim(), i = i.substr(0, u)), s) {
        let c = fM(i);
        e = dM(c), e && (i = c.pathname)
    } else i = Tne(i), e = !0;
    let l = wM(n);
    return {
        url: r,
        isInternal: e,
        path: i,
        queryParams: l,
        hash: t
    }
}, "getUrlInfo");

function wM(r) {
    let e = {};
    return r.length > 0 && r.split(iM).forEach(t => {
        let n = t.split("=");
        if (n.length === 2) {
            let i = Ex(n[0]),
                s = Ex(n[1]);
            e[i] = s
        }
    }), e
}
o(wM, "getQueryParameterParts");

function Ex(r) {
    return decodeURIComponent(r.replace(/\+/g, " "))
}
o(Ex, "safeDecodeURIComponent");

function bne(r, e) {
    if (!Ane(r.pathname + r.search)) return !1;
    let t = Nu;
    if (Nu && (Nu = !1), e && !Dd.isEmpty) {
        let i = Dd.pop();
        return GU(i, s => {
            Ue(Gr(), "Error while navigating back without an empty stack", "OS-CLRT-00000", s)
        }), !1
    }
    let n = AM(r);
    if (n || t) {
        let i = pI(r.pathname),
            s = hU(),
            a = Dt(),
            u;
        if (i.isInternal) {
            u = !0;
            for (let l in s)
                if (s.hasOwnProperty(l)) {
                    let c = i.url.replace(/\/$/, ""),
                        d = s[l];
                    if (IS(c, Fs(a), d) || d.moduleName !== Gr() && d.moduleName && IS(c, d.moduleName, d)) {
                        u = !1;
                        break
                    }
                }
        } else u = !1;
        if (t || u) {
            let l;
            if (u) l = Fs();
            else {
                let c = r.search || "";
                a === r.pathname && c === "" ? l = /\/$/.test(r.pathname) ? r.pathname : `${r.pathname}/` : l = r.pathname + c
            }
            return Xi(l, fI, n), !u
        }
    }
    return Dd.clear(), !0
}
o(bne, "onBeforeNavigate");

function IS(r, e, t) {
    return e.replace(/\/$/, "") === r || t.screens.some(n => {
        let i = Fs(e, n.screenUrl);
        return $U(i).test(r)
    })
}
o(IS, "urlBelongsToPrefix");

function mI() {
    If() && window.stop && document.readyState === "complete" && (ee(Rf, "Stopping all currently pending resources."), window.stop())
}
o(mI, "cancelAllPendingResources");

function Sne(r) {
    return k(this, void 0, void 0, function*() {
        var e, t, n;
        let i = (e = r.queryParams.redirect_uri) !== null && e !== void 0 ? e : r.queryParams.post_logout_redirect_uri;
        if (!i) throw new Error("Can't perform an external login without a redirect URI");
        let s = yield dne({
            url: r.url,
            redirectUri: i
        }), [a] = i.split("?"), u = Dt(), l = (n = (t = a.match(new RegExp(`${u}.*`))) === null || t === void 0 ? void 0 : t[0]) !== null && n !== void 0 ? n : "";
        Xi(s ? `${l}?${s}` : l)
    })
}
o(Sne, "startNativeExternalAuthFlow");

function Ane(r) {
    var e;
    if (r && AS) try {
        return (e = AS(r, o((n, i, s) => fy(n, ty(i, Af), null, !1, s), "navigationMethod"))) !== null && e !== void 0 ? e : !1
    } catch (t) {
        let n = "Error while executing navigation callback";
        return xc({
            category: Gr(),
            errorCode: "OS-CLRT-00000",
            clientMessage: n,
            internalMessage: n,
            errorObj: t instanceof Error ? t : void 0
        }), !1
    }
    return !0
}
o(Ane, "handleNavigationCallback");

function fy(r, e) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null,
        n = arguments.length > 3 ? arguments[3] : void 0,
        i = arguments.length > 4 ? arguments[4] : void 0;
    if (cy(t), Ene(r)) throw Error("Too many redirects.");
    n || mI();
    let s = pI(r);
    if (qo && Ko().goTo && s.isInternal) Ko().goTo(s, e, i);
    else {
        if (Cr() && jM({
                url: r
            })) return Sne(s);
        Xi(r)
    }
    ly(n)
}
o(fy, "navigateTo");

function TM(r, e, t) {
    cy(e), t || mI(), qo && Ko().goBack ? Ko().goBack(r) : window.history.back(), ly(t)
}
o(TM, "navigateBack");

function EM(r, e, t) {
    cy(e), t || mI(), qo && Ko().goForward ? Ko().goForward(r) : window.history.forward(), ly(t)
}
o(EM, "navigateForward");

function bM(r, e, t) {
    return t + r.substring(e.length)
}
o(bM, "switchUrlProtocol");

function SM() {
    let r = dy();
    if (r.protocol.toLocaleLowerCase() === "http:") {
        let e = r.hostname.toLocaleLowerCase();
        if (mne.includes(e)) console.warn(Rf, `Accessing through http://${e} is not supported. Please access the application using the hostname instead.`);
        else {
            let t = bM(r.href, r.protocol, "https:");
            return Xi(t, !1, !0), !0
        }
    }
    return !1
}
o(SM, "ensureRequestSecurity");

function AM(r) {
    return r.action.toUpperCase() === oM
}
o(AM, "locationReachedFromHistory");

function Ine(r, e, t) {
    let n = r,
        i = r,
        s;
    return typeof e == "string" ? (i = e, s = Cne(n, i, t)) : (t = e, n = "", s = Rne(i, t)), s
}
o(Ine, "generateScreenURL");

function Cne(r, e, t) {
    let n = Nne(t != null ? t : {}, e),
        i = Dne(t != null ? t : {}, n);
    return One(i, e), Pne(r, e, i, n)
}
o(Cne, "generateScreenURLWithModuleName");

function Rne(r, e) {
    let t = Object.keys(e).map(i => `${encodeURIComponent(i)}=${encodeURIComponent(e[i])}`).join("&");
    return `${r}${t.length>0?`?${t}`:""}`
}
o(Rne, "generateGenericURL");

function One(r, e) {
    let n = iy(e).filter(a => typeof a != "string" && a.modifier === "?").map(a => {
            var u;
            return {
                name: a.name,
                value: (u = r[a.name]) !== null && u !== void 0 ? u : ""
            }
        }),
        i = !1,
        s;
    n.forEach(a => {
        if (i && !bx(a.value)) throw new Error(`Error processing optional parameters on path ${e}. The parameter ${s.name} has an empty value while ${a.name} has a non-empty value. All optional parameters before ${a.name} must have a value when ${a.name} has a value.`);
        bx(a.value) && (s = a, i = !0)
    })
}
o(One, "detectEmptyValueOptionalParameterError");

function bx(r) {
    return r === "" || r === null || r === void 0
}
o(bx, "isEmptyValue");

function Pne(r, e, t, n) {
    let i = Object.keys(n).map(s => `${encodeURIComponent(s)}=${encodeURIComponent(n[s])}`).join("&");
    try {
        let s = Object.fromEntries(Object.entries(t).map(c => {
                let [d, f] = c;
                return [d, encodeURIComponent(f)]
            })),
            l = `${Fre(e,{validate:!1})(s)}${i.length>0?`?${i}`:""}`;
        return Lne(r, l)
    } catch (s) {
        let a = new RegExp('^Expected "(.*)" to be a string$', "g").exec(s.message);
        if (a) {
            let u = a[1],
                l = `Error building URL for ${e}. Parameter ${u} is missing or has an empty value`,
                c = `Error building URL: parameter ${u} is missing or has an empty value`;
            xc({
                category: r,
                errorCode: "OS-CLRT-00000",
                clientMessage: l,
                internalMessage: c,
                errorObj: s instanceof Error ? s : void 0
            });
            return
        }
        throw s
    }
}
o(Pne, "innerBuildURL");

function Nne(r, e) {
    let t = iy(e);
    return Object.keys(r).filter(n => !t.some(i => typeof i != "string" && i.name === n)).reduce((n, i) => (n[i] = r[i], n), {})
}
o(Nne, "selectQueryStringParameters");

function Dne(r, e) {
    return Object.keys(r).filter(t => r[t] !== "" && !(t in e)).reduce((t, n) => (t[n] = r[n], t), {})
}
o(Dne, "selectPathParameters");

function Fs() {
    for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++) e[t] = arguments[t];
    return (e.length === 0 ? Dt() : "/" + e.join("/")).replace(hne, "/")
}
o(Fs, "buildApplicationRelativeUrl");

function Lne(r, e) {
    let t = Dt(),
        n = e.replace(/^\//, ""),
        i = Gr();
    return r === i ? `${t}${n}` : `/${r}/${n}`
}
o(Lne, "generateBaseUrl");
var pc;
(function(r) {
    let e = o(i => i, "urlVersionProvider");

    function t(i) {
        e = i
    }
    o(t, "setUrlVersionProvider"), r.setUrlVersionProvider = t;

    function n(i) {
        return e(i)
    }
    o(n, "getVersionedUrl"), r.getVersionedUrl = n
})(pc || (pc = {}));
var xne = Object.freeze({
    __proto__: null,
    NAVIGATE_FROM_HISTORY_ACTION: oM,
    NAVIGATE_TO_URL_ACTION: vne,
    SCREEN_URL_PART_SEPARATOR: yne,
    get VersionedURL() {
        return pc
    },
    addInvalidationSuffixToUrl: pM,
    buildApplicationRelativeUrl: Fs,
    changeWindowLocation: Xi,
    currentLocationHasTimestamp: gM,
    ensureRequestSecurity: SM,
    forceReloadOnNextNavigation: cM,
    generateScreenURL: Ine,
    getCurrentLocation: dy,
    getLocationFromUrl: fM,
    getNavigationCallbacks: Ko,
    getSearchParameterValue: lM,
    getUrlInfo: pI,
    hasPendingReload: hI,
    isValidContext: dI,
    locationReachedFromHistory: AM,
    navigateBack: TM,
    navigateForward: EM,
    navigateTo: fy,
    onBeforeNavigate: bne,
    registerBackNavigationHandler: vM,
    registerNavigationHandler: _M,
    reloadApplication: gI,
    reloadCurrentLocation: mM,
    removeNavigationCallbacks: uM,
    resetReloadState: wne,
    setNavigationCallbacks: aM,
    switchUrlProtocol: bM,
    throwRedirectOccurredExceptionIfNeeded: ly,
    unregisterBackNavigationHandler: yM,
    urlBelongsToCurrentApplication: dM,
    urlBelongsToPrefix: IS,
    validateContext: cy,
    willReloadInNextNavigation: _ne
});

function IM() {
    var r;
    let e = window;
    if (!((r = e == null ? void 0 : e.OutSystemsNative) === null || r === void 0) && r.ApplicationInfo) return e.OutSystemsNative.ApplicationInfo
}
o(IM, "getNativeApplicationInfo");
var Une = o(function() {
    for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++) e[t] = arguments[t];
    return k(void 0, [...e], void 0, function() {
        let {
            nativeReady: n = En,
            nativeApplicationInfo: i = IM
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return (function*() {
            return yield n(), new Promise((s, a) => {
                let u = i();
                return u ? u.getAppPackageIdentifier(s, a) : a(new Error("NativeAppInfo API is not available"))
            })
        })()
    })
}, "getAppPackageIdentifier");

function Mne(r) {
    return k(this, arguments, void 0, function(e) {
        let {
            version: t,
            ensureReady: n = En,
            getNativeAppInfo: i = IM
        } = e;
        return (function*() {
            yield n();
            let s = i();
            if (typeof(s == null ? void 0 : s.setOSApplicationVersion) == "function") try {
                s.setOSApplicationVersion(t)
            } catch (a) {
                yield tn("Native", "Failed to set app version", Pe.Internal)
            }
        })()
    })
}
o(Mne, "setAppVersion");
var gt = "Authentication",
    CM = "_RedirectLogin",
    RM = "_RedirectLogout",
    Gt;
(function(r) {
    r.NotAuthenticated = "User is not authenticated.", r.Unavailable = "Authentication mechanism is unavailable."
})(Gt || (Gt = {}));
var kne = o(r => r.resumeLogin !== void 0, "isExternalAuth"),
    Fne = o(r => r.finishResetPassword !== void 0, "isBuiltinAuth"),
    OM = o(r => k(void 0, [r], void 0, function(e) {
        let {
            path: t,
            params: n = {
                isRunningOnNative: Cr,
                getAppUrl: eI,
                getHost: o(() => {
                    var i;
                    return (i = window == null ? void 0 : window.location) === null || i === void 0 ? void 0 : i.host
                }, "getHost"),
                getPlatform: o(() => cI(), "getPlatform"),
                getPackageId: o(() => k(void 0, void 0, void 0, function*() {
                    return (yield Une()).toLowerCase()
                }), "getPackageId"),
                getBasePath: Dt
            }
        } = e;
        return (function*() {
            var i, s, a, u, l;
            if (n.isRunningOnNative()) {
                let c = yield(i = n.getPackageId) === null || i === void 0 ? void 0 : i.call(n), d = (s = n.getHost) === null || s === void 0 ? void 0 : s.call(n), f = (a = n.getPlatform) === null || a === void 0 ? void 0 : a.call(n), h = (u = n.getBasePath) === null || u === void 0 ? void 0 : u.call(n);
                if (c)
                    if (d)
                        if (f) {
                            if (!h) throw new Error("Could not get the base path")
                        } else throw new Error("Could not get the platform");
                else throw new Error("Could not get host name");
                else throw new Error("Could not get the package id");
                return TS(`${c}://${d}/${f}/${h}/${t}`)
            } else {
                let c = (l = n.getAppUrl) === null || l === void 0 ? void 0 : l.call(n);
                if (!c) throw new Error("Could not get the application url");
                return TS(`${c}/${t}`)
            }
        })()
    }), "getRedirectUrl"),
    vI = o(r => k(void 0, void 0, void 0, function*() {
        return OM({
            path: CM,
            params: r
        })
    }), "getLoginRedirectUrl"),
    $ne = o(r => k(void 0, void 0, void 0, function*() {
        return OM({
            path: RM,
            params: r
        })
    }), "getLogoutRedirectUrl"),
    PM = o(r => k(void 0, void 0, void 0, function*() {
        var e, {
            callbackUrl: t = "",
            redirectUrlParams: n,
            redirectUri: i = vI(n),
            authConfigs: s,
            auth: a = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(Yt.External, s),
            actionName: u = "getExternalLoginUrl"
        } = r === void 0 ? {} : r;
        try {
            if (ee(gt, "Retrieving the external login url."), !a) throw cr(u, Gt.Unavailable);
            let l = Of(u, a),
                c = yield i;
            return l.getLoginUrl({
                redirectUri: c,
                callbackUrl: t
            })
        } catch (l) {
            throw Ue(gt, "Error retrieving the external login url.", "OS-CLRT-40100", l), l
        }
    }), "getExternalLoginUrl"),
    NM = o(r => k(void 0, void 0, void 0, function*() {
        var e, {
            callbackUrl: t = "",
            redirectUrlParams: n,
            redirectUri: i = vI(n),
            auth: s = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(Yt.External),
            actionName: a = "externalLogin"
        } = r === void 0 ? {} : r;
        try {
            if (ee(gt, "External login flow started."), !s) throw cr(a, Gt.Unavailable);
            let u = Of(a, s),
                l = yield i;
            yield u.login({
                redirectUri: l,
                callbackUrl: t,
                navigationHandler: fy
            })
        } catch (u) {
            throw Ue(gt, "Error in the external login flow.", "OS-CLRT-40100", u), new pe.InvalidLoginException("Login Failed", qi(u))
        }
    }), "externalLogin"),
    DM = o(r => k(void 0, void 0, void 0, function*() {
        var e, t, {
            username: n,
            password: i,
            persistLogin: s,
            auth: a = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(Yt.Builtin),
            actionName: u = "builtinLogin"
        } = r;
        try {
            if (ee(gt, "Builtin login flow started."), !a) throw cr(u, Gt.Unavailable);
            return yield Ji(u, a).login({
                username: n,
                password: i,
                persistLogin: s
            })
        } catch (l) {
            throw Ue(gt, "Error in the builtin login flow.", (t = l.errorCode) !== null && t !== void 0 ? t : "OS-CLRT-40100", l), l
        }
    }), "builtinLogin"),
    Bne = o(r => k(void 0, void 0, void 0, function*() {
        var e, {
            url: t,
            redirectUrlParams: n,
            redirectUri: i = vI(n),
            auth: s = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(Yt.External),
            actionName: a = "resumeLogin"
        } = r;
        try {
            if (ee(gt, "Login flow resumed."), !s) throw cr(a, Gt.Unavailable);
            let u = yield i;
            return yield Of(a, s).resumeLogin({
                url: t,
                redirectUri: u
            })
        } catch (u) {
            throw Ue(gt, "Error while resuming login.", "OS-CLRT-40100", u), new pe.InvalidLoginException("Login Failed", qi(u))
        }
    }), "resumeLogin"),
    LM = o(r => k(void 0, void 0, void 0, function*() {
        var e, {
            auth: t = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(),
            actionName: n = "logout"
        } = r === void 0 ? {} : r;
        try {
            if (ee(gt, "Logout flow started."), !t) throw cr(n, Gt.NotAuthenticated);
            yield Ji(n, t, "Use GetExternalLogoutURL instead.").logout()
        } catch (i) {
            throw Ue(gt, "Error in the logout flow.", "OS-CLRT-40100", i), i
        }
    }), "logout$1"),
    xM = o(r => k(void 0, void 0, void 0, function*() {
        var e, {
            callbackUrl: t = "",
            redirectUrlParams: n,
            redirectUri: i = $ne(n),
            auth: s = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(Yt.External),
            actionName: a = "getExternalLogoutUrl"
        } = r === void 0 ? {} : r;
        try {
            if (ee(gt, "Retrieving the external logout url."), !s) throw cr(a, Gt.NotAuthenticated);
            let u = yield i;
            return yield Of(a, s).getLogoutUrl({
                redirectUri: u,
                callbackUrl: t
            })
        } catch (u) {
            throw Ue(gt, "Error retrieving the external logout url.", "OS-CLRT-40100", u), u
        }
    }), "getExternalLogoutUrl"),
    Vne = o(r => k(void 0, void 0, void 0, function*() {
        var e, {
            url: t,
            auth: n = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(Yt.External),
            actionName: i = "resumeLogout"
        } = r;
        try {
            if (ee(gt, "Logout flow resumed."), !n) throw cr("resumeLogout", Gt.NotAuthenticated);
            return yield Of(i, n).resumeLogout({
                url: t
            })
        } catch (s) {
            throw Ue(gt, "Error while resuming logout.", "OS-CLRT-40100", s), new pe.InvalidLoginException("Logout Failed", qi(s))
        }
    }), "resumeLogout"),
    UM = o(r => k(void 0, void 0, void 0, function*() {
        var e, {
            auth: t = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance()
        } = r === void 0 ? {} : r;
        try {
            if (ee(gt, "Refresh flow started."), !t) throw cr("refreshTokens", Gt.NotAuthenticated);
            yield t.refreshTokens()
        } catch (n) {
            throw Ue(gt, "Error in the refresh flow.", "OS-CLRT-40103", n), n
        }
    }), "refreshTokens"),
    Wo = o(r => {
        var e, t, {
            auth: n = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance()
        } = r === void 0 ? {} : r;
        return (t = n == null ? void 0 : n.getUserId()) !== null && t !== void 0 ? t : ""
    }, "getUserId$1"),
    MM = o(r => {
        var e, t, {
            auth: n = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance()
        } = r === void 0 ? {} : r;
        return (t = n == null ? void 0 : n.isAuthenticated()) !== null && t !== void 0 ? t : !1
    }, "isAuthenticated"),
    kM = o(r => {
        var e, {
            auth: t = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(Yt.Builtin),
            actionName: n = "getPasswordComplexityPolicy"
        } = r === void 0 ? {} : r;
        try {
            if (!t) throw cr(n, Gt.Unavailable);
            return Ji(n, t).getPasswordComplexityPolicy()
        } catch (i) {
            throw Ue(gt, "Error getting the password complexity policy", "OS-CLRT-40100", i), i
        }
    }, "getPasswordComplexityPolicy$1"),
    FM = o(r => {
        var e, {
            password: t,
            auth: n = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(Yt.Builtin),
            actionName: i = "validatePasswordComplexity"
        } = r;
        try {
            if (!n) throw cr("validatePasswordComplexity", Gt.Unavailable);
            return Ji(i, n).validatePasswordComplexityPolicy(t)
        } catch (s) {
            throw Ue(gt, "Error validating the password complexity", "OS-CLRT-40100", s), s
        }
    }, "validatePasswordComplexity$1"),
    Hne = o(r => k(void 0, void 0, void 0, function*() {
        var e, {
            username: t,
            resetToken: n,
            newPassword: i,
            auth: s = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(Yt.Builtin),
            actionName: a = "resetPassword"
        } = r;
        try {
            if (!s) throw cr(a, Gt.Unavailable);
            return yield Ji(a, s).resetPassword({
                username: t,
                resetToken: n,
                newPassword: i
            })
        } catch (u) {
            throw Ue(gt, "Error resetting password", "OS-CLRT-40100", u), u
        }
    }), "resetPassword"),
    $M = o(r => k(void 0, void 0, void 0, function*() {
        var e, {
            username: t,
            resetToken: n,
            newPassword: i,
            auth: s = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(Yt.Builtin),
            actionName: a = "finishResetPassword"
        } = r;
        try {
            if (!s) throw cr(a, Gt.Unavailable);
            return yield Ji(a, s).finishResetPassword({
                username: t,
                resetToken: n,
                newPassword: i
            })
        } catch (u) {
            throw Ue(gt, "Error finishing reset password", "OS-CLRT-40100", u), u
        }
    }), "finishResetPassword$1"),
    BM = o(r => {
        var e, {
            auth: t = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(),
            actionName: n = "isExternalUser"
        } = r === void 0 ? {} : r;
        try {
            if (!t) throw cr(n, Gt.NotAuthenticated);
            return t.isExternalUser()
        } catch (i) {
            throw Ue(gt, "Error determining if user is external", "OS-CLRT-40100", i), i
        }
    }, "isExternalUser$1"),
    VM = o(r => k(void 0, void 0, void 0, function*() {
        var e, {
            username: t,
            password: n,
            temporaryPassword: i,
            auth: s = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(Yt.Builtin),
            actionName: a = "finishUserRegistration"
        } = r;
        try {
            if (!s) throw cr(a, Gt.Unavailable);
            return yield Ji(a, s).confirmRegistration({
                username: t,
                password: n,
                code: i
            })
        } catch (u) {
            throw Ue(gt, "Error completing user registration", "OS-CLRT-40100", u), u
        }
    }), "finishUserRegistration$1"),
    jne = o(r => k(void 0, void 0, void 0, function*() {
        var e, {
            username: t,
            auth: n = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(Yt.Builtin),
            actionName: i = "sendResetPasswordEmail"
        } = r;
        try {
            if (!n) throw cr(i, Gt.Unavailable);
            return yield Ji(i, n).sendResetPasswordEmail({
                username: t
            })
        } catch (s) {
            throw Ue(gt, "Error sending reset password email", "OS-CLRT-40100", s), s
        }
    }), "sendResetPasswordEmail"),
    HM = o(r => k(void 0, void 0, void 0, function*() {
        var e, {
            username: t,
            oldPassword: n,
            newPassword: i,
            auth: s = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(Yt.Builtin),
            actionName: a = "changePassword"
        } = r;
        try {
            if (!s) throw cr("changePassword", Gt.NotAuthenticated);
            return yield Ji(a, s).changePassword({
                username: t,
                oldPassword: n,
                newPassword: i
            })
        } catch (u) {
            throw Ue(gt, "Error changing password", "OS-CLRT-40100", u), u
        }
    }), "changePassword$1"),
    yI = o(r => k(void 0, void 0, void 0, function*() {
        var e, {
            auth: t = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(),
            actionName: n = "getUserProfile"
        } = r === void 0 ? {} : r;
        try {
            if (!t) throw cr(n, Gt.NotAuthenticated);
            return yield t.getUserInfo()
        } catch (i) {
            throw Ue(gt, "Error getting user profile", "OS-CLRT-40100", i), i
        }
    }), "getUserProfile$1"),
    jM = o(r => {
        var e, t, {
            url: n,
            auth: i = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance(),
            actionName: s = "isAuthEndpoint"
        } = r;
        try {
            return (t = i == null ? void 0 : i.isAuthEndpoint(n)) !== null && t !== void 0 ? t : !1
        } catch (a) {
            throw Ue(gt, "Error checking if a url corresponds to an auth endpoint", "OS-CLRT-40100", a), a
        }
    }, "isAuthEndpoint"),
    cr = o((r, e) => {
        let t = `Error '${r}': ${e}`,
            n = new Error(t);
        return Ue(gt, t, "OS-CLRT-40100", n, Pe.External), n
    }, "createMissingAuthError"),
    Of = o((r, e, t) => {
        if (!kne(e)) {
            let n = `Error '${r}': only supported for external authentication. `,
                i = new Error(n);
            throw Ue(gt, n, "OS-CLRT-40100", i, Pe.External), i
        }
        return e
    }, "getExternalAuth"),
    Ji = o((r, e, t) => {
        if (!Fne(e)) {
            let n = `Error '${r}': only supported for builtin authentication. ${t!=null?t:""}`,
                i = new Error(n);
            throw Ue(gt, n, "OS-CLRT-40100", i, Pe.External), i
        }
        return e
    }, "getBuiltInAuth"),
    WM = o(r => k(void 0, void 0, void 0, function*() {
        var e, {
            code: t,
            auth: n = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance()
        } = r;
        if (!n) throw cr("changeEmail", Gt.NotAuthenticated);
        return yield n.changeEmail(t)
    }), "changeEmail"),
    Wne = Object.freeze({
        __proto__: null,
        LOGIN_REDIRECT_PATH: CM,
        LOGOUT_REDIRECT_PATH: RM,
        builtinLogin: DM,
        changeEmail: WM,
        changePassword: HM,
        externalLogin: NM,
        finishResetPassword: $M,
        finishUserRegistration: VM,
        getExternalLoginUrl: PM,
        getExternalLogoutUrl: xM,
        getPasswordComplexityPolicy: kM,
        getUserId: Wo,
        getUserProfile: yI,
        isAuthEndpoint: jM,
        isAuthenticated: MM,
        isExternalUser: BM,
        logout: LM,
        refreshTokens: UM,
        resetPassword: Hne,
        resumeLogin: Bne,
        resumeLogout: Vne,
        sendResetPasswordEmail: jne,
        validatePasswordComplexity: FM
    });

function _I() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : zo;
    var e;
    let t = r();
    return (t == null ? void 0 : t.cordova) && ((e = t == null ? void 0 : t.navigator) === null || e === void 0 ? void 0 : e.connection) ? t.navigator.connection.type !== "none" : t.navigator.onLine
}
o(_I, "isOnline");

function GM(r) {
    (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window).addEventListener("online", r)
}
o(GM, "addOnOnlineEventListener");
var CS;
(function(r) {
    r.LogLevel = "LogLevel", r.EnvironmentKey = "EnvironmentKey", r.TenantID = "TenantID", r.LoggingTagID = "LoggingTagID", r.LoggerSchedulerTimeInterval = "LoggerSchedulerTimeInterval", r.EnableOpenTelemetryTraces = "EnableOpenTelemetryTraces", r.EnableSpanAggregation = "EnableSpanAggregation", r.HealthCheckInterval = "HealthCheckInterval"
})(CS || (CS = {}));
var zM = {
        HealthCheckInterval: "1800",
        LogLevel: "Information"
    },
    hy = "cognito",
    Sx = "DEV_";

function Gne(r) {
    return Object.entries(r).reduce((e, t) => {
        let [n, i] = t;
        return n.startsWith(Sx) && typeof i == "string" && (e[n.replace(Sx, "")] = i), e
    }, {})
}
o(Gne, "loadSettingsFromStorage");

function qb(r, e) {
    let t = Gne(e);
    return Object.assign(Object.assign({}, r), t)
}
o(qb, "mergeWithStoredSettings");
var hm, Oo = "SettingsManager",
    zne = "-clientsettings",
    qne = "/moduleservices/clientsettingsinfo",
    Ax = "",
    Ix = 0,
    Cx = !1,
    qM = {
        Debug: Je.Debug,
        Information: Je.Info,
        Warning: Je.Warning,
        Error: Je.Error
    },
    aC = class aC {
        constructor() {
            let {
                getBasePath: e,
                httpClient: t = ge.resolve(J.UnauthenticatedHttpClient),
                getAppKey: n = js,
                initialSettings: i = zM,
                settingsHash: s = "",
                overrideStorage: a = sessionStorage,
                cacheName: u = `${n()}${zne}`,
                cacheStorage: l = localStorage,
                onSettingsUpdated: c
            } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            hm.set(this, void 0), this.getBasePath = e != null ? e : () => Dt(), this.httpClient = t, this.settingsValue = qb(i, a), this.settingsHash = s, this.overrideStorage = a, this.cacheName = u, this.cacheStorage = l, dt(this, hm, c, "f")
        }
        update(e) {
            return k(this, void 0, void 0, function*() {
                var t, n;
                try {
                    if (!e || this.settingsHash !== e) {
                        let i = yield this.httpClient.get({
                            url: qne,
                            baseURL: (t = this.getBasePath) === null || t === void 0 ? void 0 : t.call(this)
                        });
                        if (i) {
                            let {
                                clientSettingsHash: s,
                                clientSettings: a
                            } = i;
                            this.settingsHash = s;
                            let u = qb(a, this.overrideStorage);
                            this.settingsValue = Object.assign(Object.assign({}, this.settingsValue), u), this.cacheSettings(a), (n = ie(this, hm, "f")) === null || n === void 0 || n.call(this, this)
                        } else this.fetchCachedSettings()
                    }
                } catch (i) {
                    Ue(Oo, `Error retrieving settings from endpoint: ${i.message}`, "OS-CLRT-61001"), this.fetchCachedSettings()
                }
            })
        }
        settingExists(e) {
            return Object.keys(this.settingsValue).includes(e)
        }
        cacheSettings(e) {
            this.cacheStorage.setItem(this.cacheName, JSON.stringify(e))
        }
        fetchCachedSettings() {
            try {
                let e = this.cacheStorage.getItem(this.cacheName);
                if (e) {
                    ee(Oo, "Loading client settings from cache");
                    let t = JSON.parse(e),
                        n = qb(t, this.overrideStorage);
                    this.settingsValue = Object.assign(Object.assign({}, this.settingsValue), n)
                } else ft(Oo, "No settings stored in cache, keeping previous values")
            } catch (e) {
                Ue(Oo, "Error retrieving settings from cache, keeping previous values", "OS-CLRT-61000", e)
            }
        }
        readString(e) {
            var t;
            return this.settingExists(e) ? (t = this.settingsValue[e]) !== null && t !== void 0 ? t : Ax : (ee(Oo, `Value for setting ${e} was not found.`), Ax)
        }
        readNumber(e) {
            return this.settingExists(e) ? Number(this.settingsValue[e]) || Ix : (ee(Oo, `Value for setting ${e} was not found.`), Ix)
        }
        readBool(e) {
            var t;
            return this.settingExists(e) ? ((t = this.settingsValue[e]) !== null && t !== void 0 ? t : `${Cx}`).toLowerCase() === "true" : (ee(Oo, `Value for setting ${e} was not found.`), Cx)
        }
        readLogLevel() {
            let e = this.settingsValue.LogLevel,
                t = e ? qM[e] : void 0;
            return t != null ? t : Je.Info
        }
    };
o(aC, "SettingsManager");
var RS = aC;
hm = new WeakMap;
var wI = o(function() {
        for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++) e[t] = arguments[t];
        return k(void 0, [...e], void 0, function() {
            let {
                isRunningOnNative: n = Cr(),
                basePath: i = Dt,
                frontendBuildWorkerVersion: s = IU,
                getUserId: a = Wo,
                getLibVersion: u = cU,
                getHttpScheme: l = qU,
                getUserAgent: c = rne,
                getCurrentUrl: d = zU,
                getNativeLogger: f = rM,
                getDatabaseSuffix: h = js,
                isOnlineMethod: g = _I,
                httpClient: p = ge.resolve(J.LoggerHttpClient)
            } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            return (function*() {
                try {
                    let m = Object.assign(Object.assign({}, Zne(a, u, s)), {
                            "http.scheme": l,
                            "http.url": d,
                            "http.user_agent": c
                        }),
                        w = new Vg({
                            databaseNameSuffix: h(),
                            isOnline: g,
                            baseLogAttributes: m,
                            baseSpanAttributes: m,
                            staticSpanAttributes: ["http.scheme", "http.user_agent", "outsystems.client.runtime.core.version", "outsystems.client.runtime.widgets.version", "outsystems.client.runtime.reactview.version", "outsystems.compiler.version"]
                        });
                    ge.register(J.InstrumentationFactory, () => w), yield w.init();
                    let T = qM[zM.LogLevel];
                    if (n) {
                        let E = yield f();
                        E && w.useNativeLoggerTransport({
                            plugin: E,
                            logTypeBaseline: T
                        })
                    } else w.useOpenTelemetryLoggerTransport({
                        resourceAttributes: {},
                        logTypeBaseline: T,
                        collectorBaseUrl: i(),
                        tagId: "",
                        httpClient: p
                    });
                    w.useConsoleLoggerTransport(T)
                } catch (m) {
                    console.error("Error while initializing the logger.", m)
                }
            })()
        })
    }, "registerInstrumentationFactory"),
    KM = o(r => k(void 0, void 0, void 0, function*() {
        var e, {
            version: t,
            getCurrentScreenName: n = o(() => "", "getCurrentScreenName"),
            applicationName: i = ry,
            applicationKey: s = js,
            clientRuntimeVersion: a = CU,
            basePath: u = Dt,
            getAppVersionMethod: l = RU,
            isWebApplication: c = If,
            usePwaServiceWorkerTracer: d = Hn.isEnabled(di.ServiceWorkerTraces),
            serviceWorkerContainer: f = (e = navigator.serviceWorker) === null || e === void 0 ? void 0 : e.controller,
            settingsManager: h = ge.resolve(J.SettingsManager),
            instrumentationFactory: g = ge.resolve(J.InstrumentationFactory),
            httpClient: p = ge.resolve(J.LoggerHttpClient)
        } = r;
        try {
            g || (yield wI(), g = ge.resolve(J.InstrumentationFactory)), g.setAggregateSpansStatus(h == null ? void 0 : h.readBool("EnableSpanAggregation")), g.setLogLevel(h == null ? void 0 : h.readLogLevel());
            let m = h == null ? void 0 : h.readString("LoggingTagID");
            g.setTagId(m), g.getTracer().addBaseSpanAttributes({
                "outsystems.runtime.screen": n
            });
            let w = {
                "service.name": "ClientRuntime",
                "service.version": a(),
                "outsystems.app.name": i(),
                "outsystems.app.versiontoken": t,
                "outsystems.app.key": s(),
                "outsystems.env.key": h == null ? void 0 : h.readString("EnvironmentKey"),
                "outsystems.tenant.key": h == null ? void 0 : h.readString("TenantID"),
                "outsystems.app.version": l()
            };
            g.setResourceAttributes(w), c() && (h != null && h.readBool("EnableOpenTelemetryTraces")) && (d && f ? g.useServiceWorkerTracerTransport({
                resourceAttributes: w,
                collectorBaseUrl: u(),
                tagId: m,
                enabled: !0,
                aggregateSpans: h == null ? void 0 : h.readBool("EnableSpanAggregation")
            }) : g.useOpenTelemetryTracerTransport({
                resourceAttributes: w,
                collectorBaseUrl: u(),
                tagId: m,
                enabled: !0,
                httpClient: p
            }));
            let T = h == null ? void 0 : h.readNumber("LoggerSchedulerTimeInterval");
            T > 0 && EI(T, g)
        } catch (m) {
            console.error("Error while updating the logger configurations.", m)
        }
    }), "updateInstrumentationFactory"),
    gy = o((r, e) => !!r && !!e, "isMethodEnabled"),
    Kne = o(function() {
        let {
            instrumentationFactory: r = ge.resolve(J.InstrumentationFactory)
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return gy(r, r == null ? void 0 : r.logDebug)
    }, "isDebugEnabled"),
    ee = o(function(r, e, t, n) {
        for (var i = arguments.length, s = new Array(i > 4 ? i - 4 : 0), a = 4; a < i; a++) s[a - 4] = arguments[a];
        return k(void 0, [r, e, t, n, ...s], void 0, function(u, l, c, d) {
            let f = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : ge.resolve(J.InstrumentationFactory);
            return (function*() {
                let h = Qne(u),
                    g = Rx(l);
                py(f, f == null ? void 0 : f.logDebug, h != null ? h : "", g != null ? g : "") || (yield f == null ? void 0 : f.logDebug({
                    category: h,
                    message: Rx(l),
                    visibility: c,
                    attributes: d
                }))
            })()
        })
    }, "debug$1"),
    Yne = o(function() {
        let {
            instrumentationFactory: r = ge.resolve(J.InstrumentationFactory)
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return gy(r, r == null ? void 0 : r.logInfo)
    }, "isLogEnabled"),
    tn = o(function(r, e, t, n) {
        for (var i = arguments.length, s = new Array(i > 4 ? i - 4 : 0), a = 4; a < i; a++) s[a - 4] = arguments[a];
        return k(void 0, [r, e, t, n, ...s], void 0, function(u, l, c, d) {
            let f = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : ge.resolve(J.InstrumentationFactory);
            return (function*() {
                py(f, f == null ? void 0 : f.logInfo, u, l) || (yield f == null ? void 0 : f.logInfo({
                    category: u,
                    message: l,
                    visibility: c,
                    attributes: d
                }))
            })()
        })
    }, "log$1"),
    Xne = o(function() {
        let {
            instrumentationFactory: r = ge.resolve(J.InstrumentationFactory)
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return gy(r, r == null ? void 0 : r.logWarning)
    }, "isWarningEnabled"),
    ft = o(function(r, e, t, n) {
        for (var i = arguments.length, s = new Array(i > 4 ? i - 4 : 0), a = 4; a < i; a++) s[a - 4] = arguments[a];
        return k(void 0, [r, e, t, n, ...s], void 0, function(u, l, c, d) {
            let f = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : ge.resolve(J.InstrumentationFactory);
            return (function*() {
                py(f, f == null ? void 0 : f.logWarning, u, l) || (yield f == null ? void 0 : f.logWarning({
                    category: u,
                    message: l,
                    visibility: c,
                    attributes: d
                }))
            })()
        })
    }, "warning"),
    Jne = o(function() {
        let {
            instrumentationFactory: r = ge.resolve(J.InstrumentationFactory)
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return gy(r, r == null ? void 0 : r.logError)
    }, "isErrorEnabled"),
    Ue = o(function(r, e, t, n, i, s) {
        for (var a = arguments.length, u = new Array(a > 6 ? a - 6 : 0), l = 6; l < a; l++) u[l - 6] = arguments[l];
        return k(void 0, [r, e, t, n, i, s, ...u], void 0, function(c, d, f, h, g, p) {
            let m = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : ge.resolve(J.InstrumentationFactory);
            return (function*() {
                var w;
                let {
                    error: T,
                    message: E
                } = eie(d, h);
                if (!py(m, m == null ? void 0 : m.logError, c, E != null ? E : "")) {
                    let L = (f === "OS-CLRT-00000" || typeof f == "undefined" || f === null) && (w = T.errorCode) !== null && w !== void 0 ? w : f;
                    c = c != null ? c : T.category, Bn(T, pe.UserException) && (g = Pe.Client), yield m == null ? void 0 : m.logError({
                        category: c,
                        message: E,
                        error: T,
                        errorCode: L,
                        visibility: g,
                        attributes: p
                    })
                }
            })()
        })
    }, "error"),
    py = o((r, e, t, n) => (!r && Hn.isEnabled(di.NoInstrumentationFactoryLogs) ? console.warn(`No instrumentation factory: ${t} - ${n}`) : !e && Hn.isEnabled(di.NoInstrumentationFactoryLogs) && console.warn(`Factory function not defined: ${t} - ${n}`), !r || !e), "noInstrumentationFactoryLog"),
    TI = o(function() {
        for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++) e[t] = arguments[t];
        return k(void 0, [...e], void 0, function() {
            let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ge.resolve(J.InstrumentationFactory);
            return (function*() {
                yield n == null ? void 0 : n.flushInstrumentationData()
            })()
        })
    }, "flush"),
    YM = o(function() {
        for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++) e[t] = arguments[t];
        return k(void 0, [...e], void 0, function() {
            let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ge.resolve(J.InstrumentationFactory);
            return (function*() {
                yield n == null ? void 0 : n.flushLogs()
            })()
        })
    }, "flushLogs"),
    XM = o(function(r) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ge.resolve(J.InstrumentationFactory);
        e == null || e.setLogLevel(r)
    }, "setLogLevel"),
    EI = o(function(r) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ge.resolve(J.InstrumentationFactory);
        e == null || e.setSchedulerTimerInterval(r)
    }, "setSchedulerTimerInterval");

function JM(r, e, t, n, i) {
    let s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : ge.resolve(J.InstrumentationFactory);
    return s ? s.startActiveSpan(r, e, t, n, i) : e(void 0)
}
o(JM, "startActiveSpan");

function ZM() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ge.resolve(J.InstrumentationFactory),
        e = r == null ? void 0 : r.getActiveSpan();
    e == null || e.setAttribute(On.IsNonAggregable, "true")
}
o(ZM, "setActiveSpanAsNonAggregable");

function bI(r, e, t, n) {
    let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : ge.resolve(J.InstrumentationFactory);
    return i == null ? void 0 : i.startSpan(r, e, t, n)
}
o(bI, "startSpan");
var Zne = o((r, e, t) => ({
        "enduser.id": r,
        "outsystems.client.runtime.core.version": o(() => {
            var n;
            return (n = e({
                packageKey: "client-runtime-core"
            })) !== null && n !== void 0 ? n : ""
        }, "outsystems.client.runtime.core.version"),
        "outsystems.client.runtime.widgets.version": o(() => {
            var n;
            return (n = e({
                packageKey: "client-runtime-widgets"
            })) !== null && n !== void 0 ? n : ""
        }, "outsystems.client.runtime.widgets.version"),
        "outsystems.client.runtime.reactview.version": o(() => {
            var n;
            return (n = e({
                packageKey: "client-runtime-view-framework-react"
            })) !== null && n !== void 0 ? n : ""
        }, "outsystems.client.runtime.reactview.version"),
        "outsystems.compiler.version": o(() => {
            var n;
            return (n = t()) !== null && n !== void 0 ? n : ""
        }, "outsystems.compiler.version")
    }), "getCommonAttributes"),
    Qne = o(r => {
        if (r) {
            if (typeof r == "string") return r; {
                let e = r.constructor.name;
                return e === "Function" ? r.name : e
            }
        }
    }, "buildCategory"),
    Rx = o(r => {
        if (r) return typeof r == "string" ? r : r()
    }, "buildMessage"),
    eie = o((r, e) => {
        let t = e != null ? e : typeof r == "string" ? new Error(r) : r,
            n = e && typeof r == "string" ? r : void 0;
        return t.message === n && (n = void 0), {
            error: t,
            message: n
        }
    }, "handleDuplicatedErrorMessages"),
    xc = o(r => {
        let {
            category: e,
            errorCode: t,
            clientMessage: n,
            internalMessage: i,
            instrumentationFactory: s = ge.resolve(J.InstrumentationFactory),
            errorObj: a,
            attributes: u
        } = r;
        return Promise.all([Ue(e, n, t, a, Pe.Client, u, s), Ue(e, i, t, void 0, Pe.Internal, u, s)])
    }, "clientError"),
    QM = Object.freeze({
        __proto__: null,
        clientError: xc,
        debug: ee,
        error: Ue,
        flush: TI,
        flushLogs: YM,
        isDebugEnabled: Kne,
        isErrorEnabled: Jne,
        isLogEnabled: Yne,
        isWarningEnabled: Xne,
        log: tn,
        registerInstrumentationFactory: wI,
        setActiveSpanAsNonAggregable: ZM,
        setLogLevel: XM,
        setSchedulerTimerInterval: EI,
        startActiveSpan: JM,
        startSpan: bI,
        updateInstrumentationFactory: KM,
        warning: ft
    }),
    ek = "_error.html",
    Yd = {
        errorCode: "UNHANDLED"
    },
    SI = {
        errorCode: "IGNORED"
    },
    AI = "ErrorHandling",
    ii = {
        errorPageMessage: new wn(ar.Session, "ErrorPageMessage", ""),
        errorPageExtraMessage: new wn(ar.Session, "ErrorPageExtraMessage", ""),
        errorPageExceptionInfo: new wn(ar.Session, "ErrorPageExceptionInfo")
    };

function my(r) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "",
        t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "",
        n = arguments.length > 3 ? arguments[3] : void 0;
    var i, s;
    if (!hI() && (r && Ue((i = r.category) !== null && i !== void 0 ? i : AI, r.message || "Navigating to Error page", (s = r.errorCode) !== null && s !== void 0 ? s : "OS-CLRT-00000", r, Pe.External), dI(n))) {
        let a = pc.getVersionedUrl(ek);
        ii.errorPageMessage.set(e), ii.errorPageExtraMessage.set(t), r ? ii.errorPageExceptionInfo.set(kU(r)) : ii.errorPageExceptionInfo.remove(), Xi(a)
    }
}
o(my, "navigateToErrorPage");

function tk(r, e) {
    var t;
    let n = QA(),
        i = (t = n == null ? void 0 : n.messages) === null || t === void 0 ? void 0 : t.incompatibleProducer;
    my(r, i || r.message, void 0, e)
}
o(tk, "navigateToIncompatibleProducer");

function II(r) {
    var e;
    let t = QA(),
        n = (e = t == null ? void 0 : t.messages) === null || e === void 0 ? void 0 : e.appOffline;
    my(void 0, n || "This application is temporarily unavailable. Try reloading or contact the administrator.", void 0, r)
}
o(II, "navigateToAppOffline");

function Ds(r, e) {
    ee(AI, "Error thrown by the application: " + r, Pe.Client), iI(r) ? II(e) : Bn(r, pe.IncompatibleProducerException) ? tk(r, e) : my(r, void 0, void 0, e)
}
o(Ds, "handleError");

function tie(r, e) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (i, s) => Ds(i, s),
        n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (i, s) => CI(i, s);
    return ks(r) && ft(AI, ks(r)), r instanceof pe.NotRegisteredException ? (NM({
        callbackUrl: Dt()
    }), Yd) : n(r, e) ? SI : (t(r, e), Yd)
}
o(tie, "defaultErrorHandler");

function CI(r, e) {
    return Bn(r, pe.IgnorableSystemException) ? !0 : iI(r) ? (II(e), !0) : !1
}
o(CI, "ignoreError");

function rk(r) {
    return r === Yd || r === SI
}
o(rk, "isSpecialHandleErrorResult");
var rie = Object.freeze({
        __proto__: null,
        ERROR_PAGE_HTML: ek,
        ErrorHandlingStorage: ii,
        IGNORED_ERROR_RESULT: SI,
        UNHANDLED_ERROR_RESULT: Yd,
        defaultErrorHandler: tie,
        handleError: Ds,
        ignoreError: CI,
        isSpecialHandleErrorResult: rk,
        navigateToAppOffline: II,
        navigateToErrorPage: my,
        navigateToIncompatibleProducer: tk
    }),
    Xd, Ld, RI = !0;

function nie(r) {
    Xd = r, Ld && (Ld(), Ld = null)
}
o(nie, "registerFeedbackMessageService");

function nk(r) {
    RI = r
}
o(nk, "setEnabled");

function OI(r, e) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
        n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "",
        i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0,
        s = arguments.length > 5 ? arguments[5] : void 0;
    if (!RI) return;
    let a = o(() => Xd.showMessage(r, e, t, n, i, s), "show");
    Xd ? a() : Ld = a
}
o(OI, "showFeedbackMessage");

function ik() {
    if (!RI) return;
    Xd ? o(() => Xd.closeMessage(), "close")() : Ld = null
}
o(ik, "closeFeedbackMessage");
var iie = Object.freeze({
        __proto__: null,
        closeFeedbackMessage: ik,
        registerFeedbackMessageService: nie,
        setEnabled: nk,
        showFeedbackMessage: OI
    }),
    Ox = "Argument 'handler' cannot be null or undefined",
    uC = class uC {
        constructor(e, t) {
            this.moduleName = e, this.context = t, this.subscribers = []
        }
        subscribe(e) {
            if (!e) throw new Error(Ox);
            for (let t = 0; t < this.subscribers.length; t++)
                if (this.subscribers[t] === e) return !1;
            return this.subscribers.push(e), ee(this.moduleName, `Subscribing handler for ${this.context}`), !0
        }
        unsubscribe(e) {
            if (!e) throw new Error(Ox);
            for (let t = 0; t < this.subscribers.length; t++)
                if (this.subscribers[t] === e) return this.subscribers.splice(t, 1), ee(this.moduleName, `Unsubscribing handler for ${this.context}`), !0;
            return !1
        }
        publish(e) {
            for (let t of this.subscribers) t(e);
            ee(this.moduleName, `Notifying subscribers for ${this.context}`)
        }
    };
o(uC, "Publisher");
var Jd = uC,
    xd, Ud, Ls, Md, Du, Is, Sr, Uo, Vi, sk, Px, Nx, cC = class cC {
        constructor(e, t) {
            let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
                i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
            var s, a;
            xd.add(this), Ud.set(this, void 0), Ls.set(this, void 0), Md.set(this, !1), Du.set(this, 30), Is.set(this, void 0), Sr.set(this, []), Uo.set(this, !1), Vi.set(this, !1), dt(this, Ud, t, "f"), dt(this, Ls, new Jd("SyncQueue", e), "f"), dt(this, Md, (s = n.retryOnError) !== null && s !== void 0 ? s : ie(this, Md, "f"), "f"), dt(this, Du, (a = n.retryIntervalInSeconds) !== null && a !== void 0 ? a : ie(this, Du, "f"), "f"), dt(this, Sr, i, "f")
        }
        getQueue() {
            return ie(this, Sr, "f")
        }
        suspendSync() {
            dt(this, Vi, !1, "f"), dt(this, Uo, !1, "f")
        }
        isSyncing() {
            return ie(this, Vi, "f")
        }
        startSync(e, t) {
            return ie(this, xd, "m", sk).call(this, e, t), Promise.resolve()
        }
        subscribe(e) {
            return ie(this, Ls, "f").subscribe(e)
        }
        unsubscribe(e) {
            return ie(this, Ls, "f").unsubscribe(e)
        }
    };
o(cC, "SyncQueue");
var OS = cC;
Ud = new WeakMap, Ls = new WeakMap, Md = new WeakMap, Du = new WeakMap, Is = new WeakMap, Sr = new WeakMap, Uo = new WeakMap, Vi = new WeakMap, xd = new WeakSet, sk = o(function(e, t) {
    return k(this, void 0, void 0, function*() {
        var n;
        if (!ie(this, Ud, "f")) return;
        let i = !0,
            s = ie(this, Sr, "f")[0];
        if (t ? dt(this, Sr, ie(this, Vi, "f") && s ? [s] : [], "f") : ie(this, Sr, "f").some((a, u) => a === e && (!this.isSyncing() || u !== 0)) && (i = !1), i && (ie(this, Sr, "f").push(e), dt(this, Uo, !0, "f")), ie(this, Is, "f") && (clearTimeout(ie(this, Is, "f")), dt(this, Is, null, "f")), !ie(this, Vi, "f")) {
            dt(this, Vi, !0, "f");
            try {
                if (ie(this, Ls, "f").publish({
                        type: "SyncStart",
                        context: ie(this, Sr, "f")[0]
                    }), _I()) yield ie(this, Ud, "f").call(this, ie(this, Sr, "f")[0]), ie(this, xd, "m", Px).call(this);
                else throw this.suspendSync(), new pe.CommunicationException("Unable to synchronize data. Device has no network connectivity.")
            } catch (a) {
                ie(this, xd, "m", Nx).call(this, {
                    errorMessage: (n = a.message) !== null && n !== void 0 ? n : String(a),
                    allowRetry: !(a instanceof pe.SecurityException)
                })
            }
        }
    })
}, "_SyncQueue_doSync"), Px = o(function() {
    ie(this, Ls, "f").publish({
        type: "SyncComplete",
        context: ie(this, Sr, "f")[0]
    }), ie(this, Sr, "f").shift(), dt(this, Vi, !1, "f"), ie(this, Uo, "f") && ie(this, Sr, "f").length > 0 ? this.startSync(ie(this, Sr, "f")[0]) : dt(this, Uo, !1, "f")
}, "_SyncQueue_finishSync"), Nx = o(function(e) {
    let {
        errorMessage: t,
        allowRetry: n
    } = e;
    ie(this, Ls, "f").publish({
        type: "SyncError",
        context: ie(this, Sr, "f")[0],
        message: t
    }), n && ie(this, Md, "f") && ie(this, Du, "f") > 0 && dt(this, Is, setTimeout(() => {
        dt(this, Is, null, "f"), this.startSync(ie(this, Sr, "f")[0])
    }, ie(this, Du, "f") * 1e3), "f"), dt(this, Vi, !1, "f"), ie(this, Is, "f") || dt(this, Uo, !1, "f")
}, "_SyncQueue_finishSyncWithError");

function sie(r) {
    let {
        applicationName: e,
        moduleController: t,
        syncConfiguration: n,
        regOnOnlineHandler: i = GM,
        injector: s = ge
    } = r;
    s.register(J.OfflineDataSync, () => new OS(e, t.default.onSyncHandler, {
        retryOnError: n == null ? void 0 : n.retryOnError,
        retryIntervalInSeconds: n == null ? void 0 : n.retryIntervalInSeconds
    })), n != null && n.syncOnOnline && i(() => {
        s.resolve(J.OfflineDataSync).startSync("")
    })
}
o(sie, "initOfflineDataSyncService");
var lC = class lC {
    constructor(e, t) {
        this.databaseName = e, this.databaseEngineName = t, this.isInitialized = !1, this.allInitializers = [], this.initializersToRun = []
    }
    get name() {
        return this.databaseName
    }
    get engineName() {
        var e;
        return (e = this.databaseEngineName) !== null && e !== void 0 ? e : "Unknown"
    }
    registerInitializer(e) {
        if (this.isInitialized) throw new pe.DataBaseException("", `Cannot register a database initializer on the already initialized database '${this.name}'`);
        this.allInitializers.push(e)
    }
    initialize() {
        return k(this, void 0, void 0, function*() {
            if (this.isInitialized) throw new pe.DataBaseException("", `Cannot initialize the already initialized database '${this.name}'`);
            this.markInitialized(), yield this.identifyNeededInitializers(), yield this.runNeededInitializers()
        })
    }
    initializerCleanup() {
        return k(this, void 0, void 0, function*() {
            if (!this.isInitialized) throw new pe.DataBaseException("", `Cannot perform database initializer cleanup on the non-initialized database '${this.name}'`);
            yield this.cleanupNeededInitializers()
        })
    }
    identifyNeededInitializers() {
        return k(this, void 0, void 0, function*() {
            this.allInitializers && this.allInitializers.length > 0 && (yield this.executeReadTransaction(e => k(this, void 0, void 0, function*() {
                for (let t of this.allInitializers)(yield t.isNeeded(e)) && this.initializersToRun.push(t)
            }))), this.releaseUnneededInitializers()
        })
    }
    runNeededInitializers() {
        return k(this, void 0, void 0, function*() {
            this.initializersToRun.length > 0 && (yield this.executeUpgradeTransaction(e => k(this, void 0, void 0, function*() {
                for (let t of this.initializersToRun) yield t.run(e)
            })))
        })
    }
    cleanupNeededInitializers() {
        return k(this, void 0, void 0, function*() {
            this.initializersToRun.length > 0 && (yield this.executeUpgradeTransaction(e => k(this, void 0, void 0, function*() {
                for (let t of this.initializersToRun) t.cleanup && (yield t.cleanup(e))
            })), this.releaseNeededInitializers())
        })
    }
    markInitialized() {
        this.isInitialized = !0
    }
    releaseUnneededInitializers() {
        this.allInitializers = []
    }
    releaseNeededInitializers() {
        this.initializersToRun = []
    }
};
o(lC, "Database");
var Hm = lC;

function oie(r) {
    if (r === void 0 || r === "") return r;
    let e = [],
        t = 32,
        n = 10,
        i = "\xA0";
    r.charCodeAt(0) === t ? e[0] = i : e[0] = r.charAt(0);
    for (let s = 1; s < r.length - 1; ++s) r.charCodeAt(s) === t && (r.charCodeAt(s - 1) === n || r.charCodeAt(s + 1) === t) ? e[s] = i : e[s] = r.charAt(s);
    return r.length !== 1 && (r.charCodeAt(r.length - 1) === t ? e[r.length - 1] = i : e[r.length - 1] = r.charAt(r.length - 1)), e.join("")
}
o(oie, "fixHtmlSpaces");

function aie(r) {
    let e = [];
    for (let t = 0; t < r.length; ++t) {
        let n = r.charCodeAt(t);
        n === 60 ? e.push("&lt;") : n === 62 ? e.push("&gt;") : n === 38 ? e.push("&amp;") : n === 34 ? e.push("&quot;") : n === 39 ? e.push("&#39;") : n >= 160 && n <= 255 ? e.push("&#" + n + ";") : e.push(r.charAt(t))
    }
    return e.join("")
}
o(aie, "encode");
var Eu = 9e15,
    Ws = 1e9,
    PS = "0123456789abcdef",
    jm = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",
    Wm = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",
    NS = {
        precision: 20,
        rounding: 4,
        modulo: 1,
        toExpNeg: -7,
        toExpPos: 21,
        minE: -Eu,
        maxE: Eu,
        crypto: !1
    },
    ok, Gi, ke = !0,
    vy = "[DecimalError] ",
    $s = vy + "Invalid argument: ",
    ak = vy + "Precision limit exceeded",
    uk = vy + "crypto unavailable",
    ck = "[object Decimal]",
    Rr = Math.floor,
    Jt = Math.pow,
    uie = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
    cie = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
    lie = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
    lk = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
    $n = 1e7,
    De = 7,
    die = 9007199254740991,
    fie = jm.length - 1,
    DS = Wm.length - 1,
    ue = {
        toStringTag: ck
    };
ue.absoluteValue = ue.abs = function() {
    var r = new this.constructor(this);
    return r.s < 0 && (r.s = 1), Re(r)
};
ue.ceil = function() {
    return Re(new this.constructor(this), this.e + 1, 2)
};
ue.clampedTo = ue.clamp = function(r, e) {
    var t, n = this,
        i = n.constructor;
    if (r = new i(r), e = new i(e), !r.s || !e.s) return new i(NaN);
    if (r.gt(e)) throw Error($s + e);
    return t = n.cmp(r), t < 0 ? r : n.cmp(e) > 0 ? e : new i(n)
};
ue.comparedTo = ue.cmp = function(r) {
    var e, t, n, i, s = this,
        a = s.d,
        u = (r = new s.constructor(r)).d,
        l = s.s,
        c = r.s;
    if (!a || !u) return !l || !c ? NaN : l !== c ? l : a === u ? 0 : !a ^ l < 0 ? 1 : -1;
    if (!a[0] || !u[0]) return a[0] ? l : u[0] ? -c : 0;
    if (l !== c) return l;
    if (s.e !== r.e) return s.e > r.e ^ l < 0 ? 1 : -1;
    for (n = a.length, i = u.length, e = 0, t = n < i ? n : i; e < t; ++e)
        if (a[e] !== u[e]) return a[e] > u[e] ^ l < 0 ? 1 : -1;
    return n === i ? 0 : n > i ^ l < 0 ? 1 : -1
};
ue.cosine = ue.cos = function() {
    var r, e, t = this,
        n = t.constructor;
    return t.d ? t.d[0] ? (r = n.precision, e = n.rounding, n.precision = r + Math.max(t.e, t.sd()) + De, n.rounding = 1, t = hie(n, pk(n, t)), n.precision = r, n.rounding = e, Re(Gi == 2 || Gi == 3 ? t.neg() : t, r, e, !0)) : new n(1) : new n(NaN)
};
ue.cubeRoot = ue.cbrt = function() {
    var r, e, t, n, i, s, a, u, l, c, d = this,
        f = d.constructor;
    if (!d.isFinite() || d.isZero()) return new f(d);
    for (ke = !1, s = d.s * Jt(d.s * d, 1 / 3), !s || Math.abs(s) == 1 / 0 ? (t = mr(d.d), r = d.e, (s = (r - t.length + 1) % 3) && (t += s == 1 || s == -2 ? "0" : "00"), s = Jt(t, 1 / 3), r = Rr((r + 1) / 3) - (r % 3 == (r < 0 ? -1 : 2)), s == 1 / 0 ? t = "5e" + r : (t = s.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + r), n = new f(t), n.s = d.s) : n = new f(s.toString()), a = (r = f.precision) + 3;;)
        if (u = n, l = u.times(u).times(u), c = l.plus(d), n = Et(c.plus(d).times(u), c.plus(l), a + 2, 1), mr(u.d).slice(0, a) === (t = mr(n.d)).slice(0, a))
            if (t = t.slice(a - 3, a + 1), t == "9999" || !i && t == "4999") {
                if (!i && (Re(u, r + 1, 0), u.times(u).times(u).eq(d))) {
                    n = u;
                    break
                }
                a += 4, i = 1
            } else {
                (!+t || !+t.slice(1) && t.charAt(0) == "5") && (Re(n, r + 1, 1), e = !n.times(n).times(n).eq(d));
                break
            } return ke = !0, Re(n, r, f.rounding, e)
};
ue.decimalPlaces = ue.dp = function() {
    var r, e = this.d,
        t = NaN;
    if (e) {
        if (r = e.length - 1, t = (r - Rr(this.e / De)) * De, r = e[r], r)
            for (; r % 10 == 0; r /= 10) t--;
        t < 0 && (t = 0)
    }
    return t
};
ue.dividedBy = ue.div = function(r) {
    return Et(this, new this.constructor(r))
};
ue.dividedToIntegerBy = ue.divToInt = function(r) {
    var e = this,
        t = e.constructor;
    return Re(Et(e, new t(r), 0, 1, 1), t.precision, t.rounding)
};
ue.equals = ue.eq = function(r) {
    return this.cmp(r) === 0
};
ue.floor = function() {
    return Re(new this.constructor(this), this.e + 1, 3)
};
ue.greaterThan = ue.gt = function(r) {
    return this.cmp(r) > 0
};
ue.greaterThanOrEqualTo = ue.gte = function(r) {
    var e = this.cmp(r);
    return e == 1 || e === 0
};
ue.hyperbolicCosine = ue.cosh = function() {
    var r, e, t, n, i, s = this,
        a = s.constructor,
        u = new a(1);
    if (!s.isFinite()) return new a(s.s ? 1 / 0 : NaN);
    if (s.isZero()) return u;
    t = a.precision, n = a.rounding, a.precision = t + Math.max(s.e, s.sd()) + 4, a.rounding = 1, i = s.d.length, i < 32 ? (r = Math.ceil(i / 3), e = (1 / _y(4, r)).toString()) : (r = 16, e = "2.3283064365386962890625e-10"), s = mc(a, 1, s.times(e), new a(1), !0);
    for (var l, c = r, d = new a(8); c--;) l = s.times(s), s = u.minus(l.times(d.minus(l.times(d))));
    return Re(s, a.precision = t, a.rounding = n, !0)
};
ue.hyperbolicSine = ue.sinh = function() {
    var r, e, t, n, i = this,
        s = i.constructor;
    if (!i.isFinite() || i.isZero()) return new s(i);
    if (e = s.precision, t = s.rounding, s.precision = e + Math.max(i.e, i.sd()) + 4, s.rounding = 1, n = i.d.length, n < 3) i = mc(s, 2, i, i, !0);
    else {
        r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, i = i.times(1 / _y(5, r)), i = mc(s, 2, i, i, !0);
        for (var a, u = new s(5), l = new s(16), c = new s(20); r--;) a = i.times(i), i = i.times(u.plus(a.times(l.times(a).plus(c))))
    }
    return s.precision = e, s.rounding = t, Re(i, e, t, !0)
};
ue.hyperbolicTangent = ue.tanh = function() {
    var r, e, t = this,
        n = t.constructor;
    return t.isFinite() ? t.isZero() ? new n(t) : (r = n.precision, e = n.rounding, n.precision = r + 7, n.rounding = 1, Et(t.sinh(), t.cosh(), n.precision = r, n.rounding = e)) : new n(t.s)
};
ue.inverseCosine = ue.acos = function() {
    var r = this,
        e = r.constructor,
        t = r.abs().cmp(1),
        n = e.precision,
        i = e.rounding;
    return t !== -1 ? t === 0 ? r.isNeg() ? si(e, n, i) : new e(0) : new e(NaN) : r.isZero() ? si(e, n + 4, i).times(.5) : (e.precision = n + 6, e.rounding = 1, r = new e(1).minus(r).div(r.plus(1)).sqrt().atan(), e.precision = n, e.rounding = i, r.times(2))
};
ue.inverseHyperbolicCosine = ue.acosh = function() {
    var r, e, t = this,
        n = t.constructor;
    return t.lte(1) ? new n(t.eq(1) ? 0 : NaN) : t.isFinite() ? (r = n.precision, e = n.rounding, n.precision = r + Math.max(Math.abs(t.e), t.sd()) + 4, n.rounding = 1, ke = !1, t = t.times(t).minus(1).sqrt().plus(t), ke = !0, n.precision = r, n.rounding = e, t.ln()) : new n(t)
};
ue.inverseHyperbolicSine = ue.asinh = function() {
    var r, e, t = this,
        n = t.constructor;
    return !t.isFinite() || t.isZero() ? new n(t) : (r = n.precision, e = n.rounding, n.precision = r + 2 * Math.max(Math.abs(t.e), t.sd()) + 6, n.rounding = 1, ke = !1, t = t.times(t).plus(1).sqrt().plus(t), ke = !0, n.precision = r, n.rounding = e, t.ln())
};
ue.inverseHyperbolicTangent = ue.atanh = function() {
    var r, e, t, n, i = this,
        s = i.constructor;
    return i.isFinite() ? i.e >= 0 ? new s(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (r = s.precision, e = s.rounding, n = i.sd(), Math.max(n, r) < 2 * -i.e - 1 ? Re(new s(i), r, e, !0) : (s.precision = t = n - i.e, i = Et(i.plus(1), new s(1).minus(i), t + r, 1), s.precision = r + 4, s.rounding = 1, i = i.ln(), s.precision = r, s.rounding = e, i.times(.5))) : new s(NaN)
};
ue.inverseSine = ue.asin = function() {
    var r, e, t, n, i = this,
        s = i.constructor;
    return i.isZero() ? new s(i) : (e = i.abs().cmp(1), t = s.precision, n = s.rounding, e !== -1 ? e === 0 ? (r = si(s, t + 4, n).times(.5), r.s = i.s, r) : new s(NaN) : (s.precision = t + 6, s.rounding = 1, i = i.div(new s(1).minus(i.times(i)).sqrt().plus(1)).atan(), s.precision = t, s.rounding = n, i.times(2)))
};
ue.inverseTangent = ue.atan = function() {
    var r, e, t, n, i, s, a, u, l, c = this,
        d = c.constructor,
        f = d.precision,
        h = d.rounding;
    if (c.isFinite()) {
        if (c.isZero()) return new d(c);
        if (c.abs().eq(1) && f + 4 <= DS) return a = si(d, f + 4, h).times(.25), a.s = c.s, a
    } else {
        if (!c.s) return new d(NaN);
        if (f + 4 <= DS) return a = si(d, f + 4, h).times(.5), a.s = c.s, a
    }
    for (d.precision = u = f + 10, d.rounding = 1, t = Math.min(28, u / De + 2 | 0), r = t; r; --r) c = c.div(c.times(c).plus(1).sqrt().plus(1));
    for (ke = !1, e = Math.ceil(u / De), n = 1, l = c.times(c), a = new d(c), i = c; r !== -1;)
        if (i = i.times(l), s = a.minus(i.div(n += 2)), i = i.times(l), a = s.plus(i.div(n += 2)), a.d[e] !== void 0)
            for (r = e; a.d[r] === s.d[r] && r--;);
    return t && (a = a.times(2 << t - 1)), ke = !0, Re(a, d.precision = f, d.rounding = h, !0)
};
ue.isFinite = function() {
    return !!this.d
};
ue.isInteger = ue.isInt = function() {
    return !!this.d && Rr(this.e / De) > this.d.length - 2
};
ue.isNaN = function() {
    return !this.s
};
ue.isNegative = ue.isNeg = function() {
    return this.s < 0
};
ue.isPositive = ue.isPos = function() {
    return this.s > 0
};
ue.isZero = function() {
    return !!this.d && this.d[0] === 0
};
ue.lessThan = ue.lt = function(r) {
    return this.cmp(r) < 0
};
ue.lessThanOrEqualTo = ue.lte = function(r) {
    return this.cmp(r) < 1
};
ue.logarithm = ue.log = function(r) {
    var e, t, n, i, s, a, u, l, c = this,
        d = c.constructor,
        f = d.precision,
        h = d.rounding,
        g = 5;
    if (r == null) r = new d(10), e = !0;
    else {
        if (r = new d(r), t = r.d, r.s < 0 || !t || !t[0] || r.eq(1)) return new d(NaN);
        e = r.eq(10)
    }
    if (t = c.d, c.s < 0 || !t || !t[0] || c.eq(1)) return new d(t && !t[0] ? -1 / 0 : c.s != 1 ? NaN : t ? 0 : 1 / 0);
    if (e)
        if (t.length > 1) s = !0;
        else {
            for (i = t[0]; i % 10 === 0;) i /= 10;
            s = i !== 1
        } if (ke = !1, u = f + g, a = xs(c, u), n = e ? Gm(d, u + 10) : xs(r, u), l = Et(a, n, u, 1), Zd(l.d, i = f, h))
        do
            if (u += 10, a = xs(c, u), n = e ? Gm(d, u + 10) : xs(r, u), l = Et(a, n, u, 1), !s) {
                +mr(l.d).slice(i + 1, i + 15) + 1 == 1e14 && (l = Re(l, f + 1, 0));
                break
            } while (Zd(l.d, i += 10, h));
    return ke = !0, Re(l, f, h)
};
ue.minus = ue.sub = function(r) {
    var e, t, n, i, s, a, u, l, c, d, f, h, g = this,
        p = g.constructor;
    if (r = new p(r), !g.d || !r.d) return !g.s || !r.s ? r = new p(NaN) : g.d ? r.s = -r.s : r = new p(r.d || g.s !== r.s ? g : NaN), r;
    if (g.s != r.s) return r.s = -r.s, g.plus(r);
    if (c = g.d, h = r.d, u = p.precision, l = p.rounding, !c[0] || !h[0]) {
        if (h[0]) r.s = -r.s;
        else if (c[0]) r = new p(g);
        else return new p(l === 3 ? -0 : 0);
        return ke ? Re(r, u, l) : r
    }
    if (t = Rr(r.e / De), d = Rr(g.e / De), c = c.slice(), s = d - t, s) {
        for (f = s < 0, f ? (e = c, s = -s, a = h.length) : (e = h, t = d, a = c.length), n = Math.max(Math.ceil(u / De), a) + 2, s > n && (s = n, e.length = 1), e.reverse(), n = s; n--;) e.push(0);
        e.reverse()
    } else {
        for (n = c.length, a = h.length, f = n < a, f && (a = n), n = 0; n < a; n++)
            if (c[n] != h[n]) {
                f = c[n] < h[n];
                break
            } s = 0
    }
    for (f && (e = c, c = h, h = e, r.s = -r.s), a = c.length, n = h.length - a; n > 0; --n) c[a++] = 0;
    for (n = h.length; n > s;) {
        if (c[--n] < h[n]) {
            for (i = n; i && c[--i] === 0;) c[i] = $n - 1;
            --c[i], c[n] += $n
        }
        c[n] -= h[n]
    }
    for (; c[--a] === 0;) c.pop();
    for (; c[0] === 0; c.shift()) --t;
    return c[0] ? (r.d = c, r.e = yy(c, t), ke ? Re(r, u, l) : r) : new p(l === 3 ? -0 : 0)
};
ue.modulo = ue.mod = function(r) {
    var e, t = this,
        n = t.constructor;
    return r = new n(r), !t.d || !r.s || r.d && !r.d[0] ? new n(NaN) : !r.d || t.d && !t.d[0] ? Re(new n(t), n.precision, n.rounding) : (ke = !1, n.modulo == 9 ? (e = Et(t, r.abs(), 0, 3, 1), e.s *= r.s) : e = Et(t, r, 0, n.modulo, 1), e = e.times(r), ke = !0, t.minus(e))
};
ue.naturalExponential = ue.exp = function() {
    return LS(this)
};
ue.naturalLogarithm = ue.ln = function() {
    return xs(this)
};
ue.negated = ue.neg = function() {
    var r = new this.constructor(this);
    return r.s = -r.s, Re(r)
};
ue.plus = ue.add = function(r) {
    var e, t, n, i, s, a, u, l, c, d, f = this,
        h = f.constructor;
    if (r = new h(r), !f.d || !r.d) return !f.s || !r.s ? r = new h(NaN) : f.d || (r = new h(r.d || f.s === r.s ? f : NaN)), r;
    if (f.s != r.s) return r.s = -r.s, f.minus(r);
    if (c = f.d, d = r.d, u = h.precision, l = h.rounding, !c[0] || !d[0]) return d[0] || (r = new h(f)), ke ? Re(r, u, l) : r;
    if (s = Rr(f.e / De), n = Rr(r.e / De), c = c.slice(), i = s - n, i) {
        for (i < 0 ? (t = c, i = -i, a = d.length) : (t = d, n = s, a = c.length), s = Math.ceil(u / De), a = s > a ? s + 1 : a + 1, i > a && (i = a, t.length = 1), t.reverse(); i--;) t.push(0);
        t.reverse()
    }
    for (a = c.length, i = d.length, a - i < 0 && (i = a, t = d, d = c, c = t), e = 0; i;) e = (c[--i] = c[i] + d[i] + e) / $n | 0, c[i] %= $n;
    for (e && (c.unshift(e), ++n), a = c.length; c[--a] == 0;) c.pop();
    return r.d = c, r.e = yy(c, n), ke ? Re(r, u, l) : r
};
ue.precision = ue.sd = function(r) {
    var e, t = this;
    if (r !== void 0 && r !== !!r && r !== 1 && r !== 0) throw Error($s + r);
    return t.d ? (e = dk(t.d), r && t.e + 1 > e && (e = t.e + 1)) : e = NaN, e
};
ue.round = function() {
    var r = this,
        e = r.constructor;
    return Re(new e(r), r.e + 1, e.rounding)
};
ue.sine = ue.sin = function() {
    var r, e, t = this,
        n = t.constructor;
    return t.isFinite() ? t.isZero() ? new n(t) : (r = n.precision, e = n.rounding, n.precision = r + Math.max(t.e, t.sd()) + De, n.rounding = 1, t = pie(n, pk(n, t)), n.precision = r, n.rounding = e, Re(Gi > 2 ? t.neg() : t, r, e, !0)) : new n(NaN)
};
ue.squareRoot = ue.sqrt = function() {
    var r, e, t, n, i, s, a = this,
        u = a.d,
        l = a.e,
        c = a.s,
        d = a.constructor;
    if (c !== 1 || !u || !u[0]) return new d(!c || c < 0 && (!u || u[0]) ? NaN : u ? a : 1 / 0);
    for (ke = !1, c = Math.sqrt(+a), c == 0 || c == 1 / 0 ? (e = mr(u), (e.length + l) % 2 == 0 && (e += "0"), c = Math.sqrt(e), l = Rr((l + 1) / 2) - (l < 0 || l % 2), c == 1 / 0 ? e = "5e" + l : (e = c.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + l), n = new d(e)) : n = new d(c.toString()), t = (l = d.precision) + 3;;)
        if (s = n, n = s.plus(Et(a, s, t + 2, 1)).times(.5), mr(s.d).slice(0, t) === (e = mr(n.d)).slice(0, t))
            if (e = e.slice(t - 3, t + 1), e == "9999" || !i && e == "4999") {
                if (!i && (Re(s, l + 1, 0), s.times(s).eq(a))) {
                    n = s;
                    break
                }
                t += 4, i = 1
            } else {
                (!+e || !+e.slice(1) && e.charAt(0) == "5") && (Re(n, l + 1, 1), r = !n.times(n).eq(a));
                break
            } return ke = !0, Re(n, l, d.rounding, r)
};
ue.tangent = ue.tan = function() {
    var r, e, t = this,
        n = t.constructor;
    return t.isFinite() ? t.isZero() ? new n(t) : (r = n.precision, e = n.rounding, n.precision = r + 10, n.rounding = 1, t = t.sin(), t.s = 1, t = Et(t, new n(1).minus(t.times(t)).sqrt(), r + 10, 0), n.precision = r, n.rounding = e, Re(Gi == 2 || Gi == 4 ? t.neg() : t, r, e, !0)) : new n(NaN)
};
ue.times = ue.mul = function(r) {
    var e, t, n, i, s, a, u, l, c, d = this,
        f = d.constructor,
        h = d.d,
        g = (r = new f(r)).d;
    if (r.s *= d.s, !h || !h[0] || !g || !g[0]) return new f(!r.s || h && !h[0] && !g || g && !g[0] && !h ? NaN : !h || !g ? r.s / 0 : r.s * 0);
    for (t = Rr(d.e / De) + Rr(r.e / De), l = h.length, c = g.length, l < c && (s = h, h = g, g = s, a = l, l = c, c = a), s = [], a = l + c, n = a; n--;) s.push(0);
    for (n = c; --n >= 0;) {
        for (e = 0, i = l + n; i > n;) u = s[i] + g[n] * h[i - n - 1] + e, s[i--] = u % $n | 0, e = u / $n | 0;
        s[i] = (s[i] + e) % $n | 0
    }
    for (; !s[--a];) s.pop();
    return e ? ++t : s.shift(), r.d = s, r.e = yy(s, t), ke ? Re(r, f.precision, f.rounding) : r
};
ue.toBinary = function(r, e) {
    return PI(this, 2, r, e)
};
ue.toDecimalPlaces = ue.toDP = function(r, e) {
    var t = this,
        n = t.constructor;
    return t = new n(t), r === void 0 ? t : (zr(r, 0, Ws), e === void 0 ? e = n.rounding : zr(e, 0, 8), Re(t, r + t.e + 1, e))
};
ue.toExponential = function(r, e) {
    var t, n = this,
        i = n.constructor;
    return r === void 0 ? t = oi(n, !0) : (zr(r, 0, Ws), e === void 0 ? e = i.rounding : zr(e, 0, 8), n = Re(new i(n), r + 1, e), t = oi(n, !0, r + 1)), n.isNeg() && !n.isZero() ? "-" + t : t
};
ue.toFixed = function(r, e) {
    var t, n, i = this,
        s = i.constructor;
    return r === void 0 ? t = oi(i) : (zr(r, 0, Ws), e === void 0 ? e = s.rounding : zr(e, 0, 8), n = Re(new s(i), r + i.e + 1, e), t = oi(n, !1, r + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + t : t
};
ue.toFraction = function(r) {
    var e, t, n, i, s, a, u, l, c, d, f, h, g = this,
        p = g.d,
        m = g.constructor;
    if (!p) return new m(g);
    if (c = t = new m(1), n = l = new m(0), e = new m(n), s = e.e = dk(p) - g.e - 1, a = s % De, e.d[0] = Jt(10, a < 0 ? De + a : a), r == null) r = s > 0 ? e : c;
    else {
        if (u = new m(r), !u.isInt() || u.lt(c)) throw Error($s + u);
        r = u.gt(e) ? s > 0 ? e : c : u
    }
    for (ke = !1, u = new m(mr(p)), d = m.precision, m.precision = s = p.length * De * 2; f = Et(u, e, 0, 1, 1), i = t.plus(f.times(n)), i.cmp(r) != 1;) t = n, n = i, i = c, c = l.plus(f.times(i)), l = i, i = e, e = u.minus(f.times(i)), u = i;
    return i = Et(r.minus(t), n, 0, 1, 1), l = l.plus(i.times(c)), t = t.plus(i.times(n)), l.s = c.s = g.s, h = Et(c, n, s, 1).minus(g).abs().cmp(Et(l, t, s, 1).minus(g).abs()) < 1 ? [c, n] : [l, t], m.precision = d, ke = !0, h
};
ue.toHexadecimal = ue.toHex = function(r, e) {
    return PI(this, 16, r, e)
};
ue.toNearest = function(r, e) {
    var t = this,
        n = t.constructor;
    if (t = new n(t), r == null) {
        if (!t.d) return t;
        r = new n(1), e = n.rounding
    } else {
        if (r = new n(r), e === void 0 ? e = n.rounding : zr(e, 0, 8), !t.d) return r.s ? t : r;
        if (!r.d) return r.s && (r.s = t.s), r
    }
    return r.d[0] ? (ke = !1, t = Et(t, r, 0, e, 1).times(r), ke = !0, Re(t)) : (r.s = t.s, t = r), t
};
ue.toNumber = function() {
    return +this
};
ue.toOctal = function(r, e) {
    return PI(this, 8, r, e)
};
ue.toPower = ue.pow = function(r) {
    var e, t, n, i, s, a, u = this,
        l = u.constructor,
        c = +(r = new l(r));
    if (!u.d || !r.d || !u.d[0] || !r.d[0]) return new l(Jt(+u, c));
    if (u = new l(u), u.eq(1)) return u;
    if (n = l.precision, s = l.rounding, r.eq(1)) return Re(u, n, s);
    if (e = Rr(r.e / De), e >= r.d.length - 1 && (t = c < 0 ? -c : c) <= die) return i = fk(l, u, t, n), r.s < 0 ? new l(1).div(i) : Re(i, n, s);
    if (a = u.s, a < 0) {
        if (e < r.d.length - 1) return new l(NaN);
        if ((r.d[e] & 1) == 0 && (a = 1), u.e == 0 && u.d[0] == 1 && u.d.length == 1) return u.s = a, u
    }
    return t = Jt(+u, c), e = t == 0 || !isFinite(t) ? Rr(c * (Math.log("0." + mr(u.d)) / Math.LN10 + u.e + 1)) : new l(t + "").e, e > l.maxE + 1 || e < l.minE - 1 ? new l(e > 0 ? a / 0 : 0) : (ke = !1, l.rounding = u.s = 1, t = Math.min(12, (e + "").length), i = LS(r.times(xs(u, n + t)), n), i.d && (i = Re(i, n + 5, 1), Zd(i.d, n, s) && (e = n + 10, i = Re(LS(r.times(xs(u, e + t)), e), e + 5, 1), +mr(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = Re(i, n + 1, 0)))), i.s = a, ke = !0, l.rounding = s, Re(i, n, s))
};
ue.toPrecision = function(r, e) {
    var t, n = this,
        i = n.constructor;
    return r === void 0 ? t = oi(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (zr(r, 1, Ws), e === void 0 ? e = i.rounding : zr(e, 0, 8), n = Re(new i(n), r, e), t = oi(n, r <= n.e || n.e <= i.toExpNeg, r)), n.isNeg() && !n.isZero() ? "-" + t : t
};
ue.toSignificantDigits = ue.toSD = function(r, e) {
    var t = this,
        n = t.constructor;
    return r === void 0 ? (r = n.precision, e = n.rounding) : (zr(r, 1, Ws), e === void 0 ? e = n.rounding : zr(e, 0, 8)), Re(new n(t), r, e)
};
ue.toString = function() {
    var r = this,
        e = r.constructor,
        t = oi(r, r.e <= e.toExpNeg || r.e >= e.toExpPos);
    return r.isNeg() && !r.isZero() ? "-" + t : t
};
ue.truncated = ue.trunc = function() {
    return Re(new this.constructor(this), this.e + 1, 1)
};
ue.valueOf = ue.toJSON = function() {
    var r = this,
        e = r.constructor,
        t = oi(r, r.e <= e.toExpNeg || r.e >= e.toExpPos);
    return r.isNeg() ? "-" + t : t
};

function mr(r) {
    var e, t, n, i = r.length - 1,
        s = "",
        a = r[0];
    if (i > 0) {
        for (s += a, e = 1; e < i; e++) n = r[e] + "", t = De - n.length, t && (s += Rs(t)), s += n;
        a = r[e], n = a + "", t = De - n.length, t && (s += Rs(t))
    } else if (a === 0) return "0";
    for (; a % 10 === 0;) a /= 10;
    return s + a
}
o(mr, "digitsToString");

function zr(r, e, t) {
    if (r !== ~~r || r < e || r > t) throw Error($s + r)
}
o(zr, "checkInt32");

function Zd(r, e, t, n) {
    var i, s, a, u;
    for (s = r[0]; s >= 10; s /= 10) --e;
    return --e < 0 ? (e += De, i = 0) : (i = Math.ceil((e + 1) / De), e %= De), s = Jt(10, De - e), u = r[i] % s | 0, n == null ? e < 3 ? (e == 0 ? u = u / 100 | 0 : e == 1 && (u = u / 10 | 0), a = t < 4 && u == 99999 || t > 3 && u == 49999 || u == 5e4 || u == 0) : a = (t < 4 && u + 1 == s || t > 3 && u + 1 == s / 2) && (r[i + 1] / s / 100 | 0) == Jt(10, e - 2) - 1 || (u == s / 2 || u == 0) && (r[i + 1] / s / 100 | 0) == 0 : e < 4 ? (e == 0 ? u = u / 1e3 | 0 : e == 1 ? u = u / 100 | 0 : e == 2 && (u = u / 10 | 0), a = (n || t < 4) && u == 9999 || !n && t > 3 && u == 4999) : a = ((n || t < 4) && u + 1 == s || !n && t > 3 && u + 1 == s / 2) && (r[i + 1] / s / 1e3 | 0) == Jt(10, e - 3) - 1, a
}
o(Zd, "checkRoundingDigits");

function gm(r, e, t) {
    for (var n, i = [0], s, a = 0, u = r.length; a < u;) {
        for (s = i.length; s--;) i[s] *= e;
        for (i[0] += PS.indexOf(r.charAt(a++)), n = 0; n < i.length; n++) i[n] > t - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / t | 0, i[n] %= t)
    }
    return i.reverse()
}
o(gm, "convertBase");

function hie(r, e) {
    var t, n, i;
    if (e.isZero()) return e;
    n = e.d.length, n < 32 ? (t = Math.ceil(n / 3), i = (1 / _y(4, t)).toString()) : (t = 16, i = "2.3283064365386962890625e-10"), r.precision += t, e = mc(r, 1, e.times(i), new r(1));
    for (var s = t; s--;) {
        var a = e.times(e);
        e = a.times(a).minus(a).times(8).plus(1)
    }
    return r.precision -= t, e
}
o(hie, "cosine");
var Et = (function() {
    function r(n, i, s) {
        var a, u = 0,
            l = n.length;
        for (n = n.slice(); l--;) a = n[l] * i + u, n[l] = a % s | 0, u = a / s | 0;
        return u && n.unshift(u), n
    }
    o(r, "multiplyInteger");

    function e(n, i, s, a) {
        var u, l;
        if (s != a) l = s > a ? 1 : -1;
        else
            for (u = l = 0; u < s; u++)
                if (n[u] != i[u]) {
                    l = n[u] > i[u] ? 1 : -1;
                    break
                } return l
    }
    o(e, "compare");

    function t(n, i, s, a) {
        for (var u = 0; s--;) n[s] -= u, u = n[s] < i[s] ? 1 : 0, n[s] = u * a + n[s] - i[s];
        for (; !n[0] && n.length > 1;) n.shift()
    }
    return o(t, "subtract"),
        function(n, i, s, a, u, l) {
            var c, d, f, h, g, p, m, w, T, E, b, R, L, V, z, j, Y, q, P, Z, oe = n.constructor,
                S = n.s == i.s ? 1 : -1,
                K = n.d,
                M = i.d;
            if (!K || !K[0] || !M || !M[0]) return new oe(!n.s || !i.s || (K ? M && K[0] == M[0] : !M) ? NaN : K && K[0] == 0 || !M ? S * 0 : S / 0);
            for (l ? (g = 1, d = n.e - i.e) : (l = $n, g = De, d = Rr(n.e / g) - Rr(i.e / g)), P = M.length, Y = K.length, T = new oe(S), E = T.d = [], f = 0; M[f] == (K[f] || 0); f++);
            if (M[f] > (K[f] || 0) && d--, s == null ? (V = s = oe.precision, a = oe.rounding) : u ? V = s + (n.e - i.e) + 1 : V = s, V < 0) E.push(1), p = !0;
            else {
                if (V = V / g + 2 | 0, f = 0, P == 1) {
                    for (h = 0, M = M[0], V++;
                        (f < Y || h) && V--; f++) z = h * l + (K[f] || 0), E[f] = z / M | 0, h = z % M | 0;
                    p = h || f < Y
                } else {
                    for (h = l / (M[0] + 1) | 0, h > 1 && (M = r(M, h, l), K = r(K, h, l), P = M.length, Y = K.length), j = P, b = K.slice(0, P), R = b.length; R < P;) b[R++] = 0;
                    Z = M.slice(), Z.unshift(0), q = M[0], M[1] >= l / 2 && ++q;
                    do h = 0, c = e(M, b, P, R), c < 0 ? (L = b[0], P != R && (L = L * l + (b[1] || 0)), h = L / q | 0, h > 1 ? (h >= l && (h = l - 1), m = r(M, h, l), w = m.length, R = b.length, c = e(m, b, w, R), c == 1 && (h--, t(m, P < w ? Z : M, w, l))) : (h == 0 && (c = h = 1), m = M.slice()), w = m.length, w < R && m.unshift(0), t(b, m, R, l), c == -1 && (R = b.length, c = e(M, b, P, R), c < 1 && (h++, t(b, P < R ? Z : M, R, l))), R = b.length) : c === 0 && (h++, b = [0]), E[f++] = h, c && b[0] ? b[R++] = K[j] || 0 : (b = [K[j]], R = 1); while ((j++ < Y || b[0] !== void 0) && V--);
                    p = b[0] !== void 0
                }
                E[0] || E.shift()
            }
            if (g == 1) T.e = d, ok = p;
            else {
                for (f = 1, h = E[0]; h >= 10; h /= 10) f++;
                T.e = f + d * g - 1, Re(T, u ? s + T.e + 1 : s, a, p)
            }
            return T
        }
})();

function Re(r, e, t, n) {
    var i, s, a, u, l, c, d, f, h, g = r.constructor;
    e: if (e != null) {
        if (f = r.d, !f) return r;
        for (i = 1, u = f[0]; u >= 10; u /= 10) i++;
        if (s = e - i, s < 0) s += De, a = e, d = f[h = 0], l = d / Jt(10, i - a - 1) % 10 | 0;
        else if (h = Math.ceil((s + 1) / De), u = f.length, h >= u)
            if (n) {
                for (; u++ <= h;) f.push(0);
                d = l = 0, i = 1, s %= De, a = s - De + 1
            } else break e;
        else {
            for (d = u = f[h], i = 1; u >= 10; u /= 10) i++;
            s %= De, a = s - De + i, l = a < 0 ? 0 : d / Jt(10, i - a - 1) % 10 | 0
        }
        if (n = n || e < 0 || f[h + 1] !== void 0 || (a < 0 ? d : d % Jt(10, i - a - 1)), c = t < 4 ? (l || n) && (t == 0 || t == (r.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (t == 4 || n || t == 6 && (s > 0 ? a > 0 ? d / Jt(10, i - a) : 0 : f[h - 1]) % 10 & 1 || t == (r.s < 0 ? 8 : 7)), e < 1 || !f[0]) return f.length = 0, c ? (e -= r.e + 1, f[0] = Jt(10, (De - e % De) % De), r.e = -e || 0) : f[0] = r.e = 0, r;
        if (s == 0 ? (f.length = h, u = 1, h--) : (f.length = h + 1, u = Jt(10, De - s), f[h] = a > 0 ? (d / Jt(10, i - a) % Jt(10, a) | 0) * u : 0), c)
            for (;;)
                if (h == 0) {
                    for (s = 1, a = f[0]; a >= 10; a /= 10) s++;
                    for (a = f[0] += u, u = 1; a >= 10; a /= 10) u++;
                    s != u && (r.e++, f[0] == $n && (f[0] = 1));
                    break
                } else {
                    if (f[h] += u, f[h] != $n) break;
                    f[h--] = 0, u = 1
                } for (s = f.length; f[--s] === 0;) f.pop()
    }
    return ke && (r.e > g.maxE ? (r.d = null, r.e = NaN) : r.e < g.minE && (r.e = 0, r.d = [0])), r
}
o(Re, "finalise");

function oi(r, e, t) {
    if (!r.isFinite()) return gk(r);
    var n, i = r.e,
        s = mr(r.d),
        a = s.length;
    return e ? (t && (n = t - a) > 0 ? s = s.charAt(0) + "." + s.slice(1) + Rs(n) : a > 1 && (s = s.charAt(0) + "." + s.slice(1)), s = s + (r.e < 0 ? "e" : "e+") + r.e) : i < 0 ? (s = "0." + Rs(-i - 1) + s, t && (n = t - a) > 0 && (s += Rs(n))) : i >= a ? (s += Rs(i + 1 - a), t && (n = t - i - 1) > 0 && (s = s + "." + Rs(n))) : ((n = i + 1) < a && (s = s.slice(0, n) + "." + s.slice(n)), t && (n = t - a) > 0 && (i + 1 === a && (s += "."), s += Rs(n))), s
}
o(oi, "finiteToString");

function yy(r, e) {
    var t = r[0];
    for (e *= De; t >= 10; t /= 10) e++;
    return e
}
o(yy, "getBase10Exponent");

function Gm(r, e, t) {
    if (e > fie) throw ke = !0, t && (r.precision = t), Error(ak);
    return Re(new r(jm), e, 1, !0)
}
o(Gm, "getLn10");

function si(r, e, t) {
    if (e > DS) throw Error(ak);
    return Re(new r(Wm), e, t, !0)
}
o(si, "getPi");

function dk(r) {
    var e = r.length - 1,
        t = e * De + 1;
    if (e = r[e], e) {
        for (; e % 10 == 0; e /= 10) t--;
        for (e = r[0]; e >= 10; e /= 10) t++
    }
    return t
}
o(dk, "getPrecision");

function Rs(r) {
    for (var e = ""; r--;) e += "0";
    return e
}
o(Rs, "getZeroString");

function fk(r, e, t, n) {
    var i, s = new r(1),
        a = Math.ceil(n / De + 4);
    for (ke = !1;;) {
        if (t % 2 && (s = s.times(e), Lx(s.d, a) && (i = !0)), t = Rr(t / 2), t === 0) {
            t = s.d.length - 1, i && s.d[t] === 0 && ++s.d[t];
            break
        }
        e = e.times(e), Lx(e.d, a)
    }
    return ke = !0, s
}
o(fk, "intPow");

function Dx(r) {
    return r.d[r.d.length - 1] & 1
}
o(Dx, "isOdd");

function hk(r, e, t) {
    for (var n, i, s = new r(e[0]), a = 0; ++a < e.length;) {
        if (i = new r(e[a]), !i.s) {
            s = i;
            break
        }
        n = s.cmp(i), (n === t || n === 0 && s.s === t) && (s = i)
    }
    return s
}
o(hk, "maxOrMin");

function LS(r, e) {
    var t, n, i, s, a, u, l, c = 0,
        d = 0,
        f = 0,
        h = r.constructor,
        g = h.rounding,
        p = h.precision;
    if (!r.d || !r.d[0] || r.e > 17) return new h(r.d ? r.d[0] ? r.s < 0 ? 0 : 1 / 0 : 1 : r.s ? r.s < 0 ? 0 : r : NaN);
    for (e == null ? (ke = !1, l = p) : l = e, u = new h(.03125); r.e > -2;) r = r.times(u), f += 5;
    for (n = Math.log(Jt(2, f)) / Math.LN10 * 2 + 5 | 0, l += n, t = s = a = new h(1), h.precision = l;;) {
        if (s = Re(s.times(r), l, 1), t = t.times(++d), u = a.plus(Et(s, t, l, 1)), mr(u.d).slice(0, l) === mr(a.d).slice(0, l)) {
            for (i = f; i--;) a = Re(a.times(a), l, 1);
            if (e == null)
                if (c < 3 && Zd(a.d, l - n, g, c)) h.precision = l += 10, t = s = u = new h(1), d = 0, c++;
                else return Re(a, h.precision = p, g, ke = !0);
            else return h.precision = p, a
        }
        a = u
    }
}
o(LS, "naturalExponential");

function xs(r, e) {
    var t, n, i, s, a, u, l, c, d, f, h, g = 1,
        p = 10,
        m = r,
        w = m.d,
        T = m.constructor,
        E = T.rounding,
        b = T.precision;
    if (m.s < 0 || !w || !w[0] || !m.e && w[0] == 1 && w.length == 1) return new T(w && !w[0] ? -1 / 0 : m.s != 1 ? NaN : w ? 0 : m);
    if (e == null ? (ke = !1, d = b) : d = e, T.precision = d += p, t = mr(w), n = t.charAt(0), Math.abs(s = m.e) < 15e14) {
        for (; n < 7 && n != 1 || n == 1 && t.charAt(1) > 3;) m = m.times(r), t = mr(m.d), n = t.charAt(0), g++;
        s = m.e, n > 1 ? (m = new T("0." + t), s++) : m = new T(n + "." + t.slice(1))
    } else return c = Gm(T, d + 2, b).times(s + ""), m = xs(new T(n + "." + t.slice(1)), d - p).plus(c), T.precision = b, e == null ? Re(m, b, E, ke = !0) : m;
    for (f = m, l = a = m = Et(m.minus(1), m.plus(1), d, 1), h = Re(m.times(m), d, 1), i = 3;;) {
        if (a = Re(a.times(h), d, 1), c = l.plus(Et(a, new T(i), d, 1)), mr(c.d).slice(0, d) === mr(l.d).slice(0, d))
            if (l = l.times(2), s !== 0 && (l = l.plus(Gm(T, d + 2, b).times(s + ""))), l = Et(l, new T(g), d, 1), e == null)
                if (Zd(l.d, d - p, E, u)) T.precision = d += p, c = a = m = Et(f.minus(1), f.plus(1), d, 1), h = Re(m.times(m), d, 1), i = u = 1;
                else return Re(l, T.precision = b, E, ke = !0);
        else return T.precision = b, l;
        l = c, i += 2
    }
}
o(xs, "naturalLogarithm");

function gk(r) {
    return String(r.s * r.s / 0)
}
o(gk, "nonFiniteToString");

function pm(r, e) {
    var t, n, i;
    for ((t = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (n = e.search(/e/i)) > 0 ? (t < 0 && (t = n), t += +e.slice(n + 1), e = e.substring(0, n)) : t < 0 && (t = e.length), n = 0; e.charCodeAt(n) === 48; n++);
    for (i = e.length; e.charCodeAt(i - 1) === 48; --i);
    if (e = e.slice(n, i), e) {
        if (i -= n, r.e = t = t - n - 1, r.d = [], n = (t + 1) % De, t < 0 && (n += De), n < i) {
            for (n && r.d.push(+e.slice(0, n)), i -= De; n < i;) r.d.push(+e.slice(n, n += De));
            e = e.slice(n), n = De - e.length
        } else n -= i;
        for (; n--;) e += "0";
        r.d.push(+e), ke && (r.e > r.constructor.maxE ? (r.d = null, r.e = NaN) : r.e < r.constructor.minE && (r.e = 0, r.d = [0]))
    } else r.e = 0, r.d = [0];
    return r
}
o(pm, "parseDecimal");

function gie(r, e) {
    var t, n, i, s, a, u, l, c, d;
    if (e.indexOf("_") > -1) {
        if (e = e.replace(/(\d)_(?=\d)/g, "$1"), lk.test(e)) return pm(r, e)
    } else if (e === "Infinity" || e === "NaN") return +e || (r.s = NaN), r.e = NaN, r.d = null, r;
    if (cie.test(e)) t = 16, e = e.toLowerCase();
    else if (uie.test(e)) t = 2;
    else if (lie.test(e)) t = 8;
    else throw Error($s + e);
    for (s = e.search(/p/i), s > 0 ? (l = +e.slice(s + 1), e = e.substring(2, s)) : e = e.slice(2), s = e.indexOf("."), a = s >= 0, n = r.constructor, a && (e = e.replace(".", ""), u = e.length, s = u - s, i = fk(n, new n(t), s, s * 2)), c = gm(e, t, $n), d = c.length - 1, s = d; c[s] === 0; --s) c.pop();
    return s < 0 ? new n(r.s * 0) : (r.e = yy(c, d), r.d = c, ke = !1, a && (r = Et(r, i, u * 4)), l && (r = r.times(Math.abs(l) < 54 ? Jt(2, l) : Yo.pow(2, l))), ke = !0, r)
}
o(gie, "parseOther");

function pie(r, e) {
    var t, n = e.d.length;
    if (n < 3) return e.isZero() ? e : mc(r, 2, e, e);
    t = 1.4 * Math.sqrt(n), t = t > 16 ? 16 : t | 0, e = e.times(1 / _y(5, t)), e = mc(r, 2, e, e);
    for (var i, s = new r(5), a = new r(16), u = new r(20); t--;) i = e.times(e), e = e.times(s.plus(i.times(a.times(i).minus(u))));
    return e
}
o(pie, "sine");

function mc(r, e, t, n, i) {
    var s, a, u, l, c = r.precision,
        d = Math.ceil(c / De);
    for (ke = !1, l = t.times(t), u = new r(n);;) {
        if (a = Et(u.times(l), new r(e++ * e++), c, 1), u = i ? n.plus(a) : n.minus(a), n = Et(a.times(l), new r(e++ * e++), c, 1), a = u.plus(n), a.d[d] !== void 0) {
            for (s = d; a.d[s] === u.d[s] && s--;);
            if (s == -1) break
        }
        s = u, u = n, n = a, a = s
    }
    return ke = !0, a.d.length = d + 1, a
}
o(mc, "taylorSeries");

function _y(r, e) {
    for (var t = r; --e;) t *= r;
    return t
}
o(_y, "tinyPow");

function pk(r, e) {
    var t, n = e.s < 0,
        i = si(r, r.precision, 1),
        s = i.times(.5);
    if (e = e.abs(), e.lte(s)) return Gi = n ? 4 : 1, e;
    if (t = e.divToInt(i), t.isZero()) Gi = n ? 3 : 2;
    else {
        if (e = e.minus(t.times(i)), e.lte(s)) return Gi = Dx(t) ? n ? 2 : 3 : n ? 4 : 1, e;
        Gi = Dx(t) ? n ? 1 : 4 : n ? 3 : 2
    }
    return e.minus(i).abs()
}
o(pk, "toLessThanHalfPi");

function PI(r, e, t, n) {
    var i, s, a, u, l, c, d, f, h, g = r.constructor,
        p = t !== void 0;
    if (p ? (zr(t, 1, Ws), n === void 0 ? n = g.rounding : zr(n, 0, 8)) : (t = g.precision, n = g.rounding), !r.isFinite()) d = gk(r);
    else {
        for (d = oi(r), a = d.indexOf("."), p ? (i = 2, e == 16 ? t = t * 4 - 3 : e == 8 && (t = t * 3 - 2)) : i = e, a >= 0 && (d = d.replace(".", ""), h = new g(1), h.e = d.length - a, h.d = gm(oi(h), 10, i), h.e = h.d.length), f = gm(d, 10, i), s = l = f.length; f[--l] == 0;) f.pop();
        if (!f[0]) d = p ? "0p+0" : "0";
        else {
            if (a < 0 ? s-- : (r = new g(r), r.d = f, r.e = s, r = Et(r, h, t, n, 0, i), f = r.d, s = r.e, c = ok), a = f[t], u = i / 2, c = c || f[t + 1] !== void 0, c = n < 4 ? (a !== void 0 || c) && (n === 0 || n === (r.s < 0 ? 3 : 2)) : a > u || a === u && (n === 4 || c || n === 6 && f[t - 1] & 1 || n === (r.s < 0 ? 8 : 7)), f.length = t, c)
                for (; ++f[--t] > i - 1;) f[t] = 0, t || (++s, f.unshift(1));
            for (l = f.length; !f[l - 1]; --l);
            for (a = 0, d = ""; a < l; a++) d += PS.charAt(f[a]);
            if (p) {
                if (l > 1)
                    if (e == 16 || e == 8) {
                        for (a = e == 16 ? 4 : 3, --l; l % a; l++) d += "0";
                        for (f = gm(d, i, e), l = f.length; !f[l - 1]; --l);
                        for (a = 1, d = "1."; a < l; a++) d += PS.charAt(f[a])
                    } else d = d.charAt(0) + "." + d.slice(1);
                d = d + (s < 0 ? "p" : "p+") + s
            } else if (s < 0) {
                for (; ++s;) d = "0" + d;
                d = "0." + d
            } else if (++s > l)
                for (s -= l; s--;) d += "0";
            else s < l && (d = d.slice(0, s) + "." + d.slice(s))
        }
        d = (e == 16 ? "0x" : e == 2 ? "0b" : e == 8 ? "0o" : "") + d
    }
    return r.s < 0 ? "-" + d : d
}
o(PI, "toStringBinary");

function Lx(r, e) {
    if (r.length > e) return r.length = e, !0
}
o(Lx, "truncate");

function mie(r) {
    return new this(r).abs()
}
o(mie, "abs$1");

function vie(r) {
    return new this(r).acos()
}
o(vie, "acos");

function yie(r) {
    return new this(r).acosh()
}
o(yie, "acosh");

function _ie(r, e) {
    return new this(r).plus(e)
}
o(_ie, "add");

function wie(r) {
    return new this(r).asin()
}
o(wie, "asin");

function Tie(r) {
    return new this(r).asinh()
}
o(Tie, "asinh");

function Eie(r) {
    return new this(r).atan()
}
o(Eie, "atan");

function bie(r) {
    return new this(r).atanh()
}
o(bie, "atanh");

function Sie(r, e) {
    r = new this(r), e = new this(e);
    var t, n = this.precision,
        i = this.rounding,
        s = n + 4;
    return !r.s || !e.s ? t = new this(NaN) : !r.d && !e.d ? (t = si(this, s, 1).times(e.s > 0 ? .25 : .75), t.s = r.s) : !e.d || r.isZero() ? (t = e.s < 0 ? si(this, n, i) : new this(0), t.s = r.s) : !r.d || e.isZero() ? (t = si(this, s, 1).times(.5), t.s = r.s) : e.s < 0 ? (this.precision = s, this.rounding = 1, t = this.atan(Et(r, e, s, 1)), e = si(this, s, 1), this.precision = n, this.rounding = i, t = r.s < 0 ? t.minus(e) : t.plus(e)) : t = this.atan(Et(r, e, s, 1)), t
}
o(Sie, "atan2");

function Aie(r) {
    return new this(r).cbrt()
}
o(Aie, "cbrt");

function Iie(r) {
    return Re(r = new this(r), r.e + 1, 2)
}
o(Iie, "ceil");

function Cie(r, e, t) {
    return new this(r).clamp(e, t)
}
o(Cie, "clamp");

function Rie(r) {
    if (!r || typeof r != "object") throw Error(vy + "Object expected");
    var e, t, n, i = r.defaults === !0,
        s = ["precision", 1, Ws, "rounding", 0, 8, "toExpNeg", -Eu, 0, "toExpPos", 0, Eu, "maxE", 0, Eu, "minE", -Eu, 0, "modulo", 0, 9];
    for (e = 0; e < s.length; e += 3)
        if (t = s[e], i && (this[t] = NS[t]), (n = r[t]) !== void 0)
            if (Rr(n) === n && n >= s[e + 1] && n <= s[e + 2]) this[t] = n;
            else throw Error($s + t + ": " + n);
    if (t = "crypto", i && (this[t] = NS[t]), (n = r[t]) !== void 0)
        if (n === !0 || n === !1 || n === 0 || n === 1)
            if (n)
                if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) this[t] = !0;
                else throw Error(uk);
    else this[t] = !1;
    else throw Error($s + t + ": " + n);
    return this
}
o(Rie, "config");

function Oie(r) {
    return new this(r).cos()
}
o(Oie, "cos");

function Pie(r) {
    return new this(r).cosh()
}
o(Pie, "cosh");

function mk(r) {
    var e, t, n;

    function i(s) {
        var a, u, l, c = this;
        if (!(c instanceof i)) return new i(s);
        if (c.constructor = i, xx(s)) {
            c.s = s.s, ke ? !s.d || s.e > i.maxE ? (c.e = NaN, c.d = null) : s.e < i.minE ? (c.e = 0, c.d = [0]) : (c.e = s.e, c.d = s.d.slice()) : (c.e = s.e, c.d = s.d ? s.d.slice() : s.d);
            return
        }
        if (l = typeof s, l === "number") {
            if (s === 0) {
                c.s = 1 / s < 0 ? -1 : 1, c.e = 0, c.d = [0];
                return
            }
            if (s < 0 ? (s = -s, c.s = -1) : c.s = 1, s === ~~s && s < 1e7) {
                for (a = 0, u = s; u >= 10; u /= 10) a++;
                ke ? a > i.maxE ? (c.e = NaN, c.d = null) : a < i.minE ? (c.e = 0, c.d = [0]) : (c.e = a, c.d = [s]) : (c.e = a, c.d = [s]);
                return
            }
            if (s * 0 !== 0) {
                s || (c.s = NaN), c.e = NaN, c.d = null;
                return
            }
            return pm(c, s.toString())
        }
        if (l === "string") return (u = s.charCodeAt(0)) === 45 ? (s = s.slice(1), c.s = -1) : (u === 43 && (s = s.slice(1)), c.s = 1), lk.test(s) ? pm(c, s) : gie(c, s);
        if (l === "bigint") return s < 0 ? (s = -s, c.s = -1) : c.s = 1, pm(c, s.toString());
        throw Error($s + s)
    }
    if (o(i, "Decimal"), i.prototype = ue, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = Rie, i.clone = mk, i.isDecimal = xx, i.abs = mie, i.acos = vie, i.acosh = yie, i.add = _ie, i.asin = wie, i.asinh = Tie, i.atan = Eie, i.atanh = bie, i.atan2 = Sie, i.cbrt = Aie, i.ceil = Iie, i.clamp = Cie, i.cos = Oie, i.cosh = Pie, i.div = Nie, i.exp = Die, i.floor = Lie, i.hypot = xie, i.ln = Uie, i.log = Mie, i.log10 = Fie, i.log2 = kie, i.max = $ie, i.min = Bie, i.mod = Vie, i.mul = Hie, i.pow = jie, i.random = Wie, i.round = Gie, i.sign = zie, i.sin = qie, i.sinh = Kie, i.sqrt = Yie, i.sub = Xie, i.sum = Jie, i.tan = Zie, i.tanh = Qie, i.trunc = ese, r === void 0 && (r = {}), r && r.defaults !== !0)
        for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], e = 0; e < n.length;) r.hasOwnProperty(t = n[e++]) || (r[t] = this[t]);
    return i.config(r), i
}
o(mk, "clone");

function Nie(r, e) {
    return new this(r).div(e)
}
o(Nie, "div");

function Die(r) {
    return new this(r).exp()
}
o(Die, "exp");

function Lie(r) {
    return Re(r = new this(r), r.e + 1, 3)
}
o(Lie, "floor");

function xie() {
    var r, e, t = new this(0);
    for (ke = !1, r = 0; r < arguments.length;)
        if (e = new this(arguments[r++]), e.d) t.d && (t = t.plus(e.times(e)));
        else {
            if (e.s) return ke = !0, new this(1 / 0);
            t = e
        } return ke = !0, t.sqrt()
}
o(xie, "hypot");

function xx(r) {
    return r instanceof Yo || r && r.toStringTag === ck || !1
}
o(xx, "isDecimalInstance");

function Uie(r) {
    return new this(r).ln()
}
o(Uie, "ln");

function Mie(r, e) {
    return new this(r).log(e)
}
o(Mie, "log");

function kie(r) {
    return new this(r).log(2)
}
o(kie, "log2");

function Fie(r) {
    return new this(r).log(10)
}
o(Fie, "log10");

function $ie() {
    return hk(this, arguments, -1)
}
o($ie, "max$1");

function Bie() {
    return hk(this, arguments, 1)
}
o(Bie, "min$1");

function Vie(r, e) {
    return new this(r).mod(e)
}
o(Vie, "mod$1");

function Hie(r, e) {
    return new this(r).mul(e)
}
o(Hie, "mul");

function jie(r, e) {
    return new this(r).pow(e)
}
o(jie, "pow");

function Wie(r) {
    var e, t, n, i, s = 0,
        a = new this(1),
        u = [];
    if (r === void 0 ? r = this.precision : zr(r, 1, Ws), n = Math.ceil(r / De), this.crypto)
        if (crypto.getRandomValues)
            for (e = crypto.getRandomValues(new Uint32Array(n)); s < n;) i = e[s], i >= 429e7 ? e[s] = crypto.getRandomValues(new Uint32Array(1))[0] : u[s++] = i % 1e7;
        else if (crypto.randomBytes) {
        for (e = crypto.randomBytes(n *= 4); s < n;) i = e[s] + (e[s + 1] << 8) + (e[s + 2] << 16) + ((e[s + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(e, s) : (u.push(i % 1e7), s += 4);
        s = n / 4
    } else throw Error(uk);
    else
        for (; s < n;) u[s++] = Math.random() * 1e7 | 0;
    for (n = u[--s], r %= De, n && r && (i = Jt(10, De - r), u[s] = (n / i | 0) * i); u[s] === 0; s--) u.pop();
    if (s < 0) t = 0, u = [0];
    else {
        for (t = -1; u[0] === 0; t -= De) u.shift();
        for (n = 1, i = u[0]; i >= 10; i /= 10) n++;
        n < De && (t -= De - n)
    }
    return a.e = t, a.d = u, a
}
o(Wie, "random");

function Gie(r) {
    return Re(r = new this(r), r.e + 1, this.rounding)
}
o(Gie, "round$1");

function zie(r) {
    return r = new this(r), r.d ? r.d[0] ? r.s : 0 * r.s : r.s || NaN
}
o(zie, "sign$1");

function qie(r) {
    return new this(r).sin()
}
o(qie, "sin");

function Kie(r) {
    return new this(r).sinh()
}
o(Kie, "sinh");

function Yie(r) {
    return new this(r).sqrt()
}
o(Yie, "sqrt$1");

function Xie(r, e) {
    return new this(r).sub(e)
}
o(Xie, "sub");

function Jie() {
    var r = 0,
        e = arguments,
        t = new this(e[r]);
    for (ke = !1; t.s && ++r < e.length;) t = t.plus(e[r]);
    return ke = !0, Re(t, this.precision, this.rounding)
}
o(Jie, "sum");

function Zie(r) {
    return new this(r).tan()
}
o(Zie, "tan");

function Qie(r) {
    return new this(r).tanh()
}
o(Qie, "tanh");

function ese(r) {
    return Re(r = new this(r), r.e + 1, 1)
}
o(ese, "trunc$1");
ue[Symbol.for("nodejs.util.inspect.custom")] = ue.toString;
ue[Symbol.toStringTag] = "Decimal";
var Yo = ue.constructor = mk(NS);
jm = new Yo(jm);
Wm = new Yo(Wm);

function tse(r) {
    rse(r)
}
o(tse, "applyToFormat");

function rse(r) {
    return r.prototype.toFormat = o(function(t, n, i) {
        if (!this.e && this.e !== 0) return this.toString();
        let s, a, u, l, c, d, f, h, g, p, m, w, T, E, b, R = this.format || {},
            L = this.constructor.format || {};
        if (t != c ? typeof t == "object" ? (i = t, t = c) : n != c ? typeof n == "object" ? (i = n, n = c) : typeof i != "object" && (i = {}) : i = {} : i = {}, s = this.toFixed(t, n).split("."), h = s[0], g = s[1], f = this.s < 0 ? h.slice(1) : h, d = f.length, p = i.decimalSeparator, p == c && (p = R.decimalSeparator, p == c && (p = L.decimalSeparator, p == c && (p = "."))), m = i.groupSeparator, m == c && (m = R.groupSeparator, m == c && (m = L.groupSeparator)), m && (w = i.groupSize, w == c && (w = R.groupSize, w == c && (w = L.groupSize, w == c && (w = 0))), T = i.secondaryGroupSize, T == c && (T = R.secondaryGroupSize, T == c && (T = L.secondaryGroupSize, T == c && (T = 0))), T ? (a = +T, u = +w, d -= u) : (a = +w, u = +T), a > 0 && d > 0)) {
            for (l = d % a || a, h = f.substr(0, l); l < d; l += a) h += m + f.substr(l, a);
            u > 0 && (h += m + f.slice(l)), this.s < 0 && (h = "-" + h)
        }
        return g ? (E = i.fractionGroupSeparator, E == c && (E = R.fractionGroupSeparator, E == c && (E = L.fractionGroupSeparator)), E && (b = i.fractionGroupSize, b == c && (b = R.fractionGroupSize, b == c && (b = L.fractionGroupSize, b == c && (b = 0))), b = +b, b && (g = g.replace(new RegExp("\\d{" + b + "}\\B", "g"), "$&" + E))), h + p + g) : h
    }, "toFormat"), r.format = {
        decimalSeparator: ".",
        groupSeparator: ",",
        groupSize: 3,
        secondaryGroupSize: 0,
        fractionGroupSeparator: "",
        fractionGroupSize: 0
    }, r
}
o(rse, "toFormat");
tse(Yo);
var Ux;
(function(r) {
    r[r.roundUp = 0] = "roundUp", r[r.roundDown = 1] = "roundDown", r[r.roundCeil = 2] = "roundCeil", r[r.roundFloor = 3] = "roundFloor", r[r.roundHalfUp = 4] = "roundHalfUp", r[r.roundHalfDown = 5] = "roundHalfDown", r[r.roundHalfEven = 6] = "roundHalfEven", r[r.roundHalfCeil = 7] = "roundHalfCeil", r[r.roundHalfFloor = 8] = "roundHalfFloor"
})(Ux || (Ux = {}));
var Id = Yo.config({
        precision: 30,
        toExpNeg: -1024,
        toExpPos: 1024,
        rounding: Yo.ROUND_HALF_EVEN
    }),
    et = class et {
        constructor(e) {
            this.add = this.plus, this.sub = this.minus, this.eq = this.equals, this.fastEquals = this.equals, this.lt = this.lessThan, this.lte = this.lessThanOrEqualTo, this.gt = this.greaterThan, this.gte = this.greaterThanOrEqualTo;
            let t = et.unwrapInputValue(e);
            this.internalValue = et.unsignedZeroOrValue(new Id(t))
        }
        static unsignedZeroOrValue(e) {
            return e.isZero() ? new Id(0) : e
        }
        static unwrapInputValue(e) {
            return typeof e == "string" || typeof e == "number" ? e : "internalValue" in e ? e.internalValue : e
        }
        static max(e, t) {
            let [n, i] = [et.unwrapInputValue(e), et.unwrapInputValue(t)], s = Id.max(n, i);
            return new et(s)
        }
        static min(e, t) {
            let [n, i] = [et.unwrapInputValue(e), et.unwrapInputValue(t)], s = Id.min(n, i);
            return new et(s)
        }
        abs() {
            let e = this.internalValue.abs();
            return new et(e)
        }
        neg() {
            let e = this.internalValue.neg();
            return new et(e)
        }
        sqrt() {
            let e = this.internalValue.sqrt();
            return new et(e)
        }
        trunc() {
            let e = this.internalValue.trunc();
            return new et(e)
        }
        round() {
            let e = this.internalValue.round();
            return new et(e)
        }
        isNaN() {
            return this.internalValue.isNaN()
        }
        isInteger() {
            return this.internalValue.isInteger()
        }
        decimalPlaces() {
            return this.internalValue.decimalPlaces()
        }
        plus(e) {
            let t = et.unwrapInputValue(e),
                n = this.internalValue.plus(t);
            return new et(n)
        }
        minus(e) {
            let t = et.unwrapInputValue(e),
                n = this.internalValue.minus(t);
            return new et(n)
        }
        times(e) {
            let t = et.unwrapInputValue(e),
                n = this.internalValue.times(t);
            return new et(n)
        }
        div(e) {
            let t = et.unwrapInputValue(e),
                n = this.internalValue.div(t);
            return new et(n)
        }
        pow(e) {
            let t = et.unwrapInputValue(e),
                n = this.internalValue.pow(t);
            return new et(n)
        }
        mod(e) {
            let t = et.unwrapInputValue(e),
                n = this.internalValue.mod(t);
            return new et(n)
        }
        equals(e) {
            let t = et.unwrapInputValue(e);
            return this.internalValue.equals(t)
        }
        lessThan(e) {
            let t = et.unwrapInputValue(e);
            return this.internalValue.lessThan(t)
        }
        lessThanOrEqualTo(e) {
            let t = et.unwrapInputValue(e);
            return this.internalValue.lessThanOrEqualTo(t)
        }
        greaterThan(e) {
            let t = et.unwrapInputValue(e);
            return this.internalValue.greaterThan(t)
        }
        greaterThanOrEqualTo(e) {
            let t = et.unwrapInputValue(e);
            return this.internalValue.greaterThanOrEqualTo(t)
        }
        toString() {
            return this.internalValue.toString()
        }
        toNumber() {
            return this.internalValue.toNumber()
        }
        valueOf() {
            return this.internalValue.valueOf()
        }
        toFixed(e) {
            return this.internalValue.toFixed(e)
        }
        toFormat() {
            return this.internalValue.toFormat(...arguments)
        }
        toDecimalPlaces(e) {
            let t = this.internalValue.toDecimalPlaces(e);
            return new et(t)
        }
    };
o(et, "Decimal");
var Be = et;
Be.rounding = Id.rounding;
Be.defaultValue = new Be(0);
var Mx = {};

function vk(r, e) {
    let t = Mx[r];
    if (typeof t != "undefined") return t;
    let n = r.replace(new RegExp("[" + e.join("") + "]", "gi"), "").substr(0, 1),
        i = [],
        s;
    for (s = 0; s < e.length; s++) i.push({
        index: r.toLowerCase().indexOf(e[s]),
        character: e[s],
        length: r.replace(new RegExp("[^" + e[s] + "]", "gi"), "").length
    });
    i.sort((u, l) => u.index < l.index ? -1 : 1);
    let a = {
        format: r,
        separator: n,
        parts: {},
        regExp: "^"
    };
    for (s = 0; s < i.length; s++) {
        let u = "";
        switch (i[s].character.toLowerCase()) {
            case "h":
            case "m":
            case "d":
                u = "1,2";
                break;
            case "s":
                a.regExp += "(?" + n, u = "1,2";
                break;
            default:
                u = i[s].length
        }
        s > 0 && (a.regExp += "\\" + n), a.regExp += "([0-9]{" + u + "})" + (i[s].character === "s" ? ")?" : ""), a.parts[i[s].character + "Index"] = s, a.parts[i[s].character + "Format"] = r.slice(i[s].index, i[s].index + i[s].length)
    }
    return a.regExp += "$", Mx[r] = a, a
}
o(vk, "parseComponentFormat");

function nse(r) {
    return vk(r, ["y", "m", "d"])
}
o(nse, "parseDateFormat");

function ise(r) {
    return vk(r, ["h", "m", "s"])
}
o(ise, "parseTimeFormat");
var en = class en {
    static getDayName(e) {
        return en.DayNames[e]
    }
    static getShortDayName(e) {
        return en.DayNames[e].slice(0, 3)
    }
    static getMonthName(e) {
        return en.MonthNames[e - 1]
    }
    static getShortMonthName(e) {
        return en.MonthNames[e - 1].slice(0, 3)
    }
    static get12HourNotation(e) {
        return e < 12 ? "AM" : "PM"
    }
    static getTimezoneInformationFull(e) {
        return e = -e, en.getTimezoneSignal(e) + en.padLeadingZeros(Math.floor(e / 60).toString(), 2) + ":" + en.padLeadingZeros(Math.floor(e % 60).toString(), 2)
    }
    static getTimezoneInformationHoursFull(e) {
        return e = -e, en.getTimezoneSignal(e) + en.padLeadingZeros(Math.floor(e / 60).toString(), 2)
    }
    static getTimezoneInformationHoursShort(e) {
        return e = -e, en.getTimezoneSignal(e) + Math.floor(e / 60)
    }
    static getTimezoneSignal(e) {
        return e < 0 ? "-" : "+"
    }
    static padLeadingZeros(e, t) {
        let n = e || "";
        for (; n.length < t;) n = "0" + n;
        return n
    }
    static removeTrailingZeros(e) {
        return (e || "").replace(/0+$/gm, "")
    }
    constructor(e, t) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : " ",
            i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
        this.dateFmt = nse(e), this.timeFmt = ise(t), this.dateTimeSep = n, this.tzInformation = i
    }
    get dateFormat() {
        return this.dateFmt.format
    }
    get timeFormat() {
        return this.timeFmt.format
    }
    get dateTimeFormat() {
        return this.dateFmt.format + this.dateTimeSeparator + this.timeFmt.format
    }
    getRegExpForDate() {
        return new RegExp(this.dateFmt.regExp, "i")
    }
    get yearIndexForDate() {
        return this.dateFmt.parts.yIndex
    }
    get monthIndexForDate() {
        return this.dateFmt.parts.mIndex
    }
    get dayIndexForDate() {
        return this.dateFmt.parts.dIndex
    }
    get yearFormatForDate() {
        return this.dateFmt.parts.yFormat
    }
    get monthFormatForDate() {
        return this.dateFmt.parts.mFormat
    }
    get dayFormatForDate() {
        return this.dateFmt.parts.dFormat
    }
    get dateSeparator() {
        return this.dateFmt.separator
    }
    getRegExpForTime() {
        return new RegExp(this.timeFmt.regExp, "i")
    }
    get hoursIndexForTime() {
        return this.timeFmt.parts.hIndex
    }
    get minutesIndexForTime() {
        return this.timeFmt.parts.mIndex
    }
    get secondsIndexForTime() {
        return this.timeFmt.parts.sIndex
    }
    get timeSeparator() {
        return this.timeFmt.separator
    }
    get dateTimeSeparator() {
        return this.dateTimeSep
    }
    getRegExpForDateTime() {
        return new RegExp(this.dateFmt.regExp.substring(0, this.dateFmt.regExp.length - 1) + this.dateTimeSeparator + this.timeFmt.regExp.substring(1, this.timeFmt.regExp.length - 1) + this.tzInformation + "$", "i")
    }
    get yearIndexForDateTime() {
        return this.dateFmt.parts.yIndex
    }
    get monthIndexForDateTime() {
        return this.dateFmt.parts.mIndex
    }
    get dayIndexForDateTime() {
        return this.dateFmt.parts.dIndex
    }
    get hoursIndexForDateTime() {
        return this.timeFmt.parts.hIndex + 3
    }
    get hoursFormatForTime() {
        return this.timeFmt.parts.hFormat
    }
    get minutesFormatForTime() {
        return this.timeFmt.parts.mFormat
    }
    get secondsFormatForTime() {
        return this.timeFmt.parts.sFormat
    }
    get minutesIndexForDateTime() {
        return this.timeFmt.parts.mIndex + 3
    }
    get secondsIndexForDateTime() {
        return this.timeFmt.parts.sIndex + 3
    }
};
o(en, "DateTimeFormatInfo");
var ht = en;
ht.DayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
ht.MonthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
var dC = class dC {
    constructor(e, t) {
        this.decimalSep = e, this.groupSep = t, this.generateFormatRegExps(e, t)
    }
    generateFormatRegExps(e, t) {
        let n = "\\" + e,
            i = "(([0-9]{1,3}(" + (t ? "\\" + t : "") + "[0-9]{3})*)|([0-9]+))",
            s = "[0-9]+";
        this.integerFmtRegExp = "^[-]?" + i + "$", this.decimalFmtRegExp = "^[-]?((" + i + "(" + n + "(" + s + ")?)?)|((" + i + ")?" + n + s + "))$"
    }
    get decimalSeparator() {
        return this.decimalSep
    }
    get groupSeparator() {
        return this.groupSep
    }
    getRegExpForInteger() {
        return new RegExp(this.integerFmtRegExp, "i")
    }
    getRegExpForDecimal() {
        return new RegExp(this.decimalFmtRegExp, "i")
    }
    getRegExpForJSNumber() {
        return new RegExp("^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$", "i")
    }
};
o(dC, "NumberFormatInfo");
var zm = dC,
    fC = class fC {
        constructor(e, t) {
            this.defaultDateTimeFormats = [new ht("yyyy-MM-dd", "HH:mm:ss"), new ht("yyyy-MM-dd", "HH:mm:ss"), new ht("yyyy/MM/dd", "HH:mm:ss"), new ht("yyyy.MM.dd", "HH:mm:ss")], this.defaultNumberFmt = t, this.currentNumberFmt = t, this.defaultDateTimeFormats[0] = e
        }
        get defaultDateTimeFormat() {
            return this.defaultDateTimeFormats[0]
        }
        get dateTimeFormats() {
            return this.defaultDateTimeFormats
        }
        set dateTimeFormat(e) {
            this.defaultDateTimeFormats[0] = e
        }
        get defaultNumberFormat() {
            return this.defaultNumberFmt
        }
        get numberFormat() {
            return this.currentNumberFmt
        }
        set numberFormat(e) {
            this.currentNumberFmt = e
        }
    };
o(fC, "ApplicationFormatInfo");
var qm = fC,
    sse = Object.freeze({
        __proto__: null,
        ApplicationFormatInfo: qm,
        DateTimeFormatInfo: ht,
        NumberFormatInfo: zm
    });

function As(r) {
    let e = r.length,
        t = new Array(e);
    for (; e-- > 0;) t[e] = r[e];
    return t
}
o(As, "copyArray");

function yk(r) {
    var i;
    let e = Object.keys(r);

    function t(s) {
        e.forEach(a => {
            this[a] = s[a]
        })
    }
    o(t, "CloneOfRecordProps");
    let n = (i = class {
        constructor(a) {
            this._ = a != null ? a : r
        }
        get(a) {
            return this._[a]
        }
        set(a, u) {
            let l = new t(this._);
            return l[a] = u, new n(l)
        }
        toJS() {
            let a = {};
            return e.forEach(u => {
                a[u] = this._[u]
            }), a
        }
    }, o(i, "NewImmutableRecord"), i);
    return n
}
o(yk, "defineRecordClass");
var Po = 128,
    jr = class jr {
        constructor(e, t) {
            if (typeof t != "undefined") this._values = e, this._lengths = t;
            else if (typeof e != "undefined") {
                let n = jr.fromJS(e);
                this._values = n._values, this._lengths = n._lengths
            } else this._values = [], this._lengths = []
        }
        clear() {
            return new jr
        }
        clone() {
            return this
        }
        count() {
            let e = 0,
                t = this._lengths.length;
            for (; t-- > 0;) e += this._lengths[t];
            return e
        }
        isEmpty() {
            return this._lengths.length === 0
        }
        get(e) {
            let t = 0,
                n = e,
                i = this._lengths.length;
            for (; t < i && e >= 0;) {
                if (n < this._lengths[t]) return this._values[t][n];
                n -= this._lengths[t], t++
            }
        }
        set(e, t) {
            let n = 0,
                i = e,
                s = As(this._values),
                a = this._lengths,
                u = a.length;
            for (; n < u && e >= 0;) {
                if (i < this._lengths[n]) return s[n] = As(s[n]), s[n][i] = t, new jr(s, a);
                i -= a[n], n++
            }
        }
        push(e) {
            let t = this._values.length - 1,
                n, i;
            t < 0 ? (t = 0, n = [
                []
            ], i = [0]) : (n = As(this._values), i = As(this._lengths));
            let s = n[t];
            if (s.length < Po) {
                let a = s.length,
                    u = new Array(a + 1),
                    l = a;
                for (; l-- > 0;) u[l] = s[l];
                u[a] = e, n[t] = u, i[t]++
            } else {
                let a = [e];
                n.push(a), i.push(1)
            }
            return new jr(n, i)
        }
        insert(e, t) {
            let n = 0,
                i = e,
                s = As(this._values),
                a = As(this._lengths),
                u = a.length;
            for (; n < u && i >= 0;) {
                if (i < a[n]) {
                    if (a[n] === Po) {
                        let g = Po / 2 | 0,
                            p = Po - g;
                        a.splice(n, 1, g, p);
                        let m = new Array(g),
                            w = new Array(p);
                        for (let T = 0; T < g; T++) m[T] = s[n][T];
                        for (let T = 0, E = g; T < p;) w[T++] = s[n][E++];
                        s.splice(n, 1, m, w), u++;
                        continue
                    }
                    let l = 0,
                        c = a[n],
                        d = new Array(c + 1),
                        f = s[n];
                    for (; l < i; l++) d[l] = f[l];
                    d[i] = t;
                    let h = l + 1;
                    for (; l < c;) d[h++] = f[l++];
                    return a[n]++, s[n] = d, new jr(s, a)
                }
                i -= a[n], n++
            }
            return a.push(1), s.push([t]), new jr(s, a)
        }
        remove(e) {
            let t = 0,
                n = e,
                i = As(this._lengths),
                s = As(this._values),
                a = i.length;
            for (; t < a && n >= 0;) {
                if (n < i[t]) {
                    let u = --i[t],
                        l = new Array(u),
                        c = 0,
                        d = 0;
                    for (; c < u;) c === n && d++, l[c++] = s[t][d++];
                    return s[t] = l, i[t] === 0 && (i.splice(t, 1), s.splice(t, 1)), new jr(s, i)
                }
                n -= i[t], t++
            }
        }
        reduce(e, t) {
            for (let n = 0; n < this._values.length; n++) {
                let i = this._values[n];
                for (let s = 0; s < i.length; s++) t = e(t, i[s])
            }
            return t
        }
        map(e) {
            let t = new Array(this.count()),
                n = 0;
            for (let i = 0; i < this._values.length; i++) {
                let s = this._values[i];
                for (let a = 0; a < s.length; a++) t[n] = e(s[a], n), n++
            }
            return t
        }
        pushAll(e) {
            if (e.length === 0) return this;
            let t = new jr(e),
                n = this._values.concat(t._values),
                i = this._lengths.concat(t._lengths);
            return new jr(n, i)
        }
        forEach(e) {
            for (let t = 0; t < this._values.length; t++) {
                let n = this._values[t];
                for (let i = 0; i < n.length; i++) e(n[i])
            }
        }
        addFromOther(e) {
            if (e.count() === 0) return this;
            if (this._values.length === 0) return e;
            let t = new Array(this._lengths.length + e._lengths.length),
                n = new Array(this._values.length + e._values.length),
                i = 0,
                s = 0;
            for (; i < this._values.length;) n[i] = this._values[i], t[i] = this._lengths[i], i++;
            for (; s < e._values.length;) n[i] = e._values[s], t[i] = e._lengths[s], i++, s++;
            return new jr(n, t)
        }
        static fromJS(e) {
            let t = Math.ceil(e.length / Po) | 0,
                n = new Array(t),
                i = new Array(t),
                s = 0,
                a = 0;
            for (let u = 0; u < t; u++) {
                a = e.length - s;
                let l = a > Po ? Po : a;
                i[u] = l, n[u] = new Array(l);
                for (let c = 0; c < l; c++) n[u][c] = e[s + c];
                s += l
            }
            return new jr(n, i)
        }
    };
o(jr, "ImmutableList");
var Hi = jr,
    ose = Object.freeze({
        __proto__: null,
        ImmutableList: Hi,
        defineRecordClass: yk
    }),
    Ne, Xt, NI, DI, Un, hC = class hC {
        constructor(e) {
            Xt.set(this, void 0), this.neg = this.negate, this.eq = this.equals, this.fastEquals = this.equals, this.lt = this.lessThan, this.lte = this.lessThanOrEqual, this.gt = this.greaterThan, this.gte = this.greaterThanOrEqual;
            let t;
            try {
                typeof e == "bigint" ? t = e : typeof e == "number" ? t = BigInt(Math.trunc(e)) : t = BigInt(e)
            } catch (n) {
                t = BigInt(0)
            }
            if (t < ie(Ne, Ne, "f", NI) || t > ie(Ne, Ne, "f", DI)) throw new Error("Value is out of bounds for a 64-bit signed integer");
            dt(this, Xt, t, "f")
        }
        static fromNumber(e) {
            return new Ne(e)
        }
        static fromString(e) {
            return new Ne(e)
        }
        static fromValue(e) {
            return new Ne(e instanceof Ne ? ie(e, Xt, "f") : e)
        }
        negate() {
            return new Ne(-ie(this, Xt, "f"))
        }
        add(e) {
            let t = ie(Ne, Ne, "m", Un).call(Ne, e);
            return new Ne(ie(this, Xt, "f") + BigInt(t))
        }
        sub(e) {
            let t = ie(Ne, Ne, "m", Un).call(Ne, e);
            return new Ne(ie(this, Xt, "f") - BigInt(t))
        }
        mul(e) {
            let t = ie(Ne, Ne, "m", Un).call(Ne, e);
            return new Ne(ie(this, Xt, "f") * BigInt(t))
        }
        div(e) {
            let t = ie(Ne, Ne, "m", Un).call(Ne, e);
            return new Ne(ie(this, Xt, "f") / BigInt(t))
        }
        and(e) {
            let t = ie(Ne, Ne, "m", Un).call(Ne, e);
            return new Ne(ie(this, Xt, "f") & BigInt(t))
        }
        equals(e) {
            let t = ie(Ne, Ne, "m", Un).call(Ne, e);
            return ie(this, Xt, "f") === BigInt(t)
        }
        lessThan(e) {
            let t = ie(Ne, Ne, "m", Un).call(Ne, e);
            return ie(this, Xt, "f") < BigInt(t)
        }
        lessThanOrEqual(e) {
            let t = ie(Ne, Ne, "m", Un).call(Ne, e);
            return ie(this, Xt, "f") <= BigInt(t)
        }
        greaterThan(e) {
            let t = ie(Ne, Ne, "m", Un).call(Ne, e);
            return ie(this, Xt, "f") > BigInt(t)
        }
        greaterThanOrEqual(e) {
            let t = ie(Ne, Ne, "m", Un).call(Ne, e);
            return ie(this, Xt, "f") >= BigInt(t)
        }
        toNumber() {
            return Number(ie(this, Xt, "f"))
        }
        toString() {
            return ie(this, Xt, "f").toString()
        }
        valueOf() {
            return ie(this, Xt, "f").valueOf()
        }
    };
o(hC, "LongInteger");
var bt = hC;
Ne = bt, Xt = new WeakMap, Un = o(function(e) {
    return e instanceof Ne ? ie(e, Xt, "f") : e
}, "_LongInteger_unwrapInputValue");
NI = {
    value: BigInt("-9223372036854775808")
};
DI = {
    value: BigInt("9223372036854775807")
};
bt.defaultValue = new Ne(0);
bt.MIN_VALUE = new Ne(ie(Ne, Ne, "f", NI));
bt.MAX_VALUE = new Ne(ie(Ne, Ne, "f", DI));
var LI = "outsystems-";

function _k(r, e) {
    if (e = e != null ? e : LI, typeof r != "object" || r === null) return;
    let t = {};
    for (let [n, i] of Object.entries(r)) t[e + n] = i;
    return t
}
o(_k, "buildCustomHeaders");

function wk(r, e) {
    e = e != null ? e : LI;
    let t = e.toLowerCase();
    if (typeof r != "object" || r === null) return {};
    let n = {};
    for (let [i, s] of Object.entries(r)) i.toLowerCase().startsWith(t) && (n[i.substring(e.length)] = s);
    return n
}
o(wk, "extractCustomHeaders");
var ase = Object.freeze({
        __proto__: null,
        buildCustomHeaders: _k,
        extractCustomHeaders: wk
    }),
    vc = "Communication",
    use = "http.status_code",
    Tk = 250,
    wy = o(r => k(void 0, [r], void 0, function(e) {
        let {
            url: t,
            params: n,
            headers: i,
            responseType: s,
            useLocaleInfo: a,
            timeout: u,
            timeoutHandler: l,
            baseURL: c,
            httpClient: d = ge.resolve(J.HttpClient)
        } = e;
        return (function*() {
            if (!d) throw new Error("Could not resolve the http client instance.");
            try {
                return yield d.get({
                    url: t,
                    params: n,
                    headers: i,
                    responseType: s,
                    useLocaleInfo: a,
                    timeout: u,
                    timeoutHandler: l,
                    baseURL: c
                })
            } catch (f) {
                throw Ak(f)
            }
        })()
    }), "get"),
    cse = o(r => k(void 0, [r], void 0, function(e) {
        let {
            url: t,
            params: n,
            headers: i,
            useLocaleInfo: s,
            timeout: a,
            timeoutHandler: u,
            baseURL: l,
            httpClient: c = ge.resolve(J.HttpClient)
        } = e;
        return (function*() {
            if (!c) throw new Error("Could not resolve the http client instance.");
            return c.getResponseUrl({
                url: t,
                params: n,
                headers: i,
                useLocaleInfo: s,
                timeout: a,
                timeoutHandler: u,
                baseURL: l
            })
        })()
    }), "getResponseUrl"),
    Ek = o(r => lse(r) || Sk(r), "isWellFormedResponsePayload"),
    bk = o(r => r !== null && typeof r == "object" && typeof r.hasApiVersionChanged == "boolean" && typeof r.hasModuleVersionChanged == "boolean", "isVersionInfo"),
    lse = o(r => r !== null && typeof r == "object" && (!r.hasOwnProperty("exception") || r.exception === void 0) && typeof r.clientSettingsHash == "string" && typeof r.shouldRefreshToken == "boolean" && bk(r.versionInfo), "isSuccessResponsePayload"),
    Sk = o(r => r !== null && typeof r == "object" && typeof r.exception == "object" && typeof r.clientSettingsHash == "string" && (typeof r.status == "number" || typeof r.status == "undefined") && typeof r.shouldRefreshToken == "boolean" && bk(r.versionInfo), "isErrorResponsePayload"),
    dse = o(r => {
        let e = [];
        if (Ek(r) && !r.versionInfo.hasModuleVersionChanged && r.versionInfo.hasApiVersionChanged) {
            let t = "The application was unable to make a request to the server - the API version changed, but the module version did not.";
            e.push({
                clientMessage: t,
                internalMessage: t
            })
        }
        return e
    }, "validateResponsePayload"),
    xI = o(r => k(void 0, [r], void 0, function(e) {
        let {
            url: t,
            payload: n,
            params: i,
            headers: s,
            contentType: a,
            timeout: u,
            timeoutHandler: l,
            useLocaleInfo: c,
            baseURL: d,
            abortCommand: f,
            responseHandler: h,
            refreshAuthTokens: g = UM,
            httpClient: p = ge.resolve(J.HttpClient),
            lifecycleEventsManager: m = ge.resolve(J.LifecycleEventsManager),
            actionOrAggregateName: w
        } = e;
        return (function*() {
            if (!p) throw new Error("Could not resolve the http client instance.");
            let T = _k(s),
                E = Object.assign(Object.assign({}, T), {
                    "content-type": "application/json; charset=UTF-8"
                }),
                b = [];
            try {
                let R = yield p.post({
                    url: t,
                    payload: n,
                    params: i,
                    headers: E,
                    contentType: a != null ? a : ir.Json,
                    timeout: u,
                    timeoutHandler: l,
                    useLocaleInfo: c,
                    baseURL: d,
                    abortCommand: f,
                    responseHandler: fse(h)
                });
                if (R != null && R.shouldRefreshToken && (tn(vc, "Refresh Tokens initiated: Response from the server indicates that tokens should be refreshed.", Pe.Internal), yield g()), b = dse(R), Ek(R) && gse(R, L => m == null ? void 0 : m.onNewVersion(L)), Sk(R)) throw pse(R, w);
                return R == null ? void 0 : R.data
            } catch (R) {
                throw Ak(R)
            } finally {
                for (let {
                        clientMessage: R,
                        internalMessage: L
                    } of b) xc({
                    category: vc,
                    clientMessage: R,
                    internalMessage: L,
                    errorCode: He.Communication_Internal_Server_Error
                })
            }
        })()
    }), "post"),
    fse = o(r => {
        if (typeof r == "function") return e => {
            let {
                data: t,
                responseHeaders: n
            } = e, i = wk(n);
            r({
                data: t,
                responseHeaders: i
            })
        }
    }, "buildResponseHandler"),
    hse = o(r => r && Object.values(He).includes(r), "isCommunicationError"),
    Ak = o(r => {
        var e, t, n, i, s;
        if (r.errorCode === "OS-CLRT-40103") throw Ue(vc, "User is not logged in", r.errorCode, r, Pe.Internal), new pe.SecurityException("Not authorized", qi(r));
        if (hse(r.errorCode)) {
            let a = (t = (e = r.response) === null || e === void 0 ? void 0 : e.exception) !== null && t !== void 0 ? t : r;
            throw new pe.CommunicationException(`CommunicationException: ${(n=a.message)!==null&&n!==void 0?n:r.message}`, qi(a), r.errorCode, r.category)
        }
        return r.errorCode = (i = r.errorCode) !== null && i !== void 0 ? i : He.Communication_Default, r.category = (s = r.category) !== null && s !== void 0 ? s : vc, r
    }, "mappedException"),
    gse = o((r, e) => {
        if (r.versionInfo.hasModuleVersionChanged) {
            if (r.versionInfo.hasApiVersionChanged) throw e(!0), new pe.ViewHasChangedException("View has changed.");
            e(!1)
        }
    }, "handleVersionInfoChanges"),
    pse = o((r, e) => {
        var t, n;
        let i = FU(r.exception),
            s = `Post request ${e?`issued by '${e}' `:""}failed: ${i.message}`,
            a = "Post request failed",
            u = {};
        return r.status && (u[use] = r.status), r.status === Tk ? Ue(vc, a, (t = i.errorCode) !== null && t !== void 0 ? t : He.Communication_Default, void 0, Pe.Internal, u) : xc({
            category: vc,
            clientMessage: s,
            internalMessage: a,
            errorCode: (n = i.errorCode) !== null && n !== void 0 ? n : He.Communication_Default,
            errorObj: i,
            attributes: u
        }), i
    }, "processExceptionFromResponse"),
    mse = Object.freeze({
        __proto__: null,
        SCREEN_SERVICES_EXCEPTION_HTTP_STATUS_CODE: Tk,
        get: wy,
        getResponseUrl: cse,
        post: xI
    }),
    im = "__cache";

function Lr(r, e) {
    return r == null ? e : r
}
o(Lr, "coalesce");
var _;
(function(r) {
    r[r.Integer = 0] = "Integer", r[r.LongInteger = 1] = "LongInteger", r[r.Decimal = 2] = "Decimal", r[r.Currency = 3] = "Currency", r[r.Text = 4] = "Text", r[r.PhoneNumber = 5] = "PhoneNumber", r[r.Email = 6] = "Email", r[r.Boolean = 7] = "Boolean", r[r.Date = 8] = "Date", r[r.DateTime = 9] = "DateTime", r[r.Time = 10] = "Time", r[r.Record = 11] = "Record", r[r.RecordList = 12] = "RecordList", r[r.BinaryData = 13] = "BinaryData", r[r.Object = 14] = "Object"
})(_ || (_ = {}));
var UI = o(r => {
        switch (r) {
            case _.Integer:
                return "Integer";
            case _.LongInteger:
                return "Long Integer";
            case _.Decimal:
                return "Decimal";
            case _.Currency:
                return "Currency";
            case _.Text:
                return "Text";
            case _.PhoneNumber:
                return "Phone Number";
            case _.Email:
                return "Email";
            case _.Boolean:
                return "Boolean";
            case _.Date:
                return "Date";
            case _.DateTime:
                return "Date Time";
            case _.Time:
                return "Time";
            case _.Record:
                return "Record";
            case _.RecordList:
                return "List";
            case _.BinaryData:
                return "Binary Data";
            case _.Object:
                return "Object";
            default:
                return `Unknown: ${r}`
        }
    }, "mapDataTypeToName"),
    Su = class Su {
        constructor(e, t, n) {
            this._url = t, this.getOfflineContent = n, this._cachedBlob = null, this.authenticatedUrlsRegex = [/screenservices\/.*\/_BinaryContent\/.*/], typeof Blob != "undefined" && e instanceof Blob ? (this._cachedBlob = e, this.getOfflineContent = () => this._content ? Promise.resolve(this._content) : Su.blobToBase64(this._cachedBlob)) : this._content = e || null
        }
        get url() {
            return this._url
        }
        set url(e) {
            this._url = e, this.clearCachedBlob()
        }
        get cachedBlob() {
            return this._cachedBlob
        }
        get content() {
            return this._content
        }
        set content(e) {
            this._content = e, this.clearCachedBlob()
        }
        needsAuthentication() {
            var e;
            let t = (e = this._url) !== null && e !== void 0 ? e : "";
            return this.authenticatedUrlsRegex.some(n => n.test(t))
        }
        loadBlobData() {
            return k(this, void 0, void 0, function*() {
                var e;
                let t = yield wy({
                    url: (e = this._url) !== null && e !== void 0 ? e : "",
                    responseType: "blob"
                });
                return t != null ? t : new Blob
            })
        }
        loadContent() {
            return k(this, void 0, void 0, function*() {
                return this.needsAuthentication() ? this.loadBlobData().then(e => (this._cachedBlob = e, Promise.resolve(this))) : this.getOfflineContent ? this.getOfflineContent().then(e => (this.content = e, Promise.resolve(this))) : _n(() => this)
            })
        }
        hasContent() {
            return !!(this._url && !this.needsAuthentication() || this._content)
        }
        fastEquals(e) {
            return e && this.constructor === e.constructor && this._url === e._url && this._content === e._content && (!!this.getOfflineContent && !!e.getOfflineContent || !this.getOfflineContent && !e.getOfflineContent)
        }
        base64toHex(e) {
            let t = atob(e),
                n = "";
            for (let i = 0; i < t.length; i++) {
                let s = t.charCodeAt(i).toString(16);
                n += s.length === 2 ? s : "0" + s
            }
            return n
        }
        getContentType() {
            if (this._content) {
                let e = this.base64toHex(this._content.substr(0, 16));
                return e.substr(0, 8) === "00000100" ? "image/x-icon" : e.substr(0, 8) === "ffd8ffdb" || e.substr(0, 8) === "ffd8ffe0" || e.substr(0, 8) === "ffd8ffe1" ? "image/jpeg" : e.substr(0, 8) === "49492a00" || e.substr(0, 8) === "4d4d002a" ? "image/tiff" : e.substr(0, 4) === "424d" ? "image/bmp" : e.substr(0, 6) === "474946" ? "image/gif" : e.substr(0, 8) === "89504e47" ? "image/png" : "application/octet-stream"
            } else return null
        }
        toDataURI() {
            return this._content ? `data:${this.getContentType()};base64,${this._content}` : null
        }
        toBlob() {
            var e;
            if (!this._cachedBlob && this._content) {
                let t = (e = this.getContentType()) !== null && e !== void 0 ? e : void 0;
                this._cachedBlob = Su.base64toBlob(this._content, t)
            }
            return this._cachedBlob
        }
        toArrayBuffer() {
            return this._content ? Su.base64ToArrayBuffer(this._content) : null
        }
        get length() {
            let e = this.toBlob();
            return e ? e.size : 0
        }
        static blobToBase64(e) {
            return new Promise((t, n) => {
                let i = new FileReader;
                i.readAsDataURL(e), i.onload = () => {
                    let s = i.result;
                    t(s.substring(s.indexOf(",") + 1))
                }, i.onerror = () => {
                    n(i.error)
                }
            })
        }
        static base64toBlob(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "",
                n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 512,
                i = atob((e || "").replace(/\s/g, "")),
                s = [];
            for (let a = 0; a < i.length; a += n) {
                let u = i.slice(a, a + n),
                    l = new Array(u.length);
                for (let d = 0; d < u.length; d++) l[d] = u.charCodeAt(d);
                let c = new Uint8Array(l);
                s.push(c)
            }
            return new Blob(s, {
                type: t
            })
        }
        static base64ToArrayBuffer(e) {
            return Uint8Array.from(atob(e), t => t.charCodeAt(0)).buffer
        }
        clearCachedBlob() {
            this._cachedBlob = null
        }
        requestUrl() {
            return k(this, arguments, void 0, function() {
                var e = this;
                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : () => ge.resolve(J.BinaryUrlCache);
                return (function*() {
                    return e._url && !e.needsAuthentication() ? e._url : (yield e.loadContent(), !e.hasContent() && !e.cachedBlob ? null : t().getUrl(e))
                })()
            })
        }
        releaseUrl() {
            (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : () => ge.resolve(J.BinaryUrlCache))().releaseUrl(this)
        }
    };
o(Su, "BinaryData");
var Or = Su;
Or.defaultValue = new Or;
var Ot = class Ot {
    static get defaultValue() {
        return Ot.defaultValueField
    }
    constructor(e, t, n, i, s, a, u) {
        if (arguments.length === 0) this.date = new Date(1900, 0, 1, 0, 0, 0, 0);
        else if (arguments.length === 1)
            if (e instanceof Date || Object.prototype.toString.call(e) === "[object Date]") {
                let l = e.getTime();
                isNaN(l) ? this.date = new Date(1900, 0, 1, 0, 0, 0, 0) : this.date = new Date(l)
            } else this.date = new Date(e);
        else Lr(e, 1900) < 100 ? (this.date = new Date(100, 0, 1, 0, 0, 0, 0), this.date.setFullYear(Lr(e, 1900)), this.date.setMonth(Lr(t, 1) - 1), this.date.setDate(Lr(n, 1)), this.date.setHours(Lr(i, 0)), this.date.setMinutes(Lr(s, 0)), this.date.setSeconds(Lr(a, 0)), this.date.setMilliseconds(Lr(u, 0))) : this.date = new Date(Lr(e, 1900), Lr(t, 1) - 1, Lr(n, 1), Lr(i, 0), Lr(s, 0), Lr(a, 0), Lr(u, 0))
    }
    get year() {
        return this.date.getFullYear()
    }
    get month() {
        return this.date.getMonth() + 1
    }
    get day() {
        return this.date.getDate()
    }
    get hours() {
        return this.date.getHours()
    }
    get minutes() {
        return this.date.getMinutes()
    }
    get seconds() {
        return this.date.getSeconds()
    }
    get milliseconds() {
        return this.date.getMilliseconds()
    }
    get weekDay() {
        return this.date.getDay()
    }
    addYears(e) {
        let t = new Ot(this.year + e, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);
        return this.month === 2 && this.day === 29 && t.month === 3 ? new Ot(t.year, 2, 28, t.hours, t.minutes, t.seconds, t.milliseconds) : t
    }
    daysInMonth(e, t) {
        return new Date(t, e, 0).getDate()
    }
    addMonths(e) {
        let t = new Ot(this.year, this.month + e, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);
        return t.day === this.day ? t : new Ot(t.year, t.month - 1, this.daysInMonth(t.month - 1, t.year), t.hours, t.minutes, t.seconds, t.milliseconds)
    }
    addDays(e) {
        return new Ot(this.year, this.month, this.day + e, this.hours, this.minutes, this.seconds, this.milliseconds)
    }
    addHours(e) {
        return new Ot(this.year, this.month, this.day, this.hours + e, this.minutes, this.seconds, this.milliseconds)
    }
    addMinutes(e) {
        return new Ot(this.year, this.month, this.day, this.hours, this.minutes + e, this.seconds, this.milliseconds)
    }
    addSeconds(e) {
        return new Ot(this.year, this.month, this.day, this.hours, this.minutes, this.seconds + e, this.milliseconds)
    }
    addMilliseconds(e) {
        return new Ot(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds + e)
    }
    equals(e) {
        return !!e && this.date.getTime() === e.date.getTime()
    }
    eq(e) {
        return this.equals(e)
    }
    fastEquals(e) {
        return this.equals(e)
    }
    greaterThan(e) {
        return this.date > e.date
    }
    gt(e) {
        return this.greaterThan(e)
    }
    greaterThanOrEqualTo(e) {
        return this.date >= e.date
    }
    gte(e) {
        return this.greaterThanOrEqualTo(e)
    }
    lessThan(e) {
        return this.date < e.date
    }
    lt(e) {
        return this.lessThan(e)
    }
    lessThanOrEqualTo(e) {
        return this.date <= e.date
    }
    lte(e) {
        return this.lessThanOrEqualTo(e)
    }
    toNative() {
        return new Date(this.date.getTime())
    }
    getTime() {
        return this.date.getTime()
    }
    valueOf() {
        return this.date.valueOf()
    }
    static fromISODate(e) {
        return D.RFC3339_DATEPART.test(e) ? Ot.internalFromUTCWithoutConversion(e + "T00:00:00Z") : Ot.defaultValue
    }
    toISODate() {
        return this.toString(D.RFC3339_DATEPART_FORMAT)
    }
    static fromISOTime(e) {
        return D.RFC3339_TIMEPART.test(e) ? Ot.internalFromUTCWithoutConversion("1900-01-01T" + e + "Z") : Ot.defaultValue
    }
    toISOTime() {
        return this.toString(D.RFC3339_TIMEPART_FORMAT)
    }
    static fromISODateTime(e) {
        if (e = e || "", e === "" || e.indexOf("1900-01-01") >= 0 && e.indexOf("00:00:00") >= 0) return Ot.defaultValue;
        let t = /([+\-]\d{2}((:\d{2})|(\d{2})?)|Z)$/;
        if (e.indexOf("T") > 0 && !t.test(e)) return Ot.internalFromUTCWithoutConversion(e.trim() + "Z");
        e = e.replace(/([+-]\d{2})$/, o(function(s) {
            return s + "00"
        }, "fun"));
        let n = Date.parse(e);
        return isNaN(n) ? Ot.defaultValue : new Ot(n)
    }
    static internalFromUTCWithoutConversion(e) {
        let t = Date.parse(e);
        if (!isNaN(t)) {
            let n = new Date(t);
            return new Ot(n.getUTCFullYear(), n.getUTCMonth() + 1, n.getUTCDate(), n.getUTCHours(), n.getUTCMinutes(), n.getUTCSeconds(), n.getUTCMilliseconds())
        }
        return Ot.defaultValue
    }
    getMillisecondsString() {
        return (this.milliseconds / 1e3).toFixed(3).substring(2, 5)
    }
    toString(e) {
        return e === void 0 ? this.equals(Ot.defaultValue) ? "1900-01-01T00:00:00" : this.date.toISOString() : e.replace(/(\\.)|dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|ff?f?|FF?F?|\.FF?F?|tt?|zz?z?/g, t => {
            if (t.indexOf("\\") === 0) return t.substring(1);
            switch (t) {
                case "hh":
                case "h":
                    let n = this.hours < 13 ? this.hours : this.hours - 12;
                    return ht.padLeadingZeros((this.hours === 0 ? 12 : n).toString(), t.length);
                case "HH":
                case "H":
                    return ht.padLeadingZeros(this.hours.toString(), t.length);
                case "mm":
                case "m":
                    return ht.padLeadingZeros(this.minutes.toString(), t.length);
                case "ss":
                case "s":
                    return ht.padLeadingZeros(this.seconds.toString(), t.length);
                case "fff":
                    return this.getMillisecondsString();
                case "ff":
                    return this.getMillisecondsString().substring(0, 2);
                case "f":
                    return this.getMillisecondsString().substring(0, 1);
                case ".FFF":
                case ".FF":
                case ".F":
                    return this.milliseconds === 0 ? "" : "." + ht.removeTrailingZeros(this.getMillisecondsString());
                case "FFF":
                    return ht.removeTrailingZeros(this.getMillisecondsString());
                case "FF":
                    return ht.removeTrailingZeros(this.getMillisecondsString()).substring(0, 2);
                case "F":
                    return ht.removeTrailingZeros(this.getMillisecondsString()).substring(0, 1);
                case "yyyy":
                case "yyy":
                    let i = this.year.toString();
                    return i.charAt(0) === "0" ? this.year.toString().substring(1) : i;
                case "yy":
                    return this.year.toString().substring(2, 4);
                case "y":
                    return Number(this.year.toString().substring(2, 4)).toString();
                case "dddd":
                    return ht.getDayName(this.weekDay);
                case "ddd":
                    return ht.getShortDayName(this.weekDay);
                case "dd":
                case "d":
                    return ht.padLeadingZeros(this.day.toString(), t.length);
                case "MMMM":
                    return ht.getMonthName(this.month);
                case "MMM":
                    return ht.getShortMonthName(this.month);
                case "MM":
                case "M":
                    return ht.padLeadingZeros(this.month.toString(), t.length);
                case "t":
                    return ht.get12HourNotation(this.hours).substring(0, 1);
                case "tt":
                    return ht.get12HourNotation(this.hours);
                case "zzz":
                    return ht.getTimezoneInformationFull(this.date.getTimezoneOffset());
                case "zz":
                    return ht.getTimezoneInformationHoursFull(this.date.getTimezoneOffset());
                case "z":
                    return ht.getTimezoneInformationHoursShort(this.date.getTimezoneOffset());
                default:
                    return t
            }
        })
    }
};
o(Ot, "DateTime");
var me = Ot;
me.defaultValueField = new me;
var D;
(function(r) {
    r.RFC3339_TIMEPART = /^([01][0-9]|2[0-3]):([0-5][0-9])(:[0-5][0-9](\.\d+)?)?$/, r.RFC3339_DATEPART = /^\d{4,}-(0\d|1[012])-([0-2]\d|3[01])$/, r.RFC3339_TIMEPART_FORMAT = "HH:mm:ss", r.RFC3339_DATEPART_FORMAT = "yyyy-MM-dd", r.MIN_INTEGER_VALUE = -2147483648, r.MAX_INTEGER_VALUE = 2147483647, r.MIN_LONGINTEGER_VALUE = bt.MIN_VALUE, r.MAX_LONGINTEGER_VALUE = bt.MAX_VALUE, r.MIN_DECIMAL_VALUE = new Be("2").pow(96).neg(), r.MAX_DECIMAL_VALUE = new Be("2").pow(96).minus(1), r.MIN_DATE_VALUE = new me(1753, 1, 1), r.MAX_DATE_VALUE = new me(9999, 12, 31), r.MIN_TIME_VALUE = me.defaultValue, r.MAX_TIME_VALUE = me.defaultValue.addHours(23).addMinutes(59).addSeconds(59), r.MIN_DATETIME_VALUE = new me(1753, 1, 1, 0, 0, 0), r.MAX_DATETIME_VALUE = new me(9999, 12, 31, 23, 59, 59), r.DEFAULT_INTEGER = 0, r.DEFAULT_LONGINTEGER = bt.defaultValue, r.DEFAULT_DECIMAL = Be.defaultValue, r.DEFAULT_CURRENCY = Be.defaultValue, r.DEFAULT_TEXT = "", r.DEFAULT_PHONENUMBER = "", r.DEFAULT_EMAIL = "", r.DEFAULT_BOOLEAN = !1, r.DEFAULT_DATE = me.defaultValue, r.DEFAULT_DATETIME = me.defaultValue, r.DEFAULT_TIME = me.defaultValue, r.DEFAULT_BINARYDATA = Or.defaultValue, r.DEFAULT_OBJECT = null, r.FORMAT = new qm(new ht("yyyy-MM-dd", "HH:mm:ss"), new zm(".", "")), r.ISO_DATE_FORMAT_REGEXP = /^\d{4,}-(0\d|1[012])-([0-2]\d|3[01])([T ]\d{2}:\d{2}(:\d{2}(\.\d+)?(([+\-]\d{2}((:\d{2})|(\d{2})?))|Z)?)?)?$/i
})(D || (D = {}));
var Yv = class Yv {
    constructor() {
        this.map = {}
    }
    getItem(e) {
        return this.map[e]
    }
    setItem(e, t) {
        this.map[e] = t
    }
    invalidate(e) {
        e === void 0 ? this.map = {} : this.setItem(e, void 0)
    }
    clone() {
        let e = new Yv;
        for (let t in this.map) e.setItem(t, this.map[t]);
        return e
    }
};
o(Yv, "Cache");
var yc = Yv,
    gC = class gC {
        constructor() {
            this.list = []
        }
        getItem(e) {
            if (!(e >= this.length)) return this.list[e]
        }
        append(e) {
            this.list.push(e)
        }
        appendMultiple(e) {
            this.list = this.list.concat(new Array(e))
        }
        setItem(e, t) {
            this.list[e] = t
        }
        insert(e, t) {
            this.list.splice(e, 0, t)
        }
        invalidate(e) {
            e === void 0 ? this.list = [] : this.list.splice(e, 1)
        }
        get length() {
            return this.list.length
        }
    };
o(gC, "ListCache");
var Km = gC;

function Ty(r, e) {
    if (typeof r == "string") {
        let t = r,
            n = e;
        return t.localeCompare(n)
    }
    return typeof r == "number" ? r - e : typeof r == "boolean" ? !r && e ? -1 : r && !e ? 1 : 0 : r.lessThan(e) ? -1 : r.greaterThan(e) ? 1 : 0
}
o(Ty, "compare");

function Tn(r, e) {
    return !r || !e || !(e.equals instanceof Function) ? e === r : e.equals(r)
}
o(Tn, "equals");

function vse(r, e) {
    return !r.hasContent() && !e.hasContent()
}
o(vse, "areBinaryNulls");

function Le(r) {
    switch (r) {
        case _.Integer:
            return D.DEFAULT_INTEGER;
        case _.LongInteger:
            return D.DEFAULT_LONGINTEGER;
        case _.Decimal:
            return D.DEFAULT_DECIMAL;
        case _.Currency:
            return D.DEFAULT_CURRENCY;
        case _.Text:
            return D.DEFAULT_TEXT;
        case _.PhoneNumber:
            return D.DEFAULT_PHONENUMBER;
        case _.Email:
            return D.DEFAULT_EMAIL;
        case _.Date:
            return D.DEFAULT_DATE;
        case _.DateTime:
            return D.DEFAULT_DATETIME;
        case _.Time:
            return D.DEFAULT_TIME;
        case _.Boolean:
            return D.DEFAULT_BOOLEAN;
        case _.BinaryData:
            return D.DEFAULT_BINARYDATA;
        case _.Object:
            return D.DEFAULT_OBJECT;
        default:
            throw new TypeError("Records and Record lists are not basic types")
    }
}
o(Le, "defaultForType");
var Er = class Er {
    constructor(e, t, n, i, s) {
        if (this.emptyListItem = e, this.data = t != null ? t : new Hi, this.itemIds = n != null ? n : new Hi, this._itemIdSeed = i != null ? i : 0, this._modelId = s || Er.nextModelId++, t && !n)
            for (let a = 0, u = this.data.count(); a < u; a++) this.itemIds = this.itemIds.push(this._itemIdSeed), this._itemIdSeed = this._itemIdSeed + 1 | 0
    }
    get modelId() {
        return this._modelId
    }
    push(e) {
        return new Er(this.emptyListItem, this.data.push(e), this.itemIds.push(this._itemIdSeed), this._itemIdSeed + 1 | 0, this._modelId)
    }
    addFromOther(e) {
        return new Er(this.emptyListItem, this.data.addFromOther(e.data), this.itemIds.pushAll(e.data.map(() => this._itemIdSeed++)), this._itemIdSeed, this._modelId)
    }
    pushAll(e) {
        return new Er(this.emptyListItem, this.data.pushAll(e), this.itemIds.pushAll(e.map(() => this._itemIdSeed++)), this._itemIdSeed, this._modelId)
    }
    remove(e) {
        return new Er(this.emptyListItem, this.data.remove(e), this.itemIds.remove(e), this._itemIdSeed, this._modelId)
    }
    insert(e, t) {
        return new Er(this.emptyListItem, this.data.insert(e, t), this.itemIds.insert(e, this._itemIdSeed), this._itemIdSeed + 1 | 0, this._modelId)
    }
    sort(e, t, n) {
        let i = this.data.map((l, c) => ({
                item: e(c),
                itemId: this.itemIds.get(c),
                by: t(e(c))
            })),
            s = n ? 1 : -1;
        i.sort((l, c) => s * Ty(l.by, c.by));
        let a = Hi.fromJS(i.map(l => l.item)),
            u = Hi.fromJS(i.map(l => l.itemId));
        return new Er(this.emptyListItem, a, u, this._itemIdSeed, this._modelId)
    }
    getEmptyListItem() {
        return this.emptyListItem
    }
    setEmptyListItem(e) {
        return new Er(e, this.data, this.itemIds, this._itemIdSeed, this._modelId)
    }
    get(e) {
        return this.data.get(e)
    }
    getId(e) {
        return `${this.modelId}_${this.itemIds.get(e)}`
    }
    count() {
        return this.data.count()
    }
    isEmpty() {
        return this.data.isEmpty()
    }
    set(e, t) {
        return new Er(this.emptyListItem, this.data.set(e, t), this.itemIds, this._itemIdSeed, this._modelId)
    }
    clear() {
        return new Er(this.emptyListItem, this.data.clear(), this.itemIds.clear(), this._itemIdSeed, this._modelId)
    }
    forEach(e) {
        this.data.forEach(e)
    }
    reduce(e, t) {
        return this.data.reduce(e, t)
    }
    static fromJS(e, t) {
        return new Er(t, Hi.fromJS(e))
    }
    static fromJSON(e, t) {
        return new Er(t, Hi.fromJS(e))
    }
    clone() {
        return new Er(this.emptyListItem, this.data.clone(), this.itemIds.clone(), this._itemIdSeed)
    }
};
o(Er, "ImmutableListWithTracking");
var Xo = Er;
Xo.nextModelId = 1;
var Bd = class Bd {
    constructor() {
        this.writePropagateHandler = this.defaultWritePropagate, this.propagationParent = this
    }
    static getData(e) {
        if (!(e === void 0 || e.constructor === Xo)) return e.data
    }
    static setPropagationHandler(e, t, n, i) {
        e.writePropagateHandler = i, Bd.setPropagationParent(e, t), Bd.setPropagationKey(e, n)
    }
    static setPropagationParent(e, t) {
        e.propagationParent = t
    }
    static setPropagationKey(e, t) {
        e.propagationKey = t
    }
    writePropagate(e, t) {
        var n;
        if (((n = this.data) === null || n === void 0 ? void 0 : n.constructor) !== (e == null ? void 0 : e.constructor)) throw new Error("Unexpected new data type");
        this.data = e, this.writePropagateHandler.apply(this.propagationParent, [this.propagationKey, e, t])
    }
    defaultWritePropagate(e, t, n) {
        this.onDefaultWritePropagate(n)
    }
    onDefaultWritePropagate(e) {}
};
o(Bd, "ImmutableBase");
var Ft = Bd,
    jt = class jt extends Ft {
        constructor(e, t) {
            super(), this.cache = t != null ? t : new yc, e ? this.data = e : this.data = this.constructor.createDefaultData()
        }
        static createDefaultData() {
            let t = this.RecordClass;
            if (t) return new t
        }
        getBasicProperty(e) {
            return this.data.get(e)
        }
        setBasicProperty(e, t, n, i) {
            this.data.get(e) !== t && (jt.checkType(n, t, i), this.writePropagate(this.data.set(e, t), this.cache), this.onPropertyValueChanged(e))
        }
        onPropertyValueChanged(e) {}
        getComplexProperty(e, t) {
            let n = this.cache.getItem(e);
            if (n) return jt.setPropagationParent(n, this), n;
            let i = this.data.get(e),
                s = this.cache.getItem(e + im);
            return n = new t(i, s || null), this.cache.setItem(e, n), s && this.cache.invalidate(e + im), jt.setPropagationHandler(n, this, e, this.internalSetComplexProperty), n
        }
        setComplexProperty(e, t, n, i) {
            this.setProperties([{
                name: e,
                value: t,
                expectedType: n,
                valueType: i,
                isBasicType: !1
            }])
        }
        internalSetComplexProperty(e, t, n) {
            this.internalSetProperties([{
                name: e,
                value: t,
                isBasicType: !1
            }], n)
        }
        setProperties(e) {
            var t;
            let n = [];
            for (let i of e) {
                let s = (t = jt.getData(i.value)) !== null && t !== void 0 ? t : i.value;
                this.data.get(i.name) !== s && (i.expectedType !== void 0 && jt.checkType(i.expectedType, i.value, i.valueType), n.push({
                    name: i.name,
                    value: s,
                    isBasicType: i.isBasicType
                }))
            }
            n.length > 0 && this.internalSetProperties(n)
        }
        internalSetProperties(e, t) {
            let n = this.data,
                i = this.cloneCache();
            for (let s of e) n = n.set(s.name, s.value), s.isBasicType || (i.invalidate(s.name), i.invalidate(s.name + im), t && i.setItem(s.name + im, t));
            this.writePropagate(n, i);
            for (let s of e) this.onPropertyValueChanged(s.name)
        }
        cloneCache() {
            return this.cache.clone()
        }
        onDefaultWritePropagate(e) {
            this.cache = e
        }
        static checkType(e, t, n) {
            switch (e) {
                case _.Integer:
                    jt.ensureValidInteger(t);
                    break;
                case _.LongInteger:
                    jt.ensureValidLongInteger(t);
                    break;
                case _.Decimal:
                case _.Currency:
                    jt.ensureValidDecimal(t);
                    break;
                case _.Text:
                case _.PhoneNumber:
                    jt.ensureValidText(t);
                    break;
                case _.Email:
                    jt.ensureValidEmail(t);
                    break;
                case _.Boolean:
                    jt.ensureValidBoolean(t);
                    break;
                case _.Date:
                    jt.ensureValidDate(t);
                    break;
                case _.Time:
                    jt.ensureValidTime(t);
                    break;
                case _.DateTime:
                    jt.ensureValidDateTime(t);
                    break;
                case _.Record:
                case _.RecordList:
                    jt.ensureValidComplexType(t, n);
                    break;
                case _.BinaryData:
                    jt.ensureValidBinaryData(t);
                    break;
                case _.Object:
                    break;
                default:
                    throw new TypeError("Unexpected data type: " + e)
            }
        }
        static ensureValidBinaryData(e) {
            if (!(typeof e == "string" || e instanceof Or)) throw new TypeError("Expecting a Binary Data, found: " + e)
        }
        static ensureValidInteger(e) {
            if (typeof e == "number" && !isNaN(e) && e % 1 === 0) {
                if (e < D.MIN_INTEGER_VALUE) throw new TypeError("Integers must be greater than " + D.MIN_INTEGER_VALUE + ", found: " + e);
                if (e > D.MAX_INTEGER_VALUE) throw new TypeError("Integers must be lower than " + D.MAX_INTEGER_VALUE + ", found: " + e)
            } else throw new TypeError("Expecting an Integer, found: " + e)
        }
        static ensureValidLongInteger(e) {
            if (e && e.constructor === bt) {
                if (e.lessThan(D.MIN_LONGINTEGER_VALUE)) throw new TypeError("Long Integers must be greater than " + D.MIN_LONGINTEGER_VALUE.toString() + ", found: " + e.toString());
                if (e.greaterThan(D.MAX_LONGINTEGER_VALUE)) throw new TypeError("Long Integers must be lower than " + D.MAX_LONGINTEGER_VALUE.toString() + ", found: " + e.toString())
            } else throw new TypeError("Expecting a LongInteger, found: " + e)
        }
        static ensureValidDecimal(e) {
            if (e && e.constructor === Be) {
                if (e.lessThan(D.MIN_DECIMAL_VALUE)) throw new TypeError("Decimals must be greater than " + D.MIN_DECIMAL_VALUE.toString() + ", found: " + e.toString());
                if (e.greaterThan(D.MAX_DECIMAL_VALUE)) throw new TypeError("Decimals must be lower than " + D.MAX_DECIMAL_VALUE.toString() + ", found: " + e.toString())
            } else throw new TypeError(`Expecting a Decimal, found: ${e}`)
        }
        static ensureValidText(e) {
            if (typeof e != "string") throw new TypeError(`Expecting a Text, found: ${e}`)
        }
        static ensureValidEmail(e) {
            if (typeof e != "string") throw new TypeError(`Expecting an Email, found: ${e}`)
        }
        static ensureValidBoolean(e) {
            if (typeof e != "boolean") throw new TypeError(`Expecting a Boolean, found: ${e}`)
        }
        static ensureValidDate(e) {
            if (!(e && e.constructor === me)) throw new TypeError(`Expecting a Date, found: ${e}`)
        }
        static ensureValidTime(e) {
            if (!(e && e.constructor === me)) throw new TypeError(`Expecting a Time, found: ${e}`)
        }
        static ensureValidDateTime(e) {
            if (!(e && e.constructor === me)) throw new TypeError(`Expecting a DateTime, found: ${e}`)
        }
        static ensureValidComplexType(e, t) {
            if (e) {
                if (e.constructor === t) return;
                if (e.isCompatibleWith !== void 0) {
                    if (e.isCompatibleWith(t)) return;
                    throw new TypeError(`Expecting a ${t.name} type, found:  ${e.constructor.name}`)
                }
            }
            throw new TypeError(`Expecting a Record or RecordList, found: ${e}`)
        }
        replaceWith(e) {
            let t = jt.getData(e);
            this.writePropagate(t, new yc)
        }
        fastEquals(e) {
            return this === e
        }
        equals(e) {
            return !(!e || this.constructor !== e.constructor)
        }
        static defineRecordClass(e) {
            return yk(e)
        }
        clone() {
            let e = this.constructor;
            return new e(this.data, this.cloneCache())
        }
    };
o(jt, "Record");
var ur = jt,
    pC = class pC {
        constructor(e, t, n, i, s, a, u, l, c) {
            this.name = e, this.attrName = t, this.nameForJson = n, this.mandatory = i, this.ignoreForServer = s, this.dataType = a, this.optimizeList = l, this.complexType = c, this.defaultValue = u()
        }
    };
o(pC, "StaticAttrDefinition");
var xS = pC,
    mC = class mC {
        constructor(e, t, n, i, s, a, u, l, c) {
            this.name = e, this.attrName = t, this.nameForJson = n, this.mandatory = i, this.ignoreForServer = s, this.dataType = a, this.defaultValueGetter = u, this.optimizeList = l, this.complexType = c
        }
        get defaultValue() {
            return this.defaultValueGetter()
        }
    };
o(mC, "DynamicAttrDefinition");
var US = mC;

function yse(r) {
    return r === _.Record || r === _.RecordList || r === _.LongInteger || r === _.Decimal || r === _.Currency || r === _.DateTime || r === _.Time || r === _.Date
}
o(yse, "dataTypeImplementsEquals");
var Vd = class Vd extends ur {
    static get isGenericRecordType() {
        return !0
    }
    getAttributes() {
        return this.constructor.Attributes || []
    }
    static getAttributes() {
        return this.Attributes || []
    }
    static isAnonymousRecord() {
        return this._isAnonymousRecord
    }
    constructor(e, t) {
        super(e, t)
    }
    static attr(e, t, n, i, s, a, u) {
        let l = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : !0,
            c = arguments.length > 8 ? arguments[8] : void 0,
            d;
        return typeof l != "boolean" ? (c = l, d = !0) : d = l, a === _.DateTime || a === _.Date || a === _.Time ? new US(e, t, n, i, s, a, u, d, c) : new xS(e, t, n, i, s, a, u, d, c)
    }
    static attributesToDeclare() {
        return []
    }
    static init() {
        let e = this,
            t = e.attributesToDeclare();
        e.Attributes = t, t.forEach(n => {
            n.attrName in e.prototype || (n.dataType === _.Record || n.dataType === _.RecordList ? e.defineComplexProperty(n.attrName, n.dataType, n.complexType) : e.defineBasicProperty(n.attrName, n.dataType))
        }), e.RecordClass = ur.defineRecordClass(t.reduce((n, i) => (n[i.attrName] = null, n), {})), e.prototype.equals = function(n) {
            let i = Vd.prototype.equals.call(this, n);
            return t.forEach(s => {
                yse(s.dataType) ? i && (i = this[s.attrName].equals(n[s.attrName])) : i && (i = this[s.attrName] === n[s.attrName])
            }), i
        }
    }
    static createDefaultData() {
        let e = this,
            t = e.RecordClass;
        if (t) {
            let n = {};
            for (let i of e.Attributes) i.dataType === _.Record || i.dataType === _.RecordList ? n[i.attrName] = ur.getData(i.defaultValue) : n[i.attrName] = i.defaultValue;
            return new t(n)
        }
    }
    static defineBasicProperty(e, t) {
        Object.defineProperty(this.prototype, e, {
            enumerable: !0,
            configurable: !0,
            get() {
                return this.getBasicProperty(e)
            },
            set(n) {
                this.setBasicProperty(e, n, t)
            }
        })
    }
    static defineComplexProperty(e, t, n) {
        Object.defineProperty(this.prototype, e, {
            enumerable: !0,
            configurable: !0,
            get() {
                return this.getComplexProperty(e, n)
            },
            set(i) {
                this.setComplexProperty(e, i, t, n)
            }
        })
    }
    static isCompatibleWith(e) {
        return this === e ? !0 : this.isAnonymousRecord() && e.isAnonymousRecord() && this.UniqueId === e.UniqueId
    }
    isCompatibleWith(e) {
        return e.prototype instanceof Vd && this.constructor.isCompatibleWith(e)
    }
    getNonSerializableAttributes() {
        return this.getAttributes().filter(e => e.dataType === _.Object).map(e => e.attrName)
    }
};
o(Vd, "GenericRecord");
var Ce = Vd;
Ce.UniqueId = "";
Ce._isAnonymousRecord = !1;
var vC = class vC extends Ft {
    static getItemType() {
        return this.itemType
    }
    getCache() {
        return null
    }
    newItem(e) {
        throw new Error("@abstract")
    }
    resetEmptyListItem() {
        this.data = this.data.setEmptyListItem(this.newItem())
    }
    get emptyListItem() {
        return this.isEmpty ? this.data.getEmptyListItem() : this.data.get(0)
    }
    set emptyListItem(e) {
        if (this.isEmpty) {
            if (this.data.getEmptyListItem() === e) return;
            this.writePropagate(this.data.setEmptyListItem(e), this.getCache())
        } else {
            if (this.data.get(0) === e) return;
            this.writePropagate(this.data.set(0, e), this.getCache())
        }
    }
    get modelId() {
        return this.data.modelId
    }
    get isEmpty() {
        return this.data.isEmpty()
    }
    get length() {
        return this.data.count()
    }
    isValidIndex(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
        return e % 1 === 0 && e >= 0 && e < this.length + (t ? 1 : 0)
    }
    checkIndex(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
        if (!this.isValidIndex(e, t)) {
            let n = "Index out of bounds. Index " + e + " for ";
            throw this.isEmpty ? n += "empty list." : n += "bounds [0, " + (this.length - 1) + "].", new Error(n)
        }
    }
    idOf(e) {
        return this.checkIndex(e), this.data.getId(e)
    }
    append(e) {
        this.writePropagate(this.data.push(e), this.getCache())
    }
    appendAll(e) {
        e.length > 0 && this.writePropagate(this.data.addFromOther(e.data), this.getCache())
    }
    pushAll(e) {
        e.length > 0 && this.writePropagate(this.data.pushAll(e), this.getCache())
    }
    insert(e, t) {
        this.checkIndex(e, !0), this.writePropagate(this.data.insert(e, t), this.getCache())
    }
    remove(e) {
        this.checkIndex(e), this.length === 1 && this.resetEmptyListItem(), this.writePropagate(this.data.remove(e), this.getCache())
    }
    clear() {
        this.resetEmptyListItem(), this.writePropagate(this.data.clear(), this.getCache())
    }
    indexOf(e) {
        for (let t = 0; t < this.length; t++)
            if (e(this.getItem(t))) return t;
        return -1
    }
    any(e) {
        return this.indexOf(e) !== -1
    }
    all(e) {
        return !this.any(t => !e(t))
    }
    filter(e) {
        let t = new this.constructor,
            n = [];
        for (let i = 0; i < this.length; i++) {
            let s = this.getItem(i);
            e(s) && n.push(s)
        }
        return t.pushAll(n), t
    }
    distinct() {
        let e = new this.constructor,
            t = new Array;
        for (let n = 0; n < this.length; n++) {
            let i = this.getItem(n),
                s = !0;
            for (let a = 0; a < t.length; a++)
                if (Tn(i, this.getItem(t[a]))) {
                    s = !1;
                    break
                } s && (t.push(n), e.append(i))
        }
        return e
    }
    sort(e, t) {
        let n = [];
        for (let s = 0; s < this.length; s++) n[s] = this.getItem(s);
        let i = t ? 1 : -1;
        n.sort((s, a) => i * Ty(e(s), e(a))), this.clear(), this.pushAll(n)
    }
    getCurrent(e) {
        if (this.isEmpty) return this.emptyListItem; {
            let t = this.getCurrentRowNumber(e);
            return this.getItem(t)
        }
    }
    getCurrentRowNumber(e) {
        return e.getCurrentRowNumber(this)
    }
    getItem(e) {
        return this.checkIndex(e), this.data.get(e)
    }
    setCurrent(e, t) {
        if (this.isEmpty) this.emptyListItem = t;
        else {
            let n = this.getCurrentRowNumber(e);
            this.setItem(n, t)
        }
    }
    setItem(e, t) {
        this.checkIndex(e), this.data.get(e) !== t && this.writePropagate(this.data.set(e, t), this.getCache())
    }
    fastEquals(e) {
        return this === e
    }
    equals(e) {
        if (!e || this.constructor !== e.constructor || this.length !== e.length) return !1;
        if (this.isEmpty) {
            let t = this.emptyListItem,
                n = e.emptyListItem;
            return Tn(t, n)
        } else
            for (let t = 0; t < this.length; t++) {
                let n = this.getItem(t),
                    i = e.getItem(t);
                if (!Tn(n, i)) return !1
            }
        return !0
    }
};
o(vC, "List");
var Ki = vC,
    yC = class yC extends Ki {
        constructor(e) {
            super(), this.data = e || new Xo(this.newItem())
        }
        static get isBasicTypeListType() {
            return !0
        }
        static getTypeDefaultValue() {
            throw new Error("Not implemented: getTypeDefaultValue")
        }
        newItem() {
            return this.constructor.getTypeDefaultValue()
        }
        clone() {
            let e = this.constructor,
                t = this.data.clone();
            return new e(t)
        }
    };
o(yC, "BasicTypeList");
var Mr = yC,
    Ps = class Ps extends Ki {
        constructor(e, t) {
            if (super(), this._recordType = this.constructor.getItemType(), !this._recordType) throw new TypeError("GenericRecordLists must define a RecordType");
            e ? this.data = e : this.data = new Xo(Ce.getData(this.newItem())), this.cache = t != null ? t : new Km
        }
        static get isGenericRecordListType() {
            return !0
        }
        getCache() {
            return this.cache
        }
        newItem(e) {
            return new(this.getRecordType())(e)
        }
        resetEmptyListItem() {
            this.data = this.data.setEmptyListItem(Ce.getData(this.newItem()))
        }
        getRecordType() {
            return this._recordType
        }
        get emptyListItem() {
            return this.internalGetItem(0, this.isEmpty)
        }
        set emptyListItem(e) {
            this.isEmpty ? this.internalSetEmptyListItem(0, e) : this.internalSetItem(0, e)
        }
        append(e) {
            this.isEmpty && this.cache.invalidate(0), super.append(Ce.getData(e)), this.cache.append(void 0)
        }
        appendAll(e) {
            this.isEmpty && this.cache.invalidate(0), super.appendAll(e), this.cache.appendMultiple(e.length)
        }
        pushAll(e) {
            this.isEmpty && this.cache.invalidate(0), super.pushAll(e.map(t => ur.getData(t))), this.cache.appendMultiple(e.length)
        }
        insert(e, t) {
            this.checkIndex(e, !0), this.isEmpty && this.cache.invalidate(0), super.insert(e, Ce.getData(t)), this.cache.insert(e, void 0)
        }
        getItem(e) {
            return this.internalGetItem(e, !1)
        }
        internalGetItem(e, t) {
            t || this.checkIndex(e);
            let n = this.cache.getItem(e);
            return n ? (Ps.setPropagationParent(n, this), Ps.setPropagationKey(n, e), n) : (t ? (n = this.newItem(this.data.getEmptyListItem()), Ps.setPropagationHandler(n, this, e, this.internalSetEmptyListItem)) : (n = this.newItem(this.data.get(e)), Ps.setPropagationHandler(n, this, e, this.internalSetItem)), this.cache.setItem(e, n), n)
        }
        setItem(e, t) {
            this.internalSetItem(e, t)
        }
        internalSetItem(e, t, n) {
            var i;
            let s = (i = Ce.getData(t)) !== null && i !== void 0 ? i : t;
            this.checkIndex(e), this.data.get(e) !== s && (this.writePropagate(this.data.set(e, s), this.cache), this.cache.setItem(e, void 0))
        }
        internalSetEmptyListItem(e, t, n) {
            var i;
            let s = (i = Ce.getData(t)) !== null && i !== void 0 ? i : t;
            this.data.getEmptyListItem() !== s && (this.writePropagate(this.data.setEmptyListItem(s), this.cache), this.cache.setItem(e, void 0))
        }
        remove(e) {
            super.remove(e), this.cache.invalidate(e)
        }
        clear() {
            super.clear(), this.cache.invalidate()
        }
        readAll(e, t) {
            let n = [];
            for (let i = 0; i < t.length; i++) {
                let s = this.newItem();
                e(s, t.item(i)), n.push(s)
            }
            this.pushAll(n)
        }
        clone() {
            let e = this.constructor,
                t = this.data.clone();
            return new e(t)
        }
        static isCompatibleWith(e) {
            return this === e ? !0 : this.getItemType().isCompatibleWith(e.getItemType())
        }
        isCompatibleWith(e) {
            return e.prototype instanceof Ps && this.constructor.isCompatibleWith(e)
        }
    };
o(Ps, "GenericRecordList");
var _c = Ps,
    _C = class _C extends Mr {
        constructor(e) {
            super(e)
        }
        static getTypeDefaultValue() {
            return D.DEFAULT_INTEGER
        }
    };
o(_C, "IntegerList");
var Ym = _C;
Ym.itemType = _.Integer;
var wC = class wC extends Mr {
    constructor(e) {
        super(e)
    }
    static getTypeDefaultValue() {
        return D.DEFAULT_LONGINTEGER
    }
};
o(wC, "LongIntegerList");
var Xm = wC;
Xm.itemType = _.LongInteger;
var TC = class TC extends Mr {
    constructor(e) {
        super(e)
    }
    static getTypeDefaultValue() {
        return D.DEFAULT_DATE
    }
};
o(TC, "DateList");
var Jm = TC;
Jm.itemType = _.Date;
var EC = class EC extends Mr {
    constructor(e) {
        super(e)
    }
    static getTypeDefaultValue() {
        return D.DEFAULT_DATETIME
    }
};
o(EC, "DateTimeList");
var Zm = EC;
Zm.itemType = _.DateTime;
var bC = class bC extends Mr {
    constructor(e) {
        super(e)
    }
    static getTypeDefaultValue() {
        return D.DEFAULT_TIME
    }
};
o(bC, "TimeList");
var Qm = bC;
Qm.itemType = _.Time;
var SC = class SC extends Mr {
    constructor(e) {
        super(e)
    }
    static getTypeDefaultValue() {
        return D.DEFAULT_DECIMAL
    }
};
o(SC, "DecimalList");
var ev = SC;
ev.itemType = _.Decimal;
var AC = class AC extends Mr {
    constructor(e) {
        super(e)
    }
    static getTypeDefaultValue() {
        return D.DEFAULT_CURRENCY
    }
};
o(AC, "CurrencyList");
var tv = AC;
tv.itemType = _.Currency;
var IC = class IC extends Mr {
    constructor(e) {
        super(e)
    }
    static getTypeDefaultValue() {
        return D.DEFAULT_EMAIL
    }
};
o(IC, "EmailList");
var rv = IC;
rv.itemType = _.Email;
var CC = class CC extends Mr {
    constructor(e) {
        super(e)
    }
    static getTypeDefaultValue() {
        return D.DEFAULT_PHONENUMBER
    }
};
o(CC, "PhoneNumberList");
var nv = CC;
nv.itemType = _.PhoneNumber;
var RC = class RC extends Mr {
    constructor(e) {
        super(e)
    }
    static getTypeDefaultValue() {
        return D.DEFAULT_BOOLEAN
    }
};
o(RC, "BooleanList");
var iv = RC;
iv.itemType = _.Boolean;
var OC = class OC extends Mr {
    constructor(e) {
        super(e)
    }
    static getTypeDefaultValue() {
        return D.DEFAULT_BINARYDATA
    }
};
o(OC, "BinaryDataList");
var sv = OC;
sv.itemType = _.BinaryData;
var PC = class PC extends Mr {
    constructor(e) {
        super(e)
    }
    static getTypeDefaultValue() {
        return D.DEFAULT_TEXT
    }
};
o(PC, "TextList");
var ov = PC;
ov.itemType = _.Text;
var NC = class NC {
    constructor(e) {
        this.varValue = e
    }
    get value() {
        return this.varValue
    }
    set value(e) {
        this.setValue(e)
    }
    setValue(e) {
        this.varValue = e
    }
};
o(NC, "BasicVariableHolder");
var av = NC,
    DC = class DC extends av {
        constructor(e) {
            super(e)
        }
        setValue(e) {
            super.setValue(e && e.clone())
        }
    };
o(DC, "VariableHolder");
var MS = DC;

function tt() {
    return r => {
        let e = r;
        e.init !== void 0 && e.init()
    }
}
o(tt, "RecordWithStaticConstructor");
var Uu, kS = (Uu = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("JSON", "jSONOut", "jSONOut", !0, !0, _.Text, () => Le(_.Text))].concat(super.attributesToDeclare())
    }
}, o(Uu, "JSONSerializeOutputType"), Uu);
kS = nt([tt()], kS);
var Mu, FS = (Mu = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("ExceptionMessage", "exceptionMessageAttr", "exceptionMessageAttr", !0, !0, _.Text, () => Le(_.Text))].concat(super.attributesToDeclare())
    }
}, o(Mu, "ErrorHandlerOutputType"), Mu);
FS = nt([tt()], FS);
var LC = class LC {
    constructor() {
        this.typeDefinitions = new Map, this.typeCache = new Map
    }
    isTypeRegistered(e) {
        return this.typeDefinitions.get(e) !== void 0
    }
    registerTypeDefinition(e, t) {
        this.typeDefinitions.set(e, t)
    }
    getType(e) {
        var s;
        let t = this.typeCache.get(e);
        if (t) return t;
        let n = this.typeDefinitions.get(e);
        if (!n) throw new TypeError(`Type ${e} was not registered`);
        let i = (s = class extends Ce {
            constructor(u, l) {
                super(u, l)
            }
            static attributesToDeclare() {
                return n ? n.map(u => {
                    var l, c, d;
                    return this.attr(u.name, u.attrName, u.nameForJson || u.attrName, (l = u.mandatory) !== null && l !== void 0 ? l : !1, (c = u.ignoreForServer) !== null && c !== void 0 ? c : !0, u.dataType, u.defaultValue, (d = u.optimizeList) !== null && d !== void 0 ? d : !0, u.complexType)
                }).concat(super.attributesToDeclare()) : []
            }
        }, o(s, "RecordType"), s);
        return i = nt([tt()], i), this.typeCache.set(e, i), i
    }
};
o(LC, "RecordTypeFactory");
var Qd = LC,
    xC = class xC extends Qd {
        constructor(e, t, n) {
            super(), this.mainAttributeName = e, this.mainAttributeAttrName = t, this.additionalAttributes = n
        }
        registerTypeDefinition(e, t) {
            throw new Error("Invalid operation")
        }
        createMainAttributeInfo(e) {
            return {
                name: this.mainAttributeName,
                attrName: this.mainAttributeAttrName,
                mandatory: !0,
                dataType: this.getDataType(e),
                defaultValue: this.getDefaultValue(e),
                complexType: this.getComplexType(e)
            }
        }
        registerTypeIfNeeded(e) {
            if (!this.isTypeRegistered(e)) {
                let t = [this.createMainAttributeInfo(e)];
                this.additionalAttributes && (t = t.concat(this.additionalAttributes)), super.registerTypeDefinition(e, t)
            }
        }
        getType(e) {
            return this.registerTypeIfNeeded(e), super.getType(e)
        }
    };
o(xC, "TypeKeyedTypeFactory");
var ef = xC,
    UC = class UC extends ef {
        constructor(e, t, n) {
            super(e, t, n)
        }
        getDataType(e) {
            return e
        }
        getDefaultValue(e) {
            return () => Le(e)
        }
        getComplexType(e) {}
    };
o(UC, "BasicTypeKeyedTypeFactory");
var Bs = UC,
    MC = class MC extends ef {
        constructor(e, t, n) {
            super(e, t, n)
        }
        getDataType(e) {
            return _.Record
        }
        getDefaultValue(e) {
            return () => Ft.getData(new e)
        }
        getComplexType(e) {
            return e
        }
    };
o(MC, "ComplexTypeKeyedTypeFactory");
var Qt = MC,
    G;
(function(r) {
    function e(M) {
        return M && M.constructor === Be
    }
    o(e, "isDecimal"), r.isDecimal = e;

    function t(M) {
        var Oe;
        return ((Oe = M == null ? void 0 : M.value) === null || Oe === void 0 ? void 0 : Oe.constructor) === Or
    }
    o(t, "isBinaryData"), r.isBinaryData = t;

    function n(M) {
        return e(M) && !M.isNaN()
    }
    o(n, "isValidDecimal"), r.isValidDecimal = n;

    function i(M) {
        return D.MIN_DECIMAL_VALUE.lessThanOrEqualTo(M) && D.MAX_DECIMAL_VALUE.greaterThanOrEqualTo(M)
    }
    o(i, "isWithinDecimalRange"), r.isWithinDecimalRange = i;

    function s(M) {
        return typeof M == "string"
    }
    o(s, "isText"), r.isText = s;

    function a(M) {
        return typeof M == "boolean"
    }
    o(a, "isBoolean"), r.isBoolean = a;

    function u(M) {
        return s(M) || d(M) || a(M) || w(M) || g(M) || e(M)
    }
    o(u, "isBasicType"), r.isBasicType = u;

    function l(M) {
        return c(M) && M % 1 === 0
    }
    o(l, "isValidInteger"), r.isValidInteger = l;

    function c(M) {
        return d(M) && !isNaN(M)
    }
    o(c, "isValidJsNumber"), r.isValidJsNumber = c;

    function d(M) {
        return typeof M == "number"
    }
    o(d, "isJsNumber"), r.isJsNumber = d;

    function f(M) {
        return M >= D.MIN_INTEGER_VALUE && M <= D.MAX_INTEGER_VALUE
    }
    o(f, "isWithinIntegerRange"), r.isWithinIntegerRange = f;

    function h(M) {
        return g(M)
    }
    o(h, "isValidLongInteger"), r.isValidLongInteger = h;

    function g(M) {
        return M && M.constructor === bt
    }
    o(g, "isLongInteger"), r.isLongInteger = g;

    function p(M) {
        return T(M) && M.hours === D.DEFAULT_DATE.hours && M.minutes === D.DEFAULT_DATE.minutes && M.seconds === D.DEFAULT_DATE.seconds
    }
    o(p, "isValidDate"), r.isValidDate = p;

    function m(M) {
        return T(M) && M.year === D.DEFAULT_TIME.year && M.month === D.DEFAULT_TIME.month && M.day === D.DEFAULT_TIME.day
    }
    o(m, "isValidTime"), r.isValidTime = m;

    function w(M) {
        return M instanceof me
    }
    o(w, "isDateTime"), r.isDateTime = w;

    function T(M) {
        return w(M) && !isNaN(M.getTime())
    }
    o(T, "isValidDateTime"), r.isValidDateTime = T;

    function E(M) {
        return M instanceof Date || Object.prototype.toString.call(M) === "[object Date]"
    }
    o(E, "isJsDate"), r.isJsDate = E;

    function b(M) {
        return E(M) && !isNaN(M.getTime())
    }
    o(b, "isValidJsDate"), r.isValidJsDate = b;

    function R(M) {
        return !!M && (M.content !== void 0 || M.url !== void 0)
    }
    o(R, "hasBinaryDataInterface"), r.hasBinaryDataInterface = R;
    let L = 9007199254740991,
        V = -9007199254740991;

    function z(M) {
        let Oe = "",
            Ye = "";
        if (M.greaterThan(L)) Oe = "maximum", Ye = L.toString();
        else if (M.lessThan(V)) Oe = "minimum", Ye = V.toString();
        else return;
        let Xe = `Unable to convert ${M.toString()} to the Javascript Number type since exceeds the ${Oe} value allowed which is ${Ye}.`;
        throw new pe.NumberOverflowException(Xe)
    }
    o(z, "ensureNumberInsideBounds"), r.ensureNumberInsideBounds = z;

    function j(M) {
        if (M.decimalPlaces() > 16) {
            let Ye = `Unable to convert ${M.toString()} to the Javascript Number type because it will lead to precision loss. The maximum safe number of digits after the decimal point is 16.`;
            throw new pe.NumberOverflowException(Ye)
        }
    }
    o(j, "ensureNumberPrecision"), r.ensureNumberPrecision = j;
    let K = class K {
        static get None() {
            return ""
        }
        static get Minimum() {
            return "minimum"
        }
        static get Maximum() {
            return "maximum"
        }
    };
    o(K, "RangeBoundaries");
    let Y = K;

    function q(M, Oe, Ye, Xe) {
        return `Unable to convert ${M} to the ${Oe} type since it exceeds the ${Ye} value allowed which is ${Xe}.`
    }
    o(q, "makeBasicTypeExceedsLimitMessage");

    function P(M, Oe, Ye, Xe) {
        let de = Y.None,
            N = "",
            x = Math.max(Oe, V),
            U = Math.min(Ye, L);
        if (M < x) de = Y.Minimum, N = x.toString();
        else if (M > U) de = Y.Maximum, N = U.toString();
        else return;
        throw new pe.NumberOverflowException(q(M.toString(), Xe, de, N))
    }
    o(P, "ensureNumericPlatformTypeInsideBounds");

    function Z(M) {
        P(M, D.MIN_INTEGER_VALUE, D.MAX_INTEGER_VALUE, "Integer")
    }
    o(Z, "ensureIntegerInsideBounds"), r.ensureIntegerInsideBounds = Z;

    function oe(M) {
        P(M, D.MIN_LONGINTEGER_VALUE.toNumber(), D.MAX_LONGINTEGER_VALUE.toNumber(), "Long Integer")
    }
    o(oe, "ensureLongIntegerInsideBounds"), r.ensureLongIntegerInsideBounds = oe;

    function S(M) {
        P(M, D.MIN_DECIMAL_VALUE.toNumber(), D.MAX_DECIMAL_VALUE.toNumber(), "Decimal")
    }
    o(S, "ensureDecimalInsideBounds"), r.ensureDecimalInsideBounds = S
})(G || (G = {}));
var _se = Object.freeze({
        __proto__: null,
        BasicTypeKeyedTypeFactory: Bs,
        BasicTypeList: Mr,
        BasicVariableHolder: av,
        BinaryData: Or,
        BinaryDataList: sv,
        BooleanList: iv,
        Cache: yc,
        ComplexTypeKeyedTypeFactory: Qt,
        get Constants() {
            return D
        },
        CurrencyList: tv,
        get DataTypes() {
            return _
        },
        DateList: Jm,
        DateTime: me,
        DateTimeList: Zm,
        Decimal: Be,
        DecimalList: ev,
        EmailList: rv,
        get ErrorHandlerOutputType() {
            return FS
        },
        GenericRecord: Ce,
        GenericRecordList: _c,
        ImmutableBase: Ft,
        ImmutableListWithTracking: Xo,
        IntegerList: Ym,
        get JSONSerializeOutputType() {
            return kS
        },
        List: Ki,
        ListCache: Km,
        LongInteger: bt,
        LongIntegerList: Xm,
        PhoneNumberList: nv,
        Record: ur,
        RecordTypeFactory: Qd,
        RecordWithStaticConstructor: tt,
        TextList: ov,
        TimeList: Qm,
        TypeKeyedTypeFactory: ef,
        get TypeValidations() {
            return G
        },
        VariableHolder: MS,
        areBinaryNulls: vse,
        compare: Ty,
        defaultForType: Le,
        equals: Tn,
        mapDataTypeToName: UI
    }),
    $S = "Authorization",
    wse = o(r => {
        var e, t, n, {
            roles: i,
            auth: s = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance()
        } = r;
        if (!(s != null && s.isAuthenticated())) throw ee($S, "Not authorized: User is not logged in"), new pe.SecurityException("Not authorized", "User is not logged in");
        if (!i.find(a => a ? s.hasRole(a.roleKey) : !1)) throw ee($S, "Not authorized: No roles found on current user"), (n = (t = i[i.length - 1]) === null || t === void 0 ? void 0 : t.roleException) !== null && n !== void 0 ? n : new pe.SecurityException("Not authorized", "User doesn't have the required role")
    }, "ensureUserHasRole"),
    Tse = o(r => {
        var e, {
            roleKey: t,
            auth: n = (e = ge.resolve(J.Auth)) === null || e === void 0 ? void 0 : e.getInstance()
        } = r;
        return n != null && n.isAuthenticated() ? n.hasRole(t) : (ee($S, "Not authorized: User is not logged in"), !1)
    }, "hasRole"),
    Ese = Object.freeze({
        __proto__: null,
        ensureUserHasRole: wse,
        hasRole: Tse
    }),
    bse = "RolesInfo";

function Ik() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : D.FORMAT.defaultDateTimeFormat;
    return {
        year: parseInt(RegExp["$" + (r.yearIndexForDate + 1)], 10),
        month: parseInt(RegExp["$" + (r.monthIndexForDate + 1)], 10),
        day: parseInt(RegExp["$" + (r.dayIndexForDate + 1)], 10)
    }
}
o(Ik, "parseDateFromRx");

function Ck() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : D.FORMAT.defaultDateTimeFormat,
        e = parseInt(RegExp["$" + (r.secondsIndexForTime + 1)], 10);
    return {
        hours: parseInt(RegExp["$" + (r.hoursIndexForTime + 1)], 10),
        minutes: parseInt(RegExp["$" + (r.minutesIndexForTime + 1)], 10),
        seconds: isNaN(e) ? 0 : e
    }
}
o(Ck, "parseTimeFromRx");

function Rk() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : D.FORMAT.defaultDateTimeFormat,
        e = parseInt(RegExp["$" + (r.secondsIndexForDateTime + 1)], 10);
    return {
        year: parseInt(RegExp["$" + (r.yearIndexForDateTime + 1)], 10),
        month: parseInt(RegExp["$" + (r.monthIndexForDateTime + 1)], 10),
        day: parseInt(RegExp["$" + (r.dayIndexForDateTime + 1)], 10),
        hours: parseInt(RegExp["$" + (r.hoursIndexForDateTime + 1)], 10),
        minutes: parseInt(RegExp["$" + (r.minutesIndexForDateTime + 1)], 10),
        seconds: isNaN(e) ? 0 : e
    }
}
o(Rk, "parseDateTimeFromRx");

function Sse(r) {
    let e = r.abs();
    return e.isNaN() ? D.DEFAULT_DECIMAL : e
}
o(Sse, "abs");

function Ase(r, e) {
    let t = r.mod(e);
    return t.isNaN() ? D.DEFAULT_DECIMAL : t
}
o(Ase, "mod");

function Ise(r, e) {
    let t = r.pow(e);
    return t.isNaN() ? D.DEFAULT_DECIMAL : t
}
o(Ise, "power");

function Cse(r) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
        t = r.toDecimalPlaces(e);
    return t.isNaN() ? D.DEFAULT_DECIMAL : t
}
o(Cse, "round");

function Rse(r) {
    try {
        let e = r.sqrt();
        return e.isNaN() ? D.DEFAULT_DECIMAL : e
    } catch (e) {
        return D.DEFAULT_DECIMAL
    }
}
o(Rse, "sqrt");

function Ose(r) {
    let e = r.trunc();
    return e.isNaN() ? D.DEFAULT_DECIMAL : e
}
o(Ose, "trunc");

function Pse(r, e) {
    let t = Be.max(r, e);
    return t.isNaN() ? D.DEFAULT_DECIMAL : t
}
o(Pse, "max");

function Nse(r, e) {
    let t = Be.min(r, e);
    return t.isNaN() ? D.DEFAULT_DECIMAL : t
}
o(Nse, "min");

function Dse(r) {
    let e = new Be(0);
    return r.eq(e) || r.isNaN() ? D.DEFAULT_INTEGER : r > e ? 1 : -1
}
o(Dse, "sign");

function Lse(r) {
    return r >= 0 && r <= 65535 ? String.fromCharCode(r) : D.DEFAULT_TEXT
}
o(Lse, "chr");

function xse(r, e) {
    return (r || "") + (e || "")
}
o(xse, "concat");

function Use(r) {
    return r === void 0 ? "" : oie(aie(r)).replace(/\r/g, "").replace(/&#13;/g, "").replace(/\n/g, "<br/>").replace(/&#10;/g, "<br/>")
}
o(Use, "encodeHtml");

function Mse(r) {
    return r.replace(/\\/g, "\\x5c").replace(/'/g, "\\x27").replace(/\"/g, "\\x22").replace("&", "\\x26").replace("<", "\\x3c").replace(/>/g, "\\x3e").replace(/\r/g, "\\r").replace(/\n/g, "\\n")
}
o(Mse, "encodeJavascript");

function kse(r) {
    return encodeURIComponent(r).replace(/'/g, "%27").replace(/%20/g, "+")
}
o(kse, "encodeUrl");
var uv = "[\uD800-\uDBFF]",
    Ok = new RegExp(uv, "g");

function Fse(r, e, t, n, i) {
    var s;
    try {
        if (e.length === 0 || t < 0 || t > tf(r)) return -1;
        i && (r = r.toLocaleLowerCase(), e = e.toLocaleLowerCase());
        let a;
        t && t > 0 && (a = (s = r.match(new RegExp("(" + uv + ".|.){" + t + "}"))) === null || s === void 0 ? void 0 : s[0].length);
        let u = n ? r.lastIndexOf(e, a || r.length) : r.indexOf(e, a || 0);
        return u < 0 ? -1 : tf(r.substr(0, u))
    } catch (a) {
        return -1
    }
}
o(Fse, "index");

function tf(r) {
    let e = r.match(Ok);
    return r.length - (e ? e.length : 0)
}
o(tf, "length");

function $se(r, e, t) {
    let n = e.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
    return r.replace(new RegExp(n, "g"), t)
}
o($se, "replace");

function mm(r, e, t) {
    var n;
    let i = tf(r);
    if (e >= 0 && t > 0 && i > e) i = Math.min(i - e, t);
    else return D.DEFAULT_TEXT;
    let a = r.match(Ok) ? (n = r.match(new RegExp("(" + uv + ".|.){" + e + "}((" + uv + ".|.){" + i + "})"))) === null || n === void 0 ? void 0 : n[2] : r.substring(e, e + i);
    return a != null ? a : ""
}
o(mm, "substr");

function Bse(r) {
    return r.toLowerCase()
}
o(Bse, "toLower");

function Vse(r) {
    return r.toUpperCase()
}
o(Vse, "toUpper");

function Hse(r) {
    return r.trim()
}
o(Hse, "trim");

function jse(r) {
    let e = 0,
        t = " ";
    for (; r[e] === t;) e++;
    return r.substr(e)
}
o(jse, "trimStart");

function Wse(r) {
    let e = r.length - 1,
        t = " ";
    for (; r[e] === t;) e--;
    return r.substr(0, e + 1)
}
o(Wse, "trimEnd");

function Gse(r, e) {
    if (!e) return !1;
    let t = e.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&").replace(/%/g, "[\\s\\S]*").replace(/_/g, "[\\s\\S]");
    return RegExp(`^${t}$`, "gi").test(r)
}
o(Gse, "like");

function zse(r, e) {
    return r.addDays(e)
}
o(zse, "addDays");

function qse(r, e) {
    return r.addHours(e)
}
o(qse, "addHours");

function Kse(r, e) {
    return r.addMinutes(e)
}
o(Kse, "addMinutes");

function Yse(r, e) {
    return r.addSeconds(e)
}
o(Yse, "addSeconds");

function Xse(r, e) {
    return r.addYears(e)
}
o(Xse, "addYears");

function Jse(r, e) {
    return r.addMonths(e)
}
o(Jse, "addMonths");

function Zse(r, e) {
    return new me(r.year, r.month, r.day, e.hours, e.minutes, e.seconds, e.milliseconds)
}
o(Zse, "buildDateTime");

function Qse() {
    let r = new me(new Date);
    return new me(r.year, r.month, r.day)
}
o(Qse, "currDate");

function eoe() {
    return new me(new Date)
}
o(eoe, "currDateTime");

function toe() {
    let r = new me(new Date);
    return new me(1900, 1, 1, r.hours, r.minutes, r.seconds)
}
o(toe, "currTime");

function roe(r) {
    return r.weekDay
}
o(roe, "dayOfWeek");

function kx(r) {
    let e = new Date(r.getTime());
    return e.setMinutes(r.getMinutes() - r.getTimezoneOffset()), e.getTime()
}
o(kx, "toMilisecondsWithTimezoneOffset");

function Ey(r, e, t) {
    let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1,
        i = t <= 36e5,
        s = t <= 6e4,
        a = t <= 1e3,
        u = Fx(r, i, s, a).toNative(),
        l = Fx(e, i, s, a).toNative(),
        c = Date.UTC(u.getUTCFullYear(), u.getUTCMonth(), u.getUTCDate(), u.getUTCHours(), u.getUTCMinutes(), u.getUTCSeconds(), 0),
        d = Date.UTC(l.getUTCFullYear(), l.getUTCMonth(), l.getUTCDate(), l.getUTCHours(), l.getUTCMinutes(), l.getUTCSeconds(), 0),
        f = n ? kx(l) - kx(u) : d - c;
    return Math.floor(f / t)
}
o(Ey, "diff");

function Fx(r, e, t, n) {
    return new me(r.year, r.month, r.day, e ? r.hours : 0, t ? r.minutes : 0, n ? r.seconds : 0)
}
o(Fx, "fixTimePart");

function noe(r, e) {
    return Ey(r, e, 864e5, !0)
}
o(noe, "diffDays");

function ioe(r, e) {
    return Ey(r, e, 36e5)
}
o(ioe, "diffHours");

function soe(r, e) {
    return Ey(r, e, 6e4)
}
o(soe, "diffMinutes");

function ooe(r, e) {
    return Ey(r, e, 1e3)
}
o(ooe, "diffSeconds");

function aoe(r) {
    return r.year
}
o(aoe, "year");

function uoe(r) {
    return r.month
}
o(uoe, "month");

function coe(r) {
    return r.day
}
o(coe, "day");

function loe(r) {
    return r.hours
}
o(loe, "hour");

function doe(r) {
    return r.minutes
}
o(doe, "minute");

function foe(r) {
    return r.seconds
}
o(foe, "second");

function hoe(r, e, t) {
    return MI(r, e, t, 0, 0, 0) ? new me(r, e, t) : D.DEFAULT_DATE
}
o(hoe, "newDate");

function goe(r, e, t, n, i, s) {
    return MI(r, e, t, n, i, s) ? new me(r, e, t, n, i, s) : D.DEFAULT_DATETIME
}
o(goe, "newDateTime");

function poe(r, e, t) {
    return Pk(r, e, t) ? new me(1900, 1, 1, r, e, t) : D.DEFAULT_TIME
}
o(poe, "newTime");

function Pk(r, e, t) {
    let n = new me(1900, 1, 1, r, e, t);
    return n.hours === r && n.minutes === e && n.seconds === t
}
o(Pk, "validateTime");

function MI(r, e, t, n, i, s) {
    let a = new me(r, e, t, n, i, s);
    return a.year === r && a.month === e && a.day === t && a.hours === n && a.minutes === i && a.seconds === s
}
o(MI, "validateDateTime");

function Nk(r) {
    return r ? 1 : 0
}
o(Nk, "booleanToInteger");

function Dk(r) {
    return r ? bt.fromNumber(1) : bt.fromNumber(0)
}
o(Dk, "booleanToLongInteger");

function Lk(r) {
    return new Be(r ? 1 : 0)
}
o(Lk, "booleanToDecimal");

function kI(r) {
    return r === !0 ? "True" : r === !1 ? "False" : D.DEFAULT_TEXT
}
o(kI, "booleanToText");

function xk(r) {
    return new me(r.year, r.month, r.day)
}
o(xk, "dateTimeToDate");

function Uk(r) {
    return new me(1900, 1, 1, r.hours, r.minutes, r.seconds)
}
o(Uk, "dateTimeToTime");

function BS(r) {
    return r.toString(D.FORMAT.defaultDateTimeFormat.dateTimeFormat)
}
o(BS, "dateTimeToText");

function VS(r) {
    return r.toString(D.FORMAT.defaultDateTimeFormat.dateFormat)
}
o(VS, "dateToText");

function moe(r) {
    return r
}
o(moe, "dateToDateTime");

function voe(r) {
    return !r.eq(new Be(0))
}
o(voe, "decimalToBoolean");

function rf(r) {
    return G.isValidDecimal(r) ? r.toString() : D.DEFAULT_TEXT
}
o(rf, "decimalToText");

function by(r) {
    return r.gte(D.MIN_INTEGER_VALUE) && r.lte(D.MAX_INTEGER_VALUE)
}
o(by, "decimalToIntegerValidate");

function Mk(r) {
    return by(r) ? r.round().toNumber() : D.DEFAULT_INTEGER
}
o(Mk, "decimalToInteger");

function Pf(r) {
    return r.gte(D.MIN_LONGINTEGER_VALUE.toString()) && r.lte(D.MAX_LONGINTEGER_VALUE.toString())
}
o(Pf, "decimalToLongIntegerValidate");

function kk(r) {
    return Pf(r) ? bt.fromString(r.round().toString()) : D.DEFAULT_LONGINTEGER
}
o(kk, "decimalToLongInteger");

function yoe(r) {
    return new Be(r.toString())
}
o(yoe, "longIntegerToDecimal");

function Fk(r) {
    return G.isWithinIntegerRange(r.toNumber())
}
o(Fk, "longIntegerToIntegerValidate");

function _oe(r) {
    let e = r.toNumber();
    return G.isWithinIntegerRange(e) ? e : D.DEFAULT_INTEGER
}
o(_oe, "longIntegerToInteger");

function woe(r) {
    return r
}
o(woe, "longIntegerToIdentifier");

function FI(r) {
    return G.isValidLongInteger(r) ? r.toString() : D.DEFAULT_TEXT
}
o(FI, "longIntegerToText");

function Toe(r) {
    return r
}
o(Toe, "identifierToInteger");

function Eoe(r) {
    return r
}
o(Eoe, "identifierToLongInteger");

function boe(r) {
    return r
}
o(boe, "identifierToText");

function Soe(r) {
    return bt.fromNumber(r)
}
o(Soe, "integerToLongInteger");

function Aoe(r) {
    return r
}
o(Aoe, "integerToIdentifier");

function Ioe(r) {
    return r !== 0
}
o(Ioe, "integerToBoolean");

function $k(r) {
    return G.isValidInteger(r) ? r.toString() : D.DEFAULT_TEXT
}
o($k, "integerToText");

function Coe(r) {
    return new Be(r)
}
o(Coe, "integerToDecimal");

function Roe() {
    return 0
}
o(Roe, "nullIdentifier");

function Ooe() {
    return ""
}
o(Ooe, "nullTextIdentifier");

function Poe() {
    return D.DEFAULT_DATE
}
o(Poe, "nullDate");

function Noe() {
    return null
}
o(Noe, "nullObject");

function Doe() {
    return D.DEFAULT_BINARYDATA
}
o(Doe, "nullBinary");

function Bk(r, e) {
    let t = e.getRegExpForDate().test(r);
    if (t) {
        let n = Ik(e),
            i = new me(n.year, n.month, n.day);
        t = i.year === n.year && i.month === n.month && i.day === n.day
    }
    return t
}
o(Bk, "internalTextToDateValidate");

function Loe(r, e) {
    if (!Bk(r, e)) return me.defaultValue;
    let t = Ik(e);
    return new me(t.year, t.month, t.day)
}
o(Loe, "internalTextToDate");

function Vk(r, e) {
    let t = e.getRegExpForDateTime().test(r);
    if (t) {
        let n = Rk(e);
        t = MI(n.year, n.month, n.day, n.hours, n.minutes, n.seconds)
    }
    return t
}
o(Vk, "internalTextToDateTimeValidate");

function xoe(r, e) {
    if (!Vk(r, e)) return me.defaultValue;
    let t = Rk(e);
    return new me(t.year, t.month, t.day, t.hours, t.minutes, t.seconds)
}
o(xoe, "internalTextToDateTime");

function Nf(r) {
    return /^\d{4}-\d{2}-\d{2}(?:T|t)\d{2}:\d{2}(:\d{2}(?:\.\d+)?)?(?:Z|[+-]\d{2}:\d{2})?$/.test(r)
}
o(Nf, "isISODateTime");

function Sy(r) {
    return r.indexOf(" ") !== -1
}
o(Sy, "isSpaceSeparatedDateTime");

function Hk(r) {
    let e = r.toUpperCase().search("T| ");
    return e !== -1 && (r = r.substring(0, e)), r
}
o(Hk, "getDateFromDateTime");

function jk(r) {
    let e = D.FORMAT.dateTimeFormats;
    r = Hk(r);
    for (let t = 0; t < e.length; ++t)
        if (Bk(r, e[t])) return !0;
    return !1
}
o(jk, "textToDateValidate");

function HS(r) {
    let e = D.FORMAT.dateTimeFormats;
    r = Hk(r);
    for (let t = 0; t < e.length; ++t) {
        let n = Loe(r, e[t]);
        if (!n.eq(me.defaultValue)) return n
    }
    return me.defaultValue
}
o(HS, "textToDate");

function Wk(r) {
    return Nf(r) ? !isNaN(Date.parse(r)) : !0
}
o(Wk, "ISODateTimeValidate");

function Gk(r) {
    let e = D.FORMAT.dateTimeFormats;
    if (Nf(r)) return Wk(r);
    Sy(r) || (r += " 00:00:00");
    for (let t = 0; t < e.length; ++t)
        if (Vk(r, e[t])) return !0;
    return !1
}
o(Gk, "textToDateTimeValidate");

function jS(r) {
    let e = D.FORMAT.dateTimeFormats;
    if (Nf(r)) return me.fromISODateTime(r);
    Sy(r) || (r += " 00:00:00");
    for (let t = 0; t < e.length; ++t) {
        let n = xoe(r, e[t]);
        if (!n.eq(me.defaultValue)) return n
    }
    return me.defaultValue
}
o(jS, "textToDateTime");

function zk(r) {
    let e = r.indexOf(" ");
    return e !== -1 && (r = r.substring(e + 1, r.length)), r
}
o(zk, "getTimeFromSpaceSeparatedDateTime");

function $I(r) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : D.FORMAT.defaultDateTimeFormat;
    if (Nf(r)) return Wk(r);
    Sy(r) && (r = zk(r));
    let t = e.getRegExpForTime().test(r);
    if (t) {
        let n = Ck(e);
        t = Pk(n.hours, n.minutes, n.seconds)
    }
    return t
}
o($I, "textToTimeValidate");

function qk(r) {
    if (Nf(r)) {
        let e = me.fromISODateTime(r);
        return new me(1900, 1, 1, e.hours, e.minutes, e.seconds, e.milliseconds)
    }
    return Sy(r) && (r = zk(r)), Uoe(r, D.FORMAT.defaultDateTimeFormat)
}
o(qk, "textToTime");

function Uoe(r, e) {
    if (!$I(r, e)) return me.defaultValue;
    let t = Ck(e);
    return new me(1900, 1, 1, t.hours, t.minutes, t.seconds)
}
o(Uoe, "internalTextToTime");

function WS(r) {
    return r.toString(D.FORMAT.defaultDateTimeFormat.timeFormat)
}
o(WS, "timeToText");

function Kk(r) {
    if (D.FORMAT.numberFormat.getRegExpForInteger().test(r)) {
        let e = parseInt(r, 10);
        if (!isNaN(e) && e >= D.MIN_INTEGER_VALUE && e <= D.MAX_INTEGER_VALUE) return e
    }
    return null
}
o(Kk, "tryParseInteger");

function Yk(r) {
    if (D.FORMAT.numberFormat.getRegExpForDecimal().test(r)) {
        let e = new Be(r);
        if (!e.isNaN() && e.gte(D.MIN_DECIMAL_VALUE) && e.lte(D.MAX_DECIMAL_VALUE)) return e
    }
    return null
}
o(Yk, "tryParseDecimal");

function Xk(r) {
    if (!D.FORMAT.numberFormat.getRegExpForInteger().test(r)) return null;
    let e = r.charAt(0) === "-";
    if (e && r.length < D.MIN_LONGINTEGER_VALUE.toString().length || !e && r.length < D.MAX_LONGINTEGER_VALUE.toString().length || Pf(new Be(r))) try {
        return bt.fromString(r)
    } catch (t) {}
    return null
}
o(Xk, "tryParseLongInteger");

function Jk(r) {
    return Yk(r) !== null
}
o(Jk, "textToDecimalValidate");

function Zk(r) {
    return Yk(r) === null ? D.DEFAULT_DECIMAL : new Be(r)
}
o(Zk, "textToDecimal");

function Qk(r) {
    return Kk(r) !== null
}
o(Qk, "textToIntegerValidate");

function eF(r) {
    let e = Kk(r);
    return e === null ? D.DEFAULT_INTEGER : e
}
o(eF, "textToInteger");

function tF(r) {
    return Xk(r) !== null
}
o(tF, "textToLongIntegerValidate");

function rF(r) {
    let e = Xk(r);
    return e === null ? D.DEFAULT_LONGINTEGER : e
}
o(rF, "textToLongInteger");

function nF(r) {
    return r.toLowerCase() === "true"
}
o(nF, "textToBoolean");

function Moe(r) {
    return r
}
o(Moe, "textToIdentifier");

function vm(r) {
    if (typeof r == "number" || G.isLongInteger(r) || G.isDecimal(r)) return new Be(r.toString()).round().toNumber();
    throw new TypeError("Cannot convert type '" + typeof r + "' to 'Integer'")
}
o(vm, "objectToInteger");

function ym(r) {
    if (typeof r == "number" || G.isLongInteger(r) || G.isDecimal(r)) return bt.fromString(new Be(r.toString()).round().toString());
    throw new TypeError("Cannot convert type '" + typeof r + "' to 'LongInteger'")
}
o(ym, "objectToLongInteger");

function koe(r) {
    if (typeof r == "boolean") return r;
    throw new TypeError("Cannot convert type '" + typeof r + "' to 'Boolean'")
}
o(koe, "objectToBoolean");

function _m(r) {
    if (typeof r == "number" || G.isLongInteger(r) || G.isDecimal(r)) return new Be(r.toString());
    throw new TypeError("Cannot convert type '" + typeof r + "' to 'Decimal'")
}
o(_m, "objectToDecimal");

function Foe(r) {
    if (typeof r == "string") return r;
    throw new TypeError("Cannot convert type '" + typeof r + "' to 'Text'")
}
o(Foe, "objectToText");

function $oe(r) {
    return BI(r, !0, !1)
}
o($oe, "objectToDate");

function Boe(r) {
    return BI(r, !1, !0)
}
o(Boe, "objectToTime");

function Voe(r) {
    return BI(r, !0, !0)
}
o(Voe, "objectToDateTime");

function BI(r, e, t) {
    if (r instanceof me || Object.prototype.toString.call(r) === "[object Date]") {
        let n = new me(r.getTime()),
            i = e ? n.year : 1900,
            s = e ? n.month : 1,
            a = e ? n.day : 1,
            u = t ? n.hours : 0,
            l = t ? n.minutes : 0,
            c = t ? n.seconds : 0;
        return new me(i, s, a, u, l, c)
    }
    throw new TypeError("Cannot convert type '" + typeof r + "' to 'DateTime'")
}
o(BI, "convertObjectToDateTime");

function Hoe(r) {
    return r
}
o(Hoe, "toObject");

function joe(r, e) {
    return r.toString(e)
}
o(joe, "formatDateTime");

function Woe(r, e, t, n, i) {
    let s = iF(r, t, n, i);
    return s === D.DEFAULT_TEXT ? D.DEFAULT_TEXT : e + s
}
o(Woe, "formatCurrency");

function iF(r, e, t, n) {
    return e < 0 ? D.DEFAULT_TEXT : (t.length > 1 && (t = t.substr(0, 1)), n.length > 1 && (n = n.substr(0, 1)), r.toFormat(e, Be.rounding, {
        decimalSeparator: t,
        groupSeparator: n
    }))
}
o(iF, "formatDecimal");

function Goe(r, e, t) {
    try {
        return e < 0 ? "" : (t.length > 1 && (t = t.substr(0, 1)), r.times(100).toFormat(e, Be.rounding, {
            decimalSeparator: t,
            groupSeparator: ""
        }) + "%")
    } catch (n) {
        return ""
    }
}
o(Goe, "formatPercent");

function zoe(r, e, t, n, i, s, a) {
    try {
        return !/^\d+$/.test(r) || r.length !== e + t + n ? r : i + r.substr(0, e) + s + r.substr(e, t) + a + r.substr(e + t, n)
    } catch (u) {
        return ""
    }
}
o(zoe, "formatPhoneNumber");

function qoe(r, e, t, n, i) {
    try {
        let s = tf(r);
        if (s < e) {
            i = mm(i, 0, 1);
            let a = e - s;
            for (; a-- > 0;) n ? r = i + r : r = r + i;
            return r
        }
        return s > t ? n ? mm(r, s - t, t) : mm(r, 0, t) : r
    } catch (s) {
        return ""
    }
}
o(qoe, "formatText");
var VI = "[a-zA-Z0-9.!#$%&'*+\\-/=?^_`{|}~]+@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*",
    sF = "([0-9a-zA-Z\\\\= ]*|=\\?([^?]*)\\?([qQbB])\\?([^?]*)\\?=)",
    Koe = new RegExp("^" + VI + "$"),
    Yoe = new RegExp("^" + sF + "[ ]*<" + VI + ">$"),
    Xoe = new RegExp('^\\"' + sF + '\\"[ ]*<' + VI + ">$");

function Joe(r) {
    return r === "" ? !0 : /\.@/.test(r) ? !1 : Koe.test(r) || Yoe.test(r) || Xoe.test(r)
}
o(Joe, "emailAddressValidate");

function Zoe() {
    let {
        localeService: r = Lc(J.LocaleService)
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return r ? r.getCurrentLocale() : D.DEFAULT_TEXT
}
o(Zoe, "getCurrentLocale");

function Qoe() {
    return navigator.userAgent
}
o(Qoe, "getUserAgent");

function eae() {
    return ry()
}
o(eae, "getAppName");

function tae() {
    return window.location.href
}
o(tae, "getBookmarkableURL");

function rae() {
    return Fs()
}
o(rae, "getOwnerURLPath");

function nae() {
    let r = Wo();
    return ee(bse, `Checking User's ID: ${r}`), r
}
o(nae, "getUserId");

function iae(r, e, t) {
    return r ? e : t
}
o(iae, "iif");
var HI = Object.freeze({
        __proto__: null,
        abs: Sse,
        addDays: zse,
        addHours: qse,
        addMinutes: Kse,
        addMonths: Jse,
        addSeconds: Yse,
        addYears: Xse,
        booleanToDecimal: Lk,
        booleanToInteger: Nk,
        booleanToLongInteger: Dk,
        booleanToText: kI,
        buildDateTime: Zse,
        chr: Lse,
        concat: xse,
        currDate: Qse,
        currDateTime: eoe,
        currTime: toe,
        dateTimeToDate: xk,
        dateTimeToText: BS,
        dateTimeToTime: Uk,
        dateToDateTime: moe,
        dateToText: VS,
        day: coe,
        dayOfWeek: roe,
        decimalToBoolean: voe,
        decimalToInteger: Mk,
        decimalToIntegerValidate: by,
        decimalToLongInteger: kk,
        decimalToLongIntegerValidate: Pf,
        decimalToText: rf,
        diffDays: noe,
        diffHours: ioe,
        diffMinutes: soe,
        diffSeconds: ooe,
        emailAddressValidate: Joe,
        encodeHtml: Use,
        encodeJavascript: Mse,
        encodeUrl: kse,
        formatCurrency: Woe,
        formatDateTime: joe,
        formatDecimal: iF,
        formatPercent: Goe,
        formatPhoneNumber: zoe,
        formatText: qoe,
        getAppName: eae,
        getBookmarkableURL: tae,
        getCurrentLocale: Zoe,
        getOwnerURLPath: rae,
        getUserAgent: Qoe,
        getUserId: nae,
        hour: loe,
        identifierToInteger: Toe,
        identifierToLongInteger: Eoe,
        identifierToText: boe,
        iif: iae,
        index: Fse,
        integerToBoolean: Ioe,
        integerToDecimal: Coe,
        integerToIdentifier: Aoe,
        integerToLongInteger: Soe,
        integerToText: $k,
        length: tf,
        like: Gse,
        longIntegerToDecimal: yoe,
        longIntegerToIdentifier: woe,
        longIntegerToInteger: _oe,
        longIntegerToIntegerValidate: Fk,
        longIntegerToText: FI,
        max: Pse,
        min: Nse,
        minute: doe,
        mod: Ase,
        month: uoe,
        newDate: hoe,
        newDateTime: goe,
        newTime: poe,
        nullBinary: Doe,
        nullDate: Poe,
        nullIdentifier: Roe,
        nullObject: Noe,
        nullTextIdentifier: Ooe,
        objectToBoolean: koe,
        objectToDate: $oe,
        objectToDateTime: Voe,
        objectToDecimal: _m,
        objectToInteger: vm,
        objectToLongInteger: ym,
        objectToText: Foe,
        objectToTime: Boe,
        power: Ise,
        replace: $se,
        round: Cse,
        second: foe,
        sign: Dse,
        sqrt: Rse,
        substr: mm,
        textToBoolean: nF,
        textToDate: HS,
        textToDateTime: jS,
        textToDateTimeValidate: Gk,
        textToDateValidate: jk,
        textToDecimal: Zk,
        textToDecimalValidate: Jk,
        textToIdentifier: Moe,
        textToInteger: eF,
        textToIntegerValidate: Qk,
        textToLongInteger: rF,
        textToLongIntegerValidate: tF,
        textToTime: qk,
        textToTimeValidate: $I,
        timeToText: WS,
        toLower: Bse,
        toObject: Hoe,
        toUpper: Vse,
        trim: Hse,
        trimEnd: Wse,
        trimStart: jse,
        trunc: Ose,
        year: aoe
    }),
    GS;
(function(r) {
    r[r.TEXT = 0] = "TEXT", r[r.BINARY_DATA = 1] = "BINARY_DATA", r[r.BOOLEAN = 2] = "BOOLEAN", r[r.INTEGER = 3] = "INTEGER", r[r.LONGINTEGER = 4] = "LONGINTEGER", r[r.DECIMAL = 5] = "DECIMAL", r[r.DATE_TIME = 6] = "DATE_TIME", r[r.DATE = 7] = "DATE", r[r.TIME = 8] = "TIME", r[r.UNKNOWN = 9] = "UNKNOWN"
})(GS || (GS = {}));
var re = GS,
    oF = {
        [_.Integer]: re.INTEGER,
        [_.LongInteger]: re.LONGINTEGER,
        [_.Decimal]: re.DECIMAL,
        [_.Currency]: re.DECIMAL,
        [_.Text]: re.TEXT,
        [_.PhoneNumber]: re.TEXT,
        [_.Email]: re.TEXT,
        [_.Boolean]: re.BOOLEAN,
        [_.Date]: re.DATE,
        [_.DateTime]: re.DATE_TIME,
        [_.Time]: re.TIME,
        [_.Record]: re.UNKNOWN,
        [_.RecordList]: re.UNKNOWN,
        [_.BinaryData]: re.BINARY_DATA,
        [_.Object]: re.UNKNOWN
    };

function Jo(r) {
    switch (r) {
        case re.INTEGER:
        case re.LONGINTEGER:
        case re.DECIMAL:
        case re.TEXT:
        case re.BOOLEAN:
        case re.DATE:
        case re.DATE_TIME:
        case re.TIME:
        case re.BINARY_DATA:
            return Le(wc(r));
        default:
            throw new pe.DataBaseException("", `Unable to determine default value for type ${jI(r)}`)
    }
}
o(Jo, "typeDefaultValue");

function wc(r) {
    switch (r) {
        case re.TEXT:
            return _.Text;
        case re.BINARY_DATA:
            return _.BinaryData;
        case re.BOOLEAN:
            return _.Boolean;
        case re.DATE:
            return _.Date;
        case re.DATE_TIME:
            return _.DateTime;
        case re.TIME:
            return _.Time;
        case re.DECIMAL:
            return _.Decimal;
        case re.INTEGER:
            return _.Integer;
        case re.LONGINTEGER:
            return _.LongInteger;
        default:
            throw new Error(`Missing case for conversion of DB data type '${r}' to a model data type.`)
    }
}
o(wc, "convertToModelDataType");

function jI(r) {
    let e = wc(r);
    return _[e]
}
o(jI, "typeDisplayName");

function $x(r) {
    let e = oF[r];
    return e != null ? e : re.UNKNOWN
}
o($x, "convertDataTypeToDBDataType");

function WI(r) {
    return !!r.isGenericRecordType
}
o(WI, "isGenericRecordType");

function GI(r) {
    return !!r.isGenericRecordListType
}
o(GI, "isGenericRecordListType");

function aF(r) {
    return !!r.isBasicTypeListType
}
o(aF, "isBasicTypeListType");
var Tc;
(function(r) {
    function e(c, d, f) {
        let h = c.getAttributes();
        return h.reduce((g, p, m) => (p.ignoreForServer || (p.dataType === _.Record || p.dataType === _.RecordList ? g[p.name] = n(c[p.attrName], d, p.optimizeList && f) : p.dataType !== _.Object && (g[p.name] = u(c[p.attrName], h[m].dataType))), g), {})
    }
    o(e, "serializeRecord");

    function t(c, d, f) {
        let h = c.constructor.getItemType(),
            g = {
                List: []
            };
        if (!f || !d)
            for (let p = 0; p < c.length; p++) g.List.push(n(c.getItem(p), h));
        else if (c.length > 0 && d) {
            let p = d.iterationContext.getCurrentRowNumber(c);
            g.List.push(n(c.getItem(p), h, d, f))
        }
        return c.isEmpty && (g.EmptyListItem = n(c.emptyListItem, h, d, f)), g
    }
    o(t, "serializeList");

    function n(c) {
        let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _.Record,
            f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
            h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
        if (c == null) return;
        let g = _.Record,
            p;
        if (typeof d != "number" ? (h = f === !0, p = d, g = _.Record) : (g = d, typeof f != "boolean" && (p = f)), c instanceof Ce) return e(c, p, h);
        if (c instanceof Ki) return t(c, p, h);
        if (g !== _.Object) return u(c, g)
    }
    o(n, "to"), r.to = n;

    function i(c, d) {
        let f = c != null ? c : {},
            h = d.getAttributes(),
            g = h.reduce((p, m, w) => (m.dataType === _.Record || m.dataType === _.RecordList ? p[m.attrName] = Ce.getData(a(f[m.name], h[w].complexType)) : m.dataType === _.BinaryData ? p[m.attrName] = l({
                content: f[m.name],
                url: f[`_${m.name}URL`]
            }, h[w].dataType) : p[m.attrName] = l(f[m.name], h[w].dataType), p), {});
        return new d(new d.RecordClass(g))
    }
    o(i, "deserializeRecord");

    function s(c, d) {
        if (d.getItemType() === void 0 || d.getItemType() === null) throw Error("A List can only be deserialized if its ItemType is defined.");
        let f = d,
            h = new f;
        return c.List.length === 0 ? h.emptyListItem = a(c.EmptyListItem, d.getItemType()) : h.pushAll(c.List.map(g => a(g, d.getItemType()))), h
    }
    o(s, "deserializeList");

    function a(c, d) {
        return WI(d) ? i(c, d) : GI(d) || aF(d) ? s(c, d) : l(c, d)
    }
    o(a, "from"), r.from = a;

    function u(c, d) {
        switch (d) {
            case _.Integer:
                return c;
            case _.LongInteger:
                return FI(c);
            case _.Decimal:
            case _.Currency:
                return rf(c);
            case _.Text:
            case _.PhoneNumber:
            case _.Email:
                return c;
            case _.Date:
                return c.toISODate();
            case _.DateTime:
                return c.toString();
            case _.Time:
                return c.toISOTime();
            case _.Boolean:
                return c;
            case _.Record:
            case _.RecordList:
                throw new TypeError("Records and Record lists are not basic types");
            case _.BinaryData:
                return typeof c == "string" ? c : c.content;
            case _.Object:
                return c;
            default:
                return c
        }
    }
    o(u, "basicTypeToJS");

    function l(c, d) {
        switch (d) {
            case _.Integer:
                return G.ensureIntegerInsideBounds(c), c | 0;
            case _.LongInteger:
                return typeof c == "string" ? bt.fromString(c) : bt.fromNumber(c);
            case _.Decimal:
            case _.Currency:
                return new Be(c || "0");
            case _.Boolean:
                return typeof c == "string" ? nF(c) : c;
            case _.Text:
            case _.PhoneNumber:
            case _.Email:
                return c === void 0 ? "" : c + "";
            case _.Date:
                return c instanceof Date ? new me(c) : me.fromISODate(c);
            case _.DateTime:
                return c instanceof Date ? new me(c) : me.fromISODateTime(c);
            case _.Time:
                return c instanceof Date ? new me(c) : me.fromISOTime(c);
            case _.Record:
            case _.RecordList:
                throw new TypeError("Records and Record lists are not basic types");
            case _.BinaryData:
                return G.hasBinaryDataInterface(c) ? new Or(c.content, c.url) : new Or(c);
            case _.Object:
                return c;
            default:
                return c
        }
    }
    o(l, "jsToBasicType")
})(Tc || (Tc = {}));
var Vs;
(function(r) {
    function e(S) {
        return G.isValidJsNumber(S) && S >= D.MIN_INTEGER_VALUE && S <= D.MAX_INTEGER_VALUE ? !0 : G.isLongInteger(S) ? Fk(S) : G.isDecimal(S) ? by(S) : G.isText(S) ? Qk(S) : !!G.isBoolean(S)
    }
    o(e, "isConvertibleToInteger");

    function t(S) {
        return G.isValidJsNumber(S) || G.isValidLongInteger(S) ? !0 : G.isValidDecimal(S) ? Pf(S) : G.isText(S) ? tF(S) : !!G.isBoolean(S)
    }
    o(t, "isConvertibleToLongInteger");

    function n(S) {
        return G.isValidJsNumber(S) || G.isValidDecimal(S) && D.MIN_DECIMAL_VALUE.lte(S) && D.MAX_DECIMAL_VALUE.gte(S) || G.isValidLongInteger(S) ? !0 : G.isText(S) ? Jk(S) : !!G.isBoolean(S)
    }
    o(n, "isConvertibleToDecimal");

    function i(S) {
        return n(S)
    }
    o(i, "isConvertibleToCurrency");

    function s(S) {
        return G.isJsNumber(S) ? G.isValidJsNumber(S) : G.isLongInteger(S) ? G.isValidLongInteger(S) : G.isDecimal(S) ? G.isValidDecimal(S) : G.isText(S) || G.isBoolean(S) ? !0 : G.isDateTime(S) ? G.isValidDateTime(S) : G.isJsDate(S) ? G.isValidJsDate(S) : !1
    }
    o(s, "isConvertibleToText");

    function a(S) {
        return s(S)
    }
    o(a, "isConvertibleToPhoneNumber");

    function u(S) {
        return s(S)
    }
    o(u, "isConvertibleToEmail");

    function l(S) {
        return G.isJsNumber(S) ? G.isValidJsNumber(S) : G.isLongInteger(S) ? G.isValidLongInteger(S) : G.isDecimal(S) ? G.isValidDecimal(S) : G.isText(S) ? /^(true|false)$/gi.test(S) : !!G.isBoolean(S)
    }
    o(l, "isConvertibleToBoolean");

    function c(S) {
        if (G.isValidDateTime(S) && S.gte(D.MIN_DATE_VALUE) && S.lte(D.MAX_DATE_VALUE)) return !0;
        if (G.isValidJsDate(S) && new me(S).gte(D.MIN_DATE_VALUE) && new me(S).lte(D.MAX_DATE_VALUE)) return !0;
        if (G.isText(S))
            if (D.ISO_DATE_FORMAT_REGEXP.test(S)) {
                let K = new me(new Date(S));
                return K.gte(D.MIN_DATE_VALUE) && K.lte(D.MAX_DATE_VALUE)
            } else if (jk(S)) {
            let K = HS(S);
            return K.gte(D.MIN_DATE_VALUE) && K.lte(D.MAX_DATE_VALUE)
        } else return !1;
        return !1
    }
    o(c, "isConvertibleToDate");

    function d(S) {
        return G.isValidDateTime(S) || G.isValidJsDate(S) ? !0 : G.isText(S) ? D.RFC3339_TIMEPART.test(S) || D.ISO_DATE_FORMAT_REGEXP.test(S) ? !0 : $I(S) : !1
    }
    o(d, "isConvertibleToTime");

    function f(S) {
        if (G.isValidDateTime(S) && S.gte(D.MIN_DATETIME_VALUE) && S.lte(D.MAX_DATETIME_VALUE)) return !0;
        if (G.isValidJsDate(S) && new me(S).gte(D.MIN_DATETIME_VALUE) && new me(S).lte(D.MAX_DATETIME_VALUE)) return !0;
        if (G.isText(S))
            if (D.ISO_DATE_FORMAT_REGEXP.test(S)) {
                let K = new me(new Date(S));
                return K.gte(D.MIN_DATETIME_VALUE) && K.lte(D.MAX_DATETIME_VALUE)
            } else if (Gk(S)) {
            let K = jS(S);
            return K.gte(D.MIN_DATETIME_VALUE) && K.lte(D.MAX_DATETIME_VALUE)
        } else return !1;
        return !1
    }
    o(f, "isConvertibleToDateTime");

    function h(S) {
        return G.isBinaryData(S)
    }
    o(h, "isConvertibleToBinaryData");

    function g(S, K) {
        switch (K) {
            case _.Integer:
                return e(S);
            case _.LongInteger:
                return t(S);
            case _.Decimal:
                return n(S);
            case _.Currency:
                return i(S);
            case _.Text:
                return s(S);
            case _.PhoneNumber:
                return a(S);
            case _.Email:
                return u(S);
            case _.Boolean:
                return l(S);
            case _.Date:
                return c(S);
            case _.Time:
                return d(S);
            case _.DateTime:
                return f(S);
            case _.BinaryData:
                return h(S);
            default:
                return !1
        }
    }
    o(g, "isConvertibleTo"), r.isConvertibleTo = g;

    function p(S) {
        return G.isValidJsNumber(S) && S === D.DEFAULT_INTEGER || G.isValidLongInteger(S) && S.equals(D.DEFAULT_LONGINTEGER) || G.isValidDecimal(S) && S.equals(D.DEFAULT_DECIMAL) || G.isText(S) && S === D.DEFAULT_TEXT || G.isBoolean(S) && S === D.DEFAULT_BOOLEAN || G.isValidDateTime(S) && S.equals(D.DEFAULT_DATETIME)
    }
    o(p, "isDefault"), r.isDefault = p;

    function m(S) {
        if (e(S)) {
            if (G.isJsNumber(S)) return vm(S);
            if (G.isLongInteger(S)) return vm(S);
            if (G.isDecimal(S)) return vm(S);
            if (G.isText(S) && S !== "") return eF(S);
            if (G.isBoolean(S)) return Nk(S)
        }
        return D.DEFAULT_INTEGER
    }
    o(m, "convertToInteger");

    function w(S) {
        if (t(S)) {
            if (G.isJsNumber(S)) return ym(S);
            if (G.isLongInteger(S)) return ym(S);
            if (G.isDecimal(S)) return ym(S);
            if (G.isText(S) && S !== "") return rF(S);
            if (G.isBoolean(S)) return Dk(S)
        }
        return D.DEFAULT_LONGINTEGER
    }
    o(w, "convertToLongInteger");

    function T(S) {
        if (n(S)) {
            if (G.isJsNumber(S)) return _m(S);
            if (G.isLongInteger(S)) return _m(S);
            if (G.isDecimal(S)) return _m(S);
            if (G.isText(S) && S !== "") return Zk(S);
            if (G.isBoolean(S)) return Lk(S)
        }
        return D.DEFAULT_DECIMAL
    }
    o(T, "convertToDecimal");

    function E(S) {
        return T(S)
    }
    o(E, "convertToCurrency");

    function b(S) {
        if (s(S)) {
            if (G.isJsNumber(S)) return G.isValidInteger(S) ? $k(S) : rf(new Be(S));
            if (G.isLongInteger(S)) return FI(S);
            if (G.isDecimal(S)) return rf(S);
            if (G.isText(S)) return S;
            if (G.isBoolean(S)) return kI(S);
            if (G.isValidDate(S)) return VS(S);
            if (G.isValidTime(S)) return WS(S);
            if (G.isDateTime(S)) return BS(S);
            if (G.isJsDate(S)) {
                let K = new me(S);
                return G.isValidDate(K) ? VS(K) : G.isValidTime(K) ? WS(K) : BS(K)
            }
        }
        return D.DEFAULT_TEXT
    }
    o(b, "convertToText");

    function R(S) {
        return b(S)
    }
    o(R, "convertToPhoneNumber");

    function L(S) {
        return u(S) && G.isText(S) ? S : D.DEFAULT_EMAIL
    }
    o(L, "convertToEmail");

    function V(S) {
        if (l(S)) {
            if (G.isJsNumber(S)) return S !== 0;
            if (G.isLongInteger(S)) return !S.eq(0);
            if (G.isDecimal(S)) return !S.eq(0);
            if (G.isText(S) && S !== "") return !/^(false)$/gi.test(S);
            if (G.isBoolean(S)) return S
        }
        return D.DEFAULT_BOOLEAN
    }
    o(V, "convertToBoolean");

    function z(S) {
        if (c(S)) {
            if (G.isDateTime(S)) {
                let K = S;
                return new me(K.year, K.month, K.day)
            } else if (G.isJsDate(S)) {
                let K = S;
                return new me(K.getFullYear(), K.getMonth() + 1, K.getDate())
            } else if (G.isText(S) && S !== "") return D.RFC3339_DATEPART.test(S) ? me.fromISODate(S) : D.ISO_DATE_FORMAT_REGEXP.test(S) ? xk(me.fromISODateTime(S)) : HS(S)
        }
        return D.DEFAULT_DATE
    }
    o(z, "convertToDate");

    function j(S) {
        if (d(S)) {
            if (G.isDateTime(S)) {
                let K = S;
                return new me(null, null, null, K.hours, K.minutes, K.seconds, K.milliseconds)
            } else if (G.isJsDate(S)) {
                let K = S;
                return new me(null, null, null, K.getHours(), K.getMinutes(), K.getSeconds())
            } else if (G.isText(S) && S !== "") return D.RFC3339_TIMEPART.test(S) ? me.fromISOTime(S) : D.ISO_DATE_FORMAT_REGEXP.test(S) ? Uk(me.fromISODateTime(S)) : qk(S)
        }
        return D.DEFAULT_TIME
    }
    o(j, "convertToTime");

    function Y(S) {
        if (f(S)) {
            if (G.isDateTime(S)) {
                let K = S;
                return new me(K.year, K.month, K.day, K.hours, K.minutes, K.seconds, K.milliseconds)
            } else if (G.isJsDate(S)) {
                let K = S;
                return new me(K)
            } else if (G.isText(S) && S !== "") return D.ISO_DATE_FORMAT_REGEXP.test(S) ? me.fromISODateTime(S) : jS(S)
        }
        return D.DEFAULT_DATETIME
    }
    o(Y, "convertToDateTime");

    function q(S) {
        return S
    }
    o(q, "convertToBinaryData");

    function P(S, K) {
        switch (K) {
            case _.Integer:
                return m(S);
            case _.LongInteger:
                return w(S);
            case _.Decimal:
                return T(S);
            case _.Currency:
                return E(S);
            case _.Text:
                return b(S);
            case _.PhoneNumber:
                return R(S);
            case _.Email:
                return L(S);
            case _.Boolean:
                return V(S);
            case _.Date:
                return z(S);
            case _.Time:
                return j(S);
            case _.DateTime:
                return Y(S);
            case _.BinaryData:
                return S;
            default:
                return null
        }
    }
    o(P, "convertTo"), r.convertTo = P;

    function Z(S, K, M) {
        return M(S, K)
    }
    o(Z, "typeConvertRecord"), r.typeConvertRecord = Z;

    function oe(S, K, M) {
        let Oe = 0;
        for (; Oe < S.length;) K.append(M(S.getItem(Oe), K.newItem())), Oe++;
        return K
    }
    o(oe, "typeConvertRecordList"), r.typeConvertRecordList = oe
})(Vs || (Vs = {}));
var zS;
(function(r) {
    function e(P) {
        return P - P % 1
    }
    o(e, "trunc");

    function t(P, Z) {
        return g.get(Z)(P)
    }
    o(t, "to"), r.to = t;

    function n(P, Z) {
        return q.get(Z)(P, Z)
    }
    o(n, "from"), r.from = n;

    function i(P) {
        return P
    }
    o(i, "integerToJSNodeParam");

    function s(P) {
        return G.ensureNumberInsideBounds(P), P.toNumber()
    }
    o(s, "longIntegerToJSNodeParam");

    function a(P) {
        return G.ensureNumberPrecision(P), G.ensureNumberInsideBounds(P), P.toNumber()
    }
    o(a, "decimalToJSNodeParam");

    function u(P) {
        return P
    }
    o(u, "textToJSNodeParam");

    function l(P) {
        return P.toNative()
    }
    o(l, "dateTimeToJSNodeParam");

    function c(P) {
        return P
    }
    o(c, "booleanToJSNodeParam");

    function d(P) {
        throw new TypeError("Records and Record lists are not basic types")
    }
    o(d, "recordToJSNodeParam");

    function f(P) {
        var Z;
        return typeof P == "string" ? P : (Z = P.content) !== null && Z !== void 0 ? Z : ""
    }
    o(f, "binaryDataToJSNodeParam");

    function h(P) {
        return P
    }
    o(h, "objectToJSNodeParam");
    let g = new Map([
        [_.Integer, i],
        [_.LongInteger, s],
        [_.Decimal, a],
        [_.Currency, a],
        [_.Text, u],
        [_.PhoneNumber, u],
        [_.Email, u],
        [_.Date, l],
        [_.DateTime, l],
        [_.Time, l],
        [_.Boolean, c],
        [_.Record, d],
        [_.RecordList, d],
        [_.BinaryData, f],
        [_.Object, h]
    ]);

    function p(P, Z) {
        throw new pe.InvalidJavascriptType(`Cannot assign a JavaScript ${typeof P} with value ${P==null?JSON.stringify(P):P.toString()} to an output parameter of type ${_[Z]}`)
    }
    o(p, "throwInvalidTypeError");

    function m(P) {
        return G.isValidJsNumber(P) ? (G.ensureIntegerInsideBounds(P), e(P)) : p(P, _.Integer)
    }
    o(m, "jsNodeParamToInteger");

    function w(P) {
        return G.isValidJsNumber(P) ? (G.ensureLongIntegerInsideBounds(P), bt.fromNumber(e(P))) : p(P, _.LongInteger)
    }
    o(w, "jsNodeParamToLongInteger");

    function T(P, Z) {
        return G.isValidJsNumber(P) ? (G.ensureDecimalInsideBounds(P), new Be(P)) : p(P, Z)
    }
    o(T, "jsNodeParamToDecimal");

    function E(P) {
        return G.isBoolean(P) ? P : p(P, _.Boolean)
    }
    o(E, "jsNodeParamToBoolean");

    function b(P, Z) {
        return G.isText(P) ? P : G.isValidJsNumber(P) ? (G.ensureDecimalInsideBounds(P), rf(new Be(P))) : G.isBoolean(P) ? kI(P) : p(P, Z)
    }
    o(b, "jsNodeParamToText");

    function R(P) {
        if (G.isValidJsDate(P)) {
            let Z = P;
            return new me(Z.getFullYear(), Z.getMonth() + 1, Z.getDate())
        }
        return p(P, _.Date)
    }
    o(R, "jsNodeParamToDate");

    function L(P) {
        return G.isValidJsDate(P) ? new me(P) : p(P, _.DateTime)
    }
    o(L, "jsNodeParamToDateTime");

    function V(P) {
        if (G.isValidJsDate(P)) {
            let Z = P;
            return new me(null, null, null, Z.getHours(), Z.getMinutes(), Z.getSeconds(), Z.getMilliseconds())
        }
        return p(P, _.Time)
    }
    o(V, "jsNodeParamToTime");

    function z(P, Z) {
        return p(P, Z)
    }
    o(z, "jsNodeParamToRecord");

    function j(P) {
        return G.hasBinaryDataInterface(P) ? new Or(P.content, P.url) : new Or(P)
    }
    o(j, "jsNodeParamToBinaryData");

    function Y(P) {
        return P
    }
    o(Y, "jsNodeParamToObject");
    let q = new Map([
        [_.Integer, m],
        [_.LongInteger, w],
        [_.Decimal, T],
        [_.Currency, T],
        [_.Text, b],
        [_.PhoneNumber, b],
        [_.Email, b],
        [_.Date, R],
        [_.DateTime, L],
        [_.Time, V],
        [_.Boolean, E],
        [_.Record, z],
        [_.RecordList, z],
        [_.BinaryData, j],
        [_.Object, Y]
    ])
})(zS || (zS = {}));
var nf;
(function(r) {
    let e = new Map;

    function t(h, g, p) {
        let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0,
            w = arguments.length > 4 ? arguments[4] : void 0,
            T = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
        if (!(m === !1 && !T && Tn(h, p))) switch (g) {
            case _.Time:
                return h.toISOTime();
            case _.Date:
                return h.toISODate();
            case _.DateTime:
                return w === !0 ? "" + Math.floor(h.getTime() / 1e3) : h.toString().replace(/\.\d+/, "");
            case _.LongInteger:
                let E = h;
                return G.ensureNumberInsideBounds(E), E.toNumber();
            case _.Decimal:
            case _.Currency:
                let b = h;
                return G.ensureNumberPrecision(b), G.ensureNumberInsideBounds(b), b.toNumber();
            case _.Record:
            case _.RecordList:
                throw new TypeError("Records and Record lists are not basic types");
            case _.BinaryData:
                return typeof h == "string" ? h : h.content;
            default:
                return h
        }
    }
    o(t, "serializeBasicType");

    function n(h) {
        let {
            value: g,
            serializeDefaultValues: p = !0,
            useUnixDateFormat: m = !1,
            dataType: w = _.Record,
            defaultValue: T,
            enforceDefaultValueSerializationAtThisLevel: E = !1
        } = h;
        if (g != null) return g instanceof Ce ? i(g, p != null ? p : !1, m != null ? m : !1, E) : g instanceof Ki ? s(g, p != null ? p : !1, m != null ? m : !1, E) : t(g, w, T != null ? T : Le(w), p, m, E)
    }
    o(n, "to"), r.to = n;

    function i(h, g, p) {
        let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1,
            w = h.getAttributes().reduce((T, E) => {
                if (E.dataType === _.Record || E.dataType === _.RecordList) {
                    let b = n({
                        value: h[E.attrName],
                        serializeDefaultValues: g,
                        useUnixDateFormat: p
                    });
                    b && (T[E.nameForJson] = b)
                } else {
                    let b = t(h[E.attrName], E.dataType, E.defaultValue, g, p);
                    b !== void 0 && (T[E.nameForJson] = b)
                }
                return T
            }, {});
        if (Object.keys(w).length !== 0 || m) return w
    }
    o(i, "serializeRecord");

    function s(h, g, p) {
        let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1,
            w = [],
            T = h.constructor.getItemType();
        for (let E = 0; E < h.length; E++) w.push(n({
            value: h.getItem(E),
            serializeDefaultValues: g,
            useUnixDateFormat: p,
            dataType: T,
            enforceDefaultValueSerializationAtThisLevel: !0
        }));
        if (w.length > 0 || g || m) return w
    }
    o(s, "serializeList");

    function a(h, g, p, m) {
        if (WI(g)) {
            let w = g,
                T = e.get(w);
            if (!T) {
                let E = w.getAttributes();
                T = o((b, R) => {
                    b != null || (b = {});
                    let L = E.reduce((V, z, j) => (z.nameForJson !== "" && (z.dataType === _.Record || z.dataType === _.RecordList ? V[z.attrName] = Ce.getData(a(b[z.nameForJson], E[j].complexType, R)) : V[z.attrName] = u(b[z.nameForJson], E[j].dataType, E[j].defaultValue, R)), V), {});
                    return new g(new g.RecordClass(L))
                }, "converter"), e.set(w, T)
            }
            return T(h, p)
        } else if (GI(g) || aF(g)) {
            if (g.getItemType() === void 0 || g.getItemType() === null) throw Error("A List can only be deserialized if its ItemType is defined.");
            let w = h;
            if (w == null && (w = []), w.constructor !== Array) throw new TypeError("Could not convert '" + w + "' to List");
            let T = g,
                E = new T;
            return E.pushAll(w.map(b => a(b, g.getItemType(), p))), E
        } else return u(h, g, m === void 0 ? Le(g) : m, p)
    }
    o(a, "from"), r.from = a;

    function u(h, g, p, m) {
        if (h == null) return p;
        switch (g) {
            case _.Integer:
                return l(h);
            case _.LongInteger:
                return c(h);
            case _.Currency:
            case _.Decimal:
                return d(h);
            case _.DateTime:
                return f(h, m);
            default:
                return Tc.from(h, g)
        }
    }
    o(u, "jsonToBasicType");

    function l(h) {
        let g;
        if (D.FORMAT.numberFormat.getRegExpForInteger().test(h) ? g = new Be(h) : D.FORMAT.numberFormat.getRegExpForJSNumber().test(h) && (g = new Be(+h)), g === void 0 || !g.isInteger() || !by(g)) throw new pe.Exception("Could not convert '" + h + "' to Integer");
        return Mk(g)
    }
    o(l, "jsonToInteger");

    function c(h) {
        let g;
        if (D.FORMAT.numberFormat.getRegExpForInteger().test(h) ? g = new Be(h) : D.FORMAT.numberFormat.getRegExpForJSNumber().test(h) && (g = new Be(+h)), g === void 0 || !g.isInteger() || !Pf(g)) throw new pe.Exception("Could not convert '" + h + "' to Long Integer");
        return kk(g)
    }
    o(c, "jsonToLongInteger");

    function d(h) {
        let g;
        if (D.FORMAT.numberFormat.getRegExpForInteger().test(h) ? g = new Be(h) : D.FORMAT.numberFormat.getRegExpForJSNumber().test(h) && (g = new Be(+h)), g === void 0 || g.lt(D.MIN_DECIMAL_VALUE) || g.gt(D.MAX_DECIMAL_VALUE)) throw new pe.Exception("Could not convert '" + h + "' to Decimal");
        return g
    }
    o(d, "jsonToDecimal");

    function f(h, g) {
        if (g) {
            h instanceof Date && (h = new me(h.getTime()));
            try {
                return new me(+h * 1e3)
            } catch (p) {
                throw new pe.Exception("Could not convert '" + h + "' to DateTime")
            }
        } else {
            if (!Vs.isConvertibleTo(h, _.DateTime)) throw new pe.Exception("Could not convert '" + h + "' to DateTime");
            return Tc.from(h, _.DateTime)
        }
    }
    o(f, "jsonToDateTime")
})(nf || (nf = {}));
var qS;
(function(r) {
    r.typeDefaultValue = Jo, r.convertToModelDataType = wc, r.typeDisplayName = jI;
    let e = "1900-01-01 00:00:00",
        t = new Map;

    function n(h, g, p, m) {
        var w;
        if (WI(g)) {
            let T = h,
                E = g,
                b = p,
                R = t.get(E);
            if (!R) {
                let L = E.getAttributes();
                R = o((V, z, j, Y) => {
                    let q = {};
                    return Y && Y.length > 0 ? (L.forEach(P => {
                        P.dataType !== _.RecordList && (q[P.attrName] = null)
                    }), Y.forEach(P => {
                        let Z = L.filter(oe => oe.attrName === P)[0];
                        Z.complexType ? q[P] = n(V, Z.complexType, z) : q[P] = j(V, z.value++, Z.name, Z.dataType)
                    })) : L.forEach((P, Z) => {
                        P.dataType !== _.RecordList && (P.dataType === _.Record && g.isAnonymousRecord() ? q[P.attrName] = n(V, L[Z].complexType, z) : q[P.attrName] = j(V, z.value++, L[Z].name, L[Z].dataType))
                    }), new g.RecordClass(q)
                }, "converter"), t.set(E, R)
            }
            return R(T, b, s(g), m)
        } else if (GI(g)) {
            if (g.getItemType() === void 0 || g.getItemType() === null) throw Error("A List can only be deserialized if its ItemType is defined.");
            let T = h,
                E = g.getItemType(),
                b = p,
                R = g,
                L = new R,
                V = [];
            for (let z = 0; z < T.length; z++) V.push(new E(b(null, T.item(z))));
            return L.pushAll(V), L
        } else {
            let T = g;
            throw new Error(`Unable to read data from Local Storage. Unknown type ${(w=T==null?void 0:T.name)!==null&&w!==void 0?w:T}`)
        }
    }
    o(n, "from"), r.from = n;

    function i(h) {
        let g = oF[h];
        return g === void 0 ? re.UNKNOWN : g
    }
    o(i, "convertDataTypeToDBDataType");

    function s(h) {
        return h.isAnonymousRecord() ? u : a
    }
    o(s, "getAttributeReaderImplementation");

    function a(h, g, p, m) {
        return r.deserializeFromDB(h["o" + g], i(m))
    }
    o(a, "attributeReaderImplementation");

    function u(h, g, p, m) {
        return r.deserializeFromDB(h[p], i(m))
    }
    o(u, "namedAttributeReaderImplementation");

    function l(h, g) {
        let p = g.length,
            m = h.toString();
        return g.substr(0, Math.max(0, p - m.length)) + m
    }
    o(l, "maskValue");

    function c(h, g) {
        if (g.isEntityReference && Tn(h, r.typeDefaultValue(g.type))) return null;
        switch (g.type) {
            case re.INTEGER:
                return h;
            case re.LONGINTEGER:
                let p = h;
                return p ? p.toString() : null;
            case re.DECIMAL:
                let m = h;
                return g.decimals ? m.toFixed(g.decimals) : m.toString();
            case re.TEXT:
                return h;
            case re.BOOLEAN:
                return h ? 1 : 0;
            case re.DATE_TIME:
                let T = h.toNative();
                return h.eq(me.defaultValue) ? e : (T = h.toNative(), l(T.getUTCFullYear(), "0000") + "-" + l(T.getUTCMonth() + 1, "00") + "-" + l(T.getUTCDate(), "00") + " " + l(T.getUTCHours(), "00") + ":" + l(T.getUTCMinutes(), "00") + ":" + l(T.getUTCSeconds(), "00"));
            case re.DATE:
                let E = h.toNative();
                return l(E.getFullYear(), "0000") + "-" + l(E.getMonth() + 1, "00") + "-" + l(E.getDate(), "00");
            case re.TIME:
                let b = h.toNative();
                return "1900-01-01 " + l(b.getHours(), "00") + ":" + l(b.getMinutes(), "00") + ":" + l(b.getSeconds(), "00");
            case re.BINARY_DATA:
                let R = h;
                return R.content === void 0 ? null : R.content;
            default:
                throw new pe.DataBaseException("", `Unable to serialize ${h} to a database value.`)
        }
    }
    o(c, "serializeToDB"), r.serializeToDB = c;

    function d(h, g) {
        if (h === null) return r.typeDefaultValue(g);
        switch (g) {
            case re.INTEGER:
                return h;
            case re.LONGINTEGER:
                return bt.fromValue(h);
            case re.DECIMAL:
                let p = h;
                return new Be(p);
            case re.TEXT:
                return h;
            case re.BOOLEAN:
                return h !== 0;
            case re.DATE_TIME:
            case re.DATE:
            case re.TIME:
                let w = /^((\d{4})-(\d{2})-(\d{2}))?\s?((\d{2}):(\d{2}):(\d{2}))?$/,
                    T = h,
                    E = w.exec(T),
                    b = new Date;
                switch (g) {
                    case re.DATE_TIME:
                        if (h === e) return me.defaultValue;
                        b.setUTCFullYear(parseInt(E[2], 10), parseInt(E[3], 10) - 1, parseInt(E[4], 10)), b.setUTCHours(parseInt(E[6], 10) || 0, parseInt(E[7], 10) || 0, parseInt(E[8], 10) || 0, 0);
                        break;
                    case re.DATE:
                        b.setFullYear(parseInt(E[2], 10), parseInt(E[3], 10) - 1, parseInt(E[4], 10)), b.setHours(0, 0, 0, 0);
                        break;
                    case re.TIME:
                        b.setFullYear(1900, 0, 1), b.setHours(parseInt(E[6], 10) || 0, parseInt(E[7], 10) || 0, parseInt(E[8], 10) || 0, 0);
                        break
                }
                return new me(b);
            case re.BINARY_DATA:
                return new Or(h);
            default:
                throw new pe.DataBaseException("", "Unable to deserialize " + h + " to a runtime value.")
        }
    }
    o(d, "deserializeFromDB"), r.deserializeFromDB = d;

    function f(h) {
        return new Or(void 0, void 0, h)
    }
    o(f, "deserializeLazyBinaryFromDB"), r.deserializeLazyBinaryFromDB = f
})(qS || (qS = {}));
var sae = Object.freeze({
    __proto__: null,
    get JSConversions() {
        return Vs
    },
    get JSNodeParamConverter() {
        return zS
    },
    get JSONConverter() {
        return nf
    },
    get LocalStorageConverter() {
        return qS
    },
    get ServerDataConverter() {
        return Tc
    }
});

function oae(r, e, t, n) {
    let i = nf.to({
        value: r,
        serializeDefaultValues: e,
        useUnixDateFormat: t,
        dataType: n,
        enforceDefaultValueSerializationAtThisLevel: !0
    });
    return JSON.stringify(i, uF)
}
o(oae, "serializeToJSON");

function aae(r, e, t) {
    try {
        let n;
        return r && (n = cF(r)), nf.from(n, e, t)
    } catch (n) {
        throw "Failed to deserialize JSON to " + e.name + ": " + n.message
    }
}
o(aae, "deserializeFromJSON");

function uF(r, e) {
    if (e !== null) return e
}
o(uF, "filterJSONValues");

function cF(r) {
    let e = /(?:"([^\\"]|\\.)*")|(?:'([^\\']|\\.)*')|(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(\w+)\s*:/g,
        t = r.replace(e, function(n, i, s, a, u) {
            return a ? '"' + a + '"' : s ? '"' + n.substring(1, n.length - 1) + '"' : u ? '"' + u + '":' : n
        });
    return JSON.parse(t)
}
o(cF, "parseJSON");

function lF(r, e) {
    let t, n, i, s;
    for (let a in e) t = r[a], n = e[a], n && t && (typeof n == "object" || (i = Array.isArray(n))) ? (i ? (i = !1, s = Array.isArray(t) ? t : []) : s = typeof t == "object" ? t : {}, r[a] = lF(s, n)) : n !== void 0 && (r[a] = n);
    return r
}
o(lF, "mergeJS");

function cv(r) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3,
        t = arguments.length > 2 ? arguments[2] : void 0,
        n = arguments.length > 3 ? arguments[3] : void 0,
        i = arguments.length > 4 ? arguments[4] : void 0;
    t = t != null ? t : uae, e = isNaN(+e) ? 1 : e;
    let s = new WeakMap;

    function a(u, l, c, d, f) {
        var h;
        return !u || typeof u != "object" ? u : (f = s.has(u), s.set(u, !0), d = Array.isArray(u), f ? c = (h = i == null ? void 0 : i(u)) !== null && h !== void 0 ? h : null : JSON.stringify(u, function(g, p) {
            if (d || l > 0) {
                if (t && (p = t(g, p)), !g) return d = Array.isArray(p), u = p;
                c = c || (d ? [] : {}), c[g] = a(p, d ? l : l - 1)
            }
        }), c === void 0 ? d ? [] : "(...)" : c)
    }
    return o(a, "_build"), JSON.stringify(a(r, e), null, n)
}
o(cv, "serializeObjectForLog");

function uae(r, e) {
    if (r === "") {
        if (Array.isArray(e)) {
            let a = e;
            return a.length >= 10 && (a = a.slice(0, 9), a.push("(...)")), a
        }
        return cae(e, 10)
    } else if (typeof e == "string") {
        let s = e;
        return s.length > 25 ? s.substring(0, 19) + " (...)" : s
    }
    return e
}
o(uae, "trimObject");

function cae(r, e) {
    let t = 0,
        n = !1,
        i = Object.keys(r).reduce(function(s, a) {
            return t++, t <= e ? s[a] = r[a] : n = !0, s
        }, {});
    return n && (i["..."] = "(...)"), i
}
o(cae, "cloneObjectWithPropLimit");
var lae = Object.freeze({
        __proto__: null,
        deserializeFromJSON: aae,
        filterJSONValues: uF,
        mergeJS: lF,
        parseJSON: cF,
        serializeObjectForLog: cv,
        serializeToJSON: oae
    }),
    Ay = "BACKUP_",
    Df = "OSSYS_ENTITY";

function zI(r) {
    return r && r.toUpperCase()
}
o(zI, "formatObjectName");

function lv(r, e) {
    var t;
    return (t = r.attributes.filter(n => (n == null ? void 0 : n.name) === e.name)[0]) !== null && t !== void 0 ? t : null
}
o(lv, "getMatchingColumn");

function Fn(r) {
    var e;
    return (e = Ms(r)[0]) !== null && e !== void 0 ? e : null
}
o(Fn, "getIdentifierColumn");

function Ms(r) {
    return r.attributes.filter(e => e == null ? void 0 : e.isPrimaryKey)
}
o(Ms, "getIdentifierColumns");

function qI(r) {
    let e = Ms(r);
    return e.length > 0 ? e.map(t => {
        var n;
        return (n = t == null ? void 0 : t.columnName) !== null && n !== void 0 ? n : null
    }) : null
}
o(qI, "getIdentifierColumnNames");

function Bo(r, e) {
    let t = Fn(r);
    return t && e.getAttributes().filter(n => n.name === t.name)[0] || null
}
o(Bo, "getIdentifierAttribute");

function dF(r, e) {
    let t = Fn(r);
    if (!t) return null;
    let n = e.getAttributes().filter(i => i.name === t.name)[0];
    return n ? e[n.attrName] : null
}
o(dF, "getIdentifierValue");

function dae(r, e) {
    let t = Fn(r);
    if (!t) return !0;
    let n = e.getAttributes().filter(i => i.name === t.name)[0];
    return n ? Tn(e[n.attrName], Le(n.dataType)) : !0
}
o(dae, "hasNullIdentifier");
var fae = Object.freeze({
        __proto__: null,
        BACKUP_TABLE_PREFIX: Ay,
        METADATA_TABLE_NAME: Df,
        formatObjectName: zI,
        getIdentifierAttribute: Bo,
        getIdentifierColumn: Fn,
        getIdentifierColumnNames: qI,
        getIdentifierColumns: Ms,
        getIdentifierValue: dF,
        getMatchingColumn: lv,
        hasNullIdentifier: dae
    }),
    Kb = "IndexedDBTransactionWithoutObjectStores",
    kC = class kC {
        constructor(e, t) {
            this.allowTraces = e, this.database = t, this.allowTraces && ee(Kb, `Starting transaction ${this.transactionId} over ${t.objectStoreNames.length} store(s)`)
        }
        createTable(e) {
            return new Promise(t => {
                var n, i, s;
                this.debug(`Creating table '${e.tableName}'`);
                let a = qI(e),
                    u = this.database.createObjectStore(e.tableName, {
                        autoIncrement: !a,
                        keyPath: a
                    });
                this.debug(`Creating columns for '${e.tableName}' table`);
                for (let l = 0; l < e.attributes.length; l++) this.debug(`Creating column '${(n=e.attributes[l])===null||n===void 0?void 0:n.name}'`), u.createIndex((i = e.attributes[l]) === null || i === void 0 ? void 0 : i.columnName, (s = e.attributes[l]) === null || s === void 0 ? void 0 : s.columnName);
                t()
            })
        }
        deleteTableIfExists(e) {
            let t;
            return typeof e == "string" ? t = e : t = e.tableName, new Promise((n, i) => {
                if (this.debug(`Deleting table '${t}'`), !this.database.objectStoreNames.contains(t)) return this.debug(`Table '${t}' does not exist`), n();
                try {
                    this.database.deleteObjectStore(t), this.debug(`Table '${t}' deleted successfuly`)
                } catch (s) {
                    return this.warning(`Error deleting table '${t}'`, s), i(s)
                }
                n()
            })
        }
        existsTable(e) {
            let t = typeof e == "string" ? e : e.tableName;
            return Promise.resolve(this.database.objectStoreNames.contains(t))
        }
        renameTable(e, t) {
            throw new Error("You can't execute this method on a database without object stores.")
        }
        addColumn(e, t) {
            throw new Error("You can't execute this method on a database without object stores.")
        }
        existsColumn(e, t) {
            return k(this, void 0, void 0, function*() {
                throw new Error("You can't execute this method on a database without object stores.")
            })
        }
        getRecord(e, t) {
            throw new Error("You can't execute this method on a database without object stores.")
        }
        insertRecord(e, t) {
            throw new Error("You can't execute this method on a database without object stores.")
        }
        updateRecord(e, t) {
            throw new Error("You can't execute this method on a database without object stores.")
        }
        upsertRecord(e, t) {
            throw new Error("You can't execute this method on a database without object stores.")
        }
        upsertAllRecords(e, t) {
            throw new Error("You can't execute this method on a database without object stores.")
        }
        removeRecord(e, t) {
            throw new Error("You can't execute this method on a database without object stores.")
        }
        removeAllRecords(e) {
            throw new Error("You can't execute this method on a database without object stores.")
        }
        findRecords(e, t) {
            throw new Error("You can't execute this method on a database without object stores.")
        }
        getAllRecords(e) {
            throw new Error("You can't execute this method on a database without object stores.")
        }
        debug(e) {
            this.allowTraces && ee(Kb, `${e} on transaction ${this.transactionId}`, Pe.Client)
        }
        warning(e, t) {
            ft(Kb, `${e} on transaction ${this.transactionId}${t?`: ${t.message}`:""}`, Pe.Client)
        }
    };
o(kC, "IndexedDBTransactionWithoutObjectStores");
var dv = kC;

function hae(r) {
    return r.value.charAt(r.value.length - 1) === "." ? r.value.substr(0, r.value.length - 1) : r.value.substr(1, r.value.length - 2)
}
o(hae, "getEntityNameFromMatch$1");

function gae(r, e) {
    let t = hae(r),
        n = e.some(i => i.toLowerCase() === t.toLowerCase()) ? t : "";
    if (n === "") throw new pe.DataBaseException("", `'${t}' found in 'Order By' parameter is an invalid Entity`);
    return r.value.charAt(r.value.length - 1) === "." ? n + "." : n
}
o(gae, "replaceEntityNameInOrderBy$1");

function pae(r, e) {
    let t = r.trim();
    if (t !== "") {
        let u = Bm(t, "((((\\{\\w+\\})|(\\w+)).)?((\\[\\w+\\])|(\\w+))(( )+(desc|asc))?)(( )*,( )*(((\\{\\w+\\})|(\\w+)).)?((\\[\\w+\\])|(\\w+))(( )+(desc|asc))?)*", !0);
        if (u.length !== 1 || u[0].value !== t) throw new pe.DataBaseException("", "Invalid syntax in 'Order By' parameter.")
    } else return [];
    let n = o(u => gae(u, e), "meReplaceEntityName"),
        i = o(u => u.value.substr(1, u.value.length - 2), "meReplaceAttributeName"),
        s = Vm(t, "(\\{\\w+\\}|\\w+\\.)", !1, n);
    return s = Vm(s, "(\\[\\w+\\])", !1, i), s.split(/, ?/).map(u => {
        let l = u.trim().split(" "),
            c = l.length === 2 ? l[1].toLowerCase() === "asc" : !0;
        return {
            attributeParts: l[0].split("."),
            isAscending: c
        }
    })
}
o(pae, "getDynamicSortList");

function ti(r) {
    r.stopPropagation(), r.preventDefault()
}
o(ti, "markEventAsHandled");

function fF(r) {
    return k(this, void 0, void 0, function*() {
        if (r instanceof Ki)
            for (let e = 0; e < r.length; e++) {
                let t = r.getItem(e);
                yield KS(t)
            } else r instanceof Ce && (yield KS(r))
    })
}
o(fF, "loadBinaryDataContent");

function KS(r) {
    return k(this, void 0, void 0, function*() {
        let t = r.getAttributes().map(n => k(this, void 0, void 0, function*() {
            let i = r[n.attrName];
            n.dataType === _.Record ? yield KS(i): n.dataType === _.BinaryData && (yield i.loadContent())
        }));
        yield Promise.all(t)
    })
}
o(KS, "loadItemContent");

function mae(r) {
    return r.charAt(0).toLowerCase() + r.substr(1) + "Attr"
}
o(mae, "toRuntimeName");

function vae(r, e) {
    let t = pae(r, e);
    return n => t.map(i => {
        let s = n;
        for (let a = 0; a < i.attributeParts.length; a++) {
            let u = mae(i.attributeParts[a]).toLowerCase(),
                l = s.getAttributes().filter(c => c.attrName.toLowerCase() === u);
            if (l.length === 0) throw new pe.DataBaseException("", `Invalid attribute in 'Order By' parameter: ${i.attributeParts.join(".")}`);
            s = s[l[0].attrName]
        }
        return {
            value: s,
            isAscending: i.isAscending
        }
    })
}
o(vae, "getDynamicSortsObjGenerator");
var yae = Object.freeze({
        __proto__: null,
        getDynamicSortsObjGenerator: vae,
        loadBinaryDataContent: fF,
        markEventAsHandled: ti
    }),
    _ae = 1e12,
    Bx = "IndexedDBTransaction",
    ri = class ri extends dv {
        set onComplete(e) {
            this.transaction.oncomplete = () => (this.allowTraces && ee(Bx, `Committing transaction ${this.transactionId}`), e())
        }
        set onAbort(e) {
            this.transaction.onabort = () => (ft(Bx, `Aborting transaction ${this.transactionId}: ${this.transaction.error}`), e(this.transaction.error))
        }
        executeQuery(e) {
            return e(this.transaction)
        }
        constructor(e, t, n) {
            super(e, n), this.transaction = t, ri.lastTransactionId = (ri.lastTransactionId + 1) % _ae, this.transactionId = ri.lastTransactionId + 1
        }
        renameTable(e, t) {
            return k(this, void 0, void 0, function*() {
                let n = this.transaction.objectStore(e);
                n.name = t
            })
        }
        getRecord(e, t) {
            return new Promise((n, i) => {
                this.debug(`Getting record with keys '${t}' from table '${e.tableName}'`);
                let a = this.transaction.objectStore(e.tableName).get(ri.wrapKeyIfNeeded(t, e));
                a.onsuccess = () => {
                    this.debug(`Retrieved record with keys '${t}' from table '${e.tableName}' successfully`), n(a.result || null)
                }, a.onerror = u => {
                    this.warning(`Error retrieving record with keys '${t}' from table '${e.tableName}'`, this.transaction.error), ti(u), i(this.transaction.error)
                }
            })
        }
        removeRecord(e, t) {
            return new Promise((n, i) => {
                this.debug(`Deleting record with key '${t}' from table '${e.tableName}'`);
                let a = this.transaction.objectStore(e.tableName).delete(ri.wrapKeyIfNeeded(t, e));
                a.onsuccess = () => {
                    this.debug(`Deleted record with key '${t}' from table '${e.tableName}' successfully`), n()
                }, a.onerror = u => {
                    this.warning(`Error deleting record with key '${t}' from table '${e.tableName}'`, a.error), ti(u), i(a.error)
                }
            })
        }
        removeAllRecords(e) {
            return new Promise((t, n) => {
                this.debug(`Deleting all records from table '${e.tableName}'`);
                let s = this.transaction.objectStore(e.tableName).clear();
                s.onsuccess = () => {
                    this.debug(`Deleted all records from table '${e.tableName}' successfully`), t()
                }, s.onerror = a => {
                    this.warning(`Error deleting all records from table '${e.tableName}'`, s.error), ti(a), n(s.error)
                }
            })
        }
        insertRecord(e, t) {
            return new Promise((n, i) => {
                this.debug(`Inserting record on table '${e.tableName}'`);
                let s = this.transaction.objectStore(e.tableName).add(t);
                s.onsuccess = () => {
                    this.debug(`Inserted record on table '${e.tableName}' successfully`), n(ri.unwrapKeyIfNeeded(s))
                }, s.onerror = a => {
                    this.warning(`Error inserting record on table '${e.tableName}'`, s.error), ti(a), i(s.error)
                }
            })
        }
        upsertRecord(e, t) {
            return new Promise((n, i) => {
                this.debug(`Adding/Updating record on table '${e.tableName}'`);
                let s = this.transaction.objectStore(e.tableName).put(t);
                s.onsuccess = () => {
                    this.debug(`Added/Updated record on table '${e.tableName}' successfully`), n(ri.unwrapKeyIfNeeded(s))
                }, s.onerror = a => {
                    this.warning(`Error adding/updating record on table '${e.tableName}'`, s.error), ti(a), i(s.error)
                }
            })
        }
        upsertAllRecords(e, t) {
            return k(this, void 0, void 0, function*() {
                this.debug(`Adding/updating ${t==null?void 0:t.length} record(s) on table '${e.tableName}'`);
                try {
                    for (let n of t) yield this.upsertRecord(e, n);
                    this.debug(`Added/updated ${t==null?void 0:t.length} record(s) on table '${e.tableName}' successfully`)
                } catch (n) {
                    throw this.warning(`Error adding/updating ${t==null?void 0:t.length} record(s) on table '${e.tableName}'`, n), n
                }
            })
        }
        updateRecord(e, t) {
            return k(this, void 0, void 0, function*() {
                return new Promise((n, i) => {
                    let s = qI(e);
                    if ((s == null ? void 0 : s.length) === 0) {
                        let u = new Error(`Cannot perform an update on table '${e.tableName}' since it has no primary key column`);
                        return this.warning(u.message), i(u)
                    }
                    this.debug(`Checking if record exists on table '${e.tableName}'`);
                    let a = this.transaction.objectStore(e.tableName).get(s == null ? void 0 : s.map(u => t[u]));
                    a.onsuccess = () => {
                        try {
                            if (!a.result) {
                                let l = new Error(`Record to update does not exist on table '${e.tableName}'`);
                                return this.warning(l.message), i(l)
                            }
                            this.debug(`Updating record on table '${e.tableName}'`);
                            let u = this.transaction.objectStore(e.tableName).put(t);
                            u.onsuccess = () => {
                                this.debug(`Updated record on table '${e.tableName}' successfully`), n()
                            }, u.onerror = l => {
                                this.warning(`Error updating record on table '${e.tableName}'`, u.error), ti(l), i(u.error)
                            }
                        } catch (u) {
                            this.warning(`Error updating record on table '${e.tableName}'`, u), i(u)
                        }
                    }, a.onerror = u => {
                        this.warning(`Error checking if record exists on table '${e.tableName}'`, a.error), ti(u), i(a.error)
                    }
                })
            })
        }
        addColumn(e, t) {
            return k(this, void 0, void 0, function*() {
                yield new Promise((i, s) => {
                    this.debug(`Adding column '${cv(t)}' on table '${e.tableName}'`);
                    try {
                        this.transaction.objectStore(e.tableName).createIndex(t.columnName, t.columnName), i()
                    } catch (a) {
                        this.warning(`Error adding column '${cv(t)}' on table '${e.tableName}'`, a), s(a)
                    }
                });
                let n = yield this.getAllRecords(e);
                for (let i of n) i[t.columnName] = t.serializedDefault, yield this.upsertRecord(e, i)
            })
        }
        existsColumn(e, t) {
            return k(this, void 0, void 0, function*() {
                return new Promise((n, i) => {
                    this.debug(`Checking if column '${t}' exists on table '${e}'`);
                    try {
                        let s = this.transaction.objectStoreNames.contains(e) && this.transaction.objectStore(e).indexNames.contains(t);
                        n(s)
                    } catch (s) {
                        this.warning(`Error checking if column '${t}' exists on table '${e}'`, s), i(s)
                    }
                })
            })
        }
        findRecords(e, t) {
            return new Promise((n, i) => {
                this.debug(`Searching for all records on table '${e.tableName}' that match the specified criteria.`);
                let s = [],
                    a = Ms(e).length > 0,
                    l = this.transaction.objectStore(e.tableName).openCursor();
                l.onsuccess = () => {
                    let c = l.result;
                    if (c) {
                        let d = c.value;
                        a || (d = Object.assign(Object.assign({}, d), {
                            $KEY: c.primaryKey
                        })), Object.keys(t).reduce((h, g) => h && t.hasOwnProperty(g) && d[zI(g)] === t[g], !0) && s.push(d), c.continue()
                    } else this.debug(`Search on table '${e.tableName}' found ${s.length} record(s) matching the specified criteria.`), n(s)
                }, l.onerror = c => {
                    this.warning(`Error searching for records on table '${e.tableName}'`, l.error), ti(c), i(l.error)
                }
            })
        }
        getAllRecords(e) {
            return new Promise((t, n) => {
                this.debug(`Getting all records from table '${e.tableName}'`);
                let s = this.transaction.objectStore(e.tableName).getAll();
                s.onsuccess = () => {
                    this.debug(`Retrieved all the records from table '${e.tableName}'`), t(s.result)
                }, s.onerror = a => {
                    this.warning(`Error retrieving all the records from table '${e.tableName}'`, s.error), ti(a), n(s.error)
                }
            })
        }
        static wrapKeyIfNeeded(e, t) {
            return Ms(t).length > 0 ? e instanceof Array ? e : [e] : e
        }
        static unwrapKeyIfNeeded(e) {
            return e.result instanceof Array ? e.result[0] : e.result
        }
    };
o(ri, "IndexedDBTransaction");
var sf = ri;
sf.lastTransactionId = 0;
var wae = "Could not open database",
    No = "IndexedDBDatabase",
    Au = class Au extends Hm {
        static asSafeDbName(e) {
            return e || ""
        }
        static executeTransactionPromiseWithRetry(e) {
            return k(this, arguments, void 0, function(t) {
                let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
                return (function*() {
                    let i = !0,
                        s = 0,
                        a;
                    for (; i;) {
                        s++;
                        try {
                            a = yield new Promise(t), i = !1
                        } catch (u) {
                            let l = u;
                            if (!/the transaction is inactive or finished/i.test(l.message) || s >= n) throw u
                        }
                    }
                    return a
                })()
            })
        }
        static open(e, t) {
            return e = this.asSafeDbName(e), new Promise((n, i) => {
                if (this.cache[e]) n(this.cache[e]);
                else {
                    if (typeof window == "undefined") return i(new pe.SystemException("Database is only available in the browser/web view"));
                    if (!("indexedDB" in window)) return ee(No, "This browser doesn't support IndexedDB"), i(new pe.SystemException("This browser doesn't support IndexedDB"));
                    if (tne(navigator.userAgent) && ene(window)) {
                        let a = `Your app requires native access to a Local Storage database that is not available in your browser while using an iframe.
Please test your app in your mobile device or use Google Chrome`;
                        return alert(a), i(new pe.SystemException(a))
                    }
                    ee(No, `Opening database '${e}' on IndexedDB`);
                    let s = window.indexedDB.open(e);
                    s.onsuccess = () => {
                        ee(No, `Database '${e}' opened successfully with version '${s.result.version}'`);
                        let a = s.result;
                        this.cache[e] = new Au(e, a, t), n(this.cache[e])
                    }, s.onerror = () => {
                        ft(No, `Error opening database '${e}'`), i(new pe.OpenDatabaseException(`${wae} '${e}'`))
                    }
                }
            })
        }
        constructor(e, t, n) {
            super(e, "IndexedDB"), this.databaseImplementation = t, this.onNewDatabaseVersionDetected = n, this.setOnVersionChangeEvent()
        }
        setOnVersionChangeEvent() {
            this.databaseImplementation.onversionchange = () => {
                this.databaseImplementation.close(), this.onNewDatabaseVersionDetected && this.onNewDatabaseVersionDetected()
            }
        }
        close() {
            return ee(No, `Closing database ${this.name} with version '${this.databaseImplementation.version}'`), this.databaseImplementation.close(), delete Au.cache[this.name], Promise.resolve()
        }
        testConnection() {
            return Promise.resolve()
        }
        executeQuery(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,
                n = arguments.length > 2 ? arguments[2] : void 0;
            return this.executeReadTransaction(i => i.executeQuery(e), t, n)
        }
        executeTransaction(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,
                n = arguments.length > 2 ? arguments[2] : void 0;
            return this.innerExecuteDMLTransaction(e, t, "readwrite", n)
        }
        executeReadTransaction(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,
                n = arguments.length > 2 ? arguments[2] : void 0;
            return this.innerExecuteDMLTransaction(e, t, "readonly", n)
        }
        innerExecuteDMLTransaction(e, t, n, i) {
            return this.databaseImplementation.objectStoreNames.length === 0 ? this.innerExecuteIDBTransactionWithoutObjectStores(e, t) : this.innerExecuteIDBTransaction(e, t, n, i)
        }
        innerExecuteIDBTransaction(e, t, n, i) {
            let s = o((a, u) => k(this, void 0, void 0, function*() {
                let l = null,
                    c = null,
                    d = i ? i.map(g => g.tableName) : [];
                if (d.length === 0)
                    for (let g = 0; g < this.databaseImplementation.objectStoreNames.length; g++) d.push(this.databaseImplementation.objectStoreNames.item(g));
                let f = this.databaseImplementation.transaction(d, n),
                    h = new sf(t, f, this.databaseImplementation);
                h.onComplete = () => k(this, void 0, void 0, function*() {
                    yield fF(l), a(l)
                }), h.onAbort = g => u(c != null ? c : g);
                try {
                    l = yield e(h)
                } catch (g) {
                    c = g, f == null || f.abort()
                }
            }), "txBody");
            return Au.executeTransactionPromiseWithRetry(s)
        }
        innerExecuteIDBTransactionWithoutObjectStores(e, t) {
            let n = new dv(t, this.databaseImplementation);
            return e(n)
        }
        executeUpgradeTransaction(e) {
            return k(this, arguments, void 0, function(t) {
                var n = this;
                let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
                return (function*() {
                    return new Promise((s, a) => {
                        let u = null,
                            l = null,
                            c = n.databaseImplementation.version;
                        n.databaseImplementation.close();
                        let d = window.indexedDB.open(n.name, c + 1);
                        d.onsuccess = () => (n.debug(`Database '${n.name}' opened successfully with version '${c+1}'`, i), n.databaseImplementation = d.result, n.setOnVersionChangeEvent(), s(u)), d.onerror = () => (ft(No, `Error opening '${n.name}' database with version '${c+1}'`), a(l != null ? l : d.error)), d.onupgradeneeded = () => {
                            n.debug(`Upgrading database '${n.name}' with version '${c+1}'`, i), n.databaseImplementation = d.result;
                            let f = new sf(i, d.transaction, d.result);
                            f.onAbort = h => l = l != null ? l : h, t(f).then(h => u = h).catch(h => {
                                var g;
                                l = h, (g = d.transaction) === null || g === void 0 || g.abort()
                            })
                        }
                    })
                })()
            })
        }
        debug(e) {
            (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) && ee(No, e)
        }
    };
o(Au, "IndexedDBDatabase");
var fv = Au;
fv.cache = {};
var YS;
(function(r) {
    r[r.No = 0] = "No", r[r.Yes = 1] = "Yes", r[r.YesIfEmpty = 2] = "YesIfEmpty"
})(YS || (YS = {}));
var Ar = YS,
    XS;
(function(r) {
    r[r.Read = 0] = "Read", r[r.Write = 1] = "Write", r[r.Upgrade = 2] = "Upgrade"
})(XS || (XS = {}));
var Wr = XS,
    Tae = `\r
`,
    ui = new Map;
ui.set(re.BINARY_DATA, "BLOB");
ui.set(re.BOOLEAN, "BOOLEAN");
ui.set(re.DATE, "DATE");
ui.set(re.DATE_TIME, "DATETIME");
ui.set(re.DECIMAL, "REAL");
ui.set(re.INTEGER, "INTEGER");
ui.set(re.LONGINTEGER, "BIGINT");
ui.set(re.TEXT, "TEXT");
ui.set(re.TIME, "TIME");

function Vx(r) {
    var e;
    return (e = ui.get(r)) !== null && e !== void 0 ? e : ""
}
o(Vx, "getType");
var Eae = 1e12,
    mu = "The transaction is read-only",
    sm = "The database is not running a version change transaction",
    Yb = "WebSQLTransaction",
    br = class br {
        get transactionId() {
            return this._transactionId
        }
        constructor(e, t, n) {
            this.allowTraces = e, this.transaction = t, this.mode = n, br.lastTransactionId = (br.lastTransactionId + 1) % Eae, this._transactionId = br.lastTransactionId + 1, this.allowTraces && ee(Yb, `Starting transaction ${this.transactionId}`)
        }
        executeQuery(e) {
            return e(this.transaction)
        }
        getColumnDeclaration(e, t) {
            let n = `${Vx(t.type)}`,
                i;
            if (t.isPrimaryKey) {
                if (e.idIsAutoNumber === Ar.YesIfEmpty || e.idIsAutoNumber === Ar.Yes) return t.type === re.LONGINTEGER && (n = `${Vx(re.INTEGER)}`), n += " PRIMARY KEY AUTOINCREMENT NOT NULL", {
                    declaration: `"${t.columnName}" ${n}`
                };
                i = `"${t.columnName}"`
            }
            if (t.length && (n += `(${t.length}${t.decimals?","+t.decimals:""})`), t.serializedDefault !== void 0) {
                let s = t.serializedDefault;
                typeof s == "string" && (s = `'${s.replace("'","''")}'`), n += ` DEFAULT ${s}`
            }
            return {
                declaration: `"${t.columnName}" ${n}`,
                primaryKeyDeclaration: i
            }
        }
        createTable(e) {
            return new Promise((t, n) => {
                if (this.debug(`Creating table '${e.tableName}'`), this.mode < Wr.Upgrade) {
                    let c = new Error(sm);
                    return this.warning(`Error creating table '${e.tableName}'`, c), n(c)
                }
                let i = o((c, d) => {
                        this.debug(`Table '${e.tableName}' created with success`), t()
                    }, "successCallback"),
                    s = o((c, d) => {
                        let f = new Error(d.message.toString());
                        return this.warning(`Error creating table '${e.tableName}'`, f), n(f), !1
                    }, "errorCallback"),
                    a = e.attributes.map(c => this.getColumnDeclaration(e, c)),
                    u = a.filter(c => !!c.primaryKeyDeclaration).map(c => c.primaryKeyDeclaration),
                    l = a.map(c => c.declaration);
                u.length > 0 && l.push(`PRIMARY KEY (${u.join(",")})`), this.transaction.executeSql(`CREATE TABLE "${e.tableName}" (${l.join(",")})`, void 0, i, s)
            })
        }
        deleteTableIfExists(e) {
            let t;
            return typeof e == "string" ? t = e : t = e.tableName, new Promise((n, i) => {
                if (this.debug(`Deleting table '${t}'`), this.mode < Wr.Upgrade) {
                    let u = new Error(sm);
                    return this.warning(`Error deleting table '${t}'`, u), i(u)
                }
                let s = o((u, l) => {
                        this.debug(`Table '${t}' deleted with success`), n()
                    }, "successCallback"),
                    a = o((u, l) => {
                        let c = new Error(l.message.toString());
                        return this.warning(`Error deleting table '${t}'`, c), i(c), !1
                    }, "errorCallback");
                this.transaction.executeSql(`DROP TABLE IF EXISTS "${t}"`, void 0, s, a)
            })
        }
        renameTable(e, t) {
            return new Promise((n, i) => k(this, void 0, void 0, function*() {
                if (this.debug(`Renaming table '${e}'`), this.mode < Wr.Upgrade) {
                    let u = new Error(sm);
                    return this.warning(`Error renaming table '${e}'`, u), i(u)
                }
                let s = o((u, l) => {
                        this.debug(`Table '${e}' renamed to '${t}' with success`), n()
                    }, "successCallback"),
                    a = o((u, l) => {
                        let c = new Error(l.message.toString());
                        return this.warning(`Error renaming table '${e}'`, c), i(c), !1
                    }, "errorCallback");
                this.transaction.executeSql(`ALTER TABLE "${e}" RENAME TO "${t}"`, void 0, s, a)
            }))
        }
        existsTable(e) {
            let t;
            return typeof e == "string" ? t = e : t = e.tableName, new Promise((n, i) => {
                this.debug(`Checking if table '${t}' exists`);
                let s = o((u, l) => {
                        this.debug(`Table '${t}' checked with success`), n(l.rows.length > 0)
                    }, "callback"),
                    a = o((u, l) => {
                        let c = new Error(l.message.toString());
                        return this.warning(`Error checking if table '${t}' exists`, c), i(c), !1
                    }, "callbackError");
                this.transaction.executeSql(`SELECT * FROM sqlite_master WHERE type = 'table' AND UPPER(name) = UPPER("${t}")`, void 0, s, a)
            })
        }
        addColumn(e, t) {
            return new Promise((n, i) => k(this, void 0, void 0, function*() {
                let s = cv(t);
                if (this.debug(`Adding column '${s}' on table '${e.tableName}'`), this.mode < Wr.Upgrade) {
                    let c = new Error(sm);
                    return this.warning(`Error adding column '${s}'`, c), i(c)
                }
                let a = o((c, d) => {
                        this.debug(`Column '${s}' added with success`), n()
                    }, "successCallback"),
                    u = o((c, d) => {
                        let f = new Error(d.message.toString());
                        return this.warning(`Error adding column '${s}'`, f), i(f), !1
                    }, "errorCallback"),
                    l = o((c, d) => {
                        c.executeSql(`UPDATE "${e.tableName}" SET "${t.columnName}" = ?`, [t.serializedDefault], a, u)
                    }, "addColumnSuccessCallback");
                this.transaction.executeSql(`ALTER TABLE "${e.tableName}" ADD ${this.getColumnDeclaration(e,t).declaration}`, void 0, l, u)
            }))
        }
        existsColumn(e, t) {
            return new Promise(n => {
                this.debug(`Checking if column '${t}' exists on table '${e}'`);
                let i = o(() => {
                        this.debug(`Column '${t}' exists on table '${e}'`), n(!0)
                    }, "callback"),
                    s = o(() => (this.debug(`Column '${t}' does not exist on table '${e}'`), n(!1), !1), "callbackError");
                this.transaction.executeSql(`SELECT "${e}"."${t}" FROM "${e}" LIMIT 0`, void 0, i, s)
            })
        }
        getRecord(e, t) {
            return new Promise((n, i) => {
                this.debug(`Getting record with keys '${t}' from table '${e.tableName}'`);
                let s = br.wrapKeyIfNeeded(t),
                    a = e.attributes.map(g => `"${g==null?void 0:g.columnName}"`).join(", "),
                    u = `"${e.tableName}"`,
                    l = e.attributes.filter(g => g == null ? void 0 : g.isPrimaryKey),
                    c = [...s],
                    d = l.map(g => `"${g==null?void 0:g.columnName}" = ?`).join(" and "),
                    f = o((g, p) => {
                        this.debug(`Retrieved record with keys '${t}' from table '${e.tableName}' successfully`);
                        let m = br.convertSQLResultSetToDatabaseRecord(e, p);
                        n(m.length > 0 ? m[0] : null)
                    }, "onSuccess"),
                    h = o((g, p) => {
                        let m = new Error(p.message.toString());
                        return this.warning(`Error retrieving record with keys '${t}' from table '${e.tableName}'`, m), i(m), !1
                    }, "onError");
                this.transaction.executeSql(`SELECT ${a} FROM ${u} WHERE ${d}`, c, f, h)
            })
        }
        insertRecord(e, t) {
            return new Promise((n, i) => {
                if (this.debug(`Inserting record on table '${e.tableName}'`), this.mode < Wr.Write) {
                    let h = new Error(mu);
                    return this.warning(`Error inserting record on table '${e.tableName}'`, h), i(h)
                }
                let s = e.attributes.filter(h => h == null ? void 0 : h.isPrimaryKey),
                    a = e.attributes.map(h => `"${h==null?void 0:h.columnName}"`).join(", "),
                    u = br.concatenateMultipleTimes("?", e.attributes.length, ", "),
                    l = `"${e.tableName}"`,
                    c = e.attributes.map(h => t[h == null ? void 0 : h.columnName] === void 0 ? null : t[h == null ? void 0 : h.columnName]),
                    d = o((h, g) => {
                        var p, m;
                        this.debug(`Inserted record on table '${e.tableName}' successfully`);
                        let w;
                        e.idIsAutoNumber === Ar.No || e.idIsAutoNumber === Ar.YesIfEmpty && t[(p = s[0]) === null || p === void 0 ? void 0 : p.columnName] !== null ? w = t[(m = s[0]) === null || m === void 0 ? void 0 : m.columnName] : w = g.insertId, n(w)
                    }, "onSuccess"),
                    f = o((h, g) => {
                        let p = new Error(g.message.toString());
                        return this.warning(`Error inserting record on table '${e.tableName}'`, p), i(p), !1
                    }, "onError");
                this.transaction.executeSql(`INSERT INTO ${l} (${a}) VALUES (${u})`, c, d, f)
            })
        }
        updateRecord(e, t) {
            return new Promise((n, i) => {
                if (this.debug(`Updating record on table '${e.tableName}'`), this.mode < Wr.Write) {
                    let g = new Error(mu);
                    return this.warning(`Error updating record on table '${e.tableName}'`, g), i(g)
                }
                let s = e.attributes.filter(g => !(g != null && g.isPrimaryKey)),
                    a = e.attributes.filter(g => g == null ? void 0 : g.isPrimaryKey),
                    u = s.map(g => `"${g==null?void 0:g.columnName}" = ?`).join(", "),
                    l = a.map(g => `"${g==null?void 0:g.columnName}" = ?`).join(" and "),
                    c = `"${e.tableName}"`,
                    d = [];
                s.forEach(g => d.push(t[g == null ? void 0 : g.columnName])), a.forEach(g => d.push(t[g == null ? void 0 : g.columnName]));
                let f = o((g, p) => {
                        p.rowsAffected === 0 ? this.debug(`Record to update does not exist on table '${e.tableName}'`) : this.debug(`Updated record on table '${e.tableName}' successfully`), n()
                    }, "onSuccess"),
                    h = o((g, p) => {
                        let m = new Error(p.message.toString());
                        return this.warning(`Error updating record on table '${e.tableName}'`, m), i(m), !1
                    }, "onError");
                this.transaction.executeSql(`UPDATE ${c} SET ${u} WHERE ${l}`, d, f, h)
            })
        }
        upsertRecord(e, t) {
            return new Promise((n, i) => {
                if (this.debug(`Adding/updating record on table '${e.tableName}'`), this.mode < Wr.Write) {
                    let h = new Error(mu);
                    return this.warning(`Error adding/updating record on table '${e.tableName}'`, h), i(h)
                }
                let s = e.attributes.filter(h => h == null ? void 0 : h.isPrimaryKey),
                    a = e.attributes.map(h => `"${h==null?void 0:h.columnName}"`).join(", "),
                    u = br.concatenateMultipleTimes("?", e.attributes.length, ", "),
                    l = `"${e.tableName}"`,
                    c = e.attributes.map(h => t[h == null ? void 0 : h.columnName]),
                    d = o((h, g) => {
                        var p, m;
                        this.debug(`Added/updated record on table '${e.tableName}' successfully`);
                        let w;
                        e.idIsAutoNumber === Ar.No || e.idIsAutoNumber === Ar.YesIfEmpty && t[(p = s[0]) === null || p === void 0 ? void 0 : p.columnName] !== null ? w = t[(m = s[0]) === null || m === void 0 ? void 0 : m.columnName] : w = g.insertId, n(w)
                    }, "onSuccess"),
                    f = o((h, g) => {
                        let p = new Error(g.message.toString());
                        return this.warning(`Error adding/updating record on table '${e.tableName}'`, p), i(p), !1
                    }, "onError");
                this.transaction.executeSql(`INSERT OR REPLACE INTO ${l} (${a}) VALUES (${u})`, c, d, f)
            })
        }
        upsertAllRecords(e, t) {
            return k(this, void 0, void 0, function*() {
                if (this.debug(`Adding/updating ${t==null?void 0:t.length} record(s) on table '${e.tableName}'`), this.mode < Wr.Write) {
                    let n = new Error(mu);
                    throw this.warning(`Error adding/updating records on table '${e.tableName}'`, n), n
                }
                try {
                    e.attributes.some(i => (i == null ? void 0 : i.type) === re.BINARY_DATA) ? yield this.innerUpsertAllSingle(e, t): yield this.innerUpsertAllBulk(e, t), this.debug(`Added/updated ${t==null?void 0:t.length} record(s) on table '${e.tableName}' successfully`)
                } catch (n) {
                    throw this.warning(`Error adding/updating ${t==null?void 0:t.length} record(s) on table '${e.tableName}'`, n), n
                }
            })
        }
        innerUpsertAllSingle(e, t) {
            return k(this, void 0, void 0, function*() {
                this.debug(`Adding/updating ${t==null?void 0:t.length} record(s) on table '${e.tableName}' one by one`);
                for (let n of t) yield this.upsertRecord(e, n)
            })
        }
        innerUpsertAllBulk(e, t) {
            return k(this, void 0, void 0, function*() {
                let n = Math.floor(br.MaxQueryParameters / e.attributes.length);
                if (n === 0) return this.innerUpsertAllSingle(e, t);
                let i = [],
                    s = Math.ceil(t.length / n);
                this.debug(`Adding/updating ${t==null?void 0:t.length} record(s) on table '${e.tableName}' in ${s} chunk(s) of ${n} record(s) each`);
                for (let u = 0; u < s; u++) {
                    let l = [],
                        c = 0;
                    for (; c < n;) {
                        let f = u * n + c;
                        if (f === t.length) break;
                        let h = t[f];
                        e.attributes.forEach(g => l.push(h[g == null ? void 0 : g.columnName])), c++
                    }
                    let d = this.createUpsertBulkQuery(e, c);
                    i.push({
                        query: d,
                        argList: l
                    })
                }
                let a = 0;
                for (let u of i) this.debug(`Adding/updating chunk ${++a} of ${s} on table '${e.tableName}'`), yield this.wrapExecuteSqlOnPromise(u, e)
            })
        }
        wrapExecuteSqlOnPromise(e, t) {
            return new Promise((n, i) => {
                let s = o((u, l) => {
                        this.debug(`Added/Updated bulk of records on table '${t.tableName}' successfully`), n()
                    }, "onSuccess"),
                    a = o((u, l) => {
                        let c = new Error(l.message.toString());
                        return this.warning(`Error adding/updating bulk of records on table '${t.tableName}'`, c), i(c), !1
                    }, "onError");
                this.transaction.executeSql(e.query, e.argList, s, a)
            })
        }
        createUpsertBulkQuery(e, t) {
            let n = e.attributes.map(u => `"${u==null?void 0:u.columnName}"`).join(", "),
                i = `"${e.tableName}"`,
                s = `(${br.concatenateMultipleTimes("?",e.attributes.length,", ")})`,
                a = br.concatenateMultipleTimes(s, t, ", ");
            return `INSERT OR REPLACE INTO ${i} (${n}) VALUES ${a}`
        }
        removeRecord(e, t) {
            return new Promise((n, i) => {
                if (this.debug(`Deleting record with key '${t}' from table '${e.tableName}'`), this.mode < Wr.Write) {
                    let h = new Error(mu);
                    return this.warning(`Error deleting record from table '${e.tableName}'`, h), i(h)
                }
                let s = br.wrapKeyIfNeeded(t),
                    a = `"${e.tableName}"`,
                    u = e.attributes.filter(h => h == null ? void 0 : h.isPrimaryKey),
                    l = [...s],
                    c = u.map(h => `"${h==null?void 0:h.columnName}" = ?`).join(" AND "),
                    d = o((h, g) => {
                        this.debug(`Deleted record with key '${t}' from table '${e.tableName}' successfully`), n()
                    }, "onSuccess"),
                    f = o((h, g) => {
                        let p = new Error(g.message.toString());
                        return this.warning(`Error deleting record with key '${t}' from table '${e.tableName}'`, p), i(p), !1
                    }, "onError");
                this.transaction.executeSql(`DELETE FROM ${a} WHERE ${c===""?"ROWID = ?":c}`, l, d, f)
            })
        }
        removeAllRecords(e) {
            return new Promise((t, n) => {
                if (this.debug(`Deleting all records from table '${e.tableName}'`), this.mode < Wr.Write) {
                    let u = new Error(mu);
                    return this.warning(`Error deleting all records from table '${e.tableName}'`, u), n(u)
                }
                let i = `"${e.tableName}"`,
                    s = o((u, l) => {
                        this.debug(`Deleted all records from table '${e.tableName}' successfully`), t()
                    }, "onSuccess"),
                    a = o((u, l) => {
                        let c = new Error(l.message.toString());
                        return this.warning(`Error deleting all records from table '${e.tableName}'`, c), n(c), !1
                    }, "onError");
                this.transaction.executeSql(`DELETE FROM ${i}`, void 0, s, a)
            })
        }
        findRecords(e, t) {
            return new Promise((n, i) => {
                this.debug(`Searching for all records on table '${e.tableName}' that match the specified criteria`);
                let a = (Ms(e).length > 0 ? "" : '"rowid" AS "ROWID", ') + e.attributes.map(h => `"${h==null?void 0:h.columnName}"`).join(", "),
                    u = `"${e.tableName}"`,
                    l = "",
                    c = [];
                for (let h in t)
                    if (t.hasOwnProperty(h)) {
                        let g = l.length > 0 ? " AND " : "";
                        l += `${g}"${zI(h)}" = ?`, c.push(t[h])
                    } let d = o((h, g) => {
                        this.debug(`Search on table '${e.tableName}' found ${g.rows.length} record(s) matching the specified criteria`);
                        let p = br.convertSQLResultSetToDatabaseRecord(e, g);
                        n(p)
                    }, "onSuccess"),
                    f = o((h, g) => {
                        let p = new Error(g.message.toString());
                        return this.warning(`Error searching for records on table '${e.tableName}'${Tae}${p}`, p), i(p), !1
                    }, "onError");
                this.transaction.executeSql(`SELECT ${a} FROM ${u} WHERE ${l}`, c, d, f)
            })
        }
        getAllRecords(e) {
            return new Promise((t, n) => {
                this.debug(`Getting all records on table '${e.tableName}'`);
                let s = (Ms(e).length > 0 ? "" : '"rowid" AS "ROWID", ') + e.attributes.map(c => `"${c==null?void 0:c.columnName}"`).join(", "),
                    a = `"${e.tableName}"`,
                    u = o((c, d) => {
                        this.debug(`Retrieved all records from table '${e.tableName}' successfully`);
                        let f = br.convertSQLResultSetToDatabaseRecord(e, d);
                        t(f)
                    }, "onSuccess"),
                    l = o((c, d) => {
                        let f = new Error(d.message.toString());
                        return this.warning(`Error retrieving all records from table '${e.tableName}'`, f), n(f), !1
                    }, "onError");
                this.transaction.executeSql(`SELECT ${s} FROM ${a}`, void 0, u, l)
            })
        }
        debug(e) {
            this.allowTraces && ee(Yb, `${e} on transaction ${this.transactionId}`)
        }
        warning(e, t) {
            ft(Yb, `${e} on transaction ${this.transactionId}${t?`: ${t.message}`:""}`, Pe.Client)
        }
        static wrapKeyIfNeeded(e) {
            return e instanceof Array ? e : [e]
        }
        static convertSQLResultSetToDatabaseRecord(e, t) {
            let n = Ms(e).length > 0,
                i = [];
            if (t.rows.length > 0)
                for (let s = 0; s < t.rows.length; s++) {
                    let a = t.rows.item(s),
                        u = {};
                    n || (u.$KEY = a.ROWID), e.attributes.forEach(l => {
                        u[l == null ? void 0 : l.columnName] = a[l == null ? void 0 : l.columnName]
                    }), i.push(u)
                }
            return i
        }
        static concatenateMultipleTimes(e, t, n) {
            return Array.apply(null, new Array(t)).map(() => e).join(`${n}`)
        }
    };
o(br, "WebSQLTransaction");
var of = br; of .MaxQueryParameters = 500; of .lastTransactionId = 0;
var bd = "Could not open database",
    bae = "Failed to execute canary query (probably due to zombie transaction)",
    Do = "WebSQLDatabase",
    xr = class xr extends Hm {
        static open(e) {
            return k(this, void 0, void 0, function*() {
                return this.cache[e] || (this.cache[e] = yield xr.innerOpen(e)), this.cache[e]
            })
        }
        static innerOpen(e) {
            return k(this, void 0, void 0, function*() {
                if (typeof window == "undefined") throw new pe.SystemException("Database is only available in the browser/web view");
                if (Cr()) return xr.openPluginDatabase(e);
                if (xr.isWebSQLSupported()) return xr.openWebSQLDatabase(e);
                xr.throwDatabaseRequiredError()
            })
        }
        static openPluginDatabase(e) {
            return k(this, void 0, void 0, function*() {
                yield En();
                let t = window;
                if (t.sqlitePlugin) return ee(xr, `Opening database '${e}'`), new Promise((n, i) => {
                    try {
                        t.sqlitePlugin.openDatabase({
                            name: e,
                            location: "default"
                        }, s => {
                            s ? (ee(xr, `Database '${e}' opened successfully`), n(new xr(e, s))) : (ft(Do, `Error opening database '${e}'`), i(new pe.OpenDatabaseException(`${bd} '${e}'`)))
                        }, s => {
                            ft(Do, `Error opening database '${e}' ${s.message}`), i(new pe.OpenDatabaseException(`${bd} '${e}': ${s.message.toString()}`))
                        })
                    } catch (s) {
                        i(new pe.OpenDatabaseException(`${bd} '${e}': ${s.message.toString()}`))
                    }
                });
                throw new pe.OpenDatabaseException("No database driver available")
            })
        }
        static openWebSQLDatabase(e) {
            let t = window,
                n;
            try {
                ee(xr, `Opening database '${e}'`), n = t.openDatabase(e, "1.0", e, 5 * 1024 * 1024)
            } catch (i) {
                throw new pe.OpenDatabaseException(`${bd} '${e}': ${i.message.toString()}`)
            }
            if (n) return ee(xr, `Database '${e}' opened successfully`), new xr(e, n);
            throw ft(Do, `Error opening database '${e}'`), new pe.OpenDatabaseException(`${bd} '${e}'`)
        }
        static isWebSQLSupported() {
            return !!window.openDatabase
        }
        static throwDatabaseRequiredError() {
            let n = `Your app requires native access to a Local Storage database that is not available in your browser.

Please test your app in your mobile device` + (!!window.chrome ? "" : ", or use Google Chrome web browser") + ".";
            throw alert(n), new pe.SystemException(n)
        }
        constructor(e, t) {
            super(e, "WebSQL"), this.databaseImplementation = t
        }
        testConnection() {
            return k(this, void 0, void 0, function*() {
                let t = 0;
                tn(Do, "Starting to test on database connections. Performing #5 test queries.", Pe.Internal), yield Promise.all(Array.apply(null, new Array(5)).map(() => new Promise(n => k(this, void 0, void 0, function*() {
                    try {
                        yield this.executeTransaction(i => i.executeQuery(s => new Promise((a, u) => {
                            s.executeSql("SELECT 1", void 0, () => a(), (l, c) => (u(new Error(c.message.toString())), !1))
                        })))
                    } catch (i) {
                        t++, Ue("WebSQLDatabase", bae, "OS-CLRT-60407", i)
                    } finally {
                        n()
                    }
                })))), tn(Do, `Finished tests on database connections. #${5-t} out of #5 successfull queries.`, Pe.Internal)
            })
        }
        close() {
            return this.databaseImplementation = null, delete xr.cache[this.name], Promise.resolve()
        }
        executeQuery(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
            return this.executeReadTransaction(n => n.executeQuery(e), t)
        }
        executeTransaction(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,
                n = arguments.length > 2 ? arguments[2] : void 0;
            return this.innerExecuteTransaction(e, Wr.Write, t, n)
        }
        executeReadTransaction(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,
                n = arguments.length > 2 ? arguments[2] : void 0;
            return this.innerExecuteTransaction(e, Wr.Read, t, n)
        }
        executeUpgradeTransaction(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
            return this.innerExecuteTransaction(e, Wr.Upgrade, t)
        }
        innerExecuteTransaction(e, t) {
            let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
                i = arguments.length > 3 ? arguments[3] : void 0;
            return new Promise((s, a) => {
                let u, l, c;
                this.innerExecuteTransactionInMode(t === Wr.Read, d => k(this, void 0, void 0, function*() {
                    u = new of (n, d, t);
                    try {
                        l = yield e(u)
                    } catch (f) {
                        c = f, d.executeSql("ABORT_TRANSACTION", void 0, () => {}, () => !0)
                    }
                }), d => {
                    let f = c != null ? c : new Error(d.message.toString());
                    n && ft(Do, `Aborting transaction ${u==null?void 0:u.transactionId}: ${f}`, Pe.Client), a(f)
                }, () => {
                    this.debug(`Committing transaction ${u==null?void 0:u.transactionId}`, n), s(l)
                })
            })
        }
        innerExecuteTransactionInMode(e, t, n, i) {
            var s, a;
            e ? (s = this.databaseImplementation) === null || s === void 0 || s.readTransaction(t, n, i) : (a = this.databaseImplementation) === null || a === void 0 || a.transaction(t, n, i)
        }
        debug(e) {
            (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) && ee(Do, e)
        }
    };
o(xr, "WebSQLDatabase");
var hv = xr;
hv.cache = {};
var Iy = typeof __PERFORMANCE != "undefined";

function kd(r) {
    Iy && __PERFORMANCE.start(r)
}
o(kd, "start");

function Lu(r) {
    Iy && __PERFORMANCE.end(r)
}
o(Lu, "end");

function Sae() {
    if (Iy) return __PERFORMANCE.dump()
}
o(Sae, "dump");

function Aae() {
    if (Iy) return __PERFORMANCE.clear()
}
o(Aae, "clear");
var Iae = Object.freeze({
        __proto__: null,
        clear: Aae,
        dump: Sae,
        end: Lu,
        start: kd
    }),
    FC = class FC {
        setErrorHandler(e) {
            this.errorHandler = e
        }
        loadModule(e, t, n) {
            return k(this, void 0, void 0, function*() {
                var i;
                try {
                    let s = e.map(u => u()),
                        a = yield Promise.all(s);
                    t == null || t(...a)
                } catch (s) {
                    let a = new pe.Exception(s.message, s.stack, "OS-CLRT-ESM-40000");
                    (i = n != null ? n : this.errorHandler) === null || i === void 0 || i(a)
                }
            })
        }
    };
o(FC, "ESMRequireManager");
var JS = FC,
    KI = new JS;

function hF(r) {
    KI.setErrorHandler(r)
}
o(hF, "setErrorHandler");

function Cy(r, e, t) {
    KI.loadModule(r, e, t)
}
o(Cy, "loadModule");

function gF(r) {
    return k(this, void 0, void 0, function*() {
        return new Promise((e, t) => {
            KI.loadModule(r, function() {
                for (var n = arguments.length, i = new Array(n), s = 0; s < n; s++) i[s] = arguments[s];
                return e(i)
            }, t)
        })
    })
}
o(gF, "loadModuleAsync");
var Cae = Object.freeze({
        __proto__: null,
        loadModule: Cy,
        loadModuleAsync: gF,
        setErrorHandler: hF
    }),
    Ec;
(function(r) {
    r[r.TransitionStart = 0] = "TransitionStart", r[r.TransitionEnd = 1] = "TransitionEnd", r[r.NavigationStart = 2] = "NavigationStart"
})(Ec || (Ec = {}));
var ZS;
(function(r) {
    r[r.Success = 0] = "Success", r[r.Failure = 1] = "Failure"
})(ZS || (ZS = {}));
var Rae = 0,
    Xb = (() => {
        let r = [],
            e = Object.keys(Ec).length / 2;
        for (let t = 0; t < e; t++) r.push({});
        return r
    })(),
    af;
(function(r) {
    function e() {
        return "_" + Rae++
    }
    o(e, "getNewId");

    function t(u, l) {
        let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
            d = e();
        return Xb[u][d] = {
            listenOnce: c,
            callback: l
        }, {
            type: u,
            id: d
        }
    }
    o(t, "listen"), r.listen = t;

    function n(u, l) {
        return t(u, l, !0)
    }
    o(n, "listenOnce"), r.listenOnce = n;

    function i(u) {
        return u && s(u.type, u.id)
    }
    o(i, "unregister"), r.unregister = i;

    function s(u, l) {
        return delete Xb[u][l]
    }
    o(s, "innerUnregister");

    function a(u) {
        let l, c = Xb[u.type];
        for (let d in c) {
            let f = c[d];
            f.listenOnce && s(u.type, d);
            let h = f.callback(u.args);
            h !== void 0 && (l = h)
        }
        return l
    }
    o(a, "dispatch"), r.dispatch = a
})(af || (af = {}));
var Oae = Object.freeze({
        __proto__: null,
        get EventDispatcher() {
            return af
        },
        get EventType() {
            return Ec
        },
        get TransitionEndResult() {
            return ZS
        }
    }),
    $C = class $C extends Error {
        constructor(e) {
            let {
                message: t,
                errorCode: n,
                category: i
            } = e;
            super(t), this.errorCode = n, this.category = i
        }
    };
o($C, "ClientRuntimeError");
var QS = $C,
    Hx = 1e4,
    pF = "moduleservices",
    Pae = `${pF}/moduleinfo`,
    Nae = `${pF}/moduleversioninfo`,
    BC = class BC {
        constructor() {
            let {
                getBasePath: e = o(() => Dt(), "getBasePath$1"),
                getMethod: t = wy,
                prefetchedVersion: n
            } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this.getBasePath = e != null ? e : () => Dt(), this.getMethod = t, this.prefetchedVersion = n
        }
        init() {
            return k(this, void 0, void 0, function*() {
                try {
                    this.prefetchedVersion = yield this.getLatestVersion()
                } catch (e) {
                    ee("ManifestLoader", `Failed to prefetch latest version. ${e}`)
                }
            })
        }
        getVersionTokenParameter(e) {
            return e ? `?${e}` : ""
        }
        getPrefetchedVersion() {
            return this.prefetchedVersion
        }
        getLatestManifest(e, t) {
            return this.getManifest(e, t)
        }
        getCachedManifest(e) {
            return this.getManifest("cached", e)
        }
        getManifest(e) {
            return k(this, arguments, void 0, function(t) {
                var n = this;
                let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ge.resolve(J.UnauthenticatedHttpClient);
                return (function*() {
                    var s;
                    let a = `${Pae}${n.getVersionTokenParameter(t)}`;
                    return (s = yield n.getMethod({
                        url: a,
                        timeout: Hx,
                        baseURL: n.getBasePath(),
                        httpClient: i
                    })) !== null && s !== void 0 ? s : {}
                })()
            })
        }
        getLatestVersion() {
            return k(this, arguments, void 0, function() {
                var e = this;
                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Date().getTime().toString(),
                    n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ge.resolve(J.HttpClient);
                return (function*() {
                    var i;
                    let s = `${Nae}?${t}`;
                    return (i = yield e.getMethod({
                        url: s,
                        timeout: Hx,
                        baseURL: e.getBasePath(),
                        httpClient: n
                    })) !== null && i !== void 0 ? i : {}
                })()
            })
        }
    };
o(BC, "ManifestLoader");
var eA = BC;

function Dae() {
    return k(this, void 0, void 0, function*() {
        try {
            return yield En(), uy(window) ? window.OutSystemsNative.Prebundle : null
        } catch (r) {
            return null
        }
    })
}
o(Dae, "getPrebundlePlugin");

function Lae() {
    return k(this, void 0, void 0, function*() {
        let r = yield Dae();
        return r ? new Promise((e, t) => {
            r.getManifest(e, t)
        }) : null
    })
}
o(Lae, "getManifest");
var Jb = "ResourceCache",
    VC = class VC {
        constructor() {
            this.isCaching = !1, this.errorMessages = [], this.onFinishListeners = [], this.onErrorListeners = [], this.onProgressListeners = []
        }
        onFinish() {
            this.isCaching = !1, this.onFinishListeners.forEach(e => e()), this.onFinishListeners = [], this.onErrorListeners = [], this.onProgressListeners = []
        }
        onError(e) {
            this.errorMessages.push(e), this.onErrorListeners.forEach(t => t(e))
        }
        onProgress(e, t) {
            this.onProgressListeners.forEach(n => n(e, t))
        }
        listen(e, t, n) {
            this.errorMessages.length > 0 && t && t(this.errorMessages.join(`
`)), !this.isCaching && e && e(), this.isCaching && (e && this.onFinishListeners.push(e), t && this.onErrorListeners.push(t), n && this.onProgressListeners.push(n))
        }
        start(e) {
            return new Promise((t, n) => {
                if (!this.isCaching) try {
                    this.isCaching = !0, this.errorMessages = [], this.innerStart(e)
                } catch (s) {
                    this.onError(s.message), n(s.message);
                    return
                }
                let i = {
                    finished: !1
                };
                this.listen(() => {
                    i.finished || (i.finished = !0, t())
                }, s => {
                    i.finished || (i.finished = !0, n(s))
                }, null)
            })
        }
        switch (e) {
            this.innerSwitch(e)
        }
    };
o(VC, "AbstractCacheHandler");
var uf = VC,
    Hd = class Hd extends uf {
        constructor() {
            super(), this.isNativeReady = !1, this.isCacheAvailable = !1, En().then(() => {
                if (this.isNativeReady = !0, this.isCacheAvailable = typeof OSCache != "undefined", !this.isCacheAvailable) {
                    console.error(Jb, Hd.OSCacheNotFoundMessage);
                    return
                }
                OSCache.addEventListener("onfinish", e => this.onFinish()), OSCache.addEventListener("onerror", e => this.onError(e.message)), OSCache.addEventListener("onprogress", e => this.onProgress(e.loaded, e.total))
            }, e => {
                console.error(Jb, "OSCache was not initialized because Cordova was not loaded.", e)
            })
        }
        checkOSCacheAndDeferCall(e, t) {
            if (this.isNativeReady) {
                if (!this.isCacheAvailable) return e && this.onError(Hd.OSCacheNotFoundMessage), !1
            } else return En().then(t), !1;
            return !0
        }
        getCacheName() {
            return "Native Cache"
        }
        innerStart(e) {
            if (!this.checkOSCacheAndDeferCall(!0, () => this.innerStart(e))) return;
            let t = Dt(),
                n = `/${Gr()}/`,
                i = [];
            for (let s of Object.getOwnPropertyNames(e.urlVersions)) i.push(ay(oy(s, n, t), e.urlVersions[s]));
            OSCache.startCaching(e.versionToken, i, e.urlMappings, e.urlMappingsNoCache)
        }
        innerSwitch(e) {
            if (this.checkOSCacheAndDeferCall(!1, () => this.innerSwitch(e))) try {
                OSCache.switchToVersion(e)
            } catch (t) {
                console.error(Jb, t)
            }
        }
    };
o(Hd, "NativeCacheHandler");
var gv = Hd;
gv.OSCacheNotFoundMessage = "OSCache not found (is a native plugin missing?)";
var jd = class jd extends uf {
    constructor() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : wy;
        super(), this.requested = 0, this.resourceQueue = [], this.count = 0, this.total = 0, this.getMethod = e
    }
    getCacheName() {
        return "Preloader"
    }
    innerStart(e) {
        if (this.isOngoing() || (this.count = this.requested = this.total = 0, this.resources = e.urlVersions, !this.resources) || (this.resourceQueue = Object.getOwnPropertyNames(this.resources), this.total = this.resourceQueue.length, this.resourceQueue.length <= 0)) return;
        let t = "",
            n = `/${Gr()}/`;
        for (let i = 0; i < jd.DefaultWindowSize; ++i) this.prefetchNext(n, t)
    }
    innerSwitch(e) {}
    isOngoing() {
        return this.requested > 0 || this.resourceQueue.length > 0
    }
    request(e, t, n) {
        return k(this, void 0, void 0, function*() {
            try {
                yield this.getMethod({
                    url: e,
                    timeout: jd.DefaultResourceTimeout,
                    responseType: "none"
                })
            } catch (i) {
                this.onError && this.onError(`Failed to load resource '${e}'.`)
            }
            this.onProgress && this.onProgress(++this.count, this.total), this.requested--, this.resourceQueue.length === 0 && this.requested === 0 ? this.onFinish && this.onFinish() : this.resourceQueue.length > 0 && this.prefetchNext(t, n)
        })
    }
    prefetchNext(e, t) {
        let n = this.resourceQueue.pop();
        if (!n) throw new Error("No resource to fetch next.");
        let i = ay(oy(n, e, t), this.resources[n]);
        this.request(i, e, t), this.requested++
    }
};
o(jd, "PreloaderCacheHandler");
var cf = jd;
cf.DefaultWindowSize = 2;
cf.DefaultResourceTimeout = 2e4;
var HC = class HC extends uf {
    getCacheName() {
        return "Dummy"
    }
    innerStart(e) {
        this.onFinish()
    }
    innerSwitch(e) {}
};
o(HC, "DummyCacheHandler");
var tA = HC;

function xae() {
    return typeof document == "undefined" ? new tA : Cr() ? new gv : new cf
}
o(xae, "getResourcesCacheHandler");
var wm = xae(),
    or = "VersionsManager",
    Uae = "index.html",
    mF = "__",
    jx;
(function(r) {
    r[r.Generic = 0] = "Generic", r[r.Resources = 1] = "Resources", r[r.DataModel = 2] = "DataModel"
})(jx || (jx = {}));
var Wx;
(function(r) {
    r[r.Idle = 0] = "Idle", r[r.Upgrading = 1] = "Upgrading", r[r.UpgradeSuccess = 2] = "UpgradeSuccess", r[r.UpgradeFailed = 3] = "UpgradeFailed"
})(Wx || (Wx = {}));
var vu = {
        applicationInfo: new wn(ar.Persistent, "ApplicationInfo"),
        upgradeStatus: new wn(ar.Session, "UpgradeStatus", 0)
    },
    Mae = o((r, e) => {
        let t = r.replace(/(.*)(\?[^?]+)$/, "$1").replace(/(.*)(\.[^.]+)$/, "$1");
        return e && (t = t.replace(/(.*)(__[^_]+)$/, "$1")), t
    }, "removeFileHashAndExtension"),
    kae = o(r => {
        let e = r.indexOf("?"),
            t = r.substring(0, e >= 0 ? e : void 0);
        return t.substring(t.lastIndexOf("."))
    }, "getFileExtension"),
    vF = o((r, e) => r.startsWith(`/${e}/`) ? r : `/${e}/${r}`, "getModuleBasedUrl"),
    rA = o((r, e, t) => t ? t[vF(r, e)] : void 0, "getResourceVersionTokenFromManifest"),
    yF = o(function(r, e) {
        let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
            n = Mae(r, t),
            i = jo(n),
            s = jo(kae(r)),
            a = jo(mF),
            u = new RegExp(`${i}${a}.*${s}$`),
            l = e ? Object.keys(e).find(c => u.exec(c)) : void 0;
        return l ? {
            matchedUrlVersion: l,
            relativeUrlWithoutHashAndExtension: n
        } : t ? {} : yF(r, e, !0)
    }, "matchUrl"),
    Fae = o((r, e, t) => {
        let {
            matchedUrlVersion: n,
            relativeUrlWithoutHashAndExtension: i
        } = yF(r, e);
        if (t && n && i) {
            let s = n.lastIndexOf(mF),
                a = n.substring(s);
            return `${i}${a}`
        } else return r
    }, "findResourceUrl"),
    $ae = o(function(r, e) {
        let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
            n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Gr,
            i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Dt,
            s = n(),
            a = i(),
            u = Fae(r, e, t),
            l = rA(u, s, e);
        if (l) {
            let c = ay(vF(u, s), l != null ? l : ""),
                d = `/${s}/`;
            return oy(c, d, a)
        }
        return u
    }, "getVersionedUrl"),
    Gx = o(function(r) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : zo();
        var t, n;
        return (n = (t = e.document.querySelector('meta[name="indexVersionToken"]')) === null || t === void 0 ? void 0 : t.getAttribute("content")) !== null && n !== void 0 ? n : r == null ? void 0 : r.indexVersionToken
    }, "getVersionFromGlobalContext"),
    Iu = class Iu {
        constructor() {
            let {
                manifestLoader: e = new eA
            } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this.checkedCachedInfoConsistency = !1, this.manifestLoader = e
        }
        get cachedAppInfo() {
            let e = vu.applicationInfo.get();
            if (e && !this.checkedCachedInfoConsistency) {
                try {
                    Iu.validateApplicationInfo(e)
                } catch (t) {
                    e = void 0, vu.applicationInfo.remove()
                }
                this.checkedCachedInfoConsistency = !0
            }
            return e
        }
        set cachedAppInfo(e) {
            vu.applicationInfo.set(e)
        }
        get currentAppInfo() {
            var e, t;
            return (t = (e = this.fetchedApplicationInfo) === null || e === void 0 ? void 0 : e.manifest) !== null && t !== void 0 ? t : this.cachedAppInfo
        }
        get upgradeStatus() {
            return vu.upgradeStatus.get()
        }
        set upgradeStatus(e) {
            vu.upgradeStatus.set(e)
        }
        initializeManifestLoader() {
            return this.manifestLoader.init()
        }
        initialize() {
            return k(this, void 0, void 0, function*() {
                if (ee(or, "Initializing VersionsManager"), this.initialUpgradeStatus = this.upgradeStatus, !Gr()) return Promise.reject(Error("Home module not defined!"));
                this.enableBackgroundCheckForNewVersions(), this.fetchedApplicationInfo = yield this.fetchApplicationManifest()
            })
        }
        upgradeVersion(e, t) {
            this.onVersionReady = t.onVersionReady || (() => {}), this.onUpgradeFinished = t.onUpgradeFinished || (a => {}), this.onNewVersionDetected = !this.isUpgradeDisabled && t.onNewVersionDetected || (a => Promise.resolve());
            let n = t.onAppInfoReady || (a => {}),
                i = this.fetchedApplicationInfo.manifest,
                s = this.fetchedApplicationInfo.isFromPrebundle;
            if (n(i), this.isNewVersion(i.manifest, s)) {
                if (!this.isUpgradeDisabled && this.usingStaleIndex(i)) return mM(!0), tn(or, "Reloading application - index.html was changed in the server", Pe.Internal), !1;
                this.upgrade(i, e)
            } else this.initDataModel(e);
            return !0
        }
        initDataModel(e) {
            ee(or, "Initializing data model"), e.then(t => this.upgradeDataModel(t).then(() => this.switchDataModel(t)).then(() => {
                this.onVersionReady()
            })).then(() => this.setUpgradeStatus(0)).catch(t => this.handleInitError(t))
        }
        cacheResourcesInBackground(e) {
            return ee(or, "Caching resources in the background..."), this.fetchApplicationManifest(!1).then(t => {
                let {
                    manifest: n,
                    isFromPrebundle: i
                } = t, s = this.usingStaleIndex(n);
                if (e && e(s), cM(s), this.isNewVersion(n.manifest, i)) return this.upgradeResources(n)
            }).catch(t => ft(or, `Error caching resources for new version in the background: ${t}`))
        }
        getResourceVersionToken(e, t) {
            if (this.currentAppInfo) return rA(e, t, this.currentAppInfo.manifest.urlVersions)
        }
        isNewVersion(e, t) {
            let n = e.versionToken,
                i = this.getLastApplicationVersionToken();
            return n !== i
        }
        getLastApplicationVersionToken() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
            var t;
            if (e && (!((t = this.fetchedApplicationInfo) === null || t === void 0) && t.manifest)) return this.fetchedApplicationInfo.manifest.manifest.versionToken;
            let n = this.cachedAppInfo;
            return n ? n.manifest.versionToken : ""
        }
        getVersionToken(e, t) {
            return this.getResourceVersionToken(e, t)
        }
        getVersionedUrl(e) {
            var t, n;
            return $ae(e, (t = this.currentAppInfo) === null || t === void 0 ? void 0 : t.manifest.urlVersions, (n = this.currentAppInfo) === null || n === void 0 ? void 0 : n.manifest.cdnUrlVersioning)
        }
        static getJSONParseErrorMessage() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
            return "Error parsing manifest JSON " + (e ? `, missing or invalid field: ${e}.` : ".")
        }
        static validateApplicationInfo(e) {
            if (!e) throw Error(this.getJSONParseErrorMessage());
            if (!e.manifest) throw Error(this.getJSONParseErrorMessage("manifest"));
            let t = e.manifest;
            if (!t.versionToken || typeof t.versionToken != "string") throw Error(this.getJSONParseErrorMessage("manifest.versionToken"));
            if (!t.urlVersions || typeof t.urlVersions != "object") throw Error(this.getJSONParseErrorMessage("manifest.urlVersions"));
            if (!t.urlMappings || typeof t.urlMappings != "object") throw Error(this.getJSONParseErrorMessage("manifest.urlMappings"));
            if (!t.urlMappingsNoCache || typeof t.urlMappingsNoCache != "object") throw Error(this.getJSONParseErrorMessage("manifest.urlMappingsNoCache"));
            if (!e.data) throw Error(this.getJSONParseErrorMessage("data"));
            let n = e.data;
            if (!n.modules || typeof n.modules != "object") throw Error(this.getJSONParseErrorMessage("data.modules"))
        }
        getLatestVersionFromServer() {
            return k(this, arguments, void 0, function() {
                var e = this;
                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
                return (function*() {
                    let n = yield t && e.manifestLoader.getPrefetchedVersion() || e.manifestLoader.getLatestVersion();
                    return n.versionToken || Ue(or, "Error retrieving version token from module version info.", "OS-CLRT-60301"), n
                })()
            })
        }
        checkForNewVersion() {
            this.isUpgradeDisabled || this.isUpgradingVersion || !vu.applicationInfo.isDefined() || this.getLatestVersionFromServer(!1).then(e => {
                this.getLastApplicationVersionToken() !== e.versionToken && this.onNewVersionDetected(!1)
            }, e => {
                ft(or, `Error checking for new version: ${e}`)
            })
        }
        upgrade(e, t) {
            return k(this, void 0, void 0, function*() {
                ee(or, "New application version detected, starting upgrade..."), this.setUpgradeStatus(1);
                let n = this.supportsResourceCache().then(s => s ? this.upgradeResources(e).catch(a => this.handleUpgradeError(a, 1, Promise.resolve(void 0))) : Promise.resolve()),
                    i = t.then(s => this.upgradeDataModel(s)).catch(s => this.handleUpgradeError(s, 2, n));
                yield Promise.all([n, i]).then(() => {
                    this.upgradeStatus === 1 && this.commitNewVersion(e, t).then(s => {
                        s && this.onVersionReady()
                    })
                }).catch(s => this.handleUpgradeError(s))
            })
        }
        supportsResourceCache() {
            return k(this, void 0, void 0, function*() {
                var e;
                if (If()) {
                    let t = !!(!((e = ny()) === null || e === void 0) && e.splashScreenName);
                    return ee(or, `Web app - Resource pre-caching is ${t?"enabled":"disabled"}`), t
                } else {
                    let t = yield this.serviceWorkerIsAvailable(), n = Cr() || !t;
                    return ee(or, `Mobile app - Pre-caching resources with ${n?"Resource Cache":"Service Worker"}`), n
                }
            })
        }
        serviceWorkerIsAvailable() {
            return k(this, void 0, void 0, function*() {
                try {
                    return "serviceWorker" in navigator ? (yield navigator.serviceWorker.getRegistrations()) !== null : !1
                } catch (e) {
                    return !1
                }
            })
        }
        commitNewVersion(e, t) {
            return t.then(n => this.switchDataModel(n)).then(() => this.switchResourcesVersion(e.manifest.versionToken)).then(() => {
                let n = !this.cachedAppInfo;
                return this.cachedAppInfo = e, this.setUpgradeStatus(n ? 0 : 2), !0
            })
        }
        setManifestLoader(e) {
            this.manifestLoader = e
        }
        upgradeResources(e) {
            return kd("VersionsManager upgradeResources"), $m(() => wm.start(e.manifest), () => Lu("VersionsManager upgradeResources"))
        }
        upgradeDataModel(e) {
            return e ? (kd("VersionsManager upgradeDataModel"), ee(or, `Initializing data model on ${e.engineName} database.`), $m(() => k(this, void 0, void 0, function*() {
                let t = yield this.getAllEntityModules(), n = ge.resolve(J.EntityService);
                for (let i of t) n.registerInitializer(i.getEntityInfos());
                yield e.initialize()
            }), () => Lu("VersionsManager upgradeDataModel"))) : Promise.resolve()
        }
        getAllEntityModules() {
            let e = mU();
            return e ? (ee(or, "Fetching entities module."), new Promise((t, n) => {
                Cy([e], i => t([i]), n)
            })) : Promise.resolve([])
        }
        switchResourcesVersion(e) {
            wm.switch(e)
        }
        switchDataModel(e) {
            return e ? (ee(or, "Finishing initialization of data model on database."), e.initializerCleanup()) : Promise.resolve()
        }
        handleInitError(e) {
            let t = this.isUpgradeDisabled ? "Upgrade failed and rollback isn't possible at this time" : "Unable to load the data model";
            Ue(or, t, "OS-CLRT-60303", e, Pe.External), Ds(e)
        }
        handleUpgradeError(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
                n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Promise.resolve(void 0);
            return Bn(e, pe.OpenDatabaseException) ? (Ue(or, "Upgrade failed - unable to open the database.", "OS-CLRT-60302", e), Ds(e), Promise.resolve(void 0)) : !hI() && this.initialUpgradeStatus !== 3 ? (Ue(or, "Upgrade failed - rolling back to previous application version.", "OS-CLRT-60302", e, Pe.External), this.rollBackApplicationVersion(t, n)) : this.initialUpgradeStatus === 3 ? (Ds(e), Promise.resolve(void 0)) : (ft(or, "Upgrade failed - ignoring error due to concurrent navigation."), this.upgradeStatus !== 3 && this.setUpgradeStatus(0), Promise.resolve(void 0))
        }
        get isUpgradingVersion() {
            return this.upgradeStatus === 1
        }
        setUpgradeStatus(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            if (this.upgradeStatus = e, ee(or, "Upgrade status changed to: " + e), e === 2) return this.onUpgradeFinished(!0);
            if (e === 3) return this.onUpgradeFinished(!1, t)
        }
        rollBackApplicationVersion(e, t) {
            return this.loadCachedManifest().then(n => {
                let {
                    manifest: i
                } = n;
                if (this.setUpgradeStatus(3, e), e !== 1) return t.then(() => wm.start(i.manifest))
            }).then(() => {
                gI(!1)
            }).catch(n => {
                Ds(n)
            })
        }
        get isUpgradeDisabled() {
            return this.upgradeStatus === 3
        }
        isRunningCachedIndex() {
            let e = Gx(zo().OSManifestLoader),
                t = this.getIndexVersion(this.cachedAppInfo);
            return !!t && e === t
        }
        usingStaleIndex(e) {
            if (gM()) return !1;
            let t = Gx(zo().OSManifestLoader) || this.getIndexVersion(this.cachedAppInfo),
                n = this.getIndexVersion(e);
            return t !== n
        }
        getIndexVersion(e) {
            if (!e) return "";
            let t = rA(Uae, Gr(), e.manifest.urlVersions);
            return t ? t.substr(1) : ""
        }
        loadCachedManifest() {
            return k(this, void 0, void 0, function*() {
                return {
                    manifest: yield this.innerLoadCachedManifest(),
                    isFromPrebundle: !1
                }
            })
        }
        innerLoadCachedManifest() {
            return k(this, void 0, void 0, function*() {
                if (yield this.ensureCachedManifest(), this.cachedAppInfo) return this.cachedAppInfo; {
                    let e = yield this.manifestLoader.getCachedManifest();
                    return Iu.validateApplicationInfo(e), e
                }
            })
        }
        innerLoadPrebundledManifest() {
            return Lae()
        }
        ensureCachedManifest() {
            if (Cr() || this.cachedAppInfo) return Promise.resolve(void 0); {
                this.setUpgradeStatus(0);
                let e = new QS({
                    message: "No cached manifest found. It's not possible to rollback to a previous version.",
                    errorCode: "OS-CLRT-60304"
                });
                return Promise.reject(e)
            }
        }
        getLatestManifestFromServer(e) {
            return this.manifestLoader.getLatestManifest(e).then(t => (Iu.validateApplicationInfo(t), {
                manifest: t,
                isFromPrebundle: !1
            }))
        }
        fetchApplicationManifest() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
            return kd("VersionsManager fetchApplicationManifest"), this.isUpgradeDisabled ? this.loadCachedManifest() : this.getLatestVersionFromServer(e).then(t => this.isNewVersion(t, !1) ? this.getLatestManifestFromServer(t.versionToken) : this.loadCachedManifest()).catch(() => this.loadCachedManifest()).then(t => (Lu("VersionsManager fetchApplicationManifest"), t))
        }
        enableBackgroundCheckForNewVersions() {
            let e = !1;
            af.listen(Ec.NavigationStart, () => e = !0), af.listen(Ec.TransitionEnd, () => {
                e = !1, setTimeout(() => {
                    e || this.checkForNewVersion()
                }, 1e3)
            })
        }
    };
o(Iu, "VersionsManager");
var nA = Iu,
    ai = new nA,
    xn = "Application",
    Bae = "upgrade-required",
    Vae = "upgrade-success",
    Hae = "upgrade-error",
    Tm = {
        hasRenderedSplashInSession: new wn(ar.Session, "HasRenderedSplashInSession", !1),
        pendingUpgradeFeedback: new wn(ar.Session, "PendingUpgradeFeedback")
    },
    Em = o((r, e, t) => k(void 0, void 0, void 0, function*() {
        var n;
        if (t === void 0 && (t = (n = ge.resolve(J.Auth)) === null || n === void 0 ? void 0 : n.getInstance()), !!t) return yield t.getValidAccessToken(r, e)
    }), "getToken"),
    ku, _F = (ku = class {
        constructor() {
            this.showingSplashScreen = !1, this.isApplicationReady = !1
        }
        setApplicationDefinition(e) {
            dU(e), vU(e.applicationKey), Cr() && Mne({
                version: e.appVersion
            })
        }
        triggerApplicationReadyEvent() {
            return k(this, void 0, void 0, function*() {
                let e = TU();
                if (e) {
                    let t = Gr();
                    ee(xn, `Calling application ready event handler for ${t}`);
                    try {
                        let [n] = yield gF([e]);
                        sie({
                            applicationName: t,
                            moduleController: n,
                            syncConfiguration: tI()
                        }), yield n.default.fireApplicationReady()
                    } catch (n) {
                        this.handleError(n)
                    }
                }
            })
        }
        initializeDatabase() {
            return k(this, void 0, void 0, function*() {
                ee(xn, "Initializing application database.");
                let e, t = If(),
                    n = Cr();
                if (t) e = Promise.resolve(void 0);
                else {
                    let i;
                    n ? (ee(xn, "Initializing WebSQL database service."), i = hv.open(gS())) : (ee(xn, "Initializing IndexDB database service."), i = fv.open(gS(), () => this.onNewVersionDetected(!0))), e = i.then(s => k(this, void 0, void 0, function*() {
                        return ee(xn, "Initializing entity service"), ge.resolve(J.EntityService).setDatabase(s), s
                    }))
                }
                return e
            })
        }
        onDatabaseReady(e) {
            e && (ge.resolve(J.EntityService).setReady(), ee(xn, "Database initialized successfully"))
        }
        onNewVersionDetected(e) {
            ee(xn, "New version detected, currentViewHasChanged = " + e);
            let t = !0,
                n = o(i => {
                    t = i
                }, "appInfoCallback");
            if (e) {
                this.disableDocument();
                let i = o(() => Xi(Fs(), t, !0), "onClick"),
                    s = o(a => a.getApplicationUpgradeRequiredMessage(this.canLoseDataInUpgrade()), "getMessage");
                this.showFeedbackMessage(s, 2, Bae, i).then(() => nk(!1))
            }
            return ai.cacheResourcesInBackground(n)
        }
        onAppInfoReady(e) {
            try {
                kd("Application onAppInfoReady"), this.updateServerRequestTimeoutOverrideInSeconds(e), this.updateApplicationInfo(e), this.updateClientInfo()
            } finally {
                Lu("Application onAppInfoReady")
            }
        }
        updateServerRequestTimeoutOverrideInSeconds(e) {
            var t;
            SU((t = e.data) === null || t === void 0 ? void 0 : t.serverRequestTimeoutOverrideInSeconds)
        }
        updateApplicationInfo(e) {
            var t;
            fU((t = e.data) === null || t === void 0 ? void 0 : t.modules)
        }
        updateClientInfo() {
            En().then(() => Ure()).catch(e => ft(xn, `Client info update failed: ${e}`))
        }
        shouldRenderSplashScreen() {
            let e = ny();
            return e != null && e.splashScreenName && e.splashScreenName.length > 0 ? !Tm.hasRenderedSplashInSession.get() : !1
        }
        disableDocument() {
            let e = document.createElement("div");
            e.classList.add("background-backdrop"), document.body.classList.add("disable-scroll"), document.body.appendChild(e)
        }
        canLoseDataInUpgrade() {
            return document.getElementsByTagName("form").length > 0
        }
        onUpgradeFinished(e, t) {
            e ? ee(xn, "Upgrade finished successfully") : ft(xn, `Upgrade failed with reason: ${t}`);
            let n = {
                success: e,
                failReason: t
            };
            e && !this.isShowingSplashScreen ? this.showUpgradeFeedback(n) : Tm.pendingUpgradeFeedback.set(n)
        }
        waitForAppReady() {
            return this.isApplicationReady ? Promise.resolve(void 0) : (this.appReadyPromise || (this.appReadyPromise = new Promise(e => {
                this.onReady = () => e()
            })), this.appReadyPromise)
        }
        onApplicationReady() {
            ee(xn, "Application ready"), Lu("Application ready"), TI(), this.isApplicationReady = !0, this.onReady && (this.onReady(), this.onReady = null)
        }
        showUpgradeFeedback(e) {
            let t, n, i;
            if (e.success) n = 0, t = o(s => s.getApplicationUpgradeCompleteMessage(), "getMessage"), i = Vae;
            else switch (n = 2, i = Hae, e.failReason) {
                case 1:
                    t = o(s => s.getApplicationUpgradeFailedOnResourcesMessage(), "getMessage");
                    break;
                case 2:
                    t = o(s => s.getApplicationUpgradeFailedOnDataModelMessage(), "getMessage");
                    break;
                default:
                    t = o(s => s.getApplicationUpgradeFailedUnknownMessage(), "getMessage");
                    break
            }
            this.showFeedbackMessage(t, n, i)
        }
        showFeedbackMessage(e, t) {
            let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "",
                i = arguments.length > 3 ? arguments[3] : void 0;
            return new Promise(s => {
                let a = EU();
                Cy([a], u => {
                    let l = e(u);
                    l && OI(l, t, !0, n, !0, i), s()
                })
            })
        }
        get isReady() {
            return this.isApplicationReady
        }
        get isShowingSplashScreen() {
            return this.showingSplashScreen
        }
        set isShowingSplashScreen(e) {
            e && Tm.hasRenderedSplashInSession.set(!0), this.showingSplashScreen = e
        }
        handleError(e, t) {
            Ds(e, t)
        }
        exit() {
            return Cr() ? tM() : !0
        }
        registerDefaultErrorHandler(e) {
            return ge.register(J.GlobalExceptionHandler, e)
        }
    }, o(ku, "Application"), ku),
    Uc = new _F;
pc.setUrlVersionProvider(ai.getVersionedUrl.bind(ai));
var jae = Object.freeze({
        __proto__: null,
        Application: _F,
        ApplicationStorage: Tm,
        default: Uc,
        getToken: Em
    }),
    iA, Lo, Fd, wF, jC = class jC {
        constructor() {
            iA.add(this), Lo.set(this, 0), Fd.set(this, new Map)
        }
        create() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Th;
            return dt(this, Lo, ie(this, Lo, "f") + 1, "f"), ie(this, Fd, "f").set(ie(this, Lo, "f"), e), {
                ref: ie(this, Lo, "f"),
                abortRequest: e
            }
        }
        abortPendingRequests(e) {
            for (let [t, n] of ie(this, Fd, "f")) t < e && (n.abort(), ie(this, iA, "m", wF).call(this, t))
        }
        shouldAbort(e) {
            return e !== ie(this, Lo, "f")
        }
    };
o(jC, "LinearTracker");
var sA = jC;
Lo = new WeakMap, Fd = new WeakMap, iA = new WeakSet, wF = o(function(e) {
    ie(this, Fd, "f").delete(e)
}, "_LinearTracker_deleteCommand");
var oA, bm, TF;

function Wae(r, e, t) {
    let {
        responseHandler: n
    } = t, i = o(function() {
        r.shouldAbort(e) || n == null || n(...arguments)
    }, "watcher");
    t.responseHandler = i
}
o(Wae, "watchResponseHandler");

function Gae(r, e, t, n) {
    return i => k(this, void 0, void 0, function*() {
        Wae(r, e, i);
        let s = Object.assign(Object.assign({}, i), {
            abortCommand: n
        });
        try {
            if (r.shouldAbort(e)) return {
                completed: !1
            };
            r.abortPendingRequests(e);
            let a = yield t(s);
            return r.shouldAbort(e) ? {
                completed: !1
            } : {
                completed: !0,
                data: a
            }
        } catch (a) {
            if (r.shouldAbort(e)) return {
                completed: !1
            };
            throw a
        }
    })
}
o(Gae, "createPostAction");
var WC = class WC {
    constructor() {
        oA.add(this), bm.set(this, new Map)
    }
    create(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : xI,
            n = arguments.length > 2 ? arguments[2] : void 0,
            i = ie(this, oA, "m", TF).call(this, e),
            {
                ref: s,
                abortRequest: a
            } = i.create(n);
        return {
            ref: s,
            post: Gae(i, s, t, a)
        }
    }
};
o(WC, "LinearRequest");
var aA = WC;
bm = new WeakMap, oA = new WeakSet, TF = o(function(e) {
    let t = ie(this, bm, "f").get(e);
    return t || (t = new sA, ie(this, bm, "f").set(e, t)), t
}, "_LinearRequest_getTracker");
var EF = o(() => {
        let r = bn.activeScreen;
        if (r) {
            let e = gU(yU());
            if (e) return JA(e, r.viewName)
        }
        return null
    }, "getCurrentScreenDefinition"),
    zae = o(() => {
        var r;
        let e = EF();
        return (r = e == null ? void 0 : e.screenName.split(".").pop()) !== null && r !== void 0 ? r : ""
    }, "getCurrentScreenName");

function zx(r, e) {
    tn("Public", `'${r}' is deprecated and will be removed on the next version. Consider using '${e}' instead.`)
}
o(zx, "emitDeprecatedWarning");

function qae() {
    return bn.activeScreen ? bn.activeScreen.modelContext : {
        viewName: "",
        navigatedFromHistory: !1,
        viewWasRestoredFromCache: !1
    }
}
o(qae, "getCurrentModelContext");
var Kae = HI,
    Vo;
(function(r) {
    r[r.Info = 0] = "Info", r[r.Success = 1] = "Success", r[r.Warning = 2] = "Warning", r[r.Error = 3] = "Error"
})(Vo || (Vo = {}));
var pv;
(function(r) {
    function e(i) {
        switch (i) {
            case Vo.Info:
                return 0;
            case Vo.Success:
                return 1;
            case Vo.Warning:
                return 2;
            case Vo.Error:
                return 3;
            default:
                throw new Error("Don't know how to convert " + i)
        }
    }
    o(e, "convertFeedbackMessageTypeToInternalEnum");

    function t(i, s) {
        let a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
            u = arguments.length > 3 ? arguments[3] : void 0,
            l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0,
            c = arguments.length > 5 ? arguments[5] : void 0;
        return OI(i, e(s), a, u, l, c)
    }
    o(t, "showFeedbackMessage$1"), r.showFeedbackMessage = t;

    function n() {
        return ik()
    }
    o(n, "closeFeedbackMessage$1"), r.closeFeedbackMessage = n
})(pv || (pv = {}));
var Fu, bF = (Fu = class {
        constructor(e) {
            this._model = e
        }
        setWidgetAsInvalid(e, t) {
            var n;
            let i = (n = this._model) === null || n === void 0 ? void 0 : n.widgets.get(e);
            i.validAttr = !1, i.validationMessageAttr = t
        }
        setWidgetAsValid(e) {
            var t;
            let n = (t = this._model) === null || t === void 0 ? void 0 : t.widgets.get(e);
            n.validAttr = !0, n.validationMessageAttr = ""
        }
        isWidgetValid(e) {
            var t;
            return ((t = this._model) === null || t === void 0 ? void 0 : t.widgets.get(e)).validAttr === !0
        }
    }, o(Fu, "Validation"), Fu),
    mv;
(function(r) {
    function e() {
        return lI()
    }
    o(e, "whenReady"), r.whenReady = e
})(mv || (mv = {}));
var bc;
(function(r) {
    let e = "ApplicationLifecycle";

    function t() {
        return ai.isUpgradingVersion
    }
    o(t, "isUpgradingVersion"), r.isUpgradingVersion = t;

    function n(i) {
        ee(e, "Registering listeners for the application load process."), i && (i.onLoadComplete && Uc.waitForAppReady().then(() => {
            var s;
            return (s = i.onLoadComplete) === null || s === void 0 ? void 0 : s.call(i)
        }), i.onUpgradeProgress && wm.listen(null, null, (s, a) => {
            var u;
            return (u = i.onUpgradeProgress) === null || u === void 0 ? void 0 : u.call(i, s, a)
        }))
    }
    o(n, "listen"), r.listen = n
})(bc || (bc = {}));
var GC = class GC {
    constructor(e) {
        this._context = e
    }
    navigateTo(e, t, n) {
        fy(e, this.getTransitionObject(t, Af), this._context, !1, n)
    }
    navigateBack(e) {
        TM(this.getTransitionObject(e), this._context, !1)
    }
    navigateForward(e) {
        EM(this.getTransitionObject(e), this._context, !1)
    }
    navigatedFromHistory() {
        return qae().navigatedFromHistory
    }
    registerBackNavigationHandler(e) {
        return vM(e)
    }
    unregisterBackNavigationHandler(e) {
        yM(e)
    }
    registerNavigationHandler(e) {
        return _M(e)
    }
    getTransitionObject(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        return ty(e, t)
    }
};
o(GC, "Navigation");
var vv = GC,
    yv;
(function(r) {
    function e(n, i) {
        tn(n, i, Pe.Client)
    }
    o(e, "log"), r.log = e;

    function t(n, i, s) {
        Ue(n, i, void 0, s, Pe.Client)
    }
    o(t, "error$1"), r.error = t
})(yv || (yv = {}));
var Xv = class Xv {
    constructor(e) {
        this._model = e
    }
    static get ActiveScreenCssClass() {
        return "active-screen"
    }
    getCurrentScreenRootElement() {
        return document.querySelector("." + Xv.ActiveScreenCssClass)
    }
    render() {
        return new Promise(e => {
            requestAnimationFrame(() => {
                setTimeout(e, 1)
            })
        })
    }
    wasCurrentViewRestoredFromCache() {
        return this._model ? this._model.context.viewWasRestoredFromCache : !1
    }
    registerDeviceClassGetter(e) {
        return uI(J.DeviceHelperClassProvider, () => e)
    }
};
o(Xv, "View");
var _v = Xv,
    zC = class zC {
        static getCurrentContext() {
            let e = EF();
            return {
                applicationKey: js() || "",
                applicationName: ry() || "",
                screenKey: e ? e.screenKey : "",
                screenName: e ? e.screenName : "",
                isReady: Uc.isReady
            }
        }
    };
o(zC, "ApplicationContext");
var wv = zC,
    Jv = class Jv {
        static get Instance() {
            return Jv
        }
        static get isUpgradingVersion() {
            return zx("ApplicationLoad.isUpgradingVersion", "ApplicationLifecycle.isUpgradingVersion()"), bc.isUpgradingVersion()
        }
        static listen(e) {
            zx("ApplicationLoad.listen()", "ApplicationLifecycle.listen()"), bc.listen(e)
        }
    };
o(Jv, "ApplicationLoad");
var Tv = Jv,
    Yae = Object.freeze({
        __proto__: null,
        ApplicationContext: wv,
        get ApplicationLifecycle() {
            return bc
        },
        ApplicationLoad: Tv,
        BuiltinFunctions: Kae,
        get Device() {
            return mv
        },
        get FeedbackMessage() {
            return pv
        },
        get FeedbackMessageType() {
            return Vo
        },
        get Logger() {
            return yv
        },
        Navigation: vv,
        Validation: bF,
        View: _v
    }),
    qC = class qC {
        constructor(e, t) {
            this._model = e, this._navigationContext = t
        }
        get BuiltinFunctions() {
            return HI
        }
        get Validation() {
            return this._validation || (this._validation = new bF(this._model)), this._validation
        }
        get FeedbackMessage() {
            return pv
        }
        get Device() {
            return mv
        }
        get ApplicationLifecycle() {
            return bc
        }
        get ApplicationContext() {
            return wv
        }
        get ApplicationLoad() {
            return Tv
        }
        get Navigation() {
            return this._navigation || (this._navigation = new vv(this._navigationContext)), this._navigation
        }
        get Logger() {
            return yv
        }
        get View() {
            return this._view || (this._view = new _v(this._model)), this._view
        }
    };
o(qC, "PublicApiHelper");
var Sc = qC,
    xu;
(function(r) {
    r[r.Block = 0] = "Block", r[r.IteratorItem = 1] = "IteratorItem", r[r.None = 2] = "None"
})(xu || (xu = {}));
var om = "-",
    KC = class KC {
        constructor(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "",
                n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : xu.None,
                i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            switch (this._ownerService = e, n) {
                case xu.Block:
                    this._namespace = "b";
                    break;
                case xu.IteratorItem:
                    this._namespace = "l";
                    break;
                default:
                    this._namespace = "";
                    break
            }
            if (this._namespace += t, e) {
                let s = i ? i + om : "";
                this._namespace = e.namespace + this._namespace + om + s
            } else this._namespace && (this._namespace = this._namespace + om)
        }
        getId(e) {
            return e ? this.namespace + e : null
        }
        static nameFromId(e) {
            return e.substring(e.lastIndexOf(om) + 1)
        }
        get namespace() {
            return this._namespace
        }
        get ownerService() {
            return this._ownerService
        }
    };
o(KC, "WidgetIdService");
var Ac = KC,
    Xae = Object.freeze({
        __proto__: null,
        get NamespaceKind() {
            return xu
        },
        WidgetIdService: Ac
    }),
    Sd = "",
    YC = class YC {
        constructor(e, t) {
            this.model = e, this.messagesProvider = t, this.updatingValidations = !1, this.disposed = !1, e.hasValidationWidgets && (this.widgets = {}, this.widgetChildren = {}, this.oldModelWidgets = this.model.widgets, this.model.subscribeWrites(() => {
                !this.updatingValidations && this.oldModelWidgets !== this.model.widgets && this.recalculateAggregatorsState(Sd), this.oldModelWidgets = this.model.widgets
            }, !0))
        }
        getWidgetRecord(e) {
            return this.model.widgets.get(e)
        }
        updateWidgetValidationsProperties(e, t, n) {
            let i = this.updatingValidations;
            this.updatingValidations = !0;
            try {
                if (e.isWebBlockInstance) {
                    let s = e;
                    s.valid = t
                } else {
                    let s = this.getWidgetRecord(e.getId());
                    s.validAttr !== t && (s.validAttr = t), n !== void 0 && s.validationMessageAttr !== n && (s.validationMessageAttr = n)
                }
            } finally {
                this.updatingValidations = i
            }
        }
        validateWidget(e) {
            let t = !0;
            for (let i in this.widgetChildren[e]) this.validateWidget(i) !== !0 && (t = !1);
            let n = this.widgets[e];
            if (n) {
                let i;
                n.isValidationAggregator ? i = new bv(t) : n.validate && (i = n.validate()), i && (this.updateWidgetValidationsProperties(n, i.valid, i.validationMessage), i.valid || (t = !1))
            }
            return t
        }
        recalculateAggregatorsState(e) {
            let t = !0;
            for (let i in this.widgetChildren[e]) this.recalculateAggregatorsState(i) || (t = !1);
            let n = this.widgets[e];
            if (n) {
                if (n.isWebBlockInstance) return n.valid;
                if (n.isValidationAggregator) this.updateWidgetValidationsProperties(n, t);
                else return this.getWidgetRecord(e).validAttr
            }
            return t
        }
        register(e) {
            if (this.model.hasValidationWidgets && e) {
                let t = e.getId();
                if (t) {
                    this.widgets[t] = e;
                    let n = e.validationParentId || Sd,
                        i = this.widgetChildren[n];
                    if (i || (i = {}, this.widgetChildren[n] = i), i[t] = 1, !e.isWebBlockInstance) {
                        let s = e,
                            a = this.model.widgets.create(t);
                        a.generationNode = s.generationNode, this.model.widgets.add(a)
                    }
                }
            }
        }
        unregister(e) {
            if (!e || this.disposed || !this.model.hasValidationWidgets) return;
            let t = this.widgets[e],
                n = (t ? t.validationParentId : null) || Sd;
            delete this.widgets[e], delete this.widgetChildren[n][e], t && this.model.widgets.remove(e)
        }
        isRegistered(e) {
            return !!this.widgets && this.widgets[e] !== void 0
        }
        validate(e) {
            if (!this.model.hasValidationWidgets) return !0;
            let t = this.validateWidget(e || Sd);
            return e && (t = this.recalculateAggregatorsState(Sd)), this.model.flush(), t
        }
        getMandatoryValueMessage() {
            return this.messagesProvider.getMandatoryValueMessage()
        }
        getInvalidValueMessage(e) {
            return this.messagesProvider.getInvalidValueMessage(e)
        }
        getNameById(e) {
            return Ac.nameFromId(e)
        }
        getWidgetChildren() {
            return this.widgetChildren
        }
        dispose() {
            this.disposed = !0
        }
    };
o(YC, "ValidationService");
var Ev = YC,
    XC = class XC {
        constructor(e, t) {
            this.valid = e, this.validationMessage = t
        }
        get valid() {
            return this._valid
        }
        set valid(e) {
            this._valid = e != null ? e : !0
        }
        get validationMessage() {
            return this._validationMessage
        }
        set validationMessage(e) {
            this._validationMessage = e || ""
        }
    };
o(XC, "ValidationResult");
var bv = XC,
    Jae = Object.freeze({
        __proto__: null,
        ValidationResult: bv,
        ValidationService: Ev
    }),
    Cs, Sm, SF, AF, IF, CF, RF, OF, Sv = o(() => {}, "NOOP"),
    Zae = "*",
    Qae = "Controller",
    Wd = class Wd {
        constructor(e, t) {
            this.controllerClass = e, this.messagesProvider = t
        }
        create(e, t) {
            return new this.controllerClass(e, this.messagesProvider, t)
        }
        static executeWithNavigationCallbacks(e, t, n) {
            return aM(t), $m(e, o(() => {
                t.dispose(n), uM()
            }, "dispose"))
        }
        initialize(e, t, n, i, s, a) {
            return k(this, void 0, void 0, function*() {
                let u = bn.activeScreen,
                    l = u ? u.callContext() : n.callContext();
                try {
                    MM() && (yield new Promise(g => {
                        new Sc(null, null).ApplicationLifecycle.listen({
                            onLoadComplete: g
                        })
                    }), yield yI()), this.controllerClass.checkPermissions()
                } catch (g) {
                    let p = {
                        permissionsOk: !1
                    };
                    return Wd.executeWithNavigationCallbacks(() => n.handleError(g, l), i, l).then(() => p, m => p)
                }
                let c = t.create(e),
                    d = this.create(c, new Ac(null));
                d.setAsActiveScreen();
                let f = Wd.executeWithNavigationCallbacks(() => d.fireInitialize({
                        rootSpan: a
                    }), s, d.callContext()),
                    h = {
                        permissionsOk: !0,
                        controller: d,
                        model: c
                    };
                return f.then(() => h, g => Bn(g, pe.UnhandledOrIgnoredErrorInEventException) && g.handleErrorResult === Yd ? {
                    permissionsOk: !0
                } : h)
            })
        }
        get activeScreenController() {
            return bn.activeScreen
        }
    };
o(Wd, "ControllerFactory");
var uA = Wd,
    Gd = class Gd {
        constructor() {
            this._iterationContext = new Av, this._id = ++Gd.currentId
        }
        get id() {
            return this._id
        }
        get viewName() {
            return this._viewName
        }
        get timeout() {
            return this._timeout
        }
        get iterationContext() {
            return this._iterationContext
        }
        set iterationContext(e) {
            this._iterationContext = e
        }
        withViewName(e) {
            return this._viewName !== e ? this.innerClone({
                _viewName: {
                    value: e
                }
            }) : this
        }
        withTimeout(e) {
            return this._timeout !== e ? this.innerClone({
                _timeout: {
                    value: e
                }
            }) : this
        }
        clone() {
            let e = this.innerClone();
            return e._id = ++Gd.currentId, e
        }
        innerClone(e) {
            let t = Object.create(this, e != null ? e : {});
            return t.iterationContext = this.iterationContext.clone(), t
        }
        get isOutOfContext() {
            return !!bn.activeScreen && this.viewName !== bn.activeScreen.viewName
        }
    };
o(Gd, "CallContext");
var lf = Gd;
lf.currentId = 0;
var Zv = class Zv {
    getCurrentRowNumber(e) {
        let t = this.getIterator(e);
        return t ? t.currentRowNumber : 0
    }
    setCurrentRowNumber(e, t) {
        let n = this.getIteratorForSet(e);
        n.currentRowNumber = t
    }
    isBeingIterated(e) {
        let t = this.getIterator(e);
        return t ? t.isBeingIterated : !1
    }
    registerIterationStart(e) {
        let t = this.getIteratorForSet(e);
        if (t.isBeingIterated) throw new Error("List is already being iterated in this context");
        t.currentRowNumber = e.length - 1, t.isBeingIterated = !0
    }
    registerIterationEnd(e) {
        let t = this.getIteratorForSet(e);
        if (!t.isBeingIterated) throw new Error("List was redefined while being iterated");
        t.isBeingIterated = !1
    }
    getIterator(e) {
        return this.iterators ? this.iterators.get(e.modelId) : null
    }
    getIteratorForSet(e) {
        this.iterators || (this.iterators = new Map);
        let t = this.getIterator(e);
        return t || (t = {
            currentRowNumber: 0,
            isBeingIterated: !1
        }, this.iterators.set(e.modelId, t)), t
    }
    clone() {
        let e = new Zv;
        return this.iterators && (e.iterators = eue(this.iterators, t => Object.create(t))), e
    }
};
o(Zv, "IterationContext");
var Av = Zv;

function eue(r, e) {
    let t = new Map;
    return r.forEach((n, i) => {
        let s = e(n);
        t.set(i, s)
    }), t
}
o(eue, "cloneMap");
var qx = new Qd,
    tue = new Qt("Data", "dataOut"),
    rue = new Qt("List", "listOut", [{
        name: "Count",
        attrName: "countOut",
        mandatory: !0,
        dataType: _.LongInteger,
        defaultValue: o(() => bt.defaultValue, "defaultValue")
    }]),
    Zb = "BaseController",
    zd = class zd {
        constructor(e) {
            if (this.isExecutingJSNode = !1, this.localeChangeHandler = t => {
                    var n;
                    let i = ge.resolve(J.TranslationsService),
                        s = ge.resolve(J.LocaleService);
                    i && ((n = t.localeFamily) !== null && n !== void 0 ? n : [t.localeCode]).forEach(u => {
                        var l, c;
                        this.translationResources[u] ? (ee(Zb, `Adding translations for ${u} locale.`), i.add((l = this.translationResources[u].translations) !== null && l !== void 0 ? l : {}), s.setCurrentLocaleRTL((c = this.translationResources[u].isRTL) !== null && c !== void 0 ? c : !1)) : ee(Zb, `No translations found for ${u} locale.`)
                    })
                }, this.translationResources = e != null ? e : this.translationResources, this.translationResources) {
                let t = ge.resolve(J.LocaleService);
                if (t) {
                    let n = t.getCurrentLocale(),
                        i = t.getCurrentLocaleFamily();
                    this.localeChangeHandler({
                        localeCode: n,
                        localeFamily: i
                    }), ee(Zb, "Subscribing handler for locale service."), t.subscribe(this.localeChangeHandler)
                }
            }
        }
        get publicApiHelper() {
            return this._publicApiHelper || (this._publicApiHelper = this.createPublicApiHelper()), this._publicApiHelper
        }
        getDefaultTimeout() {
            throw new Error("Controllers must implement getDefaultTimeout")
        }
        createPublicApiHelper() {
            return new Sc(null, this.callContext())
        }
        get default() {
            return this
        }
        get controller() {
            return this
        }
        callContext() {
            return arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new lf
        }
        safeExecuteJSNode(e, t, n, i, s, a, u) {
            let l = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : !1,
                c = o(h => {
                    let g = `Check the JavaScript node '${t}' of the action '${n}'.`;
                    throw h = h || new Error(g), (h instanceof pe.NumberOverflowException || h instanceof pe.InvalidJavascriptType) && (h.message = h.message + " " + g), h
                }, "handleException"),
                d = this.isExecutingJSNode,
                f = (i ? [i] : []).concat(a, u, this.publicApiHelper);
            e = e.bind(null, ...f);
            try {
                if (this.isExecutingJSNode = !0, l) return e().then(() => s(i)).catch(c);
                try {
                    return e(), s(i)
                } catch (h) {
                    c(h)
                }
            } finally {
                this.isExecutingJSNode = d
            }
        }
        safeExecuteAsyncJSNode(e, t, n, i, s, a, u) {
            return this.safeExecuteJSNode(e, t, n, i, s, a, u, !0)
        }
        executeActionInsideJSNode(e, t) {
            let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Sv,
                i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Sv,
                s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "",
                a = o(u => {
                    if (!CI(u, t)) throw u
                }, "handleException");
            try {
                if (s) try {
                    this.ensureControllerAlive(s)
                } catch (l) {
                    throw Ue("Controller", `Invalid call of action '${s}'`, "OS-CLRT-60801", l, Pe.External), l
                }
                let u = e(t);
                return u instanceof Promise ? u.then(l => (i(), n(l))).catch(l => {
                    i(), a(l)
                }) : n(u)
            } catch (u) {
                a(u)
            } finally {
                this.isExecutingJSNode || i()
            }
        }
        getInitialPayloadObject(e, t) {
            return {
                versionInfo: {
                    moduleVersion: ai.getLastApplicationVersionToken(!0),
                    apiVersion: t
                },
                viewName: e.viewName ? e.viewName : Zae
            }
        }
        getEffectiveTimeoutForServerCall(e) {
            let t = bU();
            return (e != null ? e : 0) || (t != null ? t : 0) || this.getDefaultTimeout()
        }
        callServerAction(e, t, n, i, s, a, u) {
            let l = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : !1;
            return this.innerCallServerAction(e, t, n, i, s, a, u, l)
        }
        innerCallServerAction(e, t, n, i, s, a, u) {
            let l = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : !1,
                c = this.getEffectiveTimeoutForServerCall(s.timeout),
                d = this.getInitialPayloadObject(s, n);
            d.inputParameters = i;
            let f = "The timeout of " + c + "s was reached while executing this server action.",
                h = o(() => {
                    throw ft(e, f), new pe.CommunicationException(f, e)
                }, "onTimeout");
            return xI({
                url: t,
                payload: d,
                timeout: c,
                timeoutHandler: o(() => Promise.resolve(h()), "timeoutHandler"),
                responseHandler: zd.createPostResponseHandler(u),
                headers: a,
                useLocaleInfo: l,
                actionOrAggregateName: e
            }).then(g => g || {}).catch(g => {
                throw g.extraStack = e, g
            })
        }
        static checkPermissions() {
            throw new Error("Screen Controllers must implement checkPermissions")
        }
        static handlePostResponse(e) {
            let t = ge.resolve(J.ClientVariablesService);
            t && t.checkSessionExpires();
            let n = ge.resolve(J.SettingsManager);
            if (n && e.clientSettingsHash !== void 0 && e.clientSettingsHash !== null) {
                n.update(e.clientSettingsHash), XM(n.readLogLevel());
                let i = n.readNumber("LoggerSchedulerTimeInterval");
                i > 0 && EI(i)
            }
        }
        static createPostResponseHandler(e) {
            return t => {
                let {
                    data: n,
                    responseHeaders: i
                } = t;
                zd.handlePostResponse(n), e && e(n, i)
            }
        }
        executeClientAggregate(e, t) {
            return _n(() => e()).then(n => {
                let i = t();
                i.listOut = n.list, i.countOut = n.count
            })
        }
        ensureControllerAlive(e) {}
        static getJSONDeserializeOutputType(e) {
            return tue.getType(e)
        }
        static getAggregateOutputType(e) {
            return rue.getType(e)
        }
        static registerVariableGroupType(e, t) {
            qx.registerTypeDefinition(e, t)
        }
        static getVariableGroupType(e) {
            return qx.getType(e)
        }
    };
o(zd, "BaseController");
var Ic = zd,
    JC = class JC extends Ic {
        constructor(e) {
            super(e), this.fireApplicationResumeSingletonCallback = this.fireApplicationResume.bind(this)
        }
        registerEventHandler(e, t, n) {
            n(() => new Promise((i, s) => {
                Cy([e], i, s)
            }).then(() => {
                let i = this[t],
                    s = o(() => Promise.resolve().then(() => i.call(this)), "newEventHandler");
                return n(s), s()
            }))
        }
        registerOnApplicationReadyHandler(e, t) {
            this.registerEventHandler(e, t, n => this.onApplicationReadyHandler = n)
        }
        registerOnApplicationResumeHandler(e, t) {
            this.registerEventHandler(e, t, n => this.onApplicationResumeHandler = n)
        }
        fireApplicationReady() {
            return this.onApplicationReadyHandler ? this.onApplicationReadyHandler().then(() => this.setupOnApplicationResumeListener()) : (this.setupOnApplicationResumeListener(), Promise.resolve(void 0))
        }
        setupOnApplicationResumeListener() {
            this.onApplicationResumeHandler && bS("resume", this.fireApplicationResumeSingletonCallback), this.setupSyncOnResume()
        }
        setupSyncOnResume() {
            let {
                syncQueue: e = ge.resolve(J.OfflineDataSync),
                syncConfigs: t = tI()
            } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var n;
            let i = o(() => e.startSync(""), "startSync");
            this.onSyncHandler && (t != null && t.syncOnResume) && (!((n = window.matchMedia) === null || n === void 0) && n.call(window, "(display-mode: standalone)").matches ? window.addEventListener("focus", i) : bS("resume", i))
        }
        fireApplicationResume() {
            return this.onApplicationResumeHandler ? this.onApplicationResumeHandler() : Promise.resolve(void 0)
        }
    };
o(JC, "BaseModuleController");
var cA = JC,
    _u = "BaseViewController",
    Cu = class Cu extends Ic {
        fireEvent(e) {
            for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
            return _n(() => {
                if (e) return e.call(this, ...n, this.callContext())
            }).then(s => {
                if (rk(s)) throw pe.UnhandledOrIgnoredErrorInEventException.create(s)
            })
        }
        fireEventAndForget(e) {
            for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
            this.fireEvent(e, ...n).catch(pe.UnhandledOrIgnoredErrorInEventException.ignore)
        }
        constructor(e, t, n, i) {
            super(i), Cs.add(this), this.model = e, this.messagesProvider = t, this._idService = n, this.instanceId = Cu.globalInstanceId++, this.isDisposed = !1, this.shouldSendClientVarsToDataSources = !1, this.fetchReadySources = a => {
                let u = [];
                (a === void 0 ? this.dataFetchActionNames : this.dataFetchDependentsGraph[a]).forEach(c => {
                    a && this.dataFetchDependencies[c]--, this.dataFetchDependencies[c] === 0 && u.push(c)
                }), u.forEach(c => {
                    this.remainingFetchesCount++, this.dataFetchDependencies[c] = -1, this.executeDataFetchAction(c).then(() => this.fetchReadySources(c))
                })
            }, this.clientVariablesHandler = a => {
                this.model.clientVariablesGeneration++, this.model.scheduleFlush()
            }, this.localeDependencyHandler = a => {
                this.model.currentLocale = a.localeCode, this.model.scheduleFlush()
            }, Sm.set(this, a => {
                var u;
                switch (a.type) {
                    case "SyncStart":
                        return ie(this, Cs, "m", CF).call(this, a.context);
                    case "SyncComplete":
                        return ie(this, Cs, "m", RF).call(this, a.context);
                    case "SyncError":
                        return ie(this, Cs, "m", OF).call(this, a.context, (u = a.message) !== null && u !== void 0 ? u : "");
                    default:
                        return ie(this, Cs, "m", SF).call(this, a)
                }
            });
            let s = ge.resolve(J.LocaleService);
            this.linearRequest = new aA, s && this.translationResources && (this.model.currentLocale = s.getCurrentLocale()), this.validationServiceInstance = new Ev(e, t), ie(this, Cs, "m", AF).call(this)
        }
        createPublicApiHelper() {
            return new Sc(this.model, this.callContext())
        }
        static get activeScreen() {
            return Cu.activeScreenInstance
        }
        setAsActiveScreen() {
            Cu.activeScreenInstance = this
        }
        callContext(e) {
            return super.callContext(e).withViewName(this.viewName)
        }
        get validationService() {
            return this.validationServiceInstance
        }
        get viewName() {
            var e;
            return (e = this.modelContext) === null || e === void 0 ? void 0 : e.viewName
        }
        fetchData() {
            let e = !1;
            ee(_u, "Using Improved data fetching with dependencies"), e = this.innerFetchDataWithDependencies(), e && this.model.flush()
        }
        executeDataFetchAction(e) {
            return ee(_u, "Fetching " + e), _n(() => this[e]()).then(() => {
                this.remainingFetchesCount--, clearTimeout(this.flushTimeoutHandle), ee(_u, "Fetched " + e), this.remainingFetchesCount > 0 ? this.flushTimeoutHandle = window.setTimeout(() => this.model.flush(), 50) : this.model.flush()
            }, t => {
                this.remainingFetchesCount--, this.model.flush(), this.handleError(t)
            })
        }
        innerFetchDataWithDependencies() {
            return !this.dataFetchActionNames || this.dataFetchActionNames.length === 0 ? !1 : (this.dataFetchDependencies = Object.assign({}, this.dataFetchDependenciesOriginal), this.flushTimeoutHandle = 0, this.remainingFetchesCount = 0, this.fetchReadySources(), !0)
        }
        get idService() {
            return this._idService
        }
        fireInitialize() {
            return k(this, arguments, void 0, function() {
                var e = this;
                let {
                    rootSpan: t,
                    startActiveSpan: n = JM,
                    setAttributeToSpan: i = this.setAttributesToSpan
                } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                return (function*() {
                    let s = ge.resolve(J.ClientVariablesService);
                    s && s.subscribe(e.clientVariablesHandler);
                    let a = ge.resolve(J.LocaleService);
                    if (a && a.subscribe(e.localeDependencyHandler), !t) {
                        yield e.fireEvent(e.onInitializeEventHandler), e.fetchData();
                        return
                    }
                    let u = t.getContext().attributes;
                    yield n(`${t.getSpanInformation().name}__initialize`, l => k(e, void 0, void 0, function*() {
                        try {
                            i(l, u), yield this.fireEvent(this.onInitializeEventHandler)
                        } finally {
                            l == null || l.end()
                        }
                        this.fetchData()
                    }), Pe.Internal, t)
                })()
            })
        }
        setAttributesToSpan(e, t) {
            var n, i, s;
            e && t && (e.setAttribute("code.function", t["code.function"]), e.setAttribute("outsystems.function.key", (n = t["outsystems.function.key"]) !== null && n !== void 0 ? n : ""), e.setAttribute("outsystems.function.owner.name", (i = t["outsystems.function.owner.name"]) !== null && i !== void 0 ? i : ""), e.setAttribute("outsystems.function.owner.key", (s = t["outsystems.function.owner.key"]) !== null && s !== void 0 ? s : ""), e.setAttribute("outsystems.function.type", t["outsystems.function.type"]), t.screen && e.setAttribute("outsystems.runtime.screen", t["outsystems.runtime.screen"]))
        }
        fireAfterViewReady() {
            this.fireEvent(this.onReadyEventHandler).then(() => this.fireEvent(this.onRenderEventHandler)).catch(pe.UnhandledOrIgnoredErrorInEventException.ignore)
        }
        fireAfterInputsChanged() {
            this.fireEventAndForget(this.onParametersChangedEventHandler)
        }
        fireAfterViewRender() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
            if (this.onRenderEventHandler) return this.fireEvent(t => {
                if (e) {
                    Ue("View", `Render loop avoided. This is likely due to the model of the screen/block '${this.viewName}' being changed inside its 'On Render' client action. Avoid changes to the model inside 'On Render' client actions.`, "OS-CLRT-60800", void 0, Pe.External);
                    return
                }
                return this.onRenderEventHandler(t)
            })
        }
        fireAfterViewDestroy() {
            let {
                clientVariablesService: e = ge.resolve(J.ClientVariablesService),
                localeService: t = ge.resolve(J.LocaleService)
            } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            e && e.unsubscribe(this.clientVariablesHandler), t && t.unsubscribe(this.localeDependencyHandler), this.fireEventAndForget(this.onDestroyEventHandler)
        }
        registerClientAction(e, t) {
            this[e] = t
        }
        innerCallAggregate(e, t, n, i, s, a, u, l, c, d, f, h) {
            let g = arguments.length > 12 && arguments[12] !== void 0 ? arguments[12] : !1,
                p = this.getEffectiveTimeoutForServerCall(l);
            return ee(_u, `Calling ${e} aggregate with start index endpoint`), this.callServerDataSource(e, t, n, a, u, m => {
                m.inputParameters = {
                    StartIndex: s,
                    MaxRecords: i
                }
            }, p, c, d, f, h, g)
        }
        callAggregateWithStartIndexAndClientVars(e, t, n, i, s, a, u, l, c, d, f, h) {
            let g = arguments.length > 12 && arguments[12] !== void 0 ? arguments[12] : !1;
            return this.innerCallAggregate(e, t, n, i, s, a, u, l, c, d, f, h, g)
        }
        callAggregateWithStartIndex(e, t, n, i, s, a, u, l, c, d, f) {
            return this.innerCallAggregate(e, t, n, i, s, a, u, l, c, d, f)
        }
        callAggregate(e, t, n, i, s, a, u, l, c, d) {
            return this.innerCallAggregate(e, t, n, i, 0, s, a, u, l, c, d)
        }
        callDataAction(e, t, n, i, s, a, u, l, c, d) {
            let f = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : !1;
            return this.innerCallDataAction(e, t, n, i, s, a, u, l, c, d, f)
        }
        innerCallDataAction(e, t, n, i, s, a, u, l, c, d) {
            let f = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : !1,
                h = this.getEffectiveTimeoutForServerCall(a);
            return this.callServerDataSource(e, t, n, i, s, void 0, h, u, l, c, d, f)
        }
        callServerDataSource(e, t, n, i, s) {
            let a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : void 0,
                u = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0,
                l = arguments.length > 7 ? arguments[7] : void 0,
                c = arguments.length > 8 ? arguments[8] : void 0,
                d = arguments.length > 9 ? arguments[9] : void 0,
                f = arguments.length > 10 ? arguments[10] : void 0,
                h = arguments.length > 11 && arguments[11] !== void 0 ? arguments[11] : !1,
                g = this.getInitialPayloadObject(this.callContext(), n);
            ee(_u, `Calling ${e} data source with optimized on payload`), g.screenData = {
                variables: Tc.to(this.model.variables, d, !0)
            }, a && a(g), this.shouldSendClientVarsToDataSources && f && (g.clientVariables = f.serialize()), i(0);
            let p = o(() => {
                let m = `The timeout of ${u}s was reached while fetching this screen data.`;
                throw ft(e, m), new pe.Exception(m)
            }, "onTimeout");
            return jU((m, w) => this.linearRequest.create(e).post({
                url: t,
                payload: g,
                timeout: u,
                timeoutHandler: o(() => Promise.resolve(p()), "timeoutHandler"),
                responseHandler: Ic.createPostResponseHandler(c),
                headers: l,
                useLocaleInfo: h
            }).then(T => this.handleServerDataSourceResponse({
                res: T,
                reject: w,
                resolve: m,
                setDataFromJS: s,
                setDataFetchStatus: i
            })).catch(T => {
                let E = Bn(T, pe.ViewHasChangedException) || Bn(T, pe.AbortedRequestException);
                if (!this.isDisposed) return E || i(2), w(T)
            }))
        }
        handleServerDataSourceResponse(e) {
            let {
                res: t,
                reject: n,
                resolve: i,
                setDataFromJS: s,
                setDataFetchStatus: a
            } = e;
            if (!this.isDisposed)
                if (t.completed) {
                    let u = t.data;
                    return s(u), a(1), i()
                } else return n(new pe.AbortedRequestException)
        }
        handleError(e) {
            throw new Error("@abstract")
        }
        safeExecuteAsyncJSNode(e, t, n, i, s, a, u) {
            return this.model.flush(), super.safeExecuteAsyncJSNode(e, t, n, i, s, a, u)
        }
        executeActionInsideJSNode(e, t) {
            let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Sv,
                i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Sv,
                s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "UNKNOWN";
            return super.executeActionInsideJSNode(e, t, n, () => {
                i(), this.model.flush()
            }, s)
        }
        dispose() {
            this.validationService.dispose(), ie(this, Cs, "m", IF).call(this), this.isDisposed = !0
        }
        ensureControllerAlive(e) {
            if (this.isDisposed) {
                let t = new pe.ControllerDisposedException(`Invalid call of the '${e}' client action of the '${this.viewName}' since the latter is not currently active. This is likely due to a platform's client action being used as an event handler or in a setTimeout function. Consider removing this call by using the 'On Destroy' event of the screen/block or moving your logic to a global client action.`);
                throw ft(Qae, t.message), t
            }
        }
        safeExecuteClientAction(e, t) {
            for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), s = 2; s < n; s++) i[s - 2] = arguments[s];
            return sy(() => e.apply(this, i.concat(this.callContext(t))), a => this.handleError(a), () => this.model.flush())
        }
        get modelContext() {
            return this.model.context
        }
        executeScreenClientAggregate(e, t, n) {
            return _n(() => (t().dataFetchStatusAttr = 0, e())).then(i => {
                if (!this.isDisposed) return t().bulkSet(i.list, 1, i.count), _n(n)
            }, i => {
                if (!this.isDisposed) throw t().dataFetchStatusAttr = 2, i
            })
        }
        static downloadBinary(e, t) {
            let n = e.toBlob() || new Blob([]),
                i = document.createElement("a");
            i.style.display = "none", document.body.appendChild(i), n.type && (i.type = n.type);
            let s = window.URL.createObjectURL(n);
            i.href = s, i.download = t, i.click(), setTimeout(() => window.URL.revokeObjectURL(s), 500), i.remove()
        }
    };
o(Cu, "BaseViewController");
var bn = Cu;
Sm = new WeakMap, Cs = new WeakSet, SF = o(function(e) {
    tn(_u, `Received sync queue message of unknown type '${e.type}' in '${this.viewName}'`, Pe.Internal)
}, "_BaseViewController_handleUnknownSyncQueueMessage"), AF = o(function() {
    let e = ge.resolve(J.OfflineDataSync);
    e && e.subscribe(ie(this, Sm, "f"))
}, "_BaseViewController_subscribeToSyncQueueMessages"), IF = o(function() {
    let e = ge.resolve(J.OfflineDataSync);
    e && e.unsubscribe(ie(this, Sm, "f"))
}, "_BaseViewController_unsubscribeFromSyncQueueMessages"), CF = o(function(e) {
    this.fireEventAndForget(this.onSyncStartEventHandler, e)
}, "_BaseViewController_fireOnSyncStart"), RF = o(function(e) {
    this.fireEventAndForget(this.onSyncCompleteEventHandler, e)
}, "_BaseViewController_fireOnSyncComplete"), OF = o(function(e, t) {
    this.fireEventAndForget(this.onSyncErrorEventHandler, e, t)
}, "_BaseViewController_fireOnSyncError");
bn.globalInstanceId = 0;
var nue = Object.freeze({
        __proto__: null,
        BaseController: Ic,
        BaseModuleController: cA,
        BaseViewController: bn,
        CallContext: lf,
        ControllerFactory: uA,
        IterationContext: Av
    }),
    Qb = "1900-01-01 00:00:00",
    iue = "0000",
    sue = "00",
    eS = "Serializer",
    pr = class pr {
        static get NULLDATE_IN_DB() {
            return Qb
        }
        static maskValue(e, t) {
            let n = t.length,
                i = e.toString();
            return t.substr(0, Math.max(0, n - i.length)) + i
        }
        static maskFourZeroes(e) {
            return pr.maskValue(e, iue)
        }
        static maskTwoZeroes(e) {
            return pr.maskValue(e, sue)
        }
        constructor() {
            this.serializers = new Map, this.deserializers = new Map, this.serializers.set(re.BINARY_DATA, (e, t) => this.serializeBinaryData(e, t)), this.serializers.set(re.BOOLEAN, (e, t) => this.serializeBoolean(e, t)), this.serializers.set(re.DATE, (e, t) => this.serializeDate(e, t)), this.serializers.set(re.DATE_TIME, (e, t) => this.serializeDateTime(e, t)), this.serializers.set(re.DECIMAL, (e, t) => this.serializeDecimal(e, t)), this.serializers.set(re.INTEGER, (e, t) => this.serializeInteger(e, t)), this.serializers.set(re.LONGINTEGER, (e, t) => this.serializeLongInteger(e, t)), this.serializers.set(re.TEXT, (e, t) => this.serializeText(e, t)), this.serializers.set(re.TIME, (e, t) => this.serializeTime(e, t)), this.deserializers.set(re.BINARY_DATA, (e, t) => this.deserializeBinaryData(e, t)), this.deserializers.set(re.BOOLEAN, (e, t) => this.deserializeBoolean(e, t)), this.deserializers.set(re.DATE, (e, t) => this.deserializeDate(e, t)), this.deserializers.set(re.DATE_TIME, (e, t) => this.deserializeDateTime(e, t)), this.deserializers.set(re.DECIMAL, (e, t) => this.deserializeDecimal(e, t)), this.deserializers.set(re.INTEGER, (e, t) => this.deserializeInteger(e, t)), this.deserializers.set(re.LONGINTEGER, (e, t) => this.deserializeLongInteger(e, t)), this.deserializers.set(re.TEXT, (e, t) => this.deserializeText(e, t)), this.deserializers.set(re.TIME, (e, t) => this.deserializeTime(e, t))
        }
        serialize(e, t) {
            let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ar.No;
            return e instanceof Ce ? this.serializeRecord(e, t) : this.serializeBasicType(e, t, n)
        }
        serializeRecord(e, t) {
            ee(eS, "Starting to serialize a record");
            let n = {};
            return e.getAttributes().forEach(i => {
                let s = lv(t, i);
                n[s.columnName] = this.serializeBasicType(e[i.attrName], s, s.isPrimaryKey ? t.idIsAutoNumber : Ar.No)
            }), ee(eS, "Finished serializing a record"), n
        }
        serializeInteger(e, t) {
            return e != null ? e : 0
        }
        serializeText(e, t) {
            return e != null ? e : ""
        }
        serializeBoolean(e, t) {
            return e ? 1 : 0
        }
        serializeLongInteger(e, t) {
            return e ? e.toString() : "0"
        }
        serializeDecimal(e, t) {
            return t.decimals ? e.toFixed(t.decimals) : e.toString()
        }
        serializeDate(e, t) {
            let n = e.toNative();
            return pr.maskFourZeroes(n.getFullYear()) + "-" + pr.maskTwoZeroes(n.getMonth() + 1) + "-" + pr.maskTwoZeroes(n.getDate())
        }
        serializeTime(e, t) {
            let n = e.toNative();
            return pr.maskTwoZeroes(n.getHours()) + ":" + pr.maskTwoZeroes(n.getMinutes()) + ":" + pr.maskTwoZeroes(n.getSeconds())
        }
        serializeDateTime(e, t) {
            if (e.eq(me.defaultValue)) return Qb;
            let n = e.toNative();
            return pr.maskFourZeroes(n.getUTCFullYear()) + "-" + pr.maskTwoZeroes(n.getUTCMonth() + 1) + "-" + pr.maskTwoZeroes(n.getUTCDate()) + " " + pr.maskTwoZeroes(n.getUTCHours()) + ":" + pr.maskTwoZeroes(n.getUTCMinutes()) + ":" + pr.maskTwoZeroes(n.getUTCSeconds())
        }
        innerSerializeBasicType(e, t, n) {}
        serializeBasicType(e, t, n) {
            if (ee(eS, `Serializing a value of type ${t.type}`), !this.serializers.has(t.type)) throw new pe.DataBaseException("", `Unable to serialize ${t.type} to a database value.`);
            let i = this.innerSerializeBasicType(e, t, n);
            return i !== void 0 ? i : this.serializers.get(t.type)(e, t)
        }
        deserialize(e, t, n) {
            return n ? this.deserializeRecord(e, t, n) : this.deserializeBasicType(e, t)
        }
        deserializeRecord(e, t, n) {
            let i = new n;
            return n.getAttributes().forEach(s => {
                let a = lv(t, s);
                i[s.attrName] = this.deserializeBasicType(e[a.columnName], a)
            }), i
        }
        deserializeInteger(e, t) {
            return e
        }
        deserializeLongInteger(e, t) {
            return bt.fromValue(e)
        }
        deserializeDecimal(e, t) {
            return new Be(e)
        }
        deserializeText(e, t) {
            return e
        }
        deserializeBoolean(e, t) {
            return e !== 0
        }
        deserializeDateTime(e, t) {
            if (e === Qb) return me.defaultValue;
            let i = /^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})$/.exec(e),
                s = new Date;
            return s.setUTCFullYear(parseInt(i[1], 10), parseInt(i[2], 10) - 1, parseInt(i[3], 10)), s.setUTCHours(parseInt(i[4], 10) || 0, parseInt(i[5], 10) || 0, parseInt(i[6], 10) || 0, 0), new me(s)
        }
        deserializeDate(e, t) {
            let i = /^(\d{4})-(\d{2})-(\d{2})$/.exec(e),
                s = new Date;
            return s.setFullYear(parseInt(i[1], 10), parseInt(i[2], 10) - 1, parseInt(i[3], 10)), s.setHours(0, 0, 0, 0), new me(s)
        }
        deserializeTime(e, t) {
            let i = /^(\d{2}):(\d{2}):(\d{2})$/.exec(e),
                s = new Date;
            return s.setFullYear(1900, 0, 1), s.setHours(parseInt(i[1], 10) || 0, parseInt(i[2], 10) || 0, parseInt(i[3], 10) || 0, 0), new me(s)
        }
        innerDeserializeBasicType(e, t) {}
        deserializeBasicType(e, t) {
            if (!this.deserializers.has(t.type)) throw new pe.DataBaseException("", `Unable to deserialize ${t} to a runtime value.`);
            let n = this.innerDeserializeBasicType(e, t);
            return n !== void 0 ? n : e === null ? Jo(t.type) : this.deserializers.get(t.type)(e, t)
        }
    };
o(pr, "Serializer");
var mn = pr,
    oue = "WebSQLSerializer",
    ZC = class ZC extends mn {
        constructor() {
            super(...arguments), this.fromMethodCache = new Map, this.attributeReaderImplementation = (e, t, n, i) => {
                let s = {
                    type: $x(i)
                };
                return this.deserialize(e["o" + t], s)
            }, this.namedAttributeReaderImplementation = (e, t, n, i) => {
                let s = {
                    type: $x(i)
                };
                return this.deserialize(e[n], s)
            }, this.deserializeAggregate = (e, t, n, i) => {
                var s;
                if (this.isGenericRecordType(t)) {
                    let a = e,
                        u = t,
                        l = n,
                        c = this.fromMethodCache.get(u);
                    if (!c) {
                        let d = u.getAttributes();
                        c = this.makeConverterFunction({
                            attributes: d,
                            fromLocalStorage: this.deserializeAggregate,
                            dataType: t
                        }), this.fromMethodCache.set(u, c)
                    }
                    return c(a, l, this.getAttributeReaderImplementation(t), i)
                } else if (this.isGenericRecordListType(t)) {
                    let a = new t,
                        u = e,
                        l = n,
                        c = [];
                    for (let d = 0; d < u.length; d++) c.push(a.newItem(l(null, u.item(d))));
                    return a.pushAll(c), a
                } else {
                    let a = t;
                    throw new Error(`Unable to read data from Local Storage. Unknown type ${(s=a==null?void 0:a.name)!==null&&s!==void 0?s:a}`)
                }
            }
        }
        isGenericRecordType(e) {
            return !!e.isGenericRecordType
        }
        isGenericRecordListType(e) {
            return !!e.isGenericRecordListType
        }
        getAttributeReaderImplementation(e) {
            return e.isAnonymousRecord() ? this.namedAttributeReaderImplementation : this.attributeReaderImplementation
        }
        makeAttributesDeclaration(e, t) {
            t.forEach(n => {
                n.dataType !== _.RecordList && (e[n.attrName] = null)
            })
        }
        makeDeserializerForEachAttribute(e) {
            let {
                data: t,
                attributes: n,
                dataType: i,
                row: s,
                indexRef: a,
                readerImplementation: u,
                fromLocalStorage: l
            } = e;
            n.forEach((c, d) => {
                c.dataType !== _.RecordList && (c.dataType === _.Record && i.isAnonymousRecord() ? t[c.attrName] = l(s, c.complexType, a) : t[c.attrName] = u(s, a.value++, n[d].name, n[d].dataType))
            })
        }
        makeConverterFunction(e) {
            let {
                attributes: t,
                fromLocalStorage: n,
                dataType: i
            } = e;
            return (s, a, u, l) => {
                let c = {};
                return l && l.length > 0 ? (this.makeAttributesDeclaration(c, t), l.forEach(d => {
                    let f = t.filter(function(h) {
                        return h.attrName === d
                    })[0];
                    f.complexType ? c[d] = n(s, f.complexType, a) : c[d] = u(s, a.value++, f.name, f.dataType)
                })) : this.makeDeserializerForEachAttribute({
                    data: c,
                    attributes: t,
                    dataType: i,
                    row: s,
                    indexRef: a,
                    readerImplementation: u,
                    fromLocalStorage: n
                }), new i.RecordClass(c)
            }
        }
        serializeDateTime(e, t) {
            if (e.eq(me.defaultValue)) return mn.NULLDATE_IN_DB;
            let n = e.toNative();
            return mn.maskFourZeroes(n.getUTCFullYear()) + "-" + mn.maskTwoZeroes(n.getUTCMonth() + 1) + "-" + mn.maskTwoZeroes(n.getUTCDate()) + " " + mn.maskTwoZeroes(n.getUTCHours()) + ":" + mn.maskTwoZeroes(n.getUTCMinutes()) + ":" + mn.maskTwoZeroes(n.getUTCSeconds())
        }
        serializeBinaryData(e, t) {
            return e.content === void 0 ? null : e.content
        }
        deserializeDateTime(e, t) {
            if (e === mn.NULLDATE_IN_DB) return me.defaultValue;
            let i = /^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})$/.exec(e),
                s = new Date;
            return s.setUTCFullYear(parseInt(i[1], 10), parseInt(i[2], 10) - 1, parseInt(i[3], 10)), s.setUTCHours(parseInt(i[4], 10) || 0, parseInt(i[5], 10) || 0, parseInt(i[6], 10) || 0, 0), new me(s)
        }
        deserializeBinaryData(e, t) {
            return new Or(e)
        }
        isConversionNeeded(e, t) {
            return this.isConversionNeededBetweenDBDataTypes(e.type, t.type) || !!e.isEntityReference != !!t.isEntityReference ? !0 : e.length !== void 0 && t.length !== void 0 ? e.decimals !== void 0 && t.decimals !== void 0 ? e.length - e.decimals > t.length - t.decimals : e.length > t.length : !1
        }
        isConversionNeededBetweenDBDataTypes(e, t) {
            if (e === void 0) return !0;
            if (e === t) return !1;
            switch (e) {
                case re.BOOLEAN:
                    return t !== re.INTEGER && t !== re.LONGINTEGER;
                case re.INTEGER:
                    return t !== re.LONGINTEGER && t !== re.TEXT;
                case re.LONGINTEGER:
                    return t !== re.TEXT;
                default:
                    return !0
            }
        }
        innerSerializeBasicType(e, t, n) {
            if (ee(oue, `WebSQL serializing a value of type ${t.type}`), t.isPrimaryKey && n === Ar.YesIfEmpty && Tn(e, Jo(t.type)) || t.isEntityReference && Tn(e, Jo(t.type))) return null
        }
    };
o(ZC, "WebSQLSerializer");
var df = ZC,
    aue = Object.freeze({
        __proto__: null,
        default: df
    }),
    QC = class QC {
        constructor(e, t) {
            this.storage = e, this.info = t
        }
        getStorage() {
            return this.storage
        }
        getInfo() {
            return this.info
        }
        create(e) {
            return this.storage.create(this.info, e)
        }
        createOrUpdate(e) {
            return this.storage.createOrUpdate(this.info, e)
        }
        createOrUpdateAll(e) {
            return this.storage.createOrUpdateAll(this.info, e)
        }
        update(e) {
            return this.storage.update(this.info, e)
        }
        get(e) {
            return this.storage.get(this.info, e)
        }
        delete(e) {
            return this.storage.delete(this.info, e)
        }
        deleteAll() {
            return this.storage.deleteAll(this.info)
        }
    };
o(QC, "Entity");
var lA = QC,
    uue = new df,
    eR = class eR {
        constructor(e) {
            this.skipConversion = e, this.argumentList = [], this.existingArguments = {}
        }
        add(e, t, n, i, s, a) {
            if (!this.existingArguments[e])
                if (this.existingArguments[e] = !0, n === void 0) this.argumentList.push(null);
                else {
                    let u;
                    this.skipConversion ? u = n : u = uue.serialize(n, {
                        type: t,
                        length: i,
                        decimals: s,
                        isEntityReference: a,
                        name: "",
                        columnName: ""
                    }), this.argumentList.push(u)
                }
        }
        toArray() {
            return this.argumentList
        }
    };
o(eR, "QueryArgumentsList");
var dA = eR,
    cue = Object.freeze({
        __proto__: null,
        Entity: lA,
        QueryArgumentsList: dA
    }),
    lue = "There was an error processing your request.",
    due = "",
    fue = "RELOAD",
    hue = "#error-screen-message-text",
    gue = "#error-screen-message-text-extra",
    PF = "#error-screen-message-reload-button",
    pue = "#error-screen-spinner",
    mue = "#exception-detail",
    NF = "#error-screen-show-detail-button",
    vue = "#error-screen-exception-message",
    yue = "#error-screen-exception-stack",
    _ue = "#exception-detail-text";

function wue(r) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DF;
    var t;
    e(r.errorPageConfig);
    try {
        let n = ii.errorPageExceptionInfo.get(),
            i = n ? n.message : ii.errorPageMessage.get();
        Ue("ErrorScreen", `${i}`, (t = n == null ? void 0 : n.errorCode) !== null && t !== void 0 ? t : "OS-CLRT-00000", void 0, Pe.Client)
    } catch (n) {
        Ue("ErrorScreen", "Unable to retrieve error details", "OS-CLRT-00000")
    }
    TI()
}
o(wue, "renderErrorScreen");

function DF(r) {
    var e, t, n;
    let i = ii.errorPageMessage.get(),
        s = ii.errorPageExtraMessage.get(),
        a = ii.errorPageExceptionInfo.get();
    if (a) {
        let u = a.message,
            l = qi(a);
        if (l && (u += `
` + l), console.error(u), typeof document != "undefined" && document.querySelector) {
            let c = document.querySelector(vue);
            c.innerHTML = (e = a.message) !== null && e !== void 0 ? e : "";
            let d = document.querySelector(yue);
            if (d.innerHTML = l, document.querySelector(NF).addEventListener("click", () => xF()), r != null && r.showExceptionStack) {
                let h = document.querySelector(mue);
                h.style.display = "block"
            }
        }
    }
    if (typeof document != "undefined" && document.querySelector) {
        let u = (t = r == null ? void 0 : r.messages) === null || t === void 0 ? void 0 : t.defaultMessage,
            l = r == null ? void 0 : r.extraMessage,
            c = document.querySelector(hue);
        c.innerHTML = i || u || lue;
        let d = document.querySelector(gue);
        d.innerHTML = s || l || due;
        let f = document.querySelector(PF);
        f.innerHTML = (n = r == null ? void 0 : r.reloadLabel) !== null && n !== void 0 ? n : fue, f.addEventListener("click", () => LF())
    }
}
o(DF, "setErrorPageMessages");

function LF() {
    if (typeof document != "undefined" && document.querySelector) {
        let r = document.querySelector(PF);
        r.style.display = "none";
        let e = document.querySelector(pue);
        e.style.display = "inline-block"
    }
    setTimeout(() => {
        gI()
    }, 2e3)
}
o(LF, "reloadApplication");

function xF() {
    if (typeof document != "undefined" && document.querySelector) {
        let r = document.querySelector(NF),
            e = document.querySelector(_ue);
        e.hidden ? (r.innerHTML = "Hide Detail", e.hidden = !1) : (r.innerHTML = "Show Detail", e.hidden = !0)
    }
}
o(xF, "toggleExceptionInfo");
var Tue = Object.freeze({
        __proto__: null,
        reloadApplication: LF,
        renderErrorScreen: wue,
        setErrorPageMessages: DF,
        toggleExceptionInfo: xF
    }),
    fA;
(function(r) {
    (function(e) {
        e[e.Full = 0] = "Full", e[e.Minimal = 1] = "Minimal"
    })(r.InitializationType || (r.InitializationType = {}))
})(fA || (fA = {}));
var hA;
(function(r) {
    (function(e) {
        e[e.Fetching = 0] = "Fetching", e[e.Fetched = 1] = "Fetched", e[e.Error = 2] = "Error"
    })(r.DataFetchStatus || (r.DataFetchStatus = {}))
})(hA || (hA = {}));
var gA;
(function(r) {
    (function(e) {
        e[e.Info = 0] = "Info", e[e.Success = 1] = "Success", e[e.Warning = 2] = "Warning", e[e.Error = 3] = "Error"
    })(r.FeedbackMessageType || (r.FeedbackMessageType = {}))
})(gA || (gA = {}));
var Eue = Object.freeze({
        __proto__: null,
        get Application() {
            return fA
        },
        get FeedbackMessage() {
            return gA
        },
        get Model() {
            return hA
        }
    }),
    tS = "BaseMessagesProvider",
    kn;
(function(r) {
    r.MandatoryValue = "Validation.Mandatory", r.InvalidValuePrefix = "Validation.", r.UpgradeComplete = "UpgradeComplete", r.UpgradeRequiredDataLoss = "UpgradeRequiredDataLoss", r.UpgradeRequired = "UpgradeRequired", r.UpgradeFailedOnResources = "AppInitError.Resources", r.UpgradeFailedOnDataModel = "AppInitError.DataModel", r.UpgradeFailed = "AppInitError.Generic"
})(kn || (kn = {}));
var tR = class tR {
    constructor(e) {
        if (this.messages = {}, this.localeChangeHandler = t => {
                var n;
                let i = ge.resolve(J.TranslationsService),
                    s = ge.resolve(J.LocaleService);
                i && ((n = t.localeFamily) !== null && n !== void 0 ? n : [t.localeCode]).forEach(u => {
                    var l, c;
                    this.translationResources[u] ? (ee(tS, `Adding translations for ${u} locale.`), i.add((l = this.translationResources[u].translations) !== null && l !== void 0 ? l : {}), s.setCurrentLocaleRTL((c = this.translationResources[u].isRTL) !== null && c !== void 0 ? c : !1)) : ee(tS, `No translations found for ${u} locale.`)
                })
            }, this.translationResources = e != null ? e : this.translationResources, this.translationResources) {
            let t = ge.resolve(J.LocaleService);
            if (t) {
                let n = t.getCurrentLocale(),
                    i = t.getCurrentLocaleFamily();
                this.localeChangeHandler({
                    localeCode: n,
                    localeFamily: i
                }), ee(tS, "Subscribing handler for locale service."), t.subscribe(this.localeChangeHandler)
            }
        }
    }
    getMandatoryValueMessage() {
        return this.getMessage(kn.MandatoryValue, "Required Value!")
    }
    getInvalidValueMessage(e) {
        return this.getMessage(kn.InvalidValuePrefix + _[e], "Invalid Value!")
    }
    getApplicationUpgradeCompleteMessage() {
        return this.getMessage(kn.UpgradeComplete, "")
    }
    getApplicationUpgradeRequiredMessage(e) {
        return e ? this.getMessage(kn.UpgradeRequiredDataLoss, "") : this.getMessage(kn.UpgradeRequired, "")
    }
    getApplicationUpgradeFailedOnResourcesMessage() {
        return this.getMessage(kn.UpgradeFailedOnResources, "")
    }
    getApplicationUpgradeFailedOnDataModelMessage() {
        return this.getMessage(kn.UpgradeFailedOnDataModel, "")
    }
    getApplicationUpgradeFailedUnknownMessage() {
        return this.getMessage(kn.UpgradeFailed, "")
    }
    getMessage(e, t) {
        var n;
        let i = (n = this.messages[e]) !== null && n !== void 0 ? n : t,
            s = ge.resolve(J.TranslationsService);
        return s ? s.getMessage(e, i) : i
    }
    setMessage(e, t) {
        this.messages[e] = t
    }
};
o(tR, "BaseMessagesProvider");
var pA = tR,
    bue = Object.freeze({
        __proto__: null,
        BaseMessagesProvider: pA,
        get ModuleMessageKeys() {
            return kn
        }
    }),
    mA = "idAttr",
    vA = "nameAttr",
    Am = "validAttr",
    Im = "validationMessageAttr",
    rR = class rR {
        constructor(e, t, n, i) {
            this.type = e, this._value = t, this.setter = n, this.model = i
        }
        get value() {
            return this._value
        }
        set value(e) {
            let t = Vs.convertTo(e, this.type);
            this.setter(t), this.model.flush()
        }
        isAcceptable(e) {
            return Vs.isConvertibleTo(e, this.type)
        }
        fastEquals(e) {
            return e && this.constructor === e.constructor && this.value === e.value
        }
        equals(e) {
            return e && this.constructor === e.constructor && Tn(this.value, e.value)
        }
    };
o(rR, "Variable");
var Iv = rR,
    qd = class qd extends ur {
        constructor(e) {
            super(e)
        }
        get idAttr() {
            return this.getBasicProperty(mA)
        }
        set idAttr(e) {
            this.setBasicProperty(mA, e, _.Text)
        }
        get nameAttr() {
            return this.getBasicProperty(vA)
        }
        set nameAttr(e) {
            this.setBasicProperty(vA, e, _.Text)
        }
        get generationNode() {
            return this.getBasicProperty(qd.WidgetGenerationNodeAttributeName)
        }
        set generationNode(e) {
            this.setBasicProperty(qd.WidgetGenerationNodeAttributeName, e, _.Object)
        }
        asReadOnly() {
            return {
                idAttr: this.idAttr,
                nameAttr: this.nameAttr
            }
        }
        refreshGeneration() {
            this.generationNode && (this.generationNode.generation = Oc.currentGeneration)
        }
    };
o(qd, "WidgetRecord");
var Yi = qd;
Yi.WidgetGenerationNodeAttributeName = "widgetGenerationNode";
Yi.RecordClass = ur.defineRecordClass({
    idAttr: "",
    nameAttr: "",
    widgetGenerationNode: null
});

function Sue(r) {
    return {
        idAttr: r.get(mA),
        nameAttr: r.get(vA),
        validAttr: r.get(Am),
        validationMessageAttr: r.get(Im)
    }
}
o(Sue, "validationWidgetRecordAsReadOnly");
var nR = class nR extends Yi {
    constructor(e) {
        super(e)
    }
    get validAttr() {
        return this.getBasicProperty(Am)
    }
    set validAttr(e) {
        this.setBasicProperty(Am, e, _.Boolean)
    }
    get validationMessageAttr() {
        return this.getBasicProperty(Im)
    }
    set validationMessageAttr(e) {
        this.setBasicProperty(Im, e, _.Text)
    }
    onPropertyValueChanged(e) {
        (e === Am || e === Im) && this.refreshGeneration()
    }
    asReadOnly() {
        return Sue(this.data)
    }
};
o(nR, "ValidationWidgetRecord");
var Cc = nR;
Cc.RecordClass = (() => {
    let r = new Yi.RecordClass().toJS();
    return r.validAttr = !0, r.validationMessageAttr = "", ur.defineRecordClass(r)
})();
var Fo = class Fo extends ur {
    constructor(e) {
        super(e), this.widgetsIdToRecord = this.data.get(Fo.WidgetRecordsAttribute), this.widgetsIdToRecordDataCache = this.data.get(Fo.WidgetRecordsDataCacheAttribute)
    }
    static createDefaultData() {
        return new Fo.RecordClass({
            records: new Map,
            recordsCache: new Map
        })
    }
    static getWidgetsType() {
        return {}
    }
    getWidgetsType() {
        return this.constructor.getWidgetsType()
    }
    getWidgetRecordType(e) {
        return this.getWidgetsType()[e] || Yi
    }
    get(e) {
        let t = this.widgetsIdToRecord.get(e);
        return t || (t = this.create(e), this.add(t), t)
    }
    set(e, t) {
        this.widgetsIdToRecord.set(e, t), this.widgetsIdToRecordDataCache.delete(e), this.writePropagate(this.data, null)
    }
    internalSet(e, t) {
        this.widgetsIdToRecord.delete(e), this.widgetsIdToRecordDataCache.set(e, t), this.writePropagate(this.data, null)
    }
    create(e) {
        let t = Ac.nameFromId(e),
            n = this.getWidgetRecordType(t),
            i = this.widgetsIdToRecordDataCache.get(e),
            s = new n(i);
        return s.idAttr = e, s.nameAttr = t, s
    }
    add(e) {
        Fo.setPropagationHandler(e, this, e.idAttr, this.internalSet), this.widgetsIdToRecordDataCache.delete(e.idAttr), this.widgetsIdToRecord.set(e.idAttr, e)
    }
    remove(e) {
        this.widgetsIdToRecord.delete(e), this.widgetsIdToRecordDataCache.delete(e), this.writePropagate(this.data, null)
    }
};
o(Fo, "BaseWidgetRecordMap");
var Rc = Fo;
Rc.WidgetRecordsAttribute = "records";
Rc.WidgetRecordsDataCacheAttribute = "recordsCache";
Rc.RecordClass = ur.defineRecordClass({
    records: null,
    recordsCache: null
});
var Ru = class Ru extends Ce {
    get dataFetchStatusAttr() {
        return this.getBasicProperty(Ru.DataFetchStatusAttributeName)
    }
    set dataFetchStatusAttr(e) {
        this.setBasicProperty(Ru.DataFetchStatusAttributeName, e, _.Integer)
    }
    get isDataFetchedAttr() {
        return this.dataFetchStatusAttr === 1
    }
    get hasFetchErrorAttr() {
        return this.dataFetchStatusAttr === 2
    }
    static attributesToDeclare() {
        return [Ce.attr("DataFetchStatus", Ru.DataFetchStatusAttributeName, "", !0, !1, _.Integer, () => 0)].concat(super.attributesToDeclare())
    }
    replaceWith(e) {
        let t = new this.constructor(ur.getData(e));
        t.dataFetchStatusAttr = this.dataFetchStatusAttr, this.writePropagate(ur.getData(t), new yc)
    }
};
o(Ru, "DataSourceRecord");
var Hs = Ru;
Hs.DataFetchStatusAttributeName = "dataFetchStatusAttr";
var Mn = class Mn extends Hs {
    get listOut() {
        return this.getComplexProperty(Mn.ListOutAttributeName, this.getRecordListType())
    }
    set listOut(e) {
        this.setComplexProperty(Mn.ListOutAttributeName, e, _.RecordList, this.getRecordListType())
    }
    get countOut() {
        return this.getBasicProperty(Mn.CountOutAttributeName)
    }
    set countOut(e) {
        this.setBasicProperty(Mn.CountOutAttributeName, e, _.LongInteger)
    }
    bulkSet(e, t, n) {
        let i = [{
            name: Mn.ListOutAttributeName,
            value: e,
            isBasicType: !1
        }, {
            name: Hs.DataFetchStatusAttributeName,
            value: t,
            isBasicType: !0
        }];
        n !== void 0 && i.push({
            name: Mn.CountOutAttributeName,
            value: n,
            isBasicType: !0
        }), this.setProperties(i)
    }
    getRecordListType() {
        return this.constructor.RecordListType
    }
    static attributesToDeclare() {
        return [Ce.attr("List", Mn.ListOutAttributeName, "List", !0, !1, _.RecordList, () => !1, !0, this.RecordListType), Ce.attr("Count", Mn.CountOutAttributeName, "Count", !0, !1, _.LongInteger, () => bt.defaultValue)].concat(super.attributesToDeclare())
    }
    static init() {
        if (!this.RecordListType) throw new TypeError("AggregateRecords must define a RecordListType");
        super.init()
    }
};
o(Mn, "AggregateRecord");
var ff = Mn;
ff.ListOutAttributeName = "listOut";
ff.CountOutAttributeName = "countOut";
var Aue = "BaseViewModel",
    Ur = class Ur extends ur {
        constructor(e) {
            super(), this._context = e, this.writeSubscriptions = [], this.cachedValues = {}, this.modified = !1
        }
        static createDefaultData() {
            let e = this.newVariablesRecord(),
                t = this.newWidgetsRecord();
            return new Ur.RecordClass({
                variables: ur.getData(e),
                widgets: ur.getData(t),
                clientVariablesGeneration: 0,
                currentLocale: null
            })
        }
        onDefaultWritePropagate(e) {
            super.onDefaultWritePropagate(e), this.modified = !0, this.innerFlush(!0)
        }
        cloneCache() {
            return this.cache
        }
        get isModified() {
            return this.modified
        }
        scheduleFlush() {
            this.pendingFlush || (this.pendingFlush = window.setTimeout(() => this.flush(), 0))
        }
        flush() {
            this.pendingFlush && (clearTimeout(this.pendingFlush), this.pendingFlush = void 0), this.modified && (this.modified = !1, Oc.currentGeneration++, this.innerFlush(!1), ee(Aue, "Flushing model"))
        }
        innerFlush(e) {
            for (let t = 0; t < this.writeSubscriptions.length; t++) {
                let n = this.writeSubscriptions[t];
                n.immediate === e && n.handler(this)
            }
        }
        subscribeWrites(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            return (this.hasVariables || this.hasValidationWidgets || this.currentLocale !== null || this.currentLocale !== void 0) && e ? (this.writeSubscriptions.push({
                handler: e,
                immediate: t
            }), !0) : !1
        }
        unsubscribeWrites(e) {
            if (e) {
                let t = -1;
                for (let n = 0, i = this.writeSubscriptions.length; n < i; n++)
                    if (this.writeSubscriptions[n].handler === e) {
                        t = n;
                        break
                    } if (t >= 0) return this.writeSubscriptions.splice(t, 1), !0
            }
            return !1
        }
        clearSubscriptions() {
            this.writeSubscriptions = []
        }
        static get hasVariables() {
            return !0
        }
        get hasVariables() {
            return this.constructor.hasVariables
        }
        static getVariablesRecordConstructor() {
            throw new Error("@abstract")
        }
        static newVariablesRecord(e) {
            if (this.hasVariables) return new(this.getVariablesRecordConstructor())(e)
        }
        getVariables() {
            let e = this.constructor;
            if (this.hasVariables) return this.getComplexProperty(Ur.VariablesPropertyName, e.getVariablesRecordConstructor());
            throw new Error("Model does not contain variables")
        }
        get variables() {
            return this.getVariables()
        }
        set variables(e) {
            let t = this.constructor;
            this.setComplexProperty(Ur.VariablesPropertyName, e, _.Record, t.getVariablesRecordConstructor())
        }
        get clientVariablesGeneration() {
            return this.getBasicProperty(Ur.ClientVariablesGenerationPropertyName)
        }
        set clientVariablesGeneration(e) {
            this.setBasicProperty(Ur.ClientVariablesGenerationPropertyName, e, _.Integer)
        }
        static get hasValidationWidgets() {
            return !0
        }
        get hasValidationWidgets() {
            return this.constructor.hasValidationWidgets
        }
        get currentLocale() {
            return this.getBasicProperty(Ur.CurrentLocalePropertyName)
        }
        set currentLocale(e) {
            this.currentLocale !== e && this.clearCachedValues(), this.setBasicProperty(Ur.CurrentLocalePropertyName, e, _.Text)
        }
        static getWidgetsRecordConstructor() {
            throw new Error("@abstract")
        }
        static newWidgetsRecord(e) {
            if (this.hasValidationWidgets) return new(this.getWidgetsRecordConstructor())(e)
        }
        getWidgets() {
            let e = this.constructor;
            if (this.hasValidationWidgets) return this.getComplexProperty(Ur.WidgetsPropertyName, e.getWidgetsRecordConstructor());
            throw new Error("Model does not contain validation widgets")
        }
        get widgets() {
            return this.getWidgets()
        }
        set widgets(e) {
            this.setComplexProperty(Ur.WidgetsPropertyName, e, _.Object)
        }
        hasCachedValue(e) {
            return this.cachedValues.hasOwnProperty(e)
        }
        getCachedValue(e, t) {
            let n = this.cachedValues[e];
            for (var i = arguments.length, s = new Array(i > 2 ? i - 2 : 0), a = 2; a < i; a++) s[a - 2] = arguments[a];
            let u = s.map((c, d) => {
                try {
                    return c()
                } catch (f) {
                    return Ur.InvalidValue
                }
            });
            return n !== void 0 && s.length === n.args.length && u.every((c, d) => c === n.args[d]) || (n = {
                args: u,
                value: t()
            }, this.cachedValues[e] = n), n.value
        }
        clearCachedValues() {
            this.cachedValues = {}
        }
        createVariable(e, t, n) {
            return new Iv(e, t, n, this)
        }
        fromOther(e) {
            this.fromImmutableData(e.data)
        }
        toImmutableData() {
            return this.data
        }
        fromImmutableData(e) {
            this.data = e, this.writePropagate(this.data, this.cache), this.cache.invalidate()
        }
        setInputs(e) {
            throw new Error("@abstract")
        }
        get widgetsGenerationsTree() {
            return this._widgetsGenerationsTree || (this._widgetsGenerationsTree = new Oc), this._widgetsGenerationsTree
        }
        getReadOnlyWidgetRecord(e) {
            return this.widgets.get(e).asReadOnly()
        }
        get context() {
            return this._context
        }
        sanitize(e) {
            let t = e;
            if (this.hasVariables) {
                if (e.constructor !== this.data.constructor) throw new Error("Expected data to be the same type of this model data");
                let n = this.variables.getNonSerializableAttributes();
                if (n.length > 0) {
                    let i = t.get(Ur.VariablesPropertyName);
                    n.forEach(s => i = i.set(s, null)), t = t.set(Ur.VariablesPropertyName, i)
                }
            }
            return t
        }
    };
o(Ur, "BaseViewModel");
var Vn = Ur;
Vn.VariablesPropertyName = "variables";
Vn.WidgetsPropertyName = "widgets";
Vn.ClientVariablesGenerationPropertyName = "clientVariablesGeneration";
Vn.CurrentLocalePropertyName = "currentLocale";
Vn.InvalidValue = new Object;
Vn.RecordClass = ur.defineRecordClass({
    variables: null,
    widgets: null,
    clientVariablesGeneration: 0,
    currentLocale: null
});

function Iue() {
    let r = 1;
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    for (let i of t) switch (i) {
        case 2:
            return 2;
        case 0:
            r = 0;
            break
    }
    return r
}
o(Iue, "calculateDataFetchStatus");
var iR = class iR extends Vn {
    static get hasVariables() {
        return !1
    }
    setInputs() {}
};
o(iR, "VariablelessViewModel");
var yA = iR,
    Qv = class Qv extends Vn {
        static get hasVariables() {
            return !1
        }
        static get hasValidationWidgets() {
            return !1
        }
        setInputs() {}
        static create(e, t, n) {
            return new Qv({
                viewName: e,
                navigatedFromHistory: t,
                viewWasRestoredFromCache: n
            })
        }
    };
o(Qv, "DummyViewModel");
var Cv = Qv,
    sR = class sR {
        constructor(e) {
            this.modelClass = e
        }
        create(e) {
            return !this.modelClass.hasVariables && !this.modelClass.hasValidationWidgets ? new Cv(e) : new this.modelClass(e)
        }
        get hasValidationWidgets() {
            return this.modelClass.hasValidationWidgets
        }
    };
o(sR, "ModelFactory");
var _A = sR,
    ey = class ey {
        constructor(e) {
            this._parent = e, this._generation = e ? e.generation : 0
        }
        get parent() {
            return this._parent
        }
        get generation() {
            return this._generation
        }
        set generation(e) {
            this.generation < e && (this._generation = e, this.parent && (this.parent.generation = e))
        }
        addChild() {
            return new ey(this)
        }
    };
o(ey, "GenerationNode");
var wA = ey,
    $o = class $o {
        constructor() {
            this._root = new wA(null), this._root.generation = $o.currentGeneration, $o.currentGeneration++
        }
        get root() {
            return this._root
        }
        static get currentGeneration() {
            return $o.generation
        }
        static set currentGeneration(e) {
            $o.generation = e
        }
    };
o($o, "GenerationsTree");
var Oc = $o;
Oc.generation = 0;
var Cue = Object.freeze({
        __proto__: null,
        AggregateRecord: ff,
        BaseViewModel: Vn,
        BaseWidgetRecordMap: Rc,
        DataSourceRecord: Hs,
        DummyViewModel: Cv,
        ModelFactory: _A,
        ValidationWidgetRecord: Cc,
        Variable: Iv,
        VariablelessViewModel: yA,
        WidgetRecord: Yi,
        calculateDataFetchStatus: Iue
    }),
    oR = class oR extends mn {
        serializeBinaryData(e, t) {
            return e.toArrayBuffer() || null
        }
        deserializeBinaryData(e, t) {
            let n = e instanceof ArrayBuffer ? new Blob([e]) : e;
            return new Or(n)
        }
        isConversionNeeded(e, t) {
            return this.isConversionNeededBetweenDBDataTypes(e.type, t.type) || !!e.isEntityReference != !!t.isEntityReference ? !0 : e.length !== void 0 && t.length !== void 0 ? e.decimals !== void 0 && t.decimals !== void 0 ? e.length - e.decimals > t.length - t.decimals : e.length > t.length : !1
        }
        isConversionNeededBetweenDBDataTypes(e, t) {
            if (e === void 0) return !0;
            if (e === t) return !1;
            switch (e) {
                case re.BOOLEAN:
                    return t !== re.INTEGER;
                case re.LONGINTEGER:
                    return t !== re.TEXT;
                default:
                    return !0
            }
        }
    };
o(oR, "IndexedDBSerializer");
var Rv = oR,
    Rue = Object.freeze({
        __proto__: null,
        default: Rv
    });

function Oue(r, e, t) {
    let n = '(^|\\s|\\.)(\\[|"|)(ossys_|osltm_|oslog_|osevt_|osusr_|osext_)',
        i = "((((\\{\\w+\\})|(\\w+)).)?((\\[\\w+\\])|(\\w+))(( )+(desc|asc))?)(( )*,( )*(((\\{\\w+\\})|(\\w+)).)?((\\[\\w+\\])|(\\w+))(( )+(desc|asc))?)*";
    r = r.trim();
    let s = Bm(r, n, !0);
    if (s.length > 0) {
        let c = s[0];
        throw new pe.DataBaseException("", `'${c.groups[2]+c.groups[3]}' found in 'Order By' parameter is a reserved prefix`)
    }
    if (r !== "" && (s = Bm(r, i, !0), s.length !== 1 || s[0].value !== r)) throw new pe.DataBaseException("", "Invalid syntax in 'Order By' parameter.");
    let a = o(c => Pue(c, e, t), "meReplaceEntityName"),
        u = o(c => Nue(c), "meReplaceAttributeName"),
        l = Vm(r, "(\\{\\w+\\}|\\w+\\.)", !1, a);
    return l = Vm(l, "(\\[\\w+\\])", !1, u), l
}
o(Oue, "replaceEntityReferencesInOrderBy");

function Pue(r, e, t) {
    let n = "",
        i = Due(r),
        s = !1;
    for (let a = 0; a < e.length; a++)
        if (e[a].toLowerCase() === i.toLowerCase()) {
            s = !0, n = '"' + t[a] + '"';
            break
        } if (!s) throw new pe.DataBaseException("", `'${i}' found in 'Order By' parameter is an invalid Entity`);
    return r.value.charAt(r.value.length - 1) === "." ? n + "." : n
}
o(Pue, "replaceEntityNameInOrderBy");

function Nue(r) {
    let e = r.value.substr(1, r.value.length - 2);
    return e ? (e.charAt(0) === '"' ? "" : '"') + e + (e.charAt(e.length - 1) === '"' ? "" : '"') : ""
}
o(Nue, "replaceAttributeName");

function Due(r) {
    return r.value.charAt(r.value.length - 1) === "." ? r.value.substr(0, r.value.length - 1) : r.value.substr(1, r.value.length - 2)
}
o(Due, "getEntityNameFromMatch");

function Lue(r) {
    return xue(r).join(", ")
}
o(Lue, "getOrderByColumnsWithoutDuplicates");

function xue(r) {
    let e = [],
        t = {};
    return r.forEach(n => {
        let i = n.trim();
        if (i !== "") {
            let s = i.replace(new RegExp("\\b((ASC)|(DESC))$", "im"), "").replace('"', "").replace("[", "").replace("]", "").trim().toLowerCase();
            t[s] !== !0 && (e.push(i), t[s] = !0)
        }
    }), e
}
o(xue, "filterDuplicateOrderByColumns");

function Uue(r, e) {
    return e.forEach(t => {
        let n = UF(t);
        for (let i = 0; i < r.length; i++)
            if (r[i].attributes.some(a => a.name.toLowerCase() === n.toLowerCase())) return !0;
        throw new pe.DataBaseException("", `Invalid attribute in 'Order By' parameter: ${t}`)
    }), !0
}
o(Uue, "validateQueryOrderBy");

function UF(r) {
    let t = r.trim().split(" ")[0].split(".");
    return t[t.length - 1].replace(/["]+/g, "")
}
o(UF, "getAttributeFromOrderBy");
var Mue = Object.freeze({
    __proto__: null,
    getAttributeFromOrderBy: UF,
    getOrderByColumnsWithoutDuplicates: Lue,
    replaceEntityReferencesInOrderBy: Oue,
    validateQueryOrderBy: Uue
});

function kue() {
    return !0
}
o(kue, "defaultShouldCompareProp");

function Fue(r) {
    let e = 0,
        t = r.length;
    if (t === 0) return e;
    for (let n = 0; n < t; n++) {
        let i = r.charCodeAt(n);
        e = (e << 5) - e + i, e |= 0
    }
    return e
}
o(Fue, "getHashCode");

function $ue(r) {
    return G.isBasicType(r) && !((r == null ? void 0 : r.equals) instanceof Function)
}
o($ue, "isBasicType");

function MF(r, e) {
    return !r || !e || $ue(r) ? r === e : r.fastEquals instanceof Function ? r.fastEquals(e) : Tn(r, e)
}
o(MF, "innerShallowEquals");

function Bue(r, e) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : kue;
    if (r === e) return !0;
    if (r === null || e === null || typeof r != "object" || typeof e != "object") return !1;
    let n = Object.keys(r),
        i = Object.keys(e);
    if (n.length !== i.length) return !1;
    let s = Object.prototype.hasOwnProperty.bind(e);
    for (let a = 0; a < n.length; a++) {
        let u = n[a];
        if (t(r, u) && (!s(u) || !MF(r[u], e[u]))) return !1
    }
    return !0
}
o(Bue, "shallowEquals");

function Vue(r, e) {
    if (r === e) return !0;
    if (r === null || e === null || !(r instanceof Array) || !(e instanceof Array) || r.length !== e.length) return !1;
    for (let t = 0; t < r.length; t++)
        if (!MF(r[t], e[t])) return !1;
    return !0
}
o(Vue, "arrayShallowEquals");

function Hue(r) {
    for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) t[n - 1] = arguments[n];
    return Object.assign(r, ...t)
}
o(Hue, "assign");

function jue(r) {
    return !r || Object.keys(r).length === 0
}
o(jue, "isEmptyObject");

function Wue(r) {
    let e = [],
        t = [r],
        n = 0;
    for (; t.length;) {
        let i = t.pop();
        switch (typeof i) {
            case "boolean":
                n += 4;
                break;
            case "number":
                n += 8;
                break;
            case "string":
                n += 2 * i.length;
                break;
            case "object":
                if (e.indexOf(i) !== -1) continue;
                e.push(i), Array.isArray(i) || (n += 2 * Object.keys(i).length);
                for (let s in i) {
                    let a = null;
                    try {
                        a = i[s]
                    } catch (u) {}
                    a && t.push(a)
                }
                break
        }
    }
    return n
}
o(Wue, "roughSizeOf");

function Gue(r, e, t) {
    return r + e.repeat(t)
}
o(Gue, "concatenateMultipleTimes");
var zue = Object.freeze({
        __proto__: null,
        arrayShallowEquals: Vue,
        assign: Hue,
        concatenateMultipleTimes: Gue,
        getHashCode: Fue,
        isEmptyObject: jue,
        roughSizeOf: Wue,
        shallowEquals: Bue
    }),
    $u, hf = ($u = class extends Ce {
        constructor(e, t) {
            super(e, t)
        }
        static attributesToDeclare() {
            return [this.attr("PasswordComplexityPolicyFailed", "passwordComplexityPolicyFailedAttr", "passwordComplexityPolicyFailed", !0, !1, _.Boolean, () => !1), this.attr("InvalidCredentials", "invalidCredentialsAttr", "invalidCredentials", !0, !1, _.Boolean, () => !1), this.attr("TooManyFailedAttempts", "tooManyFailedAttemptsAttr", "tooManyFailedAttempts", !0, !1, _.Boolean, () => !1)].concat(super.attributesToDeclare())
        }
    }, o($u, "ChangePasswordFailureReasonRec"), $u);
hf = nt([tt()], hf);
var Bu, Ov = (Bu = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Success", "successAttr", "success", !0, !1, _.Boolean, () => Le(_.Boolean)), this.attr("ChangePasswordFailureReason", "changePasswordFailureReasonAttr", "changePasswordFailureReason", !0, !1, _.Record, () => Ft.getData(new hf), hf)].concat(super.attributesToDeclare())
    }
}, o(Bu, "ChangePasswordResultRec"), Bu);
Ov = nt([tt()], Ov);
var Vu, gf = (Vu = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("PasswordComplexityPolicyFailed", "passwordComplexityPolicyFailedAttr", "passwordComplexityPolicyFailed", !0, !1, _.Boolean, () => !1), this.attr("InvalidVerificationCode", "invalidVerificationCodeAttr", "invalidVerificationCode", !0, !1, _.Boolean, () => !1), this.attr("InvalidEmail", "invalidEmailAttr", "invalidEmail", !0, !1, _.Boolean, () => !1)].concat(super.attributesToDeclare())
    }
}, o(Vu, "FinishUserRegistrationFailureReasonRec"), Vu);
gf = nt([tt()], gf);
var Hu, pf = (Hu = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("InvalidCredentials", "invalidCredentialsAttr", "invalidCredentials", !0, !1, _.Boolean, () => !1), this.attr("InvalidName", "invalidNameAttr", "invalidName", !0, !1, _.Boolean, () => !1), this.attr("InvalidPhotoURL", "invalidPhotoURLAttr", "invalidPhotoURL", !0, !1, _.Boolean, () => !1)].concat(super.attributesToDeclare())
    }
}, o(Hu, "UpdateUserFailureReasonRec"), Hu);
pf = nt([tt()], pf);
var ju, TA = (ju = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Success", "successAttr", "success", !0, !1, _.Boolean, () => Le(_.Boolean)), this.attr("UpdateUserFailureReason", "updateUserFailureReasonAttr", "updateUserFailureReason", !0, !1, _.Record, () => Ft.getData(new pf), pf)].concat(super.attributesToDeclare())
    }
}, o(ju, "UpdateUserResultRec"), ju);
TA = nt([tt()], TA);
var Wu, Pv = (Wu = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("MinimumLength", "minimumLengthAttr", "minimumLength", !0, !1, _.Integer, () => Le(_.Integer)), this.attr("UpperCaseLetterRequired", "upperCaseLetterRequiredAttr", "upperCaseLetterRequired", !0, !1, _.Boolean, () => Le(_.Boolean)), this.attr("LowerCaseLetterRequired", "lowerCaseLetterRequiredAttr", "lowerCaseLetterRequired", !0, !1, _.Boolean, () => Le(_.Boolean)), this.attr("NumberRequired", "numberRequiredAttr", "numberRequired", !0, !1, _.Boolean, () => Le(_.Boolean)), this.attr("SpecialCharacterRequired", "specialCharacterRequiredAttr", "specialCharacterRequired", !0, !1, _.Boolean, () => Le(_.Boolean))].concat(super.attributesToDeclare())
    }
}, o(Wu, "PasswordComplexityPolicyRec"), Wu);
Pv = nt([tt()], Pv);
var Gu, Nv = (Gu = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("IsValid", "isValidAttr", "isValid", !0, !1, _.Boolean, () => Le(_.Boolean)), this.attr("MissingMinimumLength", "missingMinimumLengthAttr", "missingMinimumLength", !0, !1, _.Boolean, () => Le(_.Boolean)), this.attr("MissingUpperCaseLetter", "missingUpperCaseLetterAttr", "missingUpperCaseLetter", !0, !1, _.Boolean, () => Le(_.Boolean)), this.attr("MissingLowerCaseLetter", "missingLowerCaseLetterAttr", "missingLowerCaseLetter", !0, !1, _.Boolean, () => Le(_.Boolean)), this.attr("MissingNumber", "missingNumberAttr", "missingNumber", !0, !1, _.Boolean, () => Le(_.Boolean)), this.attr("MissingSpecialCharacter", "missingSpecialCharacterAttr", "missingSpecialCharacter", !0, !1, _.Boolean, () => Le(_.Boolean))].concat(super.attributesToDeclare())
    }
}, o(Gu, "PasswordValidationResultRec"), Gu);
Nv = nt([tt()], Nv);
var zu, Dv = (zu = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Success", "successAttr", "success", !0, !1, _.Boolean, () => Le(_.Boolean)), this.attr("UserId", "userIdAttr", "userId", !0, !1, _.Text, () => Le(_.Text)), this.attr("finishUserRegistrationFailureReason", "finishUserRegistrationFailureReasonAttr", "finishUserRegistrationFailureReason", !0, !1, _.Record, () => Ft.getData(new gf), gf)].concat(super.attributesToDeclare())
    }
}, o(zu, "FinishUserRegistrationResultRec"), zu);
Dv = nt([tt()], Dv);
var qu, Lv = (qu = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Email", "emailAttr", "email", !0, !1, _.Email, () => Le(_.Email)), this.attr("Username", "usernameAttr", "username", !0, !1, _.Text, () => Le(_.Text)), this.attr("Name", "nameAttr", "name", !0, !1, _.Text, () => Le(_.Text)), this.attr("PhotoURL", "photoURLAttr", "photoURL", !0, !1, _.Text, () => Le(_.Text))].concat(super.attributesToDeclare())
    }
}, o(qu, "UserInfoRec"), qu);
Lv = nt([tt()], Lv);
var Ku, mf = (Ku = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("InvalidCredentials", "invalidCredentialsAttr", "invalidCredentials", !0, !1, _.Boolean, () => !1), this.attr("TooManyFailedLoginAttempts", "tooManyFailedLoginAttemptsAttr", "tooManyFailedLoginAttempts", !0, !1, _.Boolean, () => !1)].concat(super.attributesToDeclare())
    }
}, o(Ku, "UserLoginFailureReasonRec"), Ku);
mf = nt([tt()], mf);
var Yu, xv = (Yu = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Success", "successAttr", "success", !0, !1, _.Boolean, () => Le(_.Boolean)), this.attr("UserId", "userIdAttr", "userId", !0, !1, _.Text, () => Le(_.Text)), this.attr("UserLoginFailureReason", "userLoginFailureReasonAttr", "userLoginFailureReason", !0, !1, _.Record, () => Ft.getData(new mf), mf), this.attr("retryAfterSeconds", "retryAfterSecondsAttr", "retryAfterSeconds", !0, !1, _.Integer, () => Le(_.Integer))].concat(super.attributesToDeclare())
    }
}, o(Yu, "UserLoginResultRec"), Yu);
xv = nt([tt()], xv);
var Xu, vf = (Xu = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("InvalidEmail", "invalidEmailAttr", "invalidEmail", !0, !1, _.Boolean, () => !1), this.attr("InvalidName", "invalidNameAttr", "invalidName", !0, !1, _.Boolean, () => !1), this.attr("UsernameAlreadyExists", "usernameAlreadyExistsAttr", "usernameAlreadyExists", !0, !1, _.Boolean, () => !1), this.attr("UserAlreadyRegistered", "userAlreadyRegisteredAttr", "userAlreadyRegistered", !0, !1, _.Boolean, () => !1)].concat(super.attributesToDeclare())
    }
}, o(Xu, "StartUserRegistrationFailureReasonRec"), Xu);
vf = nt([tt()], vf);
var Ju, EA = (Ju = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Success", "successAttr", "success", !0, !1, _.Boolean, () => Le(_.Boolean)), this.attr("StartUserRegistrationFailureReason", "startUserRegistrationFailureReasonAttr", "startUserRegistrationFailureReason", !0, !1, _.Record, () => Ft.getData(new vf), vf), this.attr("TemporaryPassword", "temporaryPasswordAttr", "temporaryPassword", !0, !1, _.Text, () => Le(_.Text)), this.attr("UserId", "userIdAttr", "userId", !0, !1, _.Text, () => Le(_.Text)), this.attr("VerificationCode", "verificationCodeAttr", "verificationCode", !0, !1, _.Text, () => Le(_.Text))].concat(super.attributesToDeclare())
    }
}, o(Ju, "StartUserRegistrationResultRec"), Ju);
EA = nt([tt()], EA);
var Zu, bA = (Zu = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Name", "nameAttr", "name", !0, !1, _.Text, () => Le(_.Text)), this.attr("PhotoURL", "photoURLAttr", "photoURL", !0, !1, _.Text, () => Le(_.Text))].concat(super.attributesToDeclare())
    }
}, o(Zu, "UserUpdateInfoRec"), Zu);
bA = nt([tt()], bA);
var Qu, SA = (Qu = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("HasRole", "hasRoleOut", "hasRole", !0, !1, _.Boolean, () => Le(_.Boolean))].concat(super.attributesToDeclare())
    }
}, o(Qu, "HasRoleResultRec"), Qu);
SA = nt([tt()], SA);
var ec, yf = (ec = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("PasswordComplexityPolicyFailed", "passwordComplexityPolicyFailedAttr", "passwordComplexityPolicyFailed", !0, !1, _.Boolean, () => !1), this.attr("InvalidVerificationCode", "invalidVerificationCodeAttr", "invalidVerificationCode", !0, !1, _.Boolean, () => !1), this.attr("InvalidEmail", "invalidEmailAttr", "invalidEmail", !0, !1, _.Boolean, () => !1)].concat(super.attributesToDeclare())
    }
}, o(ec, "FinishResetPasswordFailureReasonRec"), ec);
yf = nt([tt()], yf);
var tc, Uv = (tc = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Success", "successAttr", "success", !0, !1, _.Boolean, () => Le(_.Boolean)), this.attr("FinishResetPasswordFailureReason", "finishResetPasswordFailureReasonAttr", "finishResetPasswordFailureReason", !0, !1, _.Record, () => Ft.getData(new yf), yf)].concat(super.attributesToDeclare())
    }
}, o(tc, "FinishResetPasswordResultRec"), tc);
Uv = nt([tt()], Uv);
var rc, AA = (rc = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Success", "successAttr", "success", !0, !1, _.Boolean, () => Le(_.Boolean)), this.attr("VerificationCode", "verificationCodeAttr", "verificationCode", !0, !1, _.Text, () => Le(_.Text))].concat(super.attributesToDeclare())
    }
}, o(rc, "StartResetPasswordResultRec"), rc);
AA = nt([tt()], AA);
var nc, _f = (nc = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("InvalidVerificationCode", "InvalidVerificationCodeAttr", "InvalidVerificationCode", !0, !1, _.Boolean, () => !1)].concat(super.attributesToDeclare())
    }
}, o(nc, "FinishUpdateEmailFailureReasonRec"), nc);
_f = nt([tt()], _f);
var ic, Mv = (ic = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Success", "successAttr", "success", !0, !1, _.Boolean, () => !1), this.attr("FinishUpdateEmailFailureReason", "finishUpdateEmailFailureReasonAttr", "finishUpdateEmailFailureReason", !0, !1, _.Record, () => Ft.getData(new _f), _f)].concat(super.attributesToDeclare())
    }
}, o(ic, "FinishUpdateEmailResultRec"), ic);
Mv = nt([tt()], Mv);
var sc, wf = (sc = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("InvalidEmail", "invalidEmailAttr", "invalidEmail", !0, !1, _.Boolean, () => !1)].concat(super.attributesToDeclare())
    }
}, o(sc, "StartUpdateEmailFailureReasonRec"), sc);
wf = nt([tt()], wf);
var oc, IA = (oc = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Success", "successAttr", "success", !0, !1, _.Boolean, () => Le(_.Boolean)), this.attr("VerificationCode", "verificationCodeAttr", "verificationCode", !0, !1, _.Text, () => Le(_.Text)), this.attr("StartUpdateEmailFailureReason", "startUpdateEmailFailureReasonAttr", "startUpdateEmailFailureReason", !0, !1, _.Record, () => Ft.getData(new wf), wf)].concat(super.attributesToDeclare())
    }
}, o(oc, "StartUpdateEmailResultRec"), oc);
IA = nt([tt()], IA);
var Cm, ac, CA = Cm = (ac = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Id", "idAttr", "Id", !0, !1, _.LongInteger, () => D.DEFAULT_LONGINTEGER), this.attr("Name", "nameAttr", "Name", !1, !1, _.Text, () => D.DEFAULT_TEXT), ...super.attributesToDeclare()]
    }
    static fromStructure(e) {
        return new Cm(new Cm.RecordClass({
            idAttr: Ft.getData(e)
        }))
    }
    static get $runtimeName() {
        return "AIRole"
    }
}, o(ac, "ENAIRoleEntityRecord"), ac);
CA = Cm = nt([tt()], CA);
var Rm, uc, RA = Rm = (uc = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Id", "idAttr", "Id", !0, !1, _.LongInteger, () => D.DEFAULT_LONGINTEGER), this.attr("Name", "nameAttr", "Name", !1, !1, _.Text, () => D.DEFAULT_TEXT), ...super.attributesToDeclare()]
    }
    static fromStructure(e) {
        return new Rm(new Rm.RecordClass({
            idAttr: Ft.getData(e)
        }))
    }
    static get $runtimeName() {
        return "AIContentType"
    }
}, o(uc, "ENAIContentTypeEntityRecord"), uc);
RA = Rm = nt([tt()], RA);
var cc, OA = (cc = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("ResponseTokens", "responseTokensAttr", "responseTokens", !1, !1, _.LongInteger, () => D.DEFAULT_LONGINTEGER), this.attr("InputTokens", "inputTokensAttr", "inputTokens", !1, !1, _.LongInteger, () => D.DEFAULT_LONGINTEGER), this.attr("TotalTokens", "totalTokensAttr", "totalTokens", !1, !1, _.LongInteger, () => D.DEFAULT_LONGINTEGER)].concat(super.attributesToDeclare())
    }
}, o(cc, "AIModelUsageRec"), cc);
OA = nt([tt()], OA);
var lc, kv = (lc = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("ContentType", "contentTypeAttr", "contentType", !0, !1, _.LongInteger, () => D.DEFAULT_LONGINTEGER), this.attr("ContentText", "contentTextAttr", "contentText", !1, !1, _.Text, () => D.DEFAULT_TEXT), this.attr("ContentUrl", "contentUrlAttr", "contentUrl", !1, !1, _.Text, () => D.DEFAULT_TEXT), this.attr("ContentBinaryData", "contentBinaryDataAttr", "contentBinaryData", !1, !1, _.BinaryData, () => D.DEFAULT_BINARYDATA), this.attr("FileFormat", "fileFormatAttr", "fileFormat", !1, !1, _.Text, () => D.DEFAULT_TEXT)].concat(super.attributesToDeclare())
    }
}, o(lc, "AIItemRec"), lc);
kv = nt([tt()], kv);
var Cd, Om, Rd, kF, FF, $F, aR = class aR {
    constructor() {
        Cd.add(this), Om.set(this, new Map), Rd.set(this, new Map)
    }
    getGenericList(e) {
        let t = ie(this, Om, "f").get(e);
        if (t) return t;
        let i = class i extends _c {
            static getItemType() {
                return e
            }
        };
        o(i, "GeneratedList");
        let n = i;
        return ie(this, Om, "f").set(e, n), n
    }
    getImplicitRecord(e, t) {
        let n = ie(this, Cd, "m", kF).call(this, t),
            i = ie(this, Cd, "m", FF).call(this, e, n);
        if (i) return i;
        let a = class a extends Ce {
            static attributesToDeclare() {
                return [this.attr(t.name, t.attrName, t.nameForJson, !1, !1, _.Record, function() {
                    return Ft.getData(new e)
                }, !0, e)].concat(Ce.attributesToDeclare.call(this))
            }
            static fromStructure(l) {
                return new a(new a.RecordClass({
                    [t.attrName]: Ft.getData(l)
                }))
            }
            static get _isAnonymousRecord() {
                return !0
            }
            static get UniqueId() {
                return t.uniqueId
            }
        };
        o(a, "GeneratedRecord");
        let s = a;
        return s.init(), ie(this, Cd, "m", $F).call(this, s, e, n), s
    }
};
o(aR, "GenericTypeCache");
var PA = aR;
Om = new WeakMap, Rd = new WeakMap, Cd = new WeakSet, kF = o(function(e) {
    let {
        name: t,
        attrName: n,
        nameForJson: i,
        uniqueId: s
    } = e;
    return `${t}.${n}.${i}.${s}`
}, "_GenericTypeCache_calcSignature"), FF = o(function(e, t) {
    var n;
    return (n = ie(this, Rd, "f").get(e)) === null || n === void 0 ? void 0 : n.get(t)
}, "_GenericTypeCache_getImplicitRecordFromCache"), $F = o(function(e, t, n) {
    var i;
    let s = (i = ie(this, Rd, "f").get(t)) !== null && i !== void 0 ? i : new Map;
    s.set(n, e), ie(this, Rd, "f").set(t, s)
}, "_GenericTypeCache_setImplicitRecordOnCache");
var YI = new PA,
    Kx = YI.getGenericList(kv),
    dc, NA = (dc = class extends Ce {
        constructor(e, t) {
            super(e, t)
        }
        static attributesToDeclare() {
            return [this.attr("Content", "contentAttr", "content", !0, !1, _.RecordList, () => Ft.getData(new Kx), !0, Kx), this.attr("CreatedOn", "createdOnAttr", "createdOn", !1, !1, _.DateTime, () => D.DEFAULT_DATETIME), this.attr("Role", "roleAttr", "role", !0, !1, _.LongInteger, () => D.DEFAULT_LONGINTEGER), this.attr("ActionName", "actionNameAttr", "actionName", !1, !1, _.Text, () => D.DEFAULT_TEXT), this.attr("ActionParameters", "actionParametersAttr", "actionParameters", !1, !1, _.Text, () => D.DEFAULT_TEXT), this.attr("ActionId", "actionIdAttr", "actionId", !1, !1, _.Text, () => D.DEFAULT_TEXT), ...super.attributesToDeclare()]
        }
    }, o(dc, "AIMessageRec"), dc);
NA = nt([tt()], NA);
var fc, Tf = (fc = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Key", "keyAttr", "key", !0, !1, _.Text, () => Le(_.Text)), this.attr("Name", "nameAttr", "name", !0, !1, _.Text, () => Le(_.Text))].concat(super.attributesToDeclare())
    }
}, o(fc, "ExternalIdentityProviderRec"), fc);
Tf = nt([tt()], Tf);
var Fv, hc, Pc = (hc = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("FileName", "fileNameAttr", "FileName", !1, !1, _.Text, () => Le(_.Text)), this.attr("FileContent", "fileContentAttr", "FileContent", !1, !1, _.BinaryData, () => Le(_.BinaryData)), this.attr("MimeType", "mimeTypeAttr", "MimeType", !1, !1, _.Text, () => Le(_.Text))].concat(super.attributesToDeclare())
    }
}, o(hc, "AttachmentRec"), hc);
Pc = nt([tt()], Pc);
var gc, Nc = Fv = (gc = class extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Attachment", "attachmentAttr", "Attachment", !1, !1, _.Record, () => Ft.getData(new Pc), Pc)].concat(Ce.attributesToDeclare())
    }
}, o(gc, "AttachmentRecord"), gc);
Nc._isAnonymousRecord = !0;
Nc.fromStructure = function(r) {
    return new Fv(new Fv.RecordClass({
        attachmentAttr: Ft.getData(r)
    }))
};
Nc = Fv = nt([tt()], Nc);
var uR = class uR extends _c {
    constructor(e) {
        super(e)
    }
};
o(uR, "RLAttachmentList");
var $v = uR;
$v.itemType = Pc;
var cR = class cR extends _c {
    constructor(e) {
        super(e)
    }
};
o(cR, "AttachmentRecordList");
var Bv = cR;
Bv.itemType = Nc;
var que = Object.freeze({
        __proto__: null,
        get AIItemRec() {
            return kv
        },
        get AIMessageRec() {
            return NA
        },
        get AIModelUsageRec() {
            return OA
        },
        get AttachmentRec() {
            return Pc
        },
        get AttachmentRecord() {
            return Nc
        },
        AttachmentRecordList: Bv,
        get ChangePasswordFailureReasonRec() {
            return hf
        },
        get ChangePasswordResultRec() {
            return Ov
        },
        get ENAIContentTypeEntityRecord() {
            return RA
        },
        get ENAIRoleEntityRecord() {
            return CA
        },
        get ExternalIdentityProviderRec() {
            return Tf
        },
        get FinishResetPasswordFailureReasonRec() {
            return yf
        },
        get FinishResetPasswordResultRec() {
            return Uv
        },
        get FinishUpdateEmailFailureReasonRec() {
            return _f
        },
        get FinishUpdateEmailResultRec() {
            return Mv
        },
        get FinishUserRegistrationFailureReasonRec() {
            return gf
        },
        get FinishUserRegistrationResultRec() {
            return Dv
        },
        get HasRoleResultRec() {
            return SA
        },
        get PasswordComplexityPolicyRec() {
            return Pv
        },
        get PasswordValidationResultRec() {
            return Nv
        },
        RLAttachmentList: $v,
        get StartResetPasswordResultRec() {
            return AA
        },
        get StartUpdateEmailFailureReasonRec() {
            return wf
        },
        get StartUpdateEmailResultRec() {
            return IA
        },
        get StartUserRegistrationFailureReasonRec() {
            return vf
        },
        get StartUserRegistrationResultRec() {
            return EA
        },
        get UpdateUserFailureReasonRec() {
            return pf
        },
        get UpdateUserResultRec() {
            return TA
        },
        get UserInfoRec() {
            return Lv
        },
        get UserLoginFailureReasonRec() {
            return mf
        },
        get UserLoginResultRec() {
            return xv
        },
        get UserUpdateInfoRec() {
            return bA
        }
    }),
    Kd = class Kd {
        static addKey(e) {
            this.cache[e] = {
                components: {}
            }, this.cacheKeys.push(e);
            let t = this.cacheKeys.length - Kd.MaxCacheSize;
            if (t > 0)
                for (let n = 0; n < t; n++) this.removeKey(this.cacheKeys[n])
        }
        static removeKey(e) {
            delete this.cache[e], this.cacheKeys.splice(this.cacheKeys.indexOf(e), 1)
        }
        static save(e, t, n, i) {
            this.cache[e] || this.addKey(e), this.cache[e].components[t] = {
                state: n,
                customProperties: i
            }
        }
        static load(e, t) {
            let n = Kd.loadScreenCache(e);
            return n ? n.components[t] : null
        }
        static loadScreenCache(e) {
            return this.cache[e] || void 0
        }
        static clear(e) {
            e ? this.cache[e] && this.removeKey(e) : (this.cache = {}, this.cacheKeys = [])
        }
    };
o(Kd, "ScreenStateCache");
var Zo = Kd;
Zo.MaxCacheSize = 20;
Zo.cache = {};
Zo.cacheKeys = [];
var Kue = Object.freeze({
        __proto__: null,
        ScreenStateCache: Zo
    }),
    DA = "data-os-finished",
    Yue = "ScriptsManager",
    Pm = new Map,
    Yx = !1,
    xo = null;

function Xue() {
    Pm.clear(), xo = null
}
o(Xue, "clearScripts");

function BF(r) {
    return r.replace(/.*\//, "").replace(/(.*)__.*/, "$1")
}
o(BF, "getScriptName");

function VF(r, e) {
    let t = BF(r),
        n = bI(t, void 0, e);
    n == null || n.setAttribute("code.function", t), n == null || n.setAttribute("outsystems.function.type", "REQUIRED_SCRIPT");
    let i = e == null ? void 0 : e.getContext().attributes["outsystems.function.key"];
    i && (n == null || n.setAttribute("outsystems.function.owner.key", i));
    let s = e == null ? void 0 : e.getContext().attributes["code.function"];
    return s && (n == null || n.setAttribute("outsystems.function.owner.name", s)), n
}
o(VF, "createScriptSpan");

function XI(r) {
    let {
        parentSpan: e,
        dom: t = document
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    rS("Adding script", r), Jue();
    let n = Pm.get(r);
    if (n) return rS("Script already added", r), n.promise;
    let i = VF(r, e),
        s = t.createElement("script");
    s.async = !1, s.setAttribute("src", r), s.setAttribute(DA, "false");
    let a = new Promise((u, l) => {
        let c = o(() => {
            s.setAttribute(DA, "true"), i == null || i.end()
        }, "onFinish");
        s.onerror = s.onabort = d => {
            c(), l(`Error adding script '${r}' to document '${t.baseURI}'`)
        }, s.onload = d => {
            rS("Script added", r), c(), u(d)
        }
    });
    return xo != null && xo.domElement.parentNode ? xo.domElement.parentNode.insertBefore(s, xo.domElement.nextSibling) : t.head.appendChild(s), i == null || i.activate(), Pm.set(r, {
        promise: a,
        domElement: s
    }), xo = Pm.get(r), a
}
o(XI, "addScript");

function rS(r, e) {
    let t = Cf(document.baseURI);
    ee(Yue, `${r} '${e}' : document '${t}'`)
}
o(rS, "debug");

function Jue() {
    Yx || (Yx = !0, Object.defineProperty(define, "amd", {
        get: Zue.bind(this, define.amd),
        configurable: !0
    }))
}
o(Jue, "initialize");

function Zue(r) {
    let e = document.currentScript;
    if (!(e != null && e.hasAttribute(DA))) return r
}
o(Zue, "hideRequireDependingOnCaller");

function Que(r, e) {
    let {
        parentSpan: t,
        dom: n = document
    } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Promise.all(r.map(i => XI(i, {
        parentSpan: t,
        dom: n
    }).catch(e)))
}
o(Que, "scheduleCustomJsLoading");
var ece = Object.freeze({
    __proto__: null,
    addScript: XI,
    clearScripts: Xue,
    createScriptSpan: VF,
    getScriptName: BF,
    scheduleCustomJsLoading: Que
});

function vr(r, e, t) {
    let n = r instanceof Error ? r.message : r,
        i = `Error in ${e}: ${typeof n=="string"?n:"Unknown error"}`,
        s = `Error in ${e}`;
    xc({
        category: "SystemAction",
        clientMessage: i,
        internalMessage: s,
        errorCode: t != null ? t : "OS-CLRT-00000",
        errorObj: r instanceof Error ? r : void 0
    })
}
o(vr, "logSystemActionError");

function pt(r, e, t) {
    let n = bI(r, Pe.External);
    n == null || n.setAttribute("code.function", r), n == null || n.setAttribute("outsystems.function.key", e), n == null || n.setAttribute("outsystems.function.owner.name", "(System)"), n == null || n.setAttribute("outsystems.function.owner.key", "478870b9-2d60-4f73-9eb3-7cd8b994a737"), n == null || n.setAttribute("outsystems.function.type", "CLIENT_SYSTEM_ACTION");
    try {
        return t(n)
    } finally {
        n == null || n.end()
    }
}
o(pt, "wrapActionInSpan");
var tce = new Qt("FinishUpdateEmailResult", "finishUpdateEmailResultOut"),
    rce = "e72200b8-ab6b-40b2-923d-b25c63640662";

function nce(r, e) {
    return k(this, arguments, void 0, function(t, n) {
        var i = this;
        let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : WM,
            a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : vr;
        return (function*() {
            return pt("FinishUpdateEmail", rce, () => k(i, void 0, void 0, function*() {
                let u = new(tce.getType(Mv));
                if (!t) return u.finishUpdateEmailResultOut.successAttr = !1, u.finishUpdateEmailResultOut.finishUpdateEmailFailureReasonAttr.invalidVerificationCodeAttr = !0, a(new Error("Invalid verification code"), "FinishUpdateEmail"), u;
                try {
                    let l = yield s({
                        code: t
                    });
                    u.finishUpdateEmailResultOut.successAttr = l.success === !0, u.finishUpdateEmailResultOut.successAttr || (u.finishUpdateEmailResultOut.finishUpdateEmailFailureReasonAttr.invalidVerificationCodeAttr = !0, l.errorMessage && a(l.errorMessage, "FinishUpdateEmail", l.errorCode))
                } catch (l) {
                    u.finishUpdateEmailResultOut.successAttr = !1, u.finishUpdateEmailResultOut.finishUpdateEmailFailureReasonAttr.invalidVerificationCodeAttr = !0, a(l, "FinishUpdateEmail")
                }
                return u
            }))
        })()
    })
}
o(nce, "finishUpdateEmail");
var ice = 10,
    sce = new Qt("DuplicatedList", "duplicatedListOut"),
    oce = new Qt("FilteredList", "filteredListOut"),
    ace = new Qt("DistinctList", "distinctListOut"),
    uce = new Bs("ExternalLoginURL", "externalLoginURLOut"),
    cce = new Qt("UserLoginResult", "userLoginResultOut"),
    lce = new Bs("ExternalLogoutURL", "externalLogoutURLOut"),
    dce = new Qt("PasswordComplexityPolicy", "passwordComplexityPolicyOut"),
    fce = new Qt("PasswordValidationResult", "passwordValidationResultOut");
new Qt("ResetPasswordResult", "resetPasswordResultOut");
var hce = new Bs("IsExternalUser", "isExternalUserOut"),
    gce = new Qt("RegistrationResult", "registrationResultOut"),
    pce = new Qt("ChangePasswordResult", "changePasswordResultOut"),
    mce = new Qt("UserInfo", "userInfoOut"),
    vce = new Qt("FinishResetPasswordResult", "finishResetPasswordResultOut"),
    lR = class lR {
        constructor() {}
        getCurrentRowNumber(e) {
            return 0
        }
        setCurrentRowNumber(e, t) {}
        isBeingIterated(e) {
            return !1
        }
        registerIterationStart(e) {}
        registerIterationEnd(e) {}
        getIterator(e) {
            return null
        }
        clone() {
            return this
        }
    };
o(lR, "NullIterationContext");
var LA = lR;

function Qo(r, e, t) {
    if (e.isBeingIterated(r)) throw new Error("List is being iterated: " + t + " is not allowed")
}
o(Qo, "validateIterationState");

function Mc(r, e, t, n) {
    Qo(r, e, t);
    try {
        return e.registerIterationStart(r), n()
    } finally {
        e.registerIterationEnd(r)
    }
}
o(Mc, "wrapInIteration");

function Sn(r) {
    return r ? r.iterationContext : new LA
}
o(Sn, "getIterationContextOrDefault");

function yce(r, e, t) {
    return pt("ListAppend", "aa5b021e-e937-4b80-a2b3-c95b4339a11d", () => {
        try {
            let n = Sn(t);
            Qo(r, n, "append"), r.append(e)
        } catch (n) {
            throw vr(n, "listAppend"), n
        }
    })
}
o(yce, "listAppend");

function _ce(r, e) {
    return pt("ListClear", "c534e5bd-7032-4d4c-97e1-abbf1dee3fbf", () => {
        try {
            let t = Sn(e);
            Qo(r, t, "clear"), r.clear(), t.setCurrentRowNumber(r, 0)
        } catch (t) {
            throw vr(t, "listClear"), t
        }
    })
}
o(_ce, "listClear");

function wce(r, e, t, n) {
    return pt("ListInsert", "6c6663d0-5b99-492d-80a5-284def1ceb8c", () => {
        try {
            let i = Sn(n);
            Qo(r, i, "insert"), r.insert(t, e);
            let s = i.getCurrentRowNumber(r);
            r.length > 1 && t <= s && i.setCurrentRowNumber(r, s + 1)
        } catch (i) {
            throw vr(i, "listInsert"), i
        }
    })
}
o(wce, "listInsert");

function Tce(r, e, t) {
    return pt("ListRemove", "9a0ebe10-cdee-4774-9179-e3c439bb0d3a", () => {
        try {
            let n = Sn(t);
            Qo(r, n, "remove");
            let i = r.length === 1,
                s;
            i && (s = r.getItem(0)), r.remove(e), i && (r.emptyListItem = s);
            let a = n.getCurrentRowNumber(r);
            e < a ? n.setCurrentRowNumber(r, a - 1) : e === r.length && n.setCurrentRowNumber(r, Math.max(0, r.length - 1))
        } catch (n) {
            throw vr(n, "listRemove"), n
        }
    })
}
o(Tce, "listRemove");

function Ece(r, e, t) {
    return pt("ListAppendAll", "cfed0293-97ed-42f7-8d5a-5a2582ecb1da", () => {
        try {
            let n = Sn(t);
            Qo(r, n, "appendAll"), r.appendAll(e)
        } catch (n) {
            throw vr(n, "listAppendAll"), n
        }
    })
}
o(Ece, "listAppendAll");

function bce(r, e) {
    return pt("ListDuplicate", "dbe15950-87da-4517-88b4-14c83bbe7d94", () => {
        try {
            let t = Sn(e);
            Qo(r, t, "duplicate");
            let n = new(sce.getType(r.constructor));
            return n.duplicatedListOut = r.clone(), n
        } catch (t) {
            throw vr(t, "listDuplicate"), t
        }
    })
}
o(bce, "listDuplicate");

function Sce(r, e) {
    return pt("ListDistinct", "b54c6849-3ce4-455a-af15-ad7a37c9899f", () => {
        try {
            let t = Sn(e);
            return Mc(r, t, "distinct", () => {
                let n = new(ace.getType(r.constructor));
                return n.distinctListOut = r.distinct(), n
            })
        } catch (t) {
            throw vr(t, "listDistinct"), t
        }
    })
}
o(Sce, "listDistinct");
var dR = class dR extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Result", "resultOut", "resultOut", !0, !0, _.Boolean, () => {})].concat(super.attributesToDeclare())
    }
};
o(dR, "ListOperationBooleanResultRecord");
var Dc = dR;
Dc._constructor = (() => {
    Dc.init()
})();

function Ace(r, e, t) {
    return pt("ListAll", "22f2c626-25d5-4457-bbe7-94261470862e", () => {
        try {
            let n = Sn(t);
            return Mc(r, n, "all", () => {
                let i = new Dc;
                return i.resultOut = r.all(e), i
            })
        } catch (n) {
            throw vr(n, "listAll"), n
        }
    })
}
o(Ace, "listAll");

function Ice(r, e, t) {
    return pt("ListAny", "d562e8a9-e680-48d3-8274-1e7e5437e4f8", () => {
        try {
            let n = Sn(t);
            return Mc(r, n, "any", () => {
                let i = new Dc;
                return i.resultOut = r.any(e), i
            })
        } catch (n) {
            throw vr(n, "listAny"), n
        }
    })
}
o(Ice, "listAny");

function Cce(r, e, t) {
    return pt("ListFilter", "5137c152-4d59-48f6-b86e-b6b8e7b1e160", () => {
        try {
            let n = Sn(t);
            return Mc(r, n, "filter", () => {
                let i = new(oce.getType(r.constructor));
                return i.filteredListOut = r.filter(e), i
            })
        } catch (n) {
            throw vr(n, "listFilter"), n
        }
    })
}
o(Cce, "listFilter");

function Rce(r, e, t, n) {
    return pt("ListSort", "c7db4ad0-51cc-44e5-aa36-50546face388", () => {
        try {
            let i = Sn(n);
            return Mc(r, i, "sort", () => {
                r.sort(e, t)
            })
        } catch (i) {
            throw vr(i, "listSort"), i
        }
    })
}
o(Rce, "listSort");
var fR = class fR extends Ce {
    constructor(e, t) {
        super(e, t)
    }
    static attributesToDeclare() {
        return [this.attr("Position", "positionOut", "positionOut", !0, !0, _.Integer, () => {})].concat(super.attributesToDeclare())
    }
};
o(fR, "ListOperationNumberResultRecord");
var Ef = fR;
Ef._constructor = (() => {
    Ef.init()
})();

function Oce(r, e, t) {
    return pt("ListIndexOf", "763a5d96-a42e-49b6-8129-b46525912667", () => {
        try {
            let n = Sn(t);
            return Mc(r, n, "indexOf", () => {
                let i = new Ef;
                return i.positionOut = r.indexOf(e), i
            })
        } catch (n) {
            throw vr(n, "listIndexOf"), n
        }
    })
}
o(Oce, "listIndexOf");

function Pce(r, e) {
    return pt("RequireScript", "388d4655-dd1c-4c5c-8d46-f420d0fe02a1", t => {
        try {
            let n = pc.getVersionedUrl(r);
            return XI(n, {
                parentSpan: t
            })
        } catch (n) {
            throw vr(n, "requireScript"), n
        }
    })
}
o(Pce, "requireScript");

function Nce(r, e, t) {
    return pt("LogMessage", "8c126211-5b78-442b-8a4d-fc2f72d10ef2", () => {
        tn(e, r, Pe.Client)
    })
}
o(Nce, "logMessage");

function Dce(r, e) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ge;
    return pt("SetCurrentLocale", "f2708145-60c0-49dc-9a1a-8b0f1fae5dce", () => {
        try {
            let n = t.resolve(J.LocaleService);
            if (!n) {
                let i = new Error("Undefined locale service: can't set current locale.");
                throw vr(i, "setCurrentLocale"), i
            }
            n.setCurrentLocale(r)
        } catch (n) {
            throw vr(n, "setCurrentLocale"), n
        }
    })
}
o(Dce, "setCurrentLocale");

function Lce(r, e, t) {
    return k(this, arguments, void 0, function(n, i, s) {
        var a = this;
        let u = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : PM,
            l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : ge.resolve(J.AuthConfigsManager);
        return (function*() {
            return pt("GetExternalLoginURL", "da6adf2c-ff63-4d63-a90e-a58819b503eb", () => k(a, void 0, void 0, function*() {
                let c = n === "" ? void 0 : n,
                    d = new(uce.getType(_.Text)),
                    [f] = l.readAuthConfigs(i);
                if (!f) {
                    let h = new Error(`The given identity provider '${i}' does not exist.`);
                    throw vr(h, "getExternalLoginURL"), h
                }
                return d.externalLoginURLOut = yield u({
                    callbackUrl: c,
                    authConfigs: i ? Object.assign(Object.assign({}, f.configs), {
                        identityProvider: f.kc_hint
                    }) : void 0
                }), d
            }))
        })()
    })
}
o(Lce, "getExternalLoginURL");

function xce(r, e, t, n) {
    return k(this, arguments, void 0, function(i, s, a, u) {
        var l = this;
        let c = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : DM;
        return (function*() {
            return pt("Login", "477c9f29-36c5-42a9-b910-3e5d70c7427e", () => k(l, void 0, void 0, function*() {
                let d = new(cce.getType(xv));
                try {
                    d.userLoginResultOut.userIdAttr = yield c({
                        username: i,
                        password: s,
                        persistLogin: a
                    }), d.userLoginResultOut.successAttr = !0
                } catch (f) {
                    let h = f;
                    if (d.userLoginResultOut.userIdAttr = "", d.userLoginResultOut.successAttr = !1, d.userLoginResultOut.retryAfterSecondsAttr = ice, h.name === Qe.InvalidCredentials) d.userLoginResultOut.userLoginFailureReasonAttr.invalidCredentialsAttr = !0;
                    else if (h.name === Qe.TooManyFailedAttempts) d.userLoginResultOut.userLoginFailureReasonAttr.tooManyFailedLoginAttemptsAttr = !0;
                    else throw Uce(h)
                }
                return d
            }))
        })()
    })
}
o(xce, "login");

function Uce(r) {
    let e = qi(r),
        t = Cf(r.message);
    switch (Ue("Login SystemAction", t, r.errorCode, r, Pe.Internal), r.errorCode) {
        case "OS-CLRT-40109":
            return new pe.InvalidLoginException("Identity provider configurations missing.", e);
        case "OS-ID-BIZ-40021":
            return new pe.InvalidLoginException("Error retrieving token from identity provider.", e);
        default:
            return new pe.InvalidLoginException("Login Failed.", e)
    }
}
o(Uce, "processLoginException");

function Mce(r) {
    return k(this, arguments, void 0, function(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : LM;
        return (function*() {
            return pt("Logout", "41ac3c1a-dffd-4b4f-acc0-fa439a975601", () => t())
        })()
    })
}
o(Mce, "logout");

function kce(r, e) {
    return k(this, arguments, void 0, function(t, n) {
        var i = this;
        let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : xM;
        return (function*() {
            return pt("GetExternalLogoutURL", "c5bd52b6-817c-4268-9d9b-7d2bfe7228fe", () => k(i, void 0, void 0, function*() {
                let a = t === "" ? void 0 : t,
                    u = new(lce.getType(_.Text));
                return u.externalLogoutURLOut = yield s({
                    callbackUrl: a
                }), u
            }))
        })()
    })
}
o(kce, "getExternalLogoutURL");

function Fce(r) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : kM;
    return pt("GetPasswordComplexityPolicy", "dc6941b3-7f13-4266-92a7-afc438918f3f", () => {
        let t = new(dce.getType(Pv)),
            n = e();
        return t.passwordComplexityPolicyOut.minimumLengthAttr = n.minimumLength, t.passwordComplexityPolicyOut.lowerCaseLetterRequiredAttr = n.lowerCaseLetterRequired, t.passwordComplexityPolicyOut.upperCaseLetterRequiredAttr = n.upperCaseLetterRequired, t.passwordComplexityPolicyOut.numberRequiredAttr = n.numberRequired, t.passwordComplexityPolicyOut.specialCharacterRequiredAttr = n.specialCharacterRequired, t
    })
}
o(Fce, "getPasswordComplexityPolicy");

function $ce(r, e) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : FM;
    return pt("ValidatePasswordComplexity", "e11739ec-bce8-4f6c-a952-886e102ecac5", () => {
        let n = new(fce.getType(Nv)),
            i = t({
                password: r
            });
        return n.passwordValidationResultOut.isValidAttr = i.isValid, n.passwordValidationResultOut.missingMinimumLengthAttr = i.missingMinimumLength, n.passwordValidationResultOut.missingUpperCaseLetterAttr = i.missingUpperCaseLetter, n.passwordValidationResultOut.missingLowerCaseLetterAttr = i.missingLowerCaseLetter, n.passwordValidationResultOut.missingNumberAttr = i.missingNumber, n.passwordValidationResultOut.missingSpecialCharacterAttr = i.missingSpecialCharacter, n
    })
}
o($ce, "validatePasswordComplexity");

function Bce(r, e, t, n) {
    return k(this, arguments, void 0, function(i, s, a, u) {
        var l = this;
        let c = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : $M;
        return (function*() {
            return pt("FinishResetPassword", "4c9a2d55-1e48-4a73-b6dd-197773173c84", () => k(l, void 0, void 0, function*() {
                let d = new(vce.getType(Uv));
                if (!s) return d.finishResetPasswordResultOut.successAttr = !1, d.finishResetPasswordResultOut.finishResetPasswordFailureReasonAttr.invalidVerificationCodeAttr = !0, d;
                if (!i) return d.finishResetPasswordResultOut.successAttr = !1, d.finishResetPasswordResultOut.finishResetPasswordFailureReasonAttr.invalidEmailAttr = !0, d;
                try {
                    yield c({
                        username: i,
                        resetToken: s,
                        newPassword: a
                    }), d.finishResetPasswordResultOut.successAttr = !0
                } catch (f) {
                    let h = f;
                    d.finishResetPasswordResultOut.successAttr = !1;
                    let g = d.finishResetPasswordResultOut.finishResetPasswordFailureReasonAttr;
                    h.name === Qe.PasswordComplexityPolicyFailed ? g.passwordComplexityPolicyFailedAttr = !0 : h.name === Qe.InvalidToken ? g.invalidVerificationCodeAttr = !0 : h.name === Qe.InvalidCredentials && (g.invalidEmailAttr = !0)
                }
                return d
            }))
        })()
    })
}
o(Bce, "finishResetPassword");

function Vce(r) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : BM;
    return pt("IsExternalUser", "5365bc0e-70f6-4e7f-90bf-6c6e12da81bb", () => {
        let t = new(hce.getType(_.Boolean));
        return t.isExternalUserOut = e(), t
    })
}
o(Vce, "isExternalUser");

function Hce(r, e, t, n) {
    return k(this, arguments, void 0, function(i, s, a, u) {
        var l = this;
        let c = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : VM,
            d = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : Wo;
        return (function*() {
            return pt("FinishUserRegistration", "44a8850b-2e2d-4f19-9ea4-e5f40a050b5b", () => k(l, void 0, void 0, function*() {
                let f = new(gce.getType(Dv));
                if (!a) return f.registrationResultOut.successAttr = !1, f.registrationResultOut.finishUserRegistrationFailureReasonAttr.invalidVerificationCodeAttr = !0, f;
                if (!i) return f.registrationResultOut.successAttr = !1, f.registrationResultOut.finishUserRegistrationFailureReasonAttr.invalidEmailAttr = !0, f;
                try {
                    yield c({
                        username: i,
                        password: s,
                        temporaryPassword: a
                    }), f.registrationResultOut.successAttr = !0, f.registrationResultOut.userIdAttr = d()
                } catch (h) {
                    let g = h;
                    f.registrationResultOut.successAttr = !1, g.name === Qe.PasswordComplexityPolicyFailed ? f.registrationResultOut.finishUserRegistrationFailureReasonAttr.passwordComplexityPolicyFailedAttr = !0 : g.name === Qe.InvalidToken ? f.registrationResultOut.finishUserRegistrationFailureReasonAttr.invalidVerificationCodeAttr = !0 : g.name === Qe.InvalidCredentials && (f.registrationResultOut.finishUserRegistrationFailureReasonAttr.invalidEmailAttr = !0)
                }
                return f
            }))
        })()
    })
}
o(Hce, "finishUserRegistration");

function jce(r, e, t, n) {
    return k(this, arguments, void 0, function(i, s, a, u) {
        var l = this;
        let c = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : HM;
        return (function*() {
            return pt("ChangePassword", "b17b5077-e564-4145-b640-9fcb359cbb07", () => k(l, void 0, void 0, function*() {
                let d = new(pce.getType(Ov));
                try {
                    yield c({
                        username: i,
                        oldPassword: a,
                        newPassword: s
                    }), d.changePasswordResultOut.successAttr = !0
                } catch (f) {
                    let h = f;
                    d.changePasswordResultOut.successAttr = !1, h.name === Qe.PasswordComplexityPolicyFailed ? d.changePasswordResultOut.changePasswordFailureReasonAttr.passwordComplexityPolicyFailedAttr = !0 : h.name === Qe.InvalidCredentials ? d.changePasswordResultOut.changePasswordFailureReasonAttr.invalidCredentialsAttr = !0 : h.name === Qe.TooManyFailedAttempts && (d.changePasswordResultOut.changePasswordFailureReasonAttr.tooManyFailedAttemptsAttr = !0)
                }
                return d
            }))
        })()
    })
}
o(jce, "changePassword");

function Wce(r) {
    return k(this, arguments, void 0, function(e) {
        var t = this;
        let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : yI;
        return (function*() {
            return pt("GetUserProfile", "a4d7f4ef-399a-4294-8ab4-cf1437699fe3", () => k(t, void 0, void 0, function*() {
                let i = new(mce.getType(Lv)),
                    s = yield n();
                return i.userInfoOut.emailAttr = s.email, i.userInfoOut.usernameAttr = s.username, i.userInfoOut.nameAttr = s.name, i.userInfoOut.photoURLAttr = s.pictureUrl, i
            }))
        })()
    })
}
o(Wce, "getUserProfile");
var Gce = new Qt("ExternalIdentityProviders", "externalIdentityProvidersOut");

function zce(r) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ge.resolve(J.AuthConfigsManager),
        t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : YI;
    return pt("GetExternalIdentityProviders", "de70fbce-fe4c-4c40-8764-797d4df2da8b", () => {
        let n = t.getGenericList(Tf),
            i = new n,
            s = e.readAuthConfigs();
        for (let u of s)
            if (u.type !== hy) {
                let l = new Tf;
                l.keyAttr = u.kc_hint, l.nameAttr = u.type, i.append(l)
            } let a = new(Gce.getType(n));
        return a.externalIdentityProvidersOut = i, a
    })
}
o(zce, "getExternalIdentityProviders");
var qce = new Bs("IsActive", "isActiveOut");

function Kce(r) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ge.resolve(J.AuthConfigsManager);
    return pt("IsBuiltinIdentityProviderActive", "18764866-65bd-44d0-b166-439b5eba5112", () => {
        let t = e.readAuthConfigs(hy).length > 0,
            n = new(qce.getType(_.Boolean));
        return n.isActiveOut = t, n
    })
}
o(Kce, "isBuiltinIdentityProviderActive");
var Yce = Object.freeze({
        __proto__: null,
        changePassword: jce,
        finishResetPassword: Bce,
        finishUpdateEmail: nce,
        finishUserRegistration: Hce,
        getExternalIdentityProviders: zce,
        getExternalLoginURL: Lce,
        getExternalLogoutURL: kce,
        getPasswordComplexityPolicy: Fce,
        getUserProfile: Wce,
        isBuiltinIdentityProviderActive: Kce,
        isExternalUser: Vce,
        listAll: Ace,
        listAny: Ice,
        listAppend: yce,
        listAppendAll: Ece,
        listClear: _ce,
        listDistinct: Sce,
        listDuplicate: bce,
        listFilter: Cce,
        listIndexOf: Oce,
        listInsert: wce,
        listRemove: Tce,
        listSort: Rce,
        logMessage: Nce,
        login: xce,
        logout: Mce,
        requireScript: Pce,
        setCurrentLocale: Dce,
        validatePasswordComplexity: $ce
    }),
    hR = class hR {
        static safeParseInt(e) {
            let t = e;
            return e && !isNaN(Number(e)) && (t = parseInt(e, 10)), t
        }
    };
o(hR, "StringUtils");
var xA = hR,
    Xce = Object.freeze({
        __proto__: null,
        StringUtils: xA
    }),
    Jce = Object.freeze({
        __proto__: null
    }),
    ji;
(function(r) {
    r[r.Normal = 0] = "Normal", r[r.AtFunctionReturn = 1] = "AtFunctionReturn", r[r.BetweenAssignments = 2] = "BetweenAssignments"
})(ji || (ji = {}));
var yu = {
        CallContextId: "ccid",
        DebugStop: "dbg-stop",
        DebugBreakpointId: "dbg-bkp"
    },
    Wt;
(function(r) {
    r[r.StepOver = 0] = "StepOver", r[r.StepInto = 1] = "StepInto", r[r.StepOut = 2] = "StepOut", r[r.Continue = 3] = "Continue", r[r.ContinueToHere = 4] = "ContinueToHere", r[r.None = 5] = "None"
})(Wt || (Wt = {}));
var Wi;
(function(r) {
    r[r.Unprepared = 0] = "Unprepared", r[r.WaitingForClient = 1] = "WaitingForClient", r[r.Prepared = 2] = "Prepared"
})(Wi || (Wi = {}));
var $i = class $i {
    constructor() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null,
            t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
            n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null,
            i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
        this.moduleKey = e, this.objectKey = t, this.compoundKey = n, this.debuggerHash = i
    }
    init(e) {
        if (!e) return;
        let t = e.split($i.SeparatorChar);
        this.moduleKey = t[0], this.objectKey = t[1], this.compoundKey = t.length > 2 && t[2] ? t[2] : null, this.debuggerHash = t.length > 3 && t[3] ? t[3] : null
    }
    static parse(e) {
        if (!e) return null;
        try {
            let t = new $i;
            return t.init(e), t
        } catch (t) {
            return null
        }
    }
    equals(e) {
        return e ? e.moduleKey === this.moduleKey && e.objectKey === this.objectKey : !1
    }
    toString() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
        var t;
        return e ? this.moduleKey + $i.SeparatorChar + (this.objectKey || "") + $i.SeparatorChar + (this.compoundKey || "") + $i.SeparatorChar + (this.debuggerHash || "") : this.moduleKey + $i.SeparatorChar + ((t = this.objectKey) !== null && t !== void 0 ? t : "")
    }
};
o($i, "BreakpointId");
var vn = $i;
vn.SeparatorChar = ":";
var gR = class gR {
    constructor() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Wt.None,
            t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
        this._commandType = e, this._stackLevel = t
    }
    resetCommandState() {
        this._commandType = Wt.None, this._stackLevel = -1
    }
    get commandType() {
        return this._commandType
    }
    set commandType(e) {
        this._commandType = e
    }
    get stackLevel() {
        return this._stackLevel
    }
    set stackLevel(e) {
        this._stackLevel = e
    }
};
o(gR, "DebugCommand");
var Vv = gR,
    pR = class pR {
        constructor(e, t, n, i, s) {
            this.elementKey = e, this.moduleName = t, this.elementName = n, this.elementType = i, this.varBag = s, this.currentBreakpoint = null, this.previousBreakpoint = null, this.breakpointType = null, this.extraInfo = null, this.functionLeft = ""
        }
        refreshLocalState(e, t, n) {
            this.previousBreakpoint = this.currentBreakpoint, this.currentBreakpoint = e, this.breakpointType = t, this.extraInfo = n
        }
    };
o(pR, "LocalState");
var Hv = pR,
    mR = class mR {
        constructor() {
            this.callStack = new Array, this._command = new Vv, this._continueToHereBreakpoint = void 0, this._stopImmediately = !1
        }
        pushCallOnStack(e, t, n, i, s) {
            this.callStack.push(new Hv(e, t, n, i, s))
        }
        popCallOnStack() {
            let e = this.callStack.pop(),
                t = this.peekLastCallOnStack();
            return this.callStack.length > 0 && t && (t.functionLeft = e == null ? void 0 : e.elementName), e
        }
        peekLastCallOnStack() {
            if (!(this.callStack.length <= 0)) return this.callStack[this.callStack.length - 1]
        }
        getCallOnStack(e) {
            if (e < 0 || e >= this.callStack.length) {
                We("The received stack level is not valid. Received '" + e + "', current thread stack length '" + this.callStack.length + "'");
                return
            }
            return this.callStack[e]
        }
        refreshLastCallOnStack(e, t, n) {
            var i;
            (i = this.peekLastCallOnStack()) === null || i === void 0 || i.refreshLocalState(e, t, n)
        }
        set command(e) {
            this._command = e
        }
        get command() {
            return this._command
        }
        get stackLevel() {
            return this.callStack.length
        }
        get stopImmediately() {
            return this._stopImmediately
        }
        set stopImmediately(e) {
            this._stopImmediately = e || !1
        }
        get continueToBreakpoint() {
            return this._continueToHereBreakpoint
        }
        set continueToBreakpoint(e) {
            this._continueToHereBreakpoint = e
        }
        get threadStartName() {
            return this._threadStartName || ""
        }
        set threadStartName(e) {
            this._threadStartName = e
        }
        getThreadStack() {
            return this.callStack.map(e => {
                var t;
                return {
                    currentBreakpoint: e.currentBreakpoint !== null && e.currentBreakpoint !== void 0 ? e.currentBreakpoint.toString(!0) : null,
                    previousBreakpoint: e.previousBreakpoint !== null && e.previousBreakpoint !== void 0 ? e.previousBreakpoint.toString(!0) : null,
                    breakpointType: (t = e.breakpointType) !== null && t !== void 0 ? t : ji.Normal,
                    extraInfo: e.extraInfo,
                    elementKey: e.elementKey !== null && e.elementKey !== void 0 ? e.elementKey.toString(!0) : null,
                    elementName: e.elementName,
                    elementType: e.elementType,
                    functionLeft: e.functionLeft,
                    moduleName: e.moduleName
                }
            })
        }
    };
o(mR, "ThreadState");
var jv = mR;

function We(r, e) {
    ee("Debugger", r, e)
}
o(We, "debugMessage");
var Zce = /^([0-9]+)$/,
    Xx = /\[[^\]]*[^0-9\]]+[^\]]*\]/,
    Qce = "$return",
    vR = class vR {
        constructor() {
            this.isInSession = !1, this.breakpoints = new Map, this.callContexts = new Map, this.initializationStatus = Wi.Unprepared, this._pauseOnAllExceptions = !1, this.exceptionsMap = new Map, this.pausedOnAnException = !1, this.allowedModules = new Map
        }
        get BreakpointType() {
            return ji
        }
        isPausedOnException() {
            return this.pausedOnAnException
        }
        get version() {
            return 3
        }
        isSessionActive() {
            return this.isInSession
        }
        startSession() {
            if (this.isInSession) {
                We("Debugger is already in session");
                return
            }
            this.pendingInitializationHandler && (this.initializationStatus = Wi.Prepared, this.pendingInitializationHandler(), this.pendingInitializationHandler = null), this.isInSession = !0;
            let e = ge.resolve(J.DebuggerHttpClient);
            e && ge.register(J.HttpClient, () => e)
        }
        endSession() {
            if (!this.isInSession) {
                We("Can't end an nonexisting session");
                return
            }
            this.isInSession = !1;
            let e = ge.resolve(J.NonDebuggerHttpClient);
            e && ge.register(J.HttpClient, () => e)
        }
        addBreakpoint(e) {
            if (vn.parse(e) === null) {
                We(`Cannot convert '${e}' to a BreakpointId`);
                return
            }
            if (this.breakpoints.get(e)) {
                We(`Breakpoint with id '${e}' already registered`);
                return
            }
            this.breakpoints.set(e, !0)
        }
        addBreakpoints(e) {
            e.forEach(t => this.addBreakpoint(t))
        }
        allowBreakpointsFromModule(e) {
            if (this.allowedModules.get(e)) {
                We(`Application with key '${e}' is already allowed`);
                return
            }
            this.allowedModules.set(e, !0)
        }
        removeBreakpoint(e) {
            if (vn.parse(e) === null) {
                We(`Cannot convert '${e}' to a BreakpointId`);
                return
            }
            this.breakpoints.delete(e) || We(`Breakpoint with id '${e}'  isn't registered`)
        }
        clearBreakpoints() {
            this.breakpoints.clear()
        }
        push(e, t, n, i, s, a) {
            if (!this.isInSession) return;
            let u = vn.parse(e);
            if (!u) {
                We(`Error when parsing breakpointId '${e}'`);
                return
            }
            let l = this.callContexts.get(s);
            l || (l = new jv, this.callContexts.set(s, l)), l.pushCallOnStack(u, t, n, i, a)
        }
        pop(e, t) {
            if (!this.isInSession) return;
            let n = vn.parse(e);
            if (!n) {
                We(`Error when parsing breakpointId '${e}'`);
                return
            }
            let i = this.callContexts.get(t);
            if (!i) {
                We(`There is no action to end to callContextId '${t.toString()}'`);
                return
            }
            let s = i.peekLastCallOnStack();
            if (!(s != null && s.elementKey.equals(n))) {
                We(`Action to end didn't match to current running action. Running action key: '${s==null?void 0:s.elementKey.toString()}', tried to end: '${n.toString()}'`);
                return
            }
            i.popCallOnStack(), i.stackLevel <= 0 && (this.callContexts.delete(t), this.exceptionsMap.delete(t))
        }
        stepInto(e) {
            this.fillCommandByCallContextId(e, Wt.StepInto)
        }
        stepOver(e) {
            this.fillCommandByCallContextId(e, Wt.StepOver)
        }
        stepOut(e) {
            this.fillCommandByCallContextId(e, Wt.StepOut)
        }
        continue (e) {
            this.fillCommandByCallContextId(e, Wt.Continue)
        }
        continueToHere(e, t) {
            let n = vn.parse(e);
            if (!n) {
                We(`Error when parsing breakpointId '${e}'`);
                return
            }
            this.fillCommandByCallContextId(t, Wt.ContinueToHere);
            let i = this.callContexts.get(t);
            i && (i.continueToBreakpoint = n)
        }
        pauseOnAllExceptions(e) {
            this._pauseOnAllExceptions = e
        }
        fillCommandByCallContextId(e, t) {
            if (!this.isInSession) {
                We("Cannot preform debug actions out of a session context");
                return
            }
            let n = this.callContexts.get(e);
            if (!n) {
                We(`No match for callContextId '${e}'`);
                return
            }
            n.command.commandType = t, n.command.stackLevel = n.stackLevel
        }
        handleFunctionCall(e, t, n) {
            var i;
            let s = e();
            if (!this.isInSession) return s;
            let a = this.callContexts.get(n);
            if (!a) return We(`There is no callContext registered with Id '${n}'`), s;
            let u = a.getCallOnStack(a.stackLevel - 1),
                l = (i = u == null ? void 0 : u.currentBreakpoint) !== null && i !== void 0 ? i : u == null ? void 0 : u.elementKey;
            return l && this.handleBreakpoint(l.toString(!0), n, ji.AtFunctionReturn, bf.to(s, u == null ? void 0 : u.varBag.callContext, null, null, t)), s
        }
        handleBreakpoint(e, t) {
            let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ji.Normal,
                i = arguments.length > 3 ? arguments[3] : void 0;
            if (!this.isInSession) return !0;
            let s = vn.parse(e);
            if (!s) return We(`Error when parsing breakpointId '${e}'`), !0;
            let a = this.callContexts.get(t);
            if (!a) return We(`Trying to handle breakpoint with id '${e}', 
                but there is no callContext registered with Id '${t}'`), !0;
            if (a.refreshLastCallOnStack(s, n, i), !this.allowedModules.get(s.moduleKey)) return ee("Debugger", `Skipping breakpoint '${e}' because breakpoints from app with key '${s.moduleKey}' are to be ignored.`), !0;
            if (a.stopImmediately || this.breakpoints.get(e) && a.command.commandType !== Wt.ContinueToHere && n === ji.Normal) return a.stopImmediately = !1, this.resetStateAndCallDebugger(a, t), !0;
            switch (a.command.commandType) {
                case Wt.StepInto:
                    this.resetStateAndCallDebugger(a, t);
                    break;
                case Wt.StepOut:
                    a.stackLevel < a.command.stackLevel && this.resetStateAndCallDebugger(a, t);
                    break;
                case Wt.StepOver:
                    a.stackLevel <= a.command.stackLevel && n === ji.Normal && this.resetStateAndCallDebugger(a, t);
                    break;
                case Wt.ContinueToHere:
                    s.equals(a.continueToBreakpoint) && n === ji.Normal && (a.continueToBreakpoint = void 0, this.resetStateAndCallDebugger(a, t));
                    break
            }
            return !0
        }
        resetStateAndCallDebugger(e, t) {
            e.command.resetCommandState(), this.callDebugger(t)
        }
        handleException(e, t) {
            if (!this.isInSession || nI(e)) return;
            let n = this.callContexts.get(t),
                i = ks(e);
            if (!n) {
                We(`Trying to handle Exception with message '${i}', but there is no callContext registered with Id '${t}'`, Pe.Client);
                return
            }
            let s = this.exceptionsMap.get(t);
            if (e !== s && (this.exceptionsMap.set(t, e), this._pauseOnAllExceptions)) {
                this.pausedOnAnException = !0;
                try {
                    this.callDebugger(t)
                } finally {
                    this.pausedOnAnException = !1
                }
            }
        }
        getExceptionMessage(e) {
            if (!this.getThreadState(e)) return;
            let n = this.exceptionsMap.get(e);
            if (n === void 0) {
                We(`There is no Exception associated to callContext with Id '${e}'`);
                return
            }
            return ks(n)
        }
        getThreadState(e) {
            if (!this.isInSession) {
                We("Cannot perform debug actions out of a session context");
                return
            }
            let t = this.callContexts.get(e);
            if (!t) {
                We(`There is no callContext registered with Id '${e}'`);
                return
            }
            return t
        }
        getThreadStack(e) {
            let t = this.getThreadState(e);
            if (t) return t.getThreadStack()
        }
        parse(e) {
            return vn.parse(e)
        }
        initialize(e) {
            switch (this.initializationStatus) {
                case Wi.WaitingForClient:
                    return Promise.reject("Debugger already waiting for client initialization");
                case Wi.Prepared:
                    return Promise.reject("Debugger already initialized")
            }
            return e === void 0 && (e = !!lM("_waitForClient")), ge.register(J.Debugger, () => this), new Promise((t, n) => {
                e && !this.isInSession ? (this.initializationStatus = Wi.WaitingForClient, this.pendingInitializationHandler = t) : (this.initializationStatus = Wi.Prepared, t())
            })
        }
        registerMetaInfo(e) {
            this.metaInfoMap || (this.metaInfoMap = new Map);
            for (let t in e) e.hasOwnProperty(t) && !this.metaInfoMap.get(t) && this.metaInfoMap.set(t, e[t])
        }
        getRuntimeExpression(e, t) {
            if (!this.metaInfoMap) {
                We("MetaInfo not registered yet.");
                return
            }
            let n = this.metaInfoMap.get(e);
            if (!n) {
                We(`There is no mapping defined for variable with the key '${e}', that was evaluated in the context of the action with the key '${t}'.`);
                return
            }
            return n
        }
        innerEvaluateVariable(e, t, n, i) {
            let s = this.getThreadState(e);
            if (!s) return;
            let a = s.getCallOnStack(t);
            if (!a) return;
            let u = this.getRuntimeExpression(i, n);
            if (!u) {
                We(`Failed to get runtime variable expression. CallContextId '${e}', stackLevel '${t}'`);
                return
            }
            let l;
            try {
                l = u.getter(a.varBag, a.varBag.idService)
            } catch (c) {} finally {
                l === void 0 && We(`Couldn't evaluate variable with key '${i}', that was evaluated in the context of the action with key: '${n}' stackLevel: '${t}' callContextId: '${e}'.`)
            }
            return l
        }
        splitPath(e) {
            if (e != null && !Xx.test(e)) return e ? e.split(/[.\[\]]/).filter(t => t !== "").slice(1) : void 0
        }
        evaluateVariable(e, t, n, i, s, a) {
            if (i === "" && s === Qce) {
                let h = this.getThreadState(e);
                if (!h) return;
                let g = h.getCallOnStack(t);
                return g ? g.extraInfo : void 0
            }
            let u = this.innerEvaluateVariable(e, t, n, i);
            if (u === void 0 || Xx.test(s)) return;
            let l = this.callContexts.get(e),
                c = l == null ? void 0 : l.getCallOnStack(t),
                d = this.getRuntimeExpression(i, n),
                f = this.splitPath(s);
            return bf.to(u, c == null ? void 0 : c.varBag.callContext, f, a, d == null ? void 0 : d.dataType)
        }
        getRequestHeaders(e) {
            if (!this.isInSession) return;
            let t = this.callContexts.get(e);
            if (!t) {
                We(`There is no callContext registered with Id '${e}'`);
                return
            }
            let n = {};
            n[yu.CallContextId] = String(e);
            let i = t.command;
            return i && i.commandType === Wt.StepInto ? n[yu.DebugStop] = "true" : t.continueToBreakpoint && i.commandType === Wt.ContinueToHere && (n[yu.DebugBreakpointId] = String(t.continueToBreakpoint)), n
        }
        lookupCaseInsensitive(e, t) {
            let n = t.toLowerCase(),
                i = Object.keys(e).find(s => s.toLowerCase() === n);
            return i ? e[i] : void 0
        }
        processResponseHeaders(e, t) {
            if (!this.isInSession) return;
            let n = this.getThreadState(e);
            if (t && n)
                if ((this.lookupCaseInsensitive(t, yu.DebugStop) || "").toLowerCase() === "true") n.stopImmediately = !0;
                else if (this.lookupCaseInsensitive(t, yu.DebugBreakpointId)) {
                let i = this.lookupCaseInsensitive(t, yu.DebugBreakpointId);
                n.command.commandType = Wt.ContinueToHere, n.continueToBreakpoint = vn.parse(i)
            } else n.command.commandType === Wt.StepInto && (n.command.commandType = Wt.Continue)
        }
        getThreadStartName(e) {
            var t;
            return (t = this.getThreadState(e)) === null || t === void 0 ? void 0 : t.threadStartName
        }
        setThreadStartName(e, t) {
            if (!this.isInSession) return;
            if (!this.callContexts) {
                We("No call context dictionary initialized yet");
                return
            }
            if (!this.callContexts.get(e)) {
                We("No thread state for this context id");
                return
            }
            let n = this.callContexts.get(e);
            n && (n.threadStartName = t)
        }
    };
o(vR, "DebuggerBase");
var Wv = vR,
    yR = class yR extends Wv {
        callDebugger(e) {
            let t = zo(),
                n = t.callContextId;
            try {
                t.callContextId = e;
                debugger
            } finally {
                t.callContextId = n
            }
        }
    };
o(yR, "RuntimeDebugger");
var UA = yR,
    bf;
(function(r) {
    let e = "DataFetchStatus",
        t = "IsDataFetched",
        n = "HasFetchError";

    function i(u, l, c) {
        let d = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1,
            f = arguments.length > 4 ? arguments[4] : void 0,
            h = Math.max(-1, (d != null ? d : 0) - 1);
        if (u instanceof Ce) {
            let g = u,
                p = g.getAttributes();
            if (c && c.length > 0) {
                let w = c[0];
                if (c = c.slice(1), u instanceof Hs) {
                    let T = u;
                    if (w === "HasFetchError") return i(T.hasFetchErrorAttr, l, c, d, _.Boolean);
                    if (w === "IsDataFetched") return i(T.isDataFetchedAttr, l, c, d, _.Boolean)
                }
                if (p = p.filter(T => T.name === w), p.length === 0) {
                    We(`No attribute matching the given path '${w}'.`);
                    return
                } else {
                    let T = p[0];
                    return i(g[T.attrName], l, c, d, T.dataType)
                }
            }
            if (d === 0) return a(null, _.Record);
            let m = {};
            for (let w of p) m[w.name] = i(g[w.attrName], l, c, h, w.dataType);
            if (u instanceof Hs) {
                let w = u;
                delete m[e], m[t] = i(w.isDataFetchedAttr, l, c, d, _.Boolean), m[n] = i(w.hasFetchErrorAttr, l, c, d, _.Boolean)
            }
            return a(m, _.Record)
        } else if (u instanceof Ki) {
            let g = u,
                p;
            g.constructor.getItemType && (p = g.constructor.getItemType());
            let T = l.iterationContext.getCurrentRowNumber(g);
            if (c && c.length > 0) {
                let b = c[0];
                if (c = c.slice(1), b === "CurrentRowNumber") return i(T, l, c, d, _.Integer);
                if (b === "Current") return i(g.isEmpty ? g.emptyListItem : g.getItem(T), l, c, d, p);
                if (b === "Empty") return i(g.isEmpty, l, c, d, _.Boolean);
                if (b === "Length") return i(g.length, l, c, d, _.Integer); {
                    let R = Zce.exec(b);
                    if (R) {
                        let L = parseInt(R[1], 10);
                        if (L >= 0 && L < g.length) return i(g.getItem(L), l, c, d, p);
                        We(`Index out of bounds '${L}'.`);
                        return
                    } else {
                        We(`No '${b}' attribute on Type 'List'.`);
                        return
                    }
                }
            }
            if (d === 0) return a(null, _.RecordList);
            let E = {
                CurrentRowNumber: i(T, l, c, h, _.Integer),
                Current: i(g.isEmpty ? g.emptyListItem : g.getItem(T), l, c, h, p),
                Empty: i(g.isEmpty, l, c, h, _.Boolean),
                Length: i(g.length, l, c, h, _.Integer)
            };
            for (let b = 0; b < g.length; b++) E["[" + b + "]"] = i(g.getItem(b), l, c, h, p);
            return a(E, _.RecordList)
        } else if (u instanceof Yi) {
            if (d === 0) return a(null, _.Record);
            let g = u;
            if (c && c.length > 0) {
                let m = c[0];
                if (c = c.slice(1), m === "Id") return i(g.idAttr, l, c, d, _.Text);
                if (g instanceof Cc) {
                    if (m === "Valid") return i(g.validAttr, l, c, d, _.Boolean);
                    if (m === "ValidationMessage") return i(g.validationMessageAttr, l, c, d, _.Text)
                }
                We(`No attribute matching the given path '${m}'.`);
                return
            }
            let p = {
                Id: i(g.idAttr, l, c, h, _.Text)
            };
            return g instanceof Cc && (p.Valid = i(g.validAttr, l, c, h, _.Boolean), p.ValidationMessage = i(g.validationMessageAttr, l, c, h, _.Text)), a(p, _.Record)
        } else if (f !== void 0) {
            if (c && c.length > 0) {
                We(`Cannot perform a inner evaluation to a Basic Type. Trying to evaluate '${c[0]}' for a variable of type '${_[f]}'.`);
                return
            }
            return s(u, f)
        } else {
            We(`Variable Type didn't match any case. ${typeof u}`);
            return
        }
    }
    o(i, "to"), r.to = i;

    function s(u, l) {
        switch (l) {
            case _.Integer:
            case _.Text:
            case _.PhoneNumber:
            case _.Email:
            case _.Boolean:
                return a(u, l);
            case _.LongInteger:
            case _.Decimal:
            case _.Currency:
                return a(u.toString(), l);
            case _.Date:
                return a(u.toISODate(), l);
            case _.DateTime:
                return a(u.toString(), l);
            case _.Time:
                return a(u.toISOTime(), l);
            case _.BinaryData:
                return a(u.length, l);
            case _.Object:
                return a(null, l);
            case _.Record:
                We("Record is not a basic type");
                return;
            case _.RecordList:
                We("RecordList is not a basic type");
                return;
            default:
                We(`Unknown data type ${l}`);
                return
        }
    }
    o(s, "basicTypeToDebuggerData");

    function a(u, l) {
        return u === void 0 && (u = null), {
            value: u,
            type: _[l]
        }
    }
    o(a, "buildValueTypeObject")
})(bf || (bf = {}));
var HF = "6.53.10";
XA("client-runtime-core", HF);
var ele = typeof window != "undefined" ? window : global;
ele.OutSystemsDebugger = new UA;
var tle = Object.freeze({
        __proto__: null,
        BreakpointId: vn,
        get CommandType() {
            return Wt
        },
        DebugCommand: Vv,
        DebuggerBase: Wv,
        get DebuggerDataConverter() {
            return bf
        },
        get InitializationStatus() {
            return Wi
        },
        LocalState: Hv,
        ThreadState: jv,
        Version: HF
    }),
    rle = Object.freeze({
        __proto__: null
    }),
    nle = Object.freeze({
        __proto__: null
    }),
    Jx = "en-US",
    Zx = "-",
    nS = !1,
    ile = "Locale Service",
    sle = "CurrentLocale",
    ole = /^[A-z]{2,3}([_-]([A-z]{4}|[\d]{3}))?([_-]([A-z]{2}|[\d]{3}))?$/,
    _R = class _R {
        constructor(e) {
            this.currentLocaleStorage = new wn(ar.Persistent, sle, void 0, ZA), this.publisher = new Jd(ile, e)
        }
        subscribe(e) {
            return this.publisher.subscribe(e)
        }
        unsubscribe(e) {
            return this.publisher.unsubscribe(e)
        }
        getCurrentLocale() {
            var e, t;
            return (t = (e = this.currentLocaleStorage.get()) === null || e === void 0 ? void 0 : e.localeCode) !== null && t !== void 0 ? t : Jx
        }
        setCurrentLocale(e) {
            let t = Lc(J.TranslationsService);
            if (t && t.clear(), this.isValidLocale(e)) {
                let i = {
                    localeCode: e,
                    isRTL: nS
                };
                this.currentLocaleStorage.set(i)
            } else throw new Error(`Value '${e}' isn't a valid locale.`);
            let n = this.getCurrentLocaleFamily();
            this.publisher.publish({
                localeCode: e,
                localeFamily: n
            })
        }
        getCurrentLocaleFamily() {
            var e;
            let t = [],
                n = (e = this.getCurrentLocale()) !== null && e !== void 0 ? e : "";
            return n.indexOf(Zx) > 0 && t.push(n.split(Zx)[0]), t.push(n), t
        }
        isValidLocale(e) {
            return ole.test(e)
        }
        isCurrentLocaleRTL() {
            var e, t;
            return (t = (e = this.currentLocaleStorage.get()) === null || e === void 0 ? void 0 : e.isRTL) !== null && t !== void 0 ? t : nS
        }
        setCurrentLocaleRTL(e) {
            var t;
            let n = (t = this.currentLocaleStorage.get()) !== null && t !== void 0 ? t : {
                localeCode: Jx,
                isRTL: nS
            };
            n.isRTL = e, this.currentLocaleStorage.set(n)
        }
    };
o(_R, "LocaleService");
var Gv = _R,
    ale = Object.freeze({
        __proto__: null,
        default: Gv
    });

function JI() {
    return k(this, void 0, void 0, function*() {
        try {
            return yield En(), uy(window) ? window.OutSystemsNative.Http : null
        } catch (r) {
            return null
        }
    })
}
o(JI, "getNativeHttpPlugin");

function jF() {
    return k(this, void 0, void 0, function*() {
        return !!(yield JI())
    })
}
o(jF, "isNativeHttpPluginAvailable");

function Qx() {
    var r;
    if (!ge.resolve(J.SettingsManager).readBool("EnableOpenTelemetryTraces")) return;
    let t = ge.resolve(J.InstrumentationFactory);
    if (!t) return;
    let n = t.getActiveSpan();
    if (!n) return;
    let i = n.getContext();
    if (!i) return;
    let s = Object.keys((r = i.attributes) !== null && r !== void 0 ? r : {}).reduce((a, u) => {
        var l;
        return typeof((l = i.attributes[u]) === null || l === void 0 ? void 0 : l.toString) == "function" && (a[u] = i.attributes[u].toString()), a
    }, {});
    return {
        spanId: i.spanId,
        traceId: i.traceId,
        attributes: s,
        sampled: i.sampled
    }
}
o(Qx, "getHttpTrace");
var iS = LI + "locale";

function sS() {
    let r = Lc(J.LocaleService);
    if (r) return r.getCurrentLocale()
}
o(sS, "getLocaleValue");

function oS(r) {
    let e = Lc(J.LocaleService);
    e && e.setCurrentLocale(r)
}
o(oS, "setLocaleValue");
var ule = "HttpClientFactory",
    cle = {
        isHealthy: !0,
        healthCheckIntervalInSeconds: Number.POSITIVE_INFINITY,
        healthCheckEndpoint: "/moduleservices/ping",
        healingTimeoutDelayInSeconds: 30
    },
    eU = o((r, e, t) => {
        let n = e ? new Eh({
            acceptionRules: [e, /^[^/]/],
            rejectionRules: [/^[a-z0-9]+:\/\//i]
        }) : void 0;
        return new pa(r, Object.assign(Object.assign({}, cle), {
            healthCheckNeededPathFilter: n,
            logger: t
        }))
    }, "wrapInHealthChecker"),
    lle = o(r => k(void 0, void 0, void 0, function*() {
        let e = yield bu.build({
            withHealthCheck: !0,
            healthCheckPathScope: Dt()
        });
        r.register(J.UnauthenticatedHttpClient, () => e);
        let t = yield bu.build({
            baseUrl: Dt(),
            getToken: Em,
            getLocale: o(() => {
                var i;
                return (i = sS()) !== null && i !== void 0 ? i : null
            }, "getLocale"),
            setLocale: o(i => oS(i), "setLocale"),
            localeHeader: iS,
            withHealthCheck: !0,
            healthCheckPathScope: Dt()
        });
        if (r.register(J.HttpClient, () => t), _U() && wU()) {
            let i = bu.buildWithDebugger({
                alternateHttpClient: t,
                appUrl: eI(),
                getToken: Em,
                getLocale: o(() => {
                    var a;
                    return (a = sS()) !== null && a !== void 0 ? a : null
                }, "getLocale"),
                setLocale: o(a => oS(a), "setLocale"),
                localeHeader: iS,
                withHealthCheck: !0
            });
            r.register(J.DebuggerHttpClient, () => i), r.register(J.NonDebuggerHttpClient, () => t);
            let s = r.resolve(J.Debugger);
            s != null && s.isSessionActive() && r.register(J.HttpClient, () => r.resolve(J.DebuggerHttpClient))
        }
        let n = bu.buildLoggerHttpClient({
            baseUrl: Dt(),
            getToken: o(i => Em(i, !1), "getToken"),
            getLocale: o(() => {
                var i;
                return (i = sS()) !== null && i !== void 0 ? i : null
            }, "getLocale"),
            setLocale: o(i => oS(i), "setLocale"),
            localeHeader: iS
        });
        r.register(J.LoggerHttpClient, () => n)
    }), "registerHttpClients"),
    wR = class wR {
        static getHttpClientLogger() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : QM;
            return {
                setActiveSpanAsNonAggregable: o(() => e.setActiveSpanAsNonAggregable(), "setActiveSpanAsNonAggregable"),
                debug: o(t => {
                    let {
                        category: n,
                        message: i
                    } = t;
                    return e.debug(n != null ? n : "", i != null ? i : "")
                }, "debug"),
                error: o(t => {
                    let {
                        category: n,
                        message: i,
                        errorCode: s,
                        error: a
                    } = t;
                    return e.error(n != null ? n : "", i != null ? i : "", s != null ? s : He.Communication_Default, a, Pe.Internal)
                }, "error"),
                clientError: o(t => {
                    let {
                        category: n,
                        clientMessage: i,
                        internalMessage: s,
                        errorCode: a,
                        error: u
                    } = t;
                    return e.clientError({
                        category: n != null ? n : "",
                        clientMessage: i != null ? i : "",
                        internalMessage: s != null ? s : "",
                        errorCode: a != null ? a : He.Communication_Default,
                        errorObj: u
                    })
                }, "clientError"),
                startActiveClientSpan: o((t, n) => e.startActiveSpan(t, n, Pe.Internal, void 0, Hg.Client), "startActiveClientSpan")
            }
        }
        static build() {
            return k(this, arguments, void 0, function() {
                let {
                    baseUrl: e,
                    headers: t,
                    localeHeader: n,
                    getLocale: i,
                    setLocale: s,
                    logger: a = this.getHttpClientLogger(),
                    usesNativeHttpPlugin: u = jF,
                    getNativeHttpPluginInstance: l = JI,
                    loadTrace: c = Qx,
                    getToken: d,
                    withHealthCheck: f = !1,
                    healthCheckPathScope: h
                } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                return (function*() {
                    let g;
                    if (!Hn.isEnabled(di.WebHttpClientForNative) && (yield u())) {
                        let p = yield l();
                        if (!p) {
                            let m = new Error("Unable to get native http plugin instance.");
                            throw a == null || a.error({
                                category: ule,
                                message: m.message,
                                error: m
                            }), m
                        }
                        g = new fh({
                            baseUrl: e,
                            headers: t,
                            localeHeader: n,
                            getLocale: i,
                            setLocale: s,
                            logger: a,
                            httpClientInstance: p,
                            loadTrace: c,
                            getToken: d
                        })
                    } else g = new mi({
                        baseUrl: e,
                        headers: t,
                        localeHeader: n,
                        getLocale: i,
                        setLocale: s,
                        logger: a,
                        loadTrace: c,
                        getToken: d
                    });
                    return f ? eU(g, h, a) : g
                })()
            })
        }
        static buildWithDebugger(e) {
            let {
                alternateHttpClient: t,
                appUrl: n,
                localeHeader: i,
                getLocale: s,
                setLocale: a,
                logger: u = {
                    setActiveSpanAsNonAggregable: o(() => ZM(), "setActiveSpanAsNonAggregable"),
                    debug: o(f => {
                        let {
                            category: h,
                            message: g
                        } = f;
                        return ee(h != null ? h : "", g != null ? g : "")
                    }, "debug"),
                    error: o(f => {
                        let {
                            category: h,
                            message: g,
                            error: p
                        } = f;
                        return Ue(h != null ? h : "", g != null ? g : "", "OS-CLRT-00000", p)
                    }, "error")
                },
                getToken: l,
                withHealthCheck: c = !1,
                healthCheckPathScope: d
            } = e;
            if (n) {
                let f = new vh({
                    appUrl: n,
                    localeHeader: i,
                    getLocale: s,
                    setLocale: a,
                    logger: u,
                    alternateHttpClientInstance: t,
                    getToken: l
                });
                return c ? eU(f, d, u) : f
            }
            return t
        }
        static buildLoggerHttpClient() {
            let {
                baseUrl: e,
                headers: t,
                localeHeader: n,
                getLocale: i,
                setLocale: s,
                loadTrace: a = Qx,
                getToken: u
            } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            return new ah({
                baseUrl: e,
                headers: t,
                localeHeader: n,
                getLocale: i,
                setLocale: s,
                loadTrace: a,
                getToken: u
            })
        }
        static updateHealthCheckConfig(e) {
            let {
                healthCheckIntervalInSeconds: t
            } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (e instanceof pa) {
                let n = t === void 0 || t < 0 ? Number.POSITIVE_INFINITY : t;
                e.setHealthCheckInterval(n)
            }
        }
    };
o(wR, "HttpClientFactory");
var bu = wR,
    dle = o((r, e) => k(void 0, [r, e], void 0, function(t, n) {
        let {
            applicationDefinition: i,
            application: s = Uc
        } = n;
        return (function*() {
            SM(), s.setApplicationDefinition(i), yield wI(), yield lle(t)
        })()
    }), "runPreInitialization"),
    fle = o(function() {
        for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++) e[t] = arguments[t];
        return k(void 0, [...e], void 0, function() {
            let {
                application: n = Uc,
                initType: i = 0,
                executeRequiredScripts: s
            } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            return (function*() {
                if (yield KM({
                        version: ai.getLastApplicationVersionToken(),
                        getCurrentScreenName: zae
                    }), i === 1) return !0;
                let a = n.initializeDatabase(),
                    u = !1,
                    l = o(() => {
                        u = !0
                    }, "onVersionManagerDone"),
                    c = new Promise(p => {
                        if (u) p();
                        else {
                            let m = l;
                            l = o(() => {
                                m(), p()
                            }, "onVersionManagerDone")
                        }
                    }),
                    d = c.then(() => n.triggerApplicationReadyEvent()),
                    f = o(() => a.then(p => n.onDatabaseReady(p)).then(() => c).then(() => d).then(() => n.onApplicationReady()), "onVersionReady"),
                    h = {
                        onVersionReady: o(() => void f(), "onVersionReady"),
                        onUpgradeFinished: o((p, m) => n.onUpgradeFinished(p, m), "onUpgradeFinished"),
                        onNewVersionDetected: o(p => n.onNewVersionDetected(p), "onNewVersionDetected"),
                        onAppInfoReady: o(p => n.onAppInfoReady(p), "onAppInfoReady")
                    },
                    g = ai.upgradeVersion(a, h);
                return g && (yield s == null ? void 0 : s(), l()), g
            })()
        })
    }, "runPostInitialization"),
    hle = o((r, e, t) => {
        let n = r.getItem(e);
        n && (r.setItem(t, n), r.removeItem(e))
    }, "swapCurrentConfigs"),
    tU = "/moduleservices/auth/configs",
    am = "AuthConfigsManager",
    gle = "os-builtin-authconfigs",
    rU = "os-runtime-authconfigs",
    TR = class TR {
        constructor() {
            let {
                httpClient: e = ge.resolve(J.UnauthenticatedHttpClient),
                initialConfigs: t,
                getBasePath: n = o(() => Dt(), "getBasePath$1"),
                cacheName: i = gle,
                cacheStorage: s = localStorage
            } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var a;
            this.isOnlineListenerRegistered = !1, this.httpClient = e, this.getBasePath = n, this.cacheStorage = s, hle(this.cacheStorage, i, rU), this.cacheName = rU, this.authConfigs = (a = t != null ? t : this.fetchCachedConfigs()) !== null && a !== void 0 ? a : []
        }
        cacheConfigs(e) {
            this.cacheStorage.setItem(this.cacheName, JSON.stringify(e))
        }
        fetchCachedConfigs() {
            try {
                let e = this.cacheStorage.getItem(this.cacheName);
                if (e) return JSON.parse(e);
                ft(am, "No auth configs stored in cache")
            } catch (e) {
                Ue(am, "Error retrieving auth configs from cache", "OS-CLRT-40100", e)
            }
        }
        update() {
            return k(this, arguments, void 0, function() {
                var e = this;
                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : GM,
                    n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ge.resolve(J.Auth);
                return (function*() {
                    var i;
                    try {
                        let s = yield e.httpClient.get({
                            url: tU,
                            baseURL: e.getBasePath()
                        }), a = s == null ? void 0 : s.authConfigurations;
                        if (!Array.isArray(a)) throw new Error("Did not receive an array of configurations");
                        if (e.authConfigs = a, e.cacheConfigs(e.authConfigs), !(!((i = n.getInstance()) === null || i === void 0) && i.isAuthenticated())) {
                            let [u] = e.readAuthConfigs(hy);
                            u && n.updateConfig(u.configs)
                        }
                    } catch (s) {
                        Ue(am, "Error while fetching auth configs", "OS-CLRT-40100", s), e.isOnlineListenerRegistered || (t(() => k(e, void 0, void 0, function*() {
                            return this.update()
                        })), e.isOnlineListenerRegistered = !0)
                    }
                })()
            })
        }
        readAuthConfigs(e) {
            let {
                suppressExternalWarnings: t = !1
            } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            try {
                let n = e ? [...this.authConfigs.filter(i => i.type === e), ...this.authConfigs.filter(i => i.kc_hint === e)] : this.authConfigs;
                if (n.length < 1) {
                    let i = e ? ` for type "${e}"` : "";
                    return ft(tU, `No identity provider configurations found${i}.`, t ? Pe.Internal : Pe.External), []
                }
                return n.map(i => {
                    var s, a, u, l, c, d, f, h, g, p, m, w, T;
                    return {
                        key: i.key,
                        type: i.type,
                        kc_hint: (s = i.kc_hint) !== null && s !== void 0 ? s : "cognito",
                        configs: {
                            identityProvider: (a = i.kc_hint) !== null && a !== void 0 ? a : i.type,
                            scope: "openid",
                            clientId: (u = i.configs.amplifyClientId) !== null && u !== void 0 ? u : i.configs.clientId,
                            poolId: i.configs.poolId,
                            region: i.configs.region,
                            tenantId: i.configs.tenantId,
                            passwordComplexityPolicy: {
                                minimumLength: (c = (l = i.configs.passwordPolicy) === null || l === void 0 ? void 0 : l.minimumLength) !== null && c !== void 0 ? c : 12,
                                lowerCaseLetterRequired: (f = (d = i.configs.passwordPolicy) === null || d === void 0 ? void 0 : d.requireLowercase) !== null && f !== void 0 ? f : !0,
                                upperCaseLetterRequired: (g = (h = i.configs.passwordPolicy) === null || h === void 0 ? void 0 : h.requireUppercase) !== null && g !== void 0 ? g : !0,
                                numberRequired: (m = (p = i.configs.passwordPolicy) === null || p === void 0 ? void 0 : p.requireNumbers) !== null && m !== void 0 ? m : !0,
                                specialCharacterRequired: (T = (w = i.configs.passwordPolicy) === null || w === void 0 ? void 0 : w.requireSymbols) !== null && T !== void 0 ? T : !0
                            }
                        }
                    }
                })
            } catch (n) {
                return ft(am, "Couldn't read auth configurations"), []
            }
        }
    };
o(TR, "AuthConfigsManager");
var MA = TR,
    ple = {
        info: o(r => {
            let {
                category: e,
                message: t
            } = r;
            return void tn(e != null ? e : "", t != null ? t : "", Pe.Internal)
        }, "info"),
        error: o(r => {
            let {
                category: e,
                message: t,
                error: n,
                code: i,
                visibility: s
            } = r;
            var a;
            return void Ue(e != null ? e : "", t != null ? t : "", (a = i) !== null && a !== void 0 ? a : "OS-CLRT-40100", n, s)
        }, "error"),
        warning: o(r => {
            let {
                category: e,
                message: t
            } = r;
            return void ft(e != null ? e : "", t != null ? t : "")
        }, "warning"),
        debug: o(r => {
            let {
                category: e,
                message: t
            } = r;
            return void ee(e != null ? e : "", t != null ? t : "")
        }, "debug")
    },
    mle = o(r => k(void 0, void 0, void 0, function*() {
        r.register(J.AuthConfigsManager, () => new MA);
        let e = r.resolve(J.AuthConfigsManager),
            [t] = e.readAuthConfigs(hy, {
                suppressExternalWarnings: !0
            });
        r.register(J.Auth, () => {
            var n;
            return new Gp({
                appKey: js(),
                appUrl: Dt(),
                region: t == null ? void 0 : t.configs.region,
                poolId: t == null ? void 0 : t.configs.poolId,
                clientId: t == null ? void 0 : t.configs.clientId,
                scope: "openid",
                identityProvider: (n = t == null ? void 0 : t.kc_hint) !== null && n !== void 0 ? n : t == null ? void 0 : t.type,
                passwordComplexityPolicy: t == null ? void 0 : t.configs.passwordComplexityPolicy,
                logger: ple,
                httpClient: r.resolve(J.UnauthenticatedHttpClient),
                isOnline: o(() => _I(), "isOnline")
            })
        }), yield e.update()
    }), "useAuthConfigsManager"),
    vle = o(function(r) {
        for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) t[n - 1] = arguments[n];
        return k(void 0, [r, ...t], void 0, function(i) {
            let {
                onSettingsUpdated: s
            } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return (function*() {
                i.register(J.SettingsManager, () => new RS({
                    onSettingsUpdated: s
                })), yield i.resolve(J.SettingsManager).update()
            })()
        })
    }, "useSettingsManager"),
    yle = o(function() {
        for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++) e[t] = arguments[t];
        return k(void 0, [...e], void 0, function() {
            let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ai;
            return (function*() {
                yield n.initializeManifestLoader(), yield n.initialize()
            })()
        })
    }, "useVersionsManager"),
    $d = "ServiceWorker",
    _le = o(function() {
        let {
            serviceWorker: r = navigator.serviceWorker,
            loggerMethods: e = {
                debug: ee,
                info: tn,
                warning: ft,
                error: Ue
            }
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        r ? r.addEventListener("message", t => {
            if (!Tle(t.origin)) {
                ee($d, "The received message is not from a secure Service Worker and will be ignored");
                return
            }
            wle(t.data) && Ele({
                log: t.data,
                loggerMethods: e
            })
        }) : ft($d, "Service Worker API is not available")
    }, "listenToServiceWorkerLogs"),
    wle = o(r => r.kind === "log", "isServiceWorkerLog"),
    Tle = o(r => window.location.origin === r, "isSecureOrigin"),
    Ele = o(r => {
        let {
            log: e,
            loggerMethods: t
        } = r;
        if (e.severity === "error") t.error($d, e.message, e.errorCode, e.error, Pe.External);
        else if (e.severity === "info") t.info($d, e.message, Pe.External);
        else {
            let n = t[e.severity];
            n($d, e.message)
        }
    }, "processLog"),
    WF = "true",
    GF = "false";

function Mo(r) {
    return `Unsupported data type (${r}) for client variable`
}
o(Mo, "unsupportedTypeMessage");

function ble(r, e) {
    switch (e) {
        case _.Integer:
            return G.isValidInteger(r);
        case _.LongInteger:
            return G.isValidLongInteger(r);
        case _.Decimal:
        case _.Currency:
            return G.isValidDecimal(r);
        case _.Boolean:
            return G.isBoolean(r);
        case _.Text:
        case _.PhoneNumber:
        case _.Email:
            return G.isText(r);
        case _.Date:
            return G.isValidDate(r);
        case _.DateTime:
            return G.isValidDateTime(r);
        case _.Time:
            return G.isValidTime(r);
        default:
            let t = UI(e),
                n = Mo(t);
            throw new TypeError(n)
    }
}
o(ble, "isValueMatchingType");

function Sle(r, e) {
    if (r == null) throw new TypeError(`Value ${r} is not a valid value for a client variable.`);
    if (!ble(r, e)) {
        let t = UI(e);
        throw new TypeError(`Value ${r} is not a valid value for a client variable of the specified type (${t}).`)
    }
    switch (e) {
        case _.Integer:
        case _.LongInteger:
        case _.Decimal:
        case _.Currency:
            return r.toString();
        case _.Boolean:
            return r ? WF : GF;
        case _.Text:
        case _.PhoneNumber:
        case _.Email:
            return r;
        case _.Date:
            return r.toISODate();
        case _.DateTime:
            return r.toString();
        case _.Time:
            return r.toISOTime();
        default:
            throw new TypeError(Mo(`${e}`))
    }
}
o(Sle, "serialize");

function Ale(r, e) {
    switch (e) {
        case _.Integer:
            let t = Number(r);
            return G.isValidInteger(t) && G.isWithinIntegerRange(t) ? t : D.DEFAULT_INTEGER;
        case _.LongInteger:
            if (!r) return D.DEFAULT_LONGINTEGER;
            let n = bt.fromString(r);
            return G.isValidLongInteger(n) ? n : D.DEFAULT_LONGINTEGER;
        case _.Decimal:
            if (!r) return D.DEFAULT_DECIMAL;
            let i = new Be(r);
            return G.isValidDecimal(i) && G.isWithinDecimalRange(i) ? i : D.DEFAULT_DECIMAL;
        case _.Currency:
            if (!r) return D.DEFAULT_CURRENCY;
            let s = new Be(r);
            return G.isValidDecimal(s) && G.isWithinDecimalRange(s) ? s : D.DEFAULT_CURRENCY;
        case _.Boolean:
            return r === WF ? !0 : r === GF ? !1 : D.DEFAULT_BOOLEAN;
        case _.Text:
            return G.isText(r) ? r : D.DEFAULT_TEXT;
        case _.PhoneNumber:
            return G.isText(r) ? r : D.DEFAULT_PHONENUMBER;
        case _.Email:
            return G.isText(r) ? r : D.DEFAULT_EMAIL;
        case _.Date:
            let a = me.fromISODate(r);
            return G.isValidDate(a) ? a : D.DEFAULT_DATE;
        case _.DateTime:
            let u = me.fromISODateTime(r);
            return G.isValidDateTime(u) ? u : D.DEFAULT_DATETIME;
        case _.Time:
            let l = me.fromISOTime(r);
            return G.isValidTime(l) ? l : D.DEFAULT_TIME;
        case _.Record:
            throw new TypeError(Mo("Record"));
        case _.RecordList:
            throw new TypeError(Mo("List"));
        case _.BinaryData:
            throw new TypeError(Mo("Binary Data"));
        case _.Object:
            throw new TypeError(Mo("Object"));
        default:
            throw new TypeError(Mo(`Unknown: ${r}`))
    }
}
o(Ale, "deserialize");
var um = "Client Variables",
    aS = "$SESSION_USER_ID";

function nU(r) {
    return r == null
}
o(nU, "isNullOrUndefined");
var ER = class ER {
    constructor(e) {
        this.namespace = e, this.publisher = new Jd(um, e), this.fullKeyMatcher = new RegExp(`^${jo(Um)}${jo(this.namespace)}\\$[^$]*\\$ClientVars\\$`), this.checkSessionExpires(), this.innerSetVariable(aS, "", _.Text, Wo())
    }
    subscribe(e) {
        return this.publisher.subscribe(e)
    }
    unsubscribe(e) {
        return this.publisher.unsubscribe(e)
    }
    getFullKey(e, t) {
        return `${Um}${this.namespace}$${t}$ClientVars$${e}`
    }
    getVariable(e, t, n, i) {
        return this.checkSessionExpires(), this.innerGetVariable(e, t, n, i)
    }
    innerGetVariable(e, t, n, i) {
        let s = window.localStorage.getItem(this.getFullKey(e, t));
        return ee(um, `Reading Client Variable ${e} of module ${t} for ${this.namespace}`), nU(s) ? nU(i) ? Le(n) : i : Ale(s, n)
    }
    setVariable(e, t, n, i) {
        this.checkSessionExpires(), this.innerSetVariable(e, t, n, i), this.publisher.publish({
            key: e,
            module: t,
            value: i
        })
    }
    innerSetVariable(e, t, n, i) {
        window.localStorage.setItem(this.getFullKey(e, t), Sle(i, n)), ee(um, `Set Client Variable ${e} of module ${t} for ${this.namespace}`)
    }
    removeAllVariables() {
        let e = [];
        for (let t = 0; t < window.localStorage.length; t++) {
            let n = window.localStorage.key(t);
            n && this.fullKeyMatcher.test(n) && e.push(n)
        }
        if (e.length > 0) {
            for (let t of e) window.localStorage.removeItem(t);
            this.publisher.publish()
        }
    }
    checkSessionExpires() {
        let e = this.innerGetVariable(aS, "", _.Text);
        Wo() !== e && (e !== "" && (ee(um, `Removing all Client Variables for user provider ${this.namespace}`), this.removeAllVariables()), this.innerSetVariable(aS, "", _.Text, Wo()))
    }
};
o(ER, "LocalStorageClientVariablesService");
var kA = ER,
    Nm, zv, wu, Dm, Os, qv, Lm, Tu, Ho, FA, bR = class bR {
        constructor(e) {
            let {
                ttl: t = 120 * 1e3,
                runInterval: n = 10 * 1e3,
                maxSize: i = 50 * 1024 * 1024,
                cleanup: s,
                create: a,
                buildKey: u
            } = e;
            Nm.add(this), zv.set(this, void 0), wu.set(this, void 0), Dm.set(this, void 0), Os.set(this, new Map), qv.set(this, void 0), Lm.set(this, void 0), Tu.set(this, void 0), Ho.set(this, 0), dt(this, zv, t, "f"), dt(this, Dm, i, "f"), dt(this, qv, s, "f"), dt(this, Lm, a, "f"), dt(this, Tu, u, "f"), this.setAutoRun(n)
        }
        setAutoRun(e) {
            ie(this, wu, "f") && (clearInterval(ie(this, wu, "f")), dt(this, wu, void 0, "f")), e > 0 && dt(this, wu, setInterval(() => this.run(), e), "f")
        }
        getGCItem(e) {
            return ie(this, Os, "f").get(ie(this, Tu, "f").call(this, e))
        }
        getItem(e) {
            let t = ie(this, Tu, "f").call(this, e),
                n = ie(this, Os, "f").get(t);
            if (n) return n.refCount++, n.lastUsed = Date.now(), n.instance;
            let i = ie(this, Lm, "f").call(this, e);
            return ie(this, Os, "f").set(t, {
                refCount: 1,
                lastUsed: Date.now(),
                instance: i.instance,
                size: i.size
            }), dt(this, Ho, ie(this, Ho, "f") + i.size, "f"), i.instance
        }
        releaseItem(e) {
            let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
                n = ie(this, Tu, "f").call(this, e),
                i = ie(this, Os, "f").get(n);
            i && (i.refCount--, ie(this, Nm, "m", FA).call(this, n, i))
        }
        run() {
            let e = ie(this, Ho, "f") >= ie(this, Dm, "f");
            for (let [t, n] of ie(this, Os, "f").entries()) ie(this, Nm, "m", FA).call(this, t, n, e)
        }
    };
o(bR, "GarbageCollector");
var $A = bR;
zv = new WeakMap, wu = new WeakMap, Dm = new WeakMap, Os = new WeakMap, qv = new WeakMap, Lm = new WeakMap, Tu = new WeakMap, Ho = new WeakMap, Nm = new WeakSet, FA = o(function(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
        i = Date.now() - t.lastUsed > ie(this, zv, "f");
    t.refCount <= 0 && (i || n) && (ie(this, qv, "f").call(this, t.instance), dt(this, Ho, ie(this, Ho, "f") - t.size, "f"), ie(this, Os, "f").delete(e))
}, "_GarbageCollector_cleanItem");
var Od, Ou = class Ou {
    constructor() {
        let {
            gc: e
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        Od.set(this, void 0), dt(this, Od, e != null ? e : new $A({
            create: Ou.createBlobUrl,
            cleanup: Ou.cleanupBlobUrl,
            buildKey: Ou.buildBinaryKey
        }), "f")
    }
    getUrl(e) {
        return ie(this, Od, "f").getItem(e)
    }
    releaseUrl(e) {
        ie(this, Od, "f").releaseItem(e)
    }
    static buildBinaryKey(e) {
        return e.content || e.url || ""
    }
    static createBlobUrl(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : URL,
            n = e.toBlob();
        return n ? {
            instance: t.createObjectURL(n),
            size: n.size
        } : {
            instance: "",
            size: 1
        }
    }
    static cleanupBlobUrl(e) {
        (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : URL).revokeObjectURL(e)
    }
};
o(Ou, "BinaryUrlCache");
var BA = Ou;
Od = new WeakMap;
var ut = {
        tableName: Df,
        idIsAutoNumber: Ar.No,
        attributes: [{
            name: "Key",
            columnName: "KEY",
            type: re.TEXT,
            isPrimaryKey: !0
        }, {
            name: "ModuleKey",
            columnName: "MODULEKEY",
            type: re.TEXT,
            isPrimaryKey: !0
        }, {
            name: "UpgradeStatus",
            columnName: "UPGRADESTATUS",
            type: re.INTEGER
        }, {
            name: "Name",
            columnName: "NAME",
            type: re.TEXT
        }, {
            name: "TableName",
            columnName: "TABLENAME",
            type: re.TEXT
        }, {
            name: "Hash",
            columnName: "HASH",
            type: re.TEXT
        }, {
            name: "ExtraInfo",
            columnName: "EXTRAINFO",
            type: re.TEXT
        }]
    },
    zi = Object.assign(Object.assign({}, ut), {
        tableName: `${Ay}${Df}`
    }),
    iU = "MetadataTableInitializer",
    Ile = {
        isNeeded: o(r => k(void 0, void 0, void 0, function*() {
            return !(yield r.existsTable(ut))
        }), "isNeeded"),
        run: o(r => k(void 0, void 0, void 0, function*() {
            ee(iU, "Running initializer for entity meta info table."), yield r.createTable(ut), yield r.createTable(zi), ee(iU, "Initializer for entity meta info table ran successfully.")
        }), "run")
    },
    VA;
(function(r) {
    r[r.Unchanged = 0] = "Unchanged", r[r.Deleted = 1] = "Deleted", r[r.Recreated = 2] = "Recreated", r[r.New = 3] = "New"
})(VA || (VA = {}));
var rn = VA;

function cm(r, e, t) {
    for (let n of e.getAttributes()) zF(e[n.attrName], lv(r, n), `${t} '${r.tableName}.${n.name}'`)
}
o(cm, "validateRecordForCreateOrUpdate");

function zF(r, e, t) {
    if (e.type === re.TEXT && e.length !== void 0) {
        if (!r) return;
        let i = r.length - e.length;
        if (i > 0) throw new pe.DataBaseException("", `Unable to ${t} because it exceeds the maximum allowed length by ${i} characters.`)
    } else if (e.type === re.DECIMAL && e.length !== void 0 && e.decimals !== void 0) {
        let i = r.trunc().abs().toString().length - (e.length - e.decimals);
        if (i > 0) throw new pe.DataBaseException("", `Unable to ${t} because it exceeds the maximum allowed length by ${i} characters.`)
    }
}
o(zF, "validateValueForCreateOrUpdate");
var Ir = "EntityModelUtils";

function yn(r) {
    return r[0]
}
o(yn, "getFirstItem");

function sU(r, e) {
    return k(this, void 0, void 0, function*() {
        return yield r.findRecords(ut, {
            MODULEKEY: e
        })
    })
}
o(sU, "loadStoredMetadata");

function Cle(r, e, t, n) {
    return k(this, void 0, void 0, function*() {
        var i;
        ee(Ir, `Checking the status of table ${e.tableName} (${e.name})`);
        let s, a = {};
        if (t && (s = t.HASH, a = JSON.parse((i = t.EXTRAINFO) !== null && i !== void 0 ? i : "{}")), !s) ee(Ir, `Table ${e.tableName} (${e.name}) does not exist and will be created`), yield YF(r, e, n), yield kle(r, e);
        else {
            if (s !== e.hash) return Gle(e, a) ? (ee(Ir, `Table ${e.tableName} (${e.name}) exists and will be fully upgraded`), Fle(r, e, a, n)) : (ee(Ir, `Table ${e.tableName} (${e.name}) exists and will be incrementally upgraded`), $le(r, e, a, n));
            ee(Ir, `Table ${e.tableName} (${e.name}) exists and is up to date`)
        }
    })
}
o(Cle, "createOrUpgradeTable");

function Rle(r, e, t) {
    return k(this, void 0, void 0, function*() {
        return Ry(r, n => (ee(Ir, `Recovering table ${n} from backup`), i => Ole(i, n)), t, n => n.UPGRADESTATUS !== rn.Unchanged)
    })
}
o(Rle, "recoverBackupTables");

function Ole(r, e) {
    return k(this, void 0, void 0, function*() {
        yield Oy(r, e), (yield r.existsTable(Sf(e))) && (yield KF(r, Sf(e), e, e, rn.Unchanged)), yield JF(r, e, !0)
    })
}
o(Ole, "recoverBackupTable");

function Ple(r, e, t) {
    return k(this, void 0, void 0, function*() {
        return Ry(r, n => (ee(Ir, `Dropping inconsistent table ${n} (same key, different physical table name)`), i => Nle(i, n)), t, n => {
            let i = n.UPGRADESTATUS === rn.Unchanged,
                s = e.some(l => l.key === n.KEY),
                a = !e.some(l => l.tableName === n.TABLENAME),
                u = e.length === 0 ? !0 : s && a;
            return i && u
        })
    })
}
o(Ple, "dropInconsistentTables");

function Nle(r, e) {
    return k(this, void 0, void 0, function*() {
        yield Oy(r, e);
        let t = yn(yield r.findRecords(ut, {
            TABLENAME: e
        }));
        t && (yield r.removeRecord(ut, [t.KEY, t.MODULEKEY]))
    })
}
o(Nle, "dropInconsistentTable");

function Dle(r, e) {
    return Ry(r, t => (ee(Ir, `Dropping backup table for ${t}`), n => xle(n, t)), e, t => t.UPGRADESTATUS !== rn.Unchanged)
}
o(Dle, "dropBackupTables");

function Lle(r, e, t) {
    return k(this, void 0, void 0, function*() {
        return Ry(r, n => (ee(Ir, `Backing up table ${n} before deletion`), i => qF(i, n, rn.Deleted)), t, n => n.UPGRADESTATUS === rn.Unchanged && !e.some(i => i.tableName === n.TABLENAME))
    })
}
o(Lle, "backupDeletedTables");

function Ry(r, e, t, n) {
    return k(this, void 0, void 0, function*() {
        let i = yield r.findRecords(ut, {
            MODULEKEY: t
        }), s = [];
        if (n)
            for (let a of i) n(a) && s.push(a);
        else s = i;
        for (let a of s) yield e(a.TABLENAME)(r)
    })
}
o(Ry, "doForEachTable");

function qF(r, e, t) {
    return k(this, void 0, void 0, function*() {
        return ee(Ir, `Backing up table '${e}'`), yield JF(r, e, !1), yield Oy(r, Sf(e)), KF(r, e, Sf(e), e, t)
    })
}
o(qF, "backupTable");

function Oy(r, e) {
    return r.deleteTableIfExists(e)
}
o(Oy, "dropTableIfExists");

function xle(r, e) {
    return k(this, void 0, void 0, function*() {
        yield Oy(r, Sf(e));
        let t = yn(yield r.findRecords(ut, {
            TABLENAME: e
        }));
        t && (t.UPGRADESTATUS === rn.Deleted ? yield r.removeRecord(ut, [t.KEY, t.MODULEKEY]): (t.UPGRADESTATUS = rn.Unchanged, yield r.updateRecord(ut, t)));
        let n = yn(yield r.findRecords(zi, {
            TABLENAME: e
        }));
        n && (yield r.removeRecord(zi, [n.KEY, n.MODULEKEY]))
    })
}
o(xle, "dropBackupTable");

function KF(r, e, t, n, i) {
    return k(this, void 0, void 0, function*() {
        return ee(Ir, `Renaming table '${e}' to '${t}' and setting status to ${rn[i]}`), yield Ule(r, e, t), Mle(r, n, i)
    })
}
o(KF, "renameTableAndSetStatus");

function Ule(r, e, t) {
    return r.renameTable(e, t)
}
o(Ule, "renameTable");

function Mle(r, e, t) {
    return k(this, void 0, void 0, function*() {
        let n = yn(yield r.findRecords(ut, {
            TABLENAME: e
        }));
        return n.UPGRADESTATUS = t, r.updateRecord(ut, n)
    })
}
o(Mle, "setTableUpgradeStatus");

function Sf(r) {
    return `${Ay}${r}`
}
o(Sf, "getBackupTableName");

function YF(r, e, t) {
    return k(this, void 0, void 0, function*() {
        return ee(Ir, `Creating table ${e.tableName} (${e.name})`), r.createTable(Object.assign(Object.assign({}, e), {
            attributes: [...e.attributes.map(n => {
                var i;
                return Object.assign(Object.assign({}, n), {
                    serializedDefault: t.serialize((i = n.default) !== null && i !== void 0 ? i : Jo(n.type), n)
                })
            })]
        }))
    })
}
o(YF, "createTable");

function kle(r, e) {
    return k(this, void 0, void 0, function*() {
        let t = ZF(e);
        t.UPGRADESTATUS = rn.New, ee(Ir, `Creating metadata for table ${e.tableName} (${e.name})`), yield r.insertRecord(ut, t)
    })
}
o(kle, "insertTableMetadata");

function XF(r, e) {
    return k(this, void 0, void 0, function*() {
        ee(Ir, `Updating metadata for table ${e.tableName} (${e.name})`);
        let t = yield r.getRecord(ut, [e.key, e.moduleKey]), n = ZF(e);
        n.UPGRADESTATUS = t.UPGRADESTATUS, n.LASTIDENTIFIER = t.LASTIDENTIFIER, yield r.updateRecord(ut, n)
    })
}
o(XF, "updateTableMetadata");

function Fle(r, e, t, n) {
    return k(this, void 0, void 0, function*() {
        try {
            let i = yield r.getAllRecords(e);
            yield qF(r, e.tableName, rn.Recreated), yield YF(r, e, n);
            for (let s of i) {
                let a = Ble(s, e, t, n);
                yield r.insertRecord(e, a)
            }
            yield XF(r, e)
        } catch (i) {
            let s = `Unable to upgrade the definition of entity '${e.name}':
${ks(i)}`;
            throw ft(Ir, s), new pe.DataBaseException("", s)
        }
    })
}
o(Fle, "recreateTable");

function $le(r, e, t, n) {
    return k(this, void 0, void 0, function*() {
        var i;
        let s = e.attributes.filter(a => {
            var u;
            return !Object.keys((u = t.attrs) !== null && u !== void 0 ? u : {}).some(l => l === a.columnName)
        });
        ee(Ir, `Upgrading table ${e.tableName} (${e.name}) with new attributes (${JSON.stringify(s)}) and new hash (${e.hash})`);
        for (let a of s) {
            let u = n.serialize((i = a.default) !== null && i !== void 0 ? i : Jo(a.type), a);
            yield r.addColumn(e, Object.assign(Object.assign({}, a), {
                serializedDefault: u
            }))
        }
        yield XF(r, e)
    })
}
o($le, "upgradeTable");

function Ble(r, e, t, n) {
    let i = {};
    for (let s of e.attributes) try {
        let a = s.columnName,
            u = r[a];
        i[a] = Hle(u, s, t, n)
    } catch (a) {
        throw new pe.DataBaseException("", `Unable to upgrade attribute '${s.name}' data type to '${jI(s.type)}':
${ks(a)}`)
    }
    return Vle(i, e, n), i
}
o(Ble, "upgradeDbRecord");

function Vle(r, e, t) {
    var n;
    for (let i of e.attributes) {
        let s = i.columnName;
        if (r[s] === void 0) {
            let a = (n = i.default) !== null && n !== void 0 ? n : Jo(i.type);
            r[s] = t.serialize(a, i)
        }
    }
}
o(Vle, "fillWithDefaults");

function Hle(r, e, t, n) {
    var i;
    let s = (i = t.attrs) === null || i === void 0 ? void 0 : i[e.columnName];
    return s ? jle(r, s, e, n) : r
}
o(Hle, "convertRecordAttribute");

function jle(r, e, t, n) {
    if (n.isConversionNeeded(e, t)) {
        let i = n.deserialize(r, e),
            s = wc(t.type),
            a = Wle(e, t);
        if (Vs.isConvertibleTo(i, s)) {
            let u = Vs.convertTo(i, s);
            return zF(u, t, a), n.serialize(u, t)
        } else throw new pe.DataBaseException("", `Unable to ${a}.`)
    } else return r
}
o(jle, "upgradeDbValue");

function Wle(r, e) {
    let t = _[wc(r.type)],
        n = _[wc(e.type)];
    return `convert column '${e.name}' from type ${t} to ${n}`
}
o(Wle, "createOperationLabel");

function Gle(r, e) {
    return e.idIsAutoNumber !== r.idIsAutoNumber ? !0 : zle(r, e).some(n => n.entityAttr ? n.metadataAttr ? qle(n.entityAttr, n.metadataAttr) : n.entityAttr.isPrimaryKey : !0)
}
o(Gle, "requiresFullUpgrade");

function zle(r, e) {
    var t, n;
    let i = {};
    for (let s of r.attributes) {
        let a = s.columnName;
        i[a] = {}, i[a].entityAttr = s
    }
    for (let s of Object.keys((t = e.attrs) !== null && t !== void 0 ? t : {})) i[s] = i[s] || {}, i[s].metadataAttr = (n = e.attrs) === null || n === void 0 ? void 0 : n[s];
    return Object.keys(i).map(s => i[s])
}
o(zle, "getAttributeInfoSummary");

function qle(r, e) {
    return Kle(r, e) || !e.isPrimaryKey != !r.isPrimaryKey
}
o(qle, "columnDefinitionHasChanged");

function Kle(r, e) {
    return r.type !== e.type || e.length !== r.length || e.decimals !== r.decimals || !!e.isEntityReference != !!r.isEntityReference && !r.isPrimaryKey
}
o(Kle, "typeDefinitionHasChanged");

function JF(r, e, t) {
    return k(this, void 0, void 0, function*() {
        let n = t ? zi : ut,
            i = t ? ut : zi,
            s = yn(yield r.findRecords(i, {
                TABLENAME: e
            }));
        s && (yield r.removeRecord(i, [s.KEY, s.MODULEKEY]));
        let a = yn(yield r.findRecords(n, {
            TABLENAME: e
        }));
        if (a && (yield r.insertRecord(i, a)), t) {
            let u = yn(yield r.findRecords(n, {
                TABLENAME: e
            }));
            u && (yield r.removeRecord(n, [u.KEY, u.MODULEKEY]))
        }
    })
}
o(JF, "copyMetadata");

function ZF(r) {
    let e = Yle(r),
        t = Fn(r),
        n = (t == null ? void 0 : t.type) === re.INTEGER ? 0 : "0";
    return {
        KEY: r.key,
        MODULEKEY: r.moduleKey,
        UPGRADESTATUS: rn.Unchanged,
        NAME: r.name,
        TABLENAME: r.tableName,
        HASH: r.hash,
        LASTIDENTIFIER: t && r.idIsAutoNumber !== Ar.No ? n : void 0,
        EXTRAINFO: JSON.stringify(e)
    }
}
o(ZF, "makeMetadataRecord");

function Yle(r) {
    let e = {};
    return r.attributes.forEach(t => {
        e[t.columnName] = {
            type: t.type,
            isPrimaryKey: t.isPrimaryKey,
            length: t.length,
            decimals: t.decimals,
            isEntityReference: t.isEntityReference
        }
    }), {
        v: 2,
        idIsAutoNumber: r.idIsAutoNumber,
        attrs: e
    }
}
o(Yle, "makeExtraInfoMetadata");
var lm = "EntityModelInitializer",
    SR = class SR {
        constructor(e, t) {
            this.entityInfos = e, this.serializer = t
        }
        isNeeded(e) {
            return k(this, void 0, void 0, function*() {
                if (this.hasEntityInfos()) {
                    if (!(yield e.existsTable(ut))) return !0;
                    let n = yn(this.entityInfos).moduleKey,
                        i = yield sU(e, n);
                    for (let s of this.entityInfos) {
                        let a = yn(i.filter(u => u.KEY === s.key));
                        if (!a || a.HASH !== s.hash || a.UPGRADESTATUS !== rn.Unchanged || a.TABLENAME !== s.tableName) return !0
                    }
                    for (let s of i)
                        if (!this.entityInfos.some(a => a.key === s.KEY)) return !0
                }
                return !1
            })
        }
        run(e) {
            return k(this, void 0, void 0, function*() {
                if (!this.hasEntityInfos()) return;
                let t = yn(this.entityInfos).moduleKey;
                ee(lm, `Running initializer for entities of module '${t}'.`), yield Rle(e, this.entityInfos, t), this.entityInfos.length > 0 && (yield Ple(e, this.entityInfos, t)), yield Lle(e, this.entityInfos, t);
                let n = yield sU(e, t);
                for (let i of this.entityInfos) {
                    let s = i,
                        a = yn(n.filter(u => u.KEY === s.key));
                    yield Cle(e, s, a, this.serializer)
                }
                ee(lm, `Initializer for entities of module '${t}' ran successfully.`)
            })
        }
        cleanup(e) {
            return k(this, void 0, void 0, function*() {
                if (!this.hasEntityInfos()) return;
                let t = yn(this.entityInfos).moduleKey;
                ee(lm, `Running initializer cleanup for entities of module '${t}'.`), yield Dle(e, t), ee(lm, `Initializer cleanup for entities of module '${t}' ran successfully.`)
            })
        }
        hasEntityInfos() {
            return this.entityInfos && this.entityInfos.length > 0
        }
    };
o(SR, "EntityModelInitializer");
var HA = SR,
    oU = new Bs("Id", "idOut"),
    Xle = new Qt("Record", "recordOut"),
    uS = "EntityService",
    Bi = class Bi {
        constructor(e) {
            this._serializer = e
        }
        get database() {
            return this._database
        }
        get serializer() {
            return this._serializer
        }
        setDatabase(e) {
            ee(uS, "Registering initializer for entity meta info table."), this._database = e, this._database.registerInitializer(Ile)
        }
        getDatabase() {
            return this.databasePromise || (this.databasePromise = new Promise(e => {
                this.releaseDatabaseForUse = () => e(this.database)
            })), this.databasePromise
        }
        registerInitializer(e) {
            if (e && e.length > 0) {
                ee(uS, `Registering initializer for entities of module '${e[0].moduleKey}'.`);
                let t = new HA(e, this.serializer);
                this.database.registerInitializer(t)
            }
        }
        setReady() {
            ee(uS, "Releasing the database as ready for use."), this.databasePromise ? this.releaseDatabaseForUse() : this.databasePromise = Promise.resolve(this.database)
        }
        static wrap(e, t) {
            let n = t.getAttributes()[0],
                i = new t;
            return i[n.attrName] = e, i
        }
        static unwrap(e) {
            let t = e.getAttributes()[0];
            return e[t.attrName]
        }
        static getWrappedType(e) {
            return e.getAttributes()[0].complexType
        }
        create(e, t) {
            return k(this, void 0, void 0, function*() {
                let n = yield this.getDatabase(), i = Bi.unwrap(t);
                cm(e, i, "create");
                let s;
                try {
                    s = yield n.executeTransaction(l => this.innerCreate(l, e, i), !0, [ut, e])
                } catch (l) {
                    throw new pe.DataBaseException("", l.message, l.stack)
                }
                if (s === null) return null;
                let a = Bo(e, i),
                    u = new(oU.getType(a.dataType));
                return u.idOut = s, u
            })
        }
        innerCreate(e, t, n) {
            return k(this, void 0, void 0, function*() {
                let i = yield e.insertRecord(t, this.serializer.serialize(n, t)), s = Fn(t);
                return s ? this.serializer.deserialize(i, s) : null
            })
        }
        update(e, t) {
            return k(this, void 0, void 0, function*() {
                let n = yield this.getDatabase(), i = Bi.unwrap(t);
                cm(e, i, "update");
                try {
                    yield n.executeTransaction(s => this.innerUpdate(s, e, i), !0, [ut, e])
                } catch (s) {
                    throw new pe.DataBaseException("", s.message, s.stack)
                }
            })
        }
        innerUpdate(e, t, n) {
            return k(this, void 0, void 0, function*() {
                return e.updateRecord(t, this.serializer.serialize(n, t))
            })
        }
        createOrUpdate(e, t) {
            return k(this, void 0, void 0, function*() {
                let n = yield this.getDatabase(), i = Bi.unwrap(t);
                cm(e, i, "create or update");
                let s;
                try {
                    s = yield n.executeTransaction(l => this.innerCreateOrUpdate(l, e, i), !0, [ut, e])
                } catch (l) {
                    throw new pe.DataBaseException("", l.message, l.stack)
                }
                let a = Bo(e, i),
                    u = new(oU.getType(a.dataType));
                return u.idOut = s, u
            })
        }
        innerCreateOrUpdate(e, t, n) {
            return k(this, void 0, void 0, function*() {
                let i = yield e.upsertRecord(t, this.serializer.serialize(n, t)), s = Fn(t);
                return s ? this.serializer.deserialize(i, s) : null
            })
        }
        createOrUpdateAll(e, t) {
            return k(this, void 0, void 0, function*() {
                let n = yield this.getDatabase(), i = [];
                for (let s = 0; s < t.length; s++) {
                    let a = t.getItem(s),
                        u = Bi.unwrap(a);
                    cm(e, u, "create or update"), i.push(u)
                }
                try {
                    yield n.executeTransaction(s => k(this, void 0, void 0, function*() {
                        return this.innerCreateOrUpdateAll(s, e, i)
                    }), !0, [ut, e])
                } catch (s) {
                    throw new pe.DataBaseException("", s.message, s.stack)
                }
            })
        }
        innerCreateOrUpdateAll(e, t, n) {
            return k(this, void 0, void 0, function*() {
                return e.upsertAllRecords(t, n.map(i => this.serializer.serialize(i, t)))
            })
        }
        get(e, t) {
            return k(this, void 0, void 0, function*() {
                let n = yield this.getDatabase(), i = null;
                try {
                    i = yield n.executeReadTransaction(s => k(this, void 0, void 0, function*() {
                        return this.innerGet(s, e, t)
                    }), !0, [e])
                } catch (s) {
                    throw new pe.DataBaseException("", s.message, s.stack)
                }
                if (i) {
                    let s = new(Xle.getType(e.implicitAnonymousType));
                    return s.recordOut = Bi.wrap(i, e.implicitAnonymousType), s
                } else throw new pe.DataBaseException("", `${e.tableName} with id ${t} was not found`)
            })
        }
        innerGet(e, t, n) {
            return k(this, void 0, void 0, function*() {
                let i = Fn(t),
                    s = yield e.getRecord(t, this.serializer.serialize(n, i));
                return s ? this.serializer.deserialize(s, t, Bi.getWrappedType(t.implicitAnonymousType)) : null
            })
        }
        delete(e, t) {
            return k(this, void 0, void 0, function*() {
                let n = yield this.getDatabase();
                try {
                    yield n.executeTransaction(i => this.innerDelete(i, e, t), !0, [ut, e])
                } catch (i) {
                    throw new pe.DataBaseException("", i.message, i.stack)
                }
            })
        }
        innerDelete(e, t, n) {
            return k(this, void 0, void 0, function*() {
                let i = Fn(t);
                return e.removeRecord(t, this.serializer.serialize(n, i))
            })
        }
        deleteAll(e) {
            return k(this, void 0, void 0, function*() {
                let t = yield this.getDatabase();
                try {
                    yield t.executeTransaction(n => this.innerDeleteAll(n, e), !0, [ut, e])
                } catch (n) {
                    throw new pe.DataBaseException("", n.message, n.stack)
                }
            })
        }
        innerDeleteAll(e, t) {
            return k(this, void 0, void 0, function*() {
                return e.removeAllRecords(t)
            })
        }
    };
o(Bi, "EntityService");
var Kv = Bi,
    AR = class AR extends Kv {
        constructor() {
            super(new Rv)
        }
        executeAggregate(e, t) {
            return k(this, void 0, void 0, function*() {
                let n = yield this.getDatabase();
                try {
                    return yield n.executeQuery(e, !0, t)
                } catch (i) {
                    throw new pe.DataBaseException("", i.message, i.stack)
                }
            })
        }
        innerCreate(e, t, n) {
            return k(this, void 0, void 0, function*() {
                let i = yield this.getMetadataRecord(e, t), s = Bo(t, n), a = n.clone();
                if (t.idIsAutoNumber === Ar.YesIfEmpty) {
                    let u = this.getRecordIdAndUpdateLastIdentifier(i, t, n);
                    yield this.updateMetadataTable(e, i), a[s.attrName] = u
                }
                return yield e.insertRecord(t, this.serializer.serialize(a, t)), s ? a[s.attrName] : null
            })
        }
        getRecordIdAndUpdateLastIdentifier(e, t, n) {
            let i = Fn(t),
                s = Bo(t, n),
                a = dF(t, n);
            if (t.idIsAutoNumber === Ar.YesIfEmpty) {
                let u = e.LASTIDENTIFIER !== void 0 ? this.serializer.deserialize(e.LASTIDENTIFIER, i) : Le(s.dataType);
                Tn(a, Le(s.dataType)) ? (u instanceof bt ? u = u.add(1) : typeof u == "number" && (u = u + 1), a = u, e.LASTIDENTIFIER = this.serializer.serialize(a, i)) : Ty(a, u) > 0 && (e.LASTIDENTIFIER = this.serializer.serialize(a, i))
            }
            return a
        }
        innerCreateOrUpdate(e, t, n) {
            return k(this, void 0, void 0, function*() {
                let i = n.clone();
                if (t.idIsAutoNumber === Ar.YesIfEmpty) {
                    let u = yield this.getMetadataRecord(e, t), l = this.getRecordIdAndUpdateLastIdentifier(u, t, n);
                    yield this.updateMetadataTable(e, u);
                    let c = Bo(t, n);
                    i[c.attrName] = l
                }
                let s = yield e.upsertRecord(t, this.serializer.serialize(i, t)), a = Fn(t);
                return a ? this.serializer.deserialize(s, a) : null
            })
        }
        innerCreateOrUpdateAll(e, t, n) {
            return k(this, void 0, void 0, function*() {
                let i = yield this.getMetadataRecord(e, t), s, a = n.map(u => {
                    s = s != null ? s : Bo(t, u);
                    let l = u.clone();
                    if (t.idIsAutoNumber === Ar.YesIfEmpty) {
                        let c = this.getRecordIdAndUpdateLastIdentifier(i, t, u);
                        l[s.attrName] = c
                    }
                    return this.serializer.serialize(l, t)
                });
                return yield this.updateMetadataTable(e, i), e.upsertAllRecords(t, a)
            })
        }
        getMetadataRecord(e, t) {
            return k(this, void 0, void 0, function*() {
                let n = yield e.getRecord(ut, [t.key, t.moduleKey]);
                if (!n) throw new Error(`Unable to fetch record with key ${t.key} and moduleKey ${t.moduleKey} from 
                metadata table ${ut.tableName}.`);
                return n
            })
        }
        updateMetadataTable(e, t) {
            return k(this, void 0, void 0, function*() {
                if (t.LASTIDENTIFIER !== void 0) return e.updateRecord(ut, t)
            })
        }
    };
o(AR, "IndexedDBEntityService");
var jA = AR,
    ko = {
        tableName: Df,
        idIsAutoNumber: Ar.No,
        attributes: [{
            name: "SS_Key",
            columnName: "SS_Key",
            type: re.TEXT
        }, {
            name: "Module_SS_Key",
            columnName: "Module_SS_Key",
            type: re.TEXT
        }, {
            name: "Name",
            columnName: "Name",
            type: re.TEXT
        }, {
            name: "Physical_Table_name",
            columnName: "Physical_Table_name",
            type: re.TEXT
        }, {
            name: "Hash",
            columnName: "Hash",
            type: re.TEXT
        }, {
            name: "Extra_Info",
            columnName: "Extra_Info",
            type: re.TEXT
        }, {
            name: "Upgrade_Status",
            columnName: "Upgrade_Status",
            type: re.INTEGER
        }]
    },
    WA = Object.assign(Object.assign({}, ko), {
        tableName: `${Ay}${Df}`
    });

function Jle(r) {
    let e = JSON.parse(r.Extra_Info),
        t = {
            v: 2,
            idIsAutoNumber: e.idIsAutoNumber,
            attrs: Object.keys(e.attrs).reduce((n, i) => (n[i.toUpperCase()] = e.attrs[i], n), {})
        };
    return {
        KEY: r.SS_Key,
        MODULEKEY: r.Module_SS_Key,
        UPGRADESTATUS: r.Upgrade_Status,
        NAME: r.Name,
        TABLENAME: r.Physical_Table_name,
        HASH: r.Hash,
        EXTRAINFO: JSON.stringify(t)
    }
}
o(Jle, "convertV0ToV2");

function Zle(r) {
    let e = JSON.parse(r.EXTRAINFO),
        t = {
            v: 0,
            idIsAutoNumber: e.idIsAutoNumber,
            attrs: Object.keys(e.attrs).reduce((n, i) => (n[i.toLowerCase()] = e.attrs[i], n), {})
        };
    return {
        SS_Key: r.KEY,
        Module_SS_Key: r.MODULEKEY,
        Name: r.NAME,
        Physical_Table_name: r.TABLENAME,
        Hash: r.HASH,
        Extra_Info: JSON.stringify(t),
        Upgrade_Status: r.UPGRADESTATUS
    }
}
o(Zle, "convertV2ToV0");

function Qle(r, e, t) {
    return k(this, void 0, void 0, function*() {
        let i = (yield r.getAllRecords(e)).map(s => Jle(s));
        yield r.deleteTableIfExists(e), yield r.createTable(t), yield r.upsertAllRecords(t, i)
    })
}
o(Qle, "migrateToV2");

function ede(r, e, t) {
    return new Promise(n => {
        r.executeSql(`SELECT "${e}"."${t}" FROM "${e}" LIMIT 1`, void 0, () => {
            n(!0)
        }, () => (n(!1), !1))
    })
}
o(ede, "checkIfColumnExists");
var QF = {
        isNeeded: o(r => k(void 0, void 0, void 0, function*() {
            let e = r,
                t = !1;
            return (yield r.existsTable(ko)) && (t = yield e.executeQuery(i => {
                var s;
                return ede(i, ko.tableName, (s = ko.attributes[0]) === null || s === void 0 ? void 0 : s.columnName)
            })), t
        }), "isNeeded"),
        run: o(r => k(void 0, void 0, void 0, function*() {
            let e = [{
                v0TableInfo: ko,
                v2TableInfo: ut
            }, {
                v0TableInfo: WA,
                v2TableInfo: zi
            }].map(t => {
                let {
                    v0TableInfo: n,
                    v2TableInfo: i
                } = t;
                return Qle(r, n, i)
            });
            yield Promise.all(e)
        }), "run"),
        cleanup: o(r => k(void 0, void 0, void 0, function*() {
            yield r.deleteTableIfExists(ko), yield r.deleteTableIfExists(WA), yield r.renameTable(`${ut.tableName}_V2`, ut.tableName), yield r.renameTable(`${zi.tableName}_V2`, zi.tableName)
        }), "cleanup")
    },
    Pu = class Pu {
        constructor() {
            Pu.lastUpgraderRegistered = this
        }
        isNeeded(e) {
            return k(this, void 0, void 0, function*() {
                let t = !1;
                return Pu.lastUpgraderRegistered === this && (t = yield QF.isNeeded(e)), t
            })
        }
        run(e) {
            return k(this, void 0, void 0, function*() {
                let t = [{
                    v2TableInfo: ut,
                    v0TableInfo: ko
                }, {
                    v2TableInfo: zi,
                    v0TableInfo: WA
                }].map(n => {
                    let {
                        v2TableInfo: i,
                        v0TableInfo: s
                    } = n;
                    return this.migrateToV0(e, i, s)
                });
                yield Promise.all(t)
            })
        }
        migrateToV0(e, t, n) {
            return k(this, void 0, void 0, function*() {
                let s = (yield e.getAllRecords(t)).map(a => Zle(a));
                yield e.deleteTableIfExists(`${t.tableName}_V2`), yield e.renameTable(t.tableName, `${t.tableName}_V2`), yield e.createTable(n), yield e.upsertAllRecords(n, s)
            })
        }
        cleanup() {
            return k(this, void 0, void 0, function*() {
                Pu.lastUpgraderRegistered = null
            })
        }
    };
o(Pu, "WebSQLMetadataV2UpgraderStep2");
var GA = Pu,
    IR = class IR extends Kv {
        constructor() {
            super(new df), this.isMetadataV2UpgraderRegistered = !1
        }
        registerInitializer(e) {
            this.isMetadataV2UpgraderRegistered || (this.database.registerInitializer(QF), this.isMetadataV2UpgraderRegistered = !0), super.registerInitializer(e), this.database.registerInitializer(new GA)
        }
        executeAggregate(e) {
            return k(this, void 0, void 0, function*() {
                let t = yield this.getDatabase();
                try {
                    return yield t.executeQuery(e)
                } catch (n) {
                    throw new pe.DataBaseException("", n.message, n.stack)
                }
            })
        }
    };
o(IR, "WebSQLEntityService");
var zA = IR,
    tde = "LifecycleHandlers",
    CR = class CR {
        constructor() {
            let {
                onNewVersionHandler: e
            } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this.onNewVersionHandler = e
        }
        setOnNewVersionHandler(e) {
            this.onNewVersionHandler = e
        }
        onNewVersion(e) {
            return k(this, void 0, void 0, function*() {
                this.onNewVersionHandler ? this.onNewVersionHandler(e) : ft(tde, "onNewVersion triggered without handler defined.")
            })
        }
    };
o(CR, "LifecycleEventsManager");
var qA = CR,
    dm = "MappingWithDefaultService",
    RR = class RR {
        constructor() {
            this.messages = {}
        }
        getMessage(e, t) {
            ee(dm, `Getting message for key ${e} with default message ${t}`);
            let n = this.messages[e];
            return n != null ? n : t
        }
        setMessage(e, t) {
            ee(dm, `Setting message for key ${e} with value ${t}`), this.messages[e] = t
        }
        add(e) {
            if (!e) throw new Error("Messages cannot either null or undefined");
            let t = Object.keys(e);
            ee(dm, `Adding ${t.length} messages`), t.forEach(n => this.setMessage(n, e[n]))
        }
        clear() {
            ee(dm, "Clearing cached messages"), this.messages = {}
        }
    };
o(RR, "MappingWithDefaultService");
var KA = RR,
    aU = "Application",
    rde = o(function(r) {
        for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) t[n - 1] = arguments[n];
        return k(void 0, [r, ...t], void 0, function(i) {
            let {
                dateTimeFormat: s,
                numberFormat: a,
                application: u = Uc
            } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return (function*() {
                NU(js());
                let l = sde();
                _le(), ee(aU, "Initializing Application"), i.register(J.LifecycleEventsManager, () => new qA({
                    onNewVersionHandler: o(c => u.onNewVersionDetected(c), "onNewVersionHandler")
                })), hF(c => {
                    if (ai.isUpgradingVersion && !nI(c)) {
                        ft(aU, "Error during upgrade, treating as an upgrade error."), ai.handleUpgradeError(c, 1);
                        return
                    }
                    Ds(c)
                }), Zo.clear(), lU(AU()), nde(s, a), yield l, i.register(J.ClientVariablesService, () => new kA(ZA())), ode(i), i.register(J.TranslationsService, () => new KA), i.register(J.LocaleService, () => new Gv(Gr())), i.register(J.BinaryUrlCache, () => new BA), ide()
            })()
        })
    }, "useBaseApplication"),
    nde = o((r, e) => {
        r && (D.FORMAT.dateTimeFormat = r), e && (D.FORMAT.numberFormat = e)
    }, "setFormats"),
    ide = o(() => {
        let r = zo();
        r && (Object.defineProperty(r, "OutSystemsApp", {
            value: {
                get public() {
                    var e;
                    return new Sc(null, (e = bn.activeScreen) === null || e === void 0 ? void 0 : e.callContext())
                }
            },
            configurable: !0
        }), r.dispatchEvent(new Event("ospublicapiready")))
    }, "defineGlobalPublicApiHelper"),
    sde = o(() => k(void 0, void 0, void 0, function*() {
        (yield jF()) && (yield JI())
    }), "initializeCookiesManager"),
    ode = o(r => {
        Cr() ? r.register(J.EntityService, () => new zA) : r.register(J.EntityService, () => new jA)
    }, "registerEntityService"),
    ade = o((r, e) => {
        r instanceof pa && r.setHealthCheckInterval(e)
    }, "updateHealthCheckInterval"),
    ude = o(function(r) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ine,
            t = r.readNumber("HealthCheckInterval"),
            n = t === void 0 || t < 0 ? Number.POSITIVE_INFINITY : t;
        [e.resolve(J.HttpClient), e.resolve(J.UnauthenticatedHttpClient), e.resolve(J.DebuggerHttpClient), e.resolve(J.NonDebuggerHttpClient)].forEach(s => ade(s, n))
    }, "settingsUpdatedHandler"),
    e2 = "6.53.10";
XA("client-runtime-core", e2);
export {
    Rt as a, ns as b, o as c, lde as d, dde as e, vt as f, wre as g, Are as h, Ore as i, Lre as j, Qre as k, nne as l, ge as m, J as n, une as o, xne as p, Wne as q, QM as r, rie as s, iie as t, sse as u, _se as v, HI as w, sae as x, Iae as y, Cae as z, Oae as A, jae as B, Yae as C, Xae as D, Jae as E, nue as F, Tue as G, Eue as H, Cue as I, zue as J, YI as K, Kue as L, ece as M, Yce as N, Xce as O, dle as P, fle as Q, mle as R, vle as S, yle as T, rde as U, ude as V, cde as W
};
/**
 * @license Angular v<unknown>
 * (c) 2010-2024 Google LLC. https://angular.io/
 * License: MIT
 */
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/*!
 * JavaScript Cookie v2.2.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
/*! https://mths.be/punycode v1.3.2 by @mathias */
/*!
 *  decimal.js v10.6.0
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */